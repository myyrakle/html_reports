<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","rrdb","rrdb","src","ast","commands","connect.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ConnectCommand {\n    pub database_name: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","commands","mod.rs"],"content":"pub mod connect;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dcl","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","alter_database.rs"],"content":"use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nALTER DATABASE database_name\n{\n    RENAME TO new_database_name\n};\n*/\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AlterDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub action: Option\u003cAlterDatabaseAction\u003e,\n}\n\nimpl AlterDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        AlterDatabaseQuery {\n            database_name: None,\n            action: None,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_action(mut self, action: AlterDatabaseAction) -\u003e Self {\n        self.action = Some(action);\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::AlterDatabase(self))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum AlterDatabaseAction {\n    RenameTo(AlterDatabaseRenameTo),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AlterDatabaseRenameTo {\n    pub name: String,\n}\n","traces":[{"line":16,"address":[4534608],"length":1,"stats":{"Line":2}},{"line":23,"address":[4534704,4534860],"length":1,"stats":{"Line":2}},{"line":24,"address":[4534731,4534814],"length":1,"stats":{"Line":4}},{"line":25,"address":[4534840],"length":1,"stats":{"Line":2}},{"line":28,"address":[4534880,4535038],"length":1,"stats":{"Line":1}},{"line":29,"address":[4534907,4534991],"length":1,"stats":{"Line":2}},{"line":30,"address":[4535018],"length":1,"stats":{"Line":1}},{"line":33,"address":[4535072],"length":1,"stats":{"Line":1}},{"line":34,"address":[4535089],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","alter_table.rs"],"content":"//use crate::ast::enums::SQLStatement;\nuse crate::ast::{\n    types::{Column, DataType, SQLExpression, TableName},\n    SQLStatement,\n};\n\nuse super::drop_database::DDLStatement;\n\n/*\nALTER TABLE [database_name.]table_name\n{\n    [RENAME TO new_table_name] |\n    [RENAME COLUMN from_name TO new_name] |\n    [ALTER COLUMN column_name ...] |\n    [DROP COLUMN column_name] |\n    [ADD COLUMN column_name column_type ... ] ...\n};\n*/\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub action: AlterTableAction,\n}\n\nimpl AlterTableQuery {\n    pub fn builder() -\u003e Self {\n        AlterTableQuery {\n            table: None,\n            action: AlterTableAction::None,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_action(mut self, action: AlterTableAction) -\u003e Self {\n        self.action = action;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::AlterTableQuery(self))\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum AlterTableAction {\n    AlterTableRenameTo(AlterTableRenameTo),\n    AddColumn(AlterTableAddColumn),\n    AlterColumn(AlterTableAlterColumn),\n    DropColumn(AlterTableDropColumn),\n    RenameColumn(AlterTableRenameColumn),\n    None,\n}\n\n// 테이블명 변경\n// ALTER TABLE [database_name.]table_name RENAME TO new_table_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableRenameTo {\n    pub name: String,\n}\n\nimpl From\u003cAlterTableRenameTo\u003e for AlterTableAction {\n    fn from(value: AlterTableRenameTo) -\u003e AlterTableAction {\n        AlterTableAction::AlterTableRenameTo(value)\n    }\n}\n\n// 컬럼 이름 변경\n// ALTER TABLE [database_name.]table_name RENAME COLUMN from_name TO new_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableRenameColumn {\n    pub from_name: String,\n    pub to_name: String,\n}\n\nimpl From\u003cAlterTableRenameColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableRenameColumn) -\u003e AlterTableAction {\n        AlterTableAction::RenameColumn(value)\n    }\n}\n\n// 컬럼 추가\n// ALTER TABLE [database_name.]table_name ADD COLUMN column_name column_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'];\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableAddColumn {\n    pub column: Column,\n}\n\nimpl From\u003cAlterTableAddColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableAddColumn) -\u003e AlterTableAction {\n        AlterTableAction::AddColumn(value)\n    }\n}\n\n// 컬럼 삭제\n// ALTER TABLE [database_name.]table_name DROP COLUMN column_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableDropColumn {\n    pub column_name: String,\n}\n\nimpl From\u003cAlterTableDropColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableDropColumn) -\u003e AlterTableAction {\n        AlterTableAction::DropColumn(value)\n    }\n}\n\n// 컬럼 변경\n// ALTER COLUMN column_name [TYPE type_name] [{SET | DROP} NOT NULL] [{SET | DROP} DEFAULT default_expr] [{SET | DROP} COMMENT 'comment']\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableAlterColumn {\n    pub column_name: String,\n    pub action: AlterColumnAction,\n}\n\nimpl From\u003cAlterTableAlterColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableAlterColumn) -\u003e AlterTableAction {\n        AlterTableAction::AlterColumn(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum AlterColumnAction {\n    AlterColumnSetType(AlterColumnSetType),\n    AlterColumnSetNotNull,\n    AlterColumnDropNotNull,\n    AlterColumnSetDefault(AlterColumnSetDefault),\n    AlterColumnDropDefault(AlterColumnDropDefault),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnSetType {\n    pub data_type: DataType,\n}\n\nimpl From\u003cAlterColumnSetType\u003e for AlterColumnAction {\n    fn from(value: AlterColumnSetType) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetType(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnSetNotNull {}\n\nimpl From\u003cAlterColumnSetNotNull\u003e for AlterColumnAction {\n    fn from(_value: AlterColumnSetNotNull) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetNotNull\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnDropNotNull {}\n\nimpl From\u003cAlterColumnDropNotNull\u003e for AlterColumnAction {\n    fn from(_value: AlterColumnDropNotNull) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnDropNotNull\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterColumnSetDefault {\n    pub expression: SQLExpression,\n}\n\nimpl From\u003cAlterColumnSetDefault\u003e for AlterColumnAction {\n    fn from(value: AlterColumnSetDefault) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetDefault(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnDropDefault {}\n\nimpl From\u003cAlterColumnDropDefault\u003e for AlterColumnAction {\n    fn from(value: AlterColumnDropDefault) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnDropDefault(value)\n    }\n}\n","traces":[{"line":26,"address":[5023200],"length":1,"stats":{"Line":2}},{"line":33,"address":[5023312,5023500],"length":1,"stats":{"Line":2}},{"line":34,"address":[5023339,5023448],"length":1,"stats":{"Line":4}},{"line":35,"address":[5023480],"length":1,"stats":{"Line":2}},{"line":38,"address":[5023520,5023661],"length":1,"stats":{"Line":2}},{"line":39,"address":[5023552,5023621],"length":1,"stats":{"Line":4}},{"line":40,"address":[5023641],"length":1,"stats":{"Line":2}},{"line":43,"address":[5023680],"length":1,"stats":{"Line":2}},{"line":44,"address":[5023697],"length":1,"stats":{"Line":2}},{"line":66,"address":[5023776],"length":1,"stats":{"Line":1}},{"line":67,"address":[5023779],"length":1,"stats":{"Line":1}},{"line":80,"address":[5023824],"length":1,"stats":{"Line":1}},{"line":81,"address":[5023841],"length":1,"stats":{"Line":1}},{"line":93,"address":[5023888],"length":1,"stats":{"Line":2}},{"line":94,"address":[5023896],"length":1,"stats":{"Line":2}},{"line":106,"address":[5023920],"length":1,"stats":{"Line":1}},{"line":107,"address":[5023923],"length":1,"stats":{"Line":1}},{"line":120,"address":[5023968],"length":1,"stats":{"Line":1}},{"line":121,"address":[5023985],"length":1,"stats":{"Line":1}},{"line":140,"address":[5024032],"length":1,"stats":{"Line":1}},{"line":141,"address":[5024045],"length":1,"stats":{"Line":2}},{"line":149,"address":[5024080],"length":1,"stats":{"Line":1}},{"line":150,"address":[5024083],"length":1,"stats":{"Line":1}},{"line":158,"address":[5024112],"length":1,"stats":{"Line":1}},{"line":159,"address":[5024115],"length":1,"stats":{"Line":1}},{"line":169,"address":[5024144],"length":1,"stats":{"Line":1}},{"line":170,"address":[5024152],"length":1,"stats":{"Line":1}},{"line":178,"address":[5024176],"length":1,"stats":{"Line":1}},{"line":179,"address":[5024179],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":29},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_database.rs"],"content":"pub use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nCREATE DATABASE [IF NOT EXISTS] database_name;\n*/\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct CreateDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub if_not_exists: bool,\n}\n\nimpl CreateDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        CreateDatabaseQuery {\n            database_name: None,\n            if_not_exists: false,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateDatabaseQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[7764672],"length":1,"stats":{"Line":1}},{"line":20,"address":[7764736,7764912],"length":1,"stats":{"Line":1}},{"line":21,"address":[7764851,7764763],"length":1,"stats":{"Line":4}},{"line":22,"address":[7764877],"length":1,"stats":{"Line":2}},{"line":25,"address":[7764944],"length":1,"stats":{"Line":2}},{"line":26,"address":[7764958],"length":1,"stats":{"Line":2}},{"line":27,"address":[7764964],"length":1,"stats":{"Line":2}},{"line":30,"address":[7765008],"length":1,"stats":{"Line":2}},{"line":31,"address":[7765028],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_index.rs"],"content":"use crate::ast::{\n    types::{Column, TableName},\n    DDLStatement, SQLStatement,\n};\n\n/*\nCREATE [ UNIQUE ] INDEX [ IF NOT EXISTS ] name ON table_name\n    ( column_name [, ...] )\n*/\n\n#[derive(Clone, Debug, PartialEq)]\npub struct CreateIndexQuery {\n    pub index_name: String,\n    pub table: TableName,\n    pub columns: Vec\u003cColumn\u003e,\n    pub is_unique: bool,\n    pub if_not_exists: bool,\n}\n\nimpl CreateIndexQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            table: Default::default(),\n            columns: vec![],\n            is_unique: false,\n            if_not_exists: false,\n            index_name: \"\".into(),\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = table;\n        self\n    }\n\n    pub fn set_index_name(mut self, index_name: String) -\u003e Self {\n        self.index_name = index_name;\n        self\n    }\n\n    pub fn add_column(mut self, column: Column) -\u003e Self {\n        self.columns.push(column);\n        self\n    }\n\n    pub fn set_unique(mut self, unique: bool) -\u003e Self {\n        self.is_unique = unique;\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateIndexQuery(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::DataType;\n\n    use super::*;\n\n    #[test]\n    fn test_create_index() {\n        let query = CreateIndexQuery::builder()\n            .set_table(TableName::new(None, \"table_name\".into()))\n            .set_index_name(\"index_name\".into())\n            .add_column(\n                Column::builder()\n                    .set_name(\"column_name\".into())\n                    .set_data_type(DataType::Boolean)\n                    .build(),\n            )\n            .set_unique(true)\n            .set_if_not_exists(true)\n            .build();\n\n        let expected = SQLStatement::DDL(DDLStatement::CreateIndexQuery(CreateIndexQuery {\n            table: TableName::new(None, \"table_name\".into()),\n            index_name: \"index_name\".into(),\n            columns: vec![Column::builder()\n                .set_name(\"column_name\".into())\n                .set_data_type(DataType::Boolean)\n                .build()],\n            is_unique: true,\n            if_not_exists: true,\n        }));\n\n        assert_eq!(query, expected);\n    }\n}\n","traces":[{"line":21,"address":[3106992,3107229],"length":1,"stats":{"Line":1}},{"line":23,"address":[3107014],"length":1,"stats":{"Line":1}},{"line":24,"address":[3107024],"length":1,"stats":{"Line":1}},{"line":27,"address":[3107065],"length":1,"stats":{"Line":1}},{"line":31,"address":[3107401,3107248],"length":1,"stats":{"Line":1}},{"line":32,"address":[3107280,3107357],"length":1,"stats":{"Line":2}},{"line":33,"address":[3107381],"length":1,"stats":{"Line":1}},{"line":36,"address":[3107424,3107571],"length":1,"stats":{"Line":1}},{"line":37,"address":[3107529,3107456],"length":1,"stats":{"Line":2}},{"line":38,"address":[3107551],"length":1,"stats":{"Line":1}},{"line":41,"address":[3107709,3107600],"length":1,"stats":{"Line":1}},{"line":42,"address":[3107640],"length":1,"stats":{"Line":1}},{"line":43,"address":[3107689],"length":1,"stats":{"Line":1}},{"line":46,"address":[3107728],"length":1,"stats":{"Line":1}},{"line":47,"address":[3107751],"length":1,"stats":{"Line":1}},{"line":48,"address":[3107756],"length":1,"stats":{"Line":1}},{"line":51,"address":[3107776],"length":1,"stats":{"Line":1}},{"line":52,"address":[3107799],"length":1,"stats":{"Line":1}},{"line":53,"address":[3107804],"length":1,"stats":{"Line":1}},{"line":56,"address":[3107824],"length":1,"stats":{"Line":1}},{"line":57,"address":[3107841],"length":1,"stats":{"Line":1}}],"covered":21,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_table.rs"],"content":"use crate::ast::{\n    types::{Column, ForeignKey, TableName, TableOptions, UniqueKey},\n    DDLStatement, SQLStatement,\n};\n\n/*\nCREATE TABLE [IF NOT EXISTS] [database_name.]table_name (\n    column_name data_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'],\n    column_name data_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'],\n    ...\n    PRIMARY KEY (column_name),\n    UNIQUE (column_name),\n    FOREIGN KEY (column_name) REFERENCES table_name (column_name),\n    FOREIGN KEY (column_name) REFERENCES table_name (column_name),\n    ...\n);\n*/\n\n#[derive(Clone, Debug, PartialEq)]\npub struct CreateTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub columns: Vec\u003cColumn\u003e,\n    pub primary_key: Vec\u003cString\u003e,\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub unique_keys: Vec\u003cUniqueKey\u003e,\n    pub table_options: Option\u003cTableOptions\u003e,\n    pub if_not_exists: bool,\n}\n\nimpl CreateTableQuery {\n    pub fn builder() -\u003e Self {\n        CreateTableQuery {\n            table: None,\n            columns: vec![],\n            primary_key: vec![],\n            foreign_keys: vec![],\n            unique_keys: vec![],\n            table_options: None,\n            if_not_exists: false,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_table_option(mut self, option: TableOptions) -\u003e Self {\n        self.table_options = Some(option);\n        self\n    }\n\n    pub fn add_column(mut self, column: Column) -\u003e Self {\n        self.columns.push(column);\n        self\n    }\n\n    pub fn set_primary_key(mut self, columns: Vec\u003cString\u003e) -\u003e Self {\n        self.primary_key = columns;\n        self\n    }\n\n    pub fn add_unique_key(mut self, unique_key: UniqueKey) -\u003e Self {\n        self.unique_keys.push(unique_key);\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateTableQuery(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::DataType;\n\n    use super::*;\n\n    #[test]\n    fn test_create_table() {\n        let query = CreateTableQuery::builder()\n            .set_table(TableName::new(None, \"table_name\".into()))\n            .add_column(\n                Column::builder()\n                    .set_name(\"column_name\".into())\n                    .set_data_type(DataType::Int)\n                    .set_not_null(true)\n                    .set_primary_key(true)\n                    .set_comment(\"comment\".into())\n                    .build(),\n            )\n            .set_primary_key(vec![\"column_name\".into()])\n            .set_table_option(TableOptions {})\n            .add_unique_key(UniqueKey {\n                key_name: \"unique_key\".into(),\n                database_name: None,\n                columns: vec![\"column_name\".into()],\n            })\n            .set_if_not_exists(true)\n            .build();\n\n        let expected = SQLStatement::DDL(DDLStatement::CreateTableQuery(CreateTableQuery {\n            table: Some(TableName::new(None, \"table_name\".into())),\n            columns: vec![Column {\n                name: \"column_name\".into(),\n                data_type: DataType::Int,\n                comment: \"comment\".into(),\n                default: None,\n                not_null: true,\n                primary_key: true,\n            }],\n            primary_key: vec![\"column_name\".into()],\n            foreign_keys: vec![],\n            unique_keys: vec![UniqueKey {\n                key_name: \"unique_key\".into(),\n                database_name: None,\n                columns: vec![\"column_name\".into()],\n            }],\n            table_options: Some(TableOptions {}),\n            if_not_exists: true,\n        }));\n\n        assert_eq!(query, expected);\n    }\n}\n","traces":[{"line":31,"address":[2849296,2849715],"length":1,"stats":{"Line":1}},{"line":34,"address":[2849332],"length":1,"stats":{"Line":1}},{"line":35,"address":[2849376],"length":1,"stats":{"Line":1}},{"line":36,"address":[2849431],"length":1,"stats":{"Line":1}},{"line":37,"address":[2849484],"length":1,"stats":{"Line":1}},{"line":43,"address":[2849744,2849920],"length":1,"stats":{"Line":1}},{"line":44,"address":[2849771,2849871],"length":1,"stats":{"Line":2}},{"line":45,"address":[2849900],"length":1,"stats":{"Line":1}},{"line":48,"address":[2849952],"length":1,"stats":{"Line":1}},{"line":49,"address":[2849964],"length":1,"stats":{"Line":1}},{"line":50,"address":[2849981],"length":1,"stats":{"Line":1}},{"line":53,"address":[2850121,2850016],"length":1,"stats":{"Line":1}},{"line":54,"address":[2850056],"length":1,"stats":{"Line":1}},{"line":55,"address":[2850101],"length":1,"stats":{"Line":1}},{"line":58,"address":[2850144,2850297],"length":1,"stats":{"Line":1}},{"line":59,"address":[2850254,2850176],"length":1,"stats":{"Line":2}},{"line":60,"address":[2850277],"length":1,"stats":{"Line":1}},{"line":63,"address":[2850429,2850320],"length":1,"stats":{"Line":1}},{"line":64,"address":[2850360],"length":1,"stats":{"Line":1}},{"line":65,"address":[2850409],"length":1,"stats":{"Line":1}},{"line":68,"address":[2850448],"length":1,"stats":{"Line":1}},{"line":69,"address":[2850471],"length":1,"stats":{"Line":1}},{"line":70,"address":[2850479],"length":1,"stats":{"Line":1}},{"line":73,"address":[2850512],"length":1,"stats":{"Line":1}},{"line":74,"address":[2850529],"length":1,"stats":{"Line":1}}],"covered":25,"coverable":25},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","drop_database.rs"],"content":"pub use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nDROP DATABASE [IF EXISTS] database_name;\n*/\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DropDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub if_exists: bool,\n}\n\nimpl DropDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        DropDatabaseQuery {\n            database_name: None,\n            if_exists: false,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_if_exists(mut self, set_if_exists: bool) -\u003e Self {\n        self.if_exists = set_if_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::DropDatabaseQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[5632352],"length":1,"stats":{"Line":1}},{"line":20,"address":[5632416,5632592],"length":1,"stats":{"Line":1}},{"line":21,"address":[5632443,5632531],"length":1,"stats":{"Line":2}},{"line":22,"address":[5632557],"length":1,"stats":{"Line":1}},{"line":25,"address":[5632624],"length":1,"stats":{"Line":1}},{"line":26,"address":[5632638],"length":1,"stats":{"Line":1}},{"line":27,"address":[5632644],"length":1,"stats":{"Line":1}},{"line":30,"address":[5632688],"length":1,"stats":{"Line":1}},{"line":31,"address":[5632708],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","drop_table.rs"],"content":"use crate::ast::{types::TableName, DDLStatement, SQLStatement};\n\n/*\nDROP TABLE [IF EXISTS] [database_name.]table_name;\n*/\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DropTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub if_exists: bool,\n}\n\nimpl DropTableQuery {\n    pub fn builder() -\u003e Self {\n        DropTableQuery {\n            table: None,\n            if_exists: false,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_if_exists(mut self, set_if_exists: bool) -\u003e Self {\n        self.if_exists = set_if_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::DropTableQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[1955536],"length":1,"stats":{"Line":1}},{"line":20,"address":[1955616,1955780],"length":1,"stats":{"Line":1}},{"line":21,"address":[1955643,1955735],"length":1,"stats":{"Line":2}},{"line":22,"address":[1955760],"length":1,"stats":{"Line":1}},{"line":25,"address":[1955808],"length":1,"stats":{"Line":1}},{"line":26,"address":[1955831],"length":1,"stats":{"Line":1}},{"line":27,"address":[1955836],"length":1,"stats":{"Line":1}},{"line":30,"address":[1955856],"length":1,"stats":{"Line":1}},{"line":31,"address":[1955873],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","mod.rs"],"content":"pub mod alter_database;\npub mod alter_table;\npub mod create_database;\npub mod create_index;\npub mod create_table;\npub mod drop_database;\npub mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","delete.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::parts::{_where::WhereClause, target::UpdateTarget};\n\n#[derive(Clone, Debug, PartialEq, Default)]\npub struct DeleteQuery {\n    pub from_table: Option\u003cUpdateTarget\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n}\n\nimpl DeleteQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            from_table: None,\n            where_clause: None,\n        }\n    }\n\n    pub fn set_from_table(mut self, from: TableName) -\u003e Self {\n        self.from_table = Some(from.into());\n        self\n    }\n\n    pub fn set_from_alias(mut self, alias: String) -\u003e Self {\n        if self.from_table.is_some() {\n            self.from_table = self.from_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cDeleteQuery\u003e for SQLStatement {\n    fn from(value: DeleteQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::DeleteQuery(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    use super::*;\n\n    #[test]\n    fn test_builder_all() {\n        let delete_query = DeleteQuery::builder()\n            .set_from_table(TableName::new(None, \"table\".into()))\n            .set_where(WhereClause {\n                expression: SQLExpression::String(\"a\".into()),\n            })\n            .set_from_alias(\"alias\".into())\n            .build();\n\n        assert_eq!(\n            delete_query,\n            DeleteQuery {\n                from_table: Some(UpdateTarget {\n                    table: TableName::new(None, \"table\".into()),\n                    alias: Some(\"alias\".into()),\n                }),\n                where_clause: Some(WhereClause {\n                    expression: SQLExpression::String(\"a\".into()),\n                }),\n            }\n        );\n    }\n}\n","traces":[{"line":12,"address":[1955968],"length":1,"stats":{"Line":1}},{"line":19,"address":[1956080,1956343],"length":1,"stats":{"Line":1}},{"line":20,"address":[1956113,1956174],"length":1,"stats":{"Line":2}},{"line":21,"address":[1956320],"length":1,"stats":{"Line":1}},{"line":24,"address":[1956839,1956368,1956806],"length":1,"stats":{"Line":1}},{"line":25,"address":[1956506,1956724,1956402],"length":1,"stats":{"Line":3}},{"line":26,"address":[1956576],"length":1,"stats":{"Line":2}},{"line":27,"address":[5727527,5727419],"length":1,"stats":{"Line":2}},{"line":28,"address":[5727554],"length":1,"stats":{"Line":1}},{"line":31,"address":[1956522],"length":1,"stats":{"Line":1}},{"line":34,"address":[1956880,1957092],"length":1,"stats":{"Line":1}},{"line":35,"address":[1957043,1956907],"length":1,"stats":{"Line":2}},{"line":36,"address":[1957072],"length":1,"stats":{"Line":1}},{"line":39,"address":[1957120],"length":1,"stats":{"Line":1}},{"line":40,"address":[1957128],"length":1,"stats":{"Line":1}},{"line":45,"address":[5051440],"length":1,"stats":{"Line":0}},{"line":46,"address":[5051457],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":17},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","between.rs"],"content":"use std::ops::Not;\n\nuse crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::not_between::NotBetweenExpression;\n\n// a BETWEEN x AND y\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct BetweenExpression {\n    pub a: SQLExpression,\n    pub x: SQLExpression,\n    pub y: SQLExpression,\n}\n\nimpl From\u003cBetweenExpression\u003e for SQLExpression {\n    fn from(value: BetweenExpression) -\u003e SQLExpression {\n        SQLExpression::Between(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cBetweenExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cBetweenExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::Between(value)\n    }\n}\n\nimpl From\u003cBetweenExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: BetweenExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Between(Box::new(value))))\n    }\n}\n\nimpl Not for BetweenExpression {\n    type Output = NotBetweenExpression;\n\n    fn not(self) -\u003e Self::Output {\n        NotBetweenExpression {\n            a: self.a,\n            x: self.x,\n            y: self.y,\n        }\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_Box_BetweenExpression_for_SQLExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: SQLExpression = Box::new(between).into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::Between(Box::new(BetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into())\n            }))\n        );\n    }\n\n    #[test]\n    fn test_From_BetweenExpression_for_Option_Box_SQLExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: Option\u003cBox\u003cSQLExpression\u003e\u003e = between.into();\n        assert_eq!(\n            sql_expression,\n            Some(Box::new(SQLExpression::Between(Box::new(\n                BetweenExpression {\n                    a: SQLExpression::String(\"a\".into()),\n                    x: SQLExpression::String(\"x\".into()),\n                    y: SQLExpression::String(\"y\".into())\n                }\n            ))))\n        );\n    }\n\n    #[test]\n    fn test_Not_for_BetweenExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let not_between = !between;\n        assert_eq!(\n            not_between,\n            super::NotBetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into())\n            }\n        );\n    }\n}\n","traces":[{"line":17,"address":[8201456],"length":1,"stats":{"Line":1}},{"line":18,"address":[8201577],"length":1,"stats":{"Line":1}},{"line":23,"address":[8201600],"length":1,"stats":{"Line":1}},{"line":24,"address":[8201608],"length":1,"stats":{"Line":1}},{"line":29,"address":[7769200],"length":1,"stats":{"Line":1}},{"line":30,"address":[7769439,7769316],"length":1,"stats":{"Line":2}},{"line":37,"address":[5731568],"length":1,"stats":{"Line":1}},{"line":39,"address":[5731590],"length":1,"stats":{"Line":1}},{"line":40,"address":[5731610],"length":1,"stats":{"Line":1}},{"line":41,"address":[5731634],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","binary.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::operators::BinaryOperator;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct BinaryOperatorExpression {\n    pub operator: BinaryOperator,\n    pub lhs: SQLExpression,\n    pub rhs: SQLExpression,\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for SQLExpression {\n    fn from(value: BinaryOperatorExpression) -\u003e SQLExpression {\n        SQLExpression::Binary(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cBinaryOperatorExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cBinaryOperatorExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::Binary(value)\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Option\u003cSQLExpression\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Option\u003cSQLExpression\u003e {\n        Some(SQLExpression::Binary(Box::new(value)))\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Box\u003cSQLExpression\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Box\u003cSQLExpression\u003e {\n        Box::new(SQLExpression::Binary(Box::new(value)))\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Binary(Box::new(value))))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::dml::expressions::operators::BinaryOperator;\n\n    #[test]\n    fn test_From_BinaryOperatorExpression_for_Option_Box_SQLExpression() {\n        use crate::ast::dml::expressions::binary::BinaryOperatorExpression;\n        use crate::ast::types::SQLExpression;\n        use std::convert::From;\n\n        let binary_operator_expression = BinaryOperatorExpression {\n            operator: BinaryOperator::Add,\n            lhs: SQLExpression::Integer(1),\n            rhs: SQLExpression::Integer(2),\n        };\n        let res: Option\u003cBox\u003cSQLExpression\u003e\u003e = From::from(binary_operator_expression.clone());\n\n        assert_eq!(\n            res,\n            Some(Box::new(SQLExpression::Binary(Box::new(\n                binary_operator_expression\n            ))))\n        );\n    }\n}\n","traces":[{"line":14,"address":[8201632],"length":1,"stats":{"Line":1}},{"line":15,"address":[8201753],"length":1,"stats":{"Line":1}},{"line":20,"address":[8201776],"length":1,"stats":{"Line":1}},{"line":21,"address":[8201784],"length":1,"stats":{"Line":1}},{"line":26,"address":[7769472],"length":1,"stats":{"Line":1}},{"line":27,"address":[7769585],"length":1,"stats":{"Line":1}},{"line":32,"address":[7769632],"length":1,"stats":{"Line":1}},{"line":33,"address":[7769745],"length":1,"stats":{"Line":1}},{"line":38,"address":[7769888],"length":1,"stats":{"Line":1}},{"line":39,"address":[7770127,7770004],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","boolean.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct BooleanExpression {\n    pub value: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","call.rs"],"content":"use crate::ast::types::{Function, SQLExpression};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct CallExpression {\n    pub function: Function,\n    pub arguments: Vec\u003cSQLExpression\u003e,\n}\n\nimpl From\u003cCallExpression\u003e for SQLExpression {\n    fn from(value: CallExpression) -\u003e SQLExpression {\n        SQLExpression::FunctionCall(value)\n    }\n}\n","traces":[{"line":12,"address":[8201808],"length":1,"stats":{"Line":2}},{"line":13,"address":[8201816],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","float.rs"],"content":"#[derive(Clone, Debug, PartialEq)]\npub struct FloatExpression {\n    pub value: f64,\n}\n\nimpl FloatExpression {\n    pub fn new(value: f64) -\u003e Self {\n        Self { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::FloatExpression;\n\n    #[test]\n    fn test_new() {\n        let float = FloatExpression::new(1.0);\n        assert_eq!(float.value, 1.0);\n    }\n}\n","traces":[{"line":7,"address":[1842304],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","identifier.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct IdentifierExpression {\n    pub idendifier: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","integer.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct IntegerExpression {\n    pub value: i64,\n}\n\nimpl IntegerExpression {\n    pub fn new(value: i64) -\u003e Self {\n        Self { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::IntegerExpression;\n\n    #[test]\n    fn test_new() {\n        let integer = IntegerExpression::new(1);\n        assert_eq!(integer.value, 1);\n    }\n}\n","traces":[{"line":7,"address":[1212720],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","list.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct ListExpression {\n    pub value: Vec\u003cSQLExpression\u003e,\n}\n\nimpl From\u003cListExpression\u003e for SQLExpression {\n    fn from(value: ListExpression) -\u003e SQLExpression {\n        SQLExpression::List(value)\n    }\n}\n\nimpl From\u003cVec\u003cSQLExpression\u003e\u003e for ListExpression {\n    fn from(value: Vec\u003cSQLExpression\u003e) -\u003e ListExpression {\n        ListExpression { value }\n    }\n}\n","traces":[{"line":11,"address":[8201840],"length":1,"stats":{"Line":2}},{"line":12,"address":[8201843],"length":1,"stats":{"Line":2}},{"line":17,"address":[3537424],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","mod.rs"],"content":"pub mod between;\npub mod binary;\npub mod boolean;\npub mod call;\npub mod float;\npub mod identifier;\npub mod integer;\npub mod list;\npub mod not_between;\npub mod operators;\npub mod parentheses;\npub mod string;\npub mod subquery;\npub mod unary;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","not_between.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n// a NOT BETWEEN x AND y\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct NotBetweenExpression {\n    pub a: SQLExpression,\n    pub x: SQLExpression,\n    pub y: SQLExpression,\n}\n\nimpl From\u003cNotBetweenExpression\u003e for SQLExpression {\n    fn from(value: NotBetweenExpression) -\u003e SQLExpression {\n        SQLExpression::NotBetween(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cNotBetweenExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cNotBetweenExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::NotBetween(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use super::NotBetweenExpression;\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_Box_NotBetweenExpression_for_SQLExpression() {\n        let not_between = NotBetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: SQLExpression = Box::new(not_between).into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into()),\n            }))\n        );\n    }\n}\n","traces":[{"line":14,"address":[8201888],"length":1,"stats":{"Line":1}},{"line":15,"address":[8202009],"length":1,"stats":{"Line":1}},{"line":20,"address":[8202032],"length":1,"stats":{"Line":1}},{"line":21,"address":[8202040],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","operators.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// 2항연산자\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum BinaryOperator {\n    Add,     // A + B\n    Sub,     // A - B\n    Mul,     // A * B\n    Div,     // A / B\n    And,     // A AND B\n    Or,      // A OR B\n    Lt,      // A \u003c B\n    Gt,      // A \u003e B\n    Lte,     // A \u003c= B\n    Gte,     // A \u003e= B\n    Eq,      // A = B\n    Neq,     // A != B, A \u003c\u003e B\n    Like,    // A LIKE B\n    NotLike, // A NOT LIKE B\n    In,      // A In B\n    NotIn,   // A Not In B\n    Is,      // A Is B\n    IsNot,   // A Is Not B\n}\n\n// 단항연산자\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum UnaryOperator {\n    Pos, // +A\n    Neg, // -A\n    Not, // Not A\n}\n\nimpl BinaryOperator {\n    // 2항연산자 우선순위 획득\n    pub fn get_precedence(\u0026self) -\u003e i32 {\n        match self {\n            BinaryOperator::Add =\u003e 10,\n            BinaryOperator::Sub =\u003e 10,\n            BinaryOperator::Mul =\u003e 40,\n            BinaryOperator::Div =\u003e 40,\n            BinaryOperator::And =\u003e 10,\n            BinaryOperator::Or =\u003e 10,\n            BinaryOperator::Lt =\u003e 10,\n            BinaryOperator::Gt =\u003e 10,\n            BinaryOperator::Lte =\u003e 10,\n            BinaryOperator::Gte =\u003e 10,\n            BinaryOperator::Eq =\u003e 10,\n            BinaryOperator::Neq =\u003e 10,\n            BinaryOperator::Like =\u003e 10,\n            BinaryOperator::NotLike =\u003e 10,\n            BinaryOperator::In =\u003e 10,\n            BinaryOperator::NotIn =\u003e 10,\n            BinaryOperator::Is =\u003e 10,\n            BinaryOperator::IsNot =\u003e 10,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BinaryOperator;\n\n    #[test]\n    fn test_get_precedence() {\n        assert_eq!(BinaryOperator::Add.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Sub.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Mul.get_precedence(), 40);\n        assert_eq!(BinaryOperator::Div.get_precedence(), 40);\n        assert_eq!(BinaryOperator::And.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Or.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Lt.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Gt.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Lte.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Gte.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Eq.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Neq.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Like.get_precedence(), 10);\n        assert_eq!(BinaryOperator::NotLike.get_precedence(), 10);\n        assert_eq!(BinaryOperator::In.get_precedence(), 10);\n        assert_eq!(BinaryOperator::NotIn.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Is.get_precedence(), 10);\n        assert_eq!(BinaryOperator::IsNot.get_precedence(), 10);\n    }\n}\n","traces":[{"line":36,"address":[2073440],"length":1,"stats":{"Line":1}},{"line":37,"address":[2073445],"length":1,"stats":{"Line":1}},{"line":38,"address":[2073476],"length":1,"stats":{"Line":1}},{"line":39,"address":[2073489],"length":1,"stats":{"Line":1}},{"line":40,"address":[2073502],"length":1,"stats":{"Line":1}},{"line":41,"address":[2073515],"length":1,"stats":{"Line":1}},{"line":42,"address":[2073528],"length":1,"stats":{"Line":1}},{"line":43,"address":[2073541],"length":1,"stats":{"Line":1}},{"line":44,"address":[2073551],"length":1,"stats":{"Line":1}},{"line":45,"address":[2073561],"length":1,"stats":{"Line":1}},{"line":46,"address":[2073571],"length":1,"stats":{"Line":1}},{"line":47,"address":[2073581],"length":1,"stats":{"Line":1}},{"line":48,"address":[2073591],"length":1,"stats":{"Line":1}},{"line":49,"address":[2073601],"length":1,"stats":{"Line":1}},{"line":50,"address":[2073611],"length":1,"stats":{"Line":1}},{"line":51,"address":[2073621],"length":1,"stats":{"Line":1}},{"line":52,"address":[2073631],"length":1,"stats":{"Line":1}},{"line":53,"address":[2073641],"length":1,"stats":{"Line":1}},{"line":54,"address":[2073651],"length":1,"stats":{"Line":1}},{"line":55,"address":[2073661],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","parentheses.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct ParenthesesExpression {\n    pub expression: SQLExpression,\n}\n\nimpl From\u003cParenthesesExpression\u003e for SQLExpression {\n    fn from(value: ParenthesesExpression) -\u003e SQLExpression {\n        SQLExpression::Parentheses(Box::new(value))\n    }\n}\n","traces":[{"line":11,"address":[8202064],"length":1,"stats":{"Line":1}},{"line":12,"address":[8202185],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","string.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct StringExpression {\n    pub value: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","subquery.rs"],"content":"use crate::ast::{dml::select::SelectQuery, types::SQLExpression};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SubqueryExpression {\n    Select(Box\u003cSelectQuery\u003e),\n}\n\nimpl From\u003cSubqueryExpression\u003e for SQLExpression {\n    fn from(value: SubqueryExpression) -\u003e SQLExpression {\n        SQLExpression::Subquery(value)\n    }\n}\n","traces":[{"line":11,"address":[8202208],"length":1,"stats":{"Line":1}},{"line":12,"address":[8202216],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","unary.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::operators::UnaryOperator;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct UnaryOperatorExpression {\n    pub operator: UnaryOperator,\n    pub operand: SQLExpression,\n}\n\nimpl From\u003cUnaryOperatorExpression\u003e for SQLExpression {\n    fn from(value: UnaryOperatorExpression) -\u003e SQLExpression {\n        SQLExpression::Unary(Box::new(value))\n    }\n}\n\nimpl From\u003cUnaryOperatorExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: UnaryOperatorExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Unary(Box::new(value))))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use super::UnaryOperatorExpression;\n    use crate::ast::dml::expressions::operators::UnaryOperator;\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_UnaryOperatorExpression_for_SQLExpression() {\n        let unary = UnaryOperatorExpression {\n            operator: UnaryOperator::Neg,\n            operand: SQLExpression::Integer(1),\n        };\n        let sql_expression: SQLExpression = unary.into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                operator: UnaryOperator::Neg,\n                operand: SQLExpression::Integer(1),\n            }))\n        );\n    }\n\n    #[test]\n    fn test_From_UnaryOperatorExpression_for_Option_Box_SQLExpression() {\n        let unary = UnaryOperatorExpression {\n            operator: UnaryOperator::Neg,\n            operand: SQLExpression::Integer(1),\n        };\n        let sql_expression: Option\u003cBox\u003cSQLExpression\u003e\u003e = unary.into();\n\n        assert_eq!(\n            sql_expression,\n            Some(Box::new(SQLExpression::Unary(Box::new(\n                UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::Integer(1),\n                }\n            ))))\n        );\n    }\n}\n","traces":[{"line":13,"address":[8202240],"length":1,"stats":{"Line":1}},{"line":14,"address":[8202361],"length":1,"stats":{"Line":1}},{"line":19,"address":[7770160],"length":1,"stats":{"Line":1}},{"line":20,"address":[7770418,7770301],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","insert.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::{parts::insert_values::InsertValue, select::SelectQuery};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct InsertQuery {\n    pub into_table: Option\u003cTableName\u003e,\n    pub columns: Vec\u003cString\u003e,\n    pub data: InsertData,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum InsertData {\n    Select(Box\u003cSelectQuery\u003e),\n    Values(Vec\u003cInsertValue\u003e),\n    None,\n}\n\nimpl InsertQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            columns: vec![],\n            into_table: None,\n            data: InsertData::None,\n        }\n    }\n\n    pub fn set_into_table(mut self, from: TableName) -\u003e Self {\n        self.into_table = Some(from);\n        self\n    }\n\n    pub fn set_columns(mut self, columns: Vec\u003cString\u003e) -\u003e Self {\n        self.columns = columns;\n        self\n    }\n\n    pub fn set_values(mut self, values: Vec\u003cInsertValue\u003e) -\u003e Self {\n        self.data = InsertData::Values(values);\n        self\n    }\n\n    pub fn set_select(mut self, select: SelectQuery) -\u003e Self {\n        self.data = InsertData::Select(Box::new(select));\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cInsertQuery\u003e for SQLStatement {\n    fn from(value: InsertQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::InsertQuery(value))\n    }\n}\n","traces":[{"line":20,"address":[2891440],"length":1,"stats":{"Line":1}},{"line":22,"address":[2891454],"length":1,"stats":{"Line":4}},{"line":28,"address":[2891600,2891773],"length":1,"stats":{"Line":4}},{"line":29,"address":[2891627,2891724],"length":1,"stats":{"Line":8}},{"line":30,"address":[2891753],"length":1,"stats":{"Line":4}},{"line":33,"address":[2891792,2891939],"length":1,"stats":{"Line":4}},{"line":34,"address":[2891824,2891897],"length":1,"stats":{"Line":8}},{"line":35,"address":[2891919],"length":1,"stats":{"Line":4}},{"line":38,"address":[2891968,2892126],"length":1,"stats":{"Line":3}},{"line":39,"address":[2891995,2892079],"length":1,"stats":{"Line":6}},{"line":40,"address":[2892106],"length":1,"stats":{"Line":3}},{"line":43,"address":[2892160,2892466],"length":1,"stats":{"Line":1}},{"line":44,"address":[2892328],"length":1,"stats":{"Line":1}},{"line":45,"address":[2892446],"length":1,"stats":{"Line":1}},{"line":48,"address":[2892496],"length":1,"stats":{"Line":3}},{"line":49,"address":[2892504],"length":1,"stats":{"Line":3}},{"line":54,"address":[5051536],"length":1,"stats":{"Line":3}},{"line":55,"address":[5051553],"length":1,"stats":{"Line":3}}],"covered":18,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","mod.rs"],"content":"pub mod delete;\npub mod insert;\npub mod select;\npub mod update;\n\npub mod parts;\n\npub mod expressions;\n\npub mod plan;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","from.rs"],"content":"use crate::ast::{dml::expressions::subquery::SubqueryExpression, types::TableName};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct FromClause {\n    pub from: FromTarget,\n    pub alias: Option\u003cString\u003e,\n}\n\nimpl FromClause {}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum FromTarget {\n    Table(TableName),             // 일반 테이블 참조\n    Subquery(SubqueryExpression), // 서브쿼리 참조\n}\n\nimpl FromTarget {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","group_by.rs"],"content":"use crate::ast::types::SelectColumn;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct GroupByClause {\n    pub group_by_items: Vec\u003cGroupByItem\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash)]\npub struct GroupByItem {\n    pub item: SelectColumn,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","having.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct HavingClause {\n    pub expression: Box\u003cSQLExpression\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","insert_values.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct InsertValue {\n    pub list: Vec\u003cOption\u003cSQLExpression\u003e\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","join.rs"],"content":"use crate::ast::types::{SQLExpression, TableName};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct JoinClause {\n    pub join_type: JoinType,\n    pub right: TableName,\n    pub right_alias: Option\u003cString\u003e,\n    pub on: Option\u003cSQLExpression\u003e,\n}\n\nimpl JoinClause {}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum JoinType {\n    InnerJoin,\n    LeftOuterJoin,\n    RightOuterJoin,\n    FullOuterJoin,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","mod.rs"],"content":"#[path = \"./where.rs\"]\npub mod _where;\npub mod from;\npub mod group_by;\npub mod having;\npub mod insert_values;\npub mod join;\npub mod order_by;\npub mod select_item;\npub mod target;\npub mod update_item;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","order_by.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct OrderByClause {\n    pub order_by_items: Vec\u003cOrderByItem\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct OrderByItem {\n    pub item: SQLExpression,\n    pub order_type: OrderByType,\n    pub nulls: OrderByNulls,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum OrderByType {\n    Asc,\n    Desc,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum OrderByNulls {\n    First,\n    Last,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","select_item.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SelectKind {\n    WildCard(SelectWildCard),\n    SelectItem(SelectItem),\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct SelectWildCard {\n    pub alias: Option\u003cString\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct SelectItem {\n    pub item: Option\u003cSQLExpression\u003e, // select 요소\n    pub alias: Option\u003cString\u003e,       // as 절이 있을 경우 alias 정보\n}\n\nimpl SelectItem {\n    pub fn builder() -\u003e Self {\n        Self {\n            item: None,\n            alias: None,\n        }\n    }\n\n    pub fn set_item(mut self, item: SQLExpression) -\u003e Self {\n        self.item = Some(item);\n        self\n    }\n\n    pub fn set_alias(mut self, alias: String) -\u003e Self {\n        self.alias = Some(alias);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n","traces":[{"line":23,"address":[7513136],"length":1,"stats":{"Line":1}},{"line":30,"address":[7513457,7513248],"length":1,"stats":{"Line":1}},{"line":31,"address":[7513408,7513275],"length":1,"stats":{"Line":2}},{"line":32,"address":[7513437],"length":1,"stats":{"Line":1}},{"line":35,"address":[7513644,7513488],"length":1,"stats":{"Line":1}},{"line":36,"address":[7513515,7513598],"length":1,"stats":{"Line":2}},{"line":37,"address":[7513624],"length":1,"stats":{"Line":1}},{"line":40,"address":[7513664],"length":1,"stats":{"Line":1}},{"line":41,"address":[7513672],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","target.rs"],"content":"use crate::ast::types::TableName;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UpdateTarget {\n    pub table: TableName,\n    pub alias: Option\u003cString\u003e,\n}\n\nimpl From\u003cTableName\u003e for UpdateTarget {\n    fn from(value: TableName) -\u003e UpdateTarget {\n        UpdateTarget {\n            table: value,\n            alias: None,\n        }\n    }\n}\n","traces":[{"line":12,"address":[2073344],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","update_item.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdateItem {\n    pub column: String,       // update할 컬럼\n    pub value: SQLExpression, // 수정할 값\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","where.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct WhereClause {\n    pub expression: SQLExpression,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","delete_plan.rs"],"content":"use crate::ast::dml::plan::select::filter::FilterPlan;\n\nuse super::from::DeleteFromPlan;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct DeletePlan {\n    pub list: Vec\u003cDeletePlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DeletePlanItem {\n    DeleteFrom(DeleteFromPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cFilterPlan\u003e for DeletePlanItem {\n    fn from(value: FilterPlan) -\u003e DeletePlanItem {\n        DeletePlanItem::Filter(value)\n    }\n}\n\nimpl From\u003cDeleteFromPlan\u003e for DeletePlanItem {\n    fn from(value: DeleteFromPlan) -\u003e DeletePlanItem {\n        DeletePlanItem::DeleteFrom(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::plan::select::scan::ScanType,\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_FilterPlan_for_DeletePlanItem() {\n        use super::DeletePlanItem;\n\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let delete_plan_item: DeletePlanItem = filter.clone().into();\n        assert_eq!(delete_plan_item, DeletePlanItem::Filter(filter));\n    }\n\n    #[test]\n    fn From_DeleteFromPlan_for_DeletePlanItem() {\n        use super::DeleteFromPlan;\n\n        let delete_from = DeleteFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let delete_plan_item: DeletePlanItem = delete_from.clone().into();\n        assert_eq!(delete_plan_item, DeletePlanItem::DeleteFrom(delete_from));\n    }\n}\n","traces":[{"line":17,"address":[2313968],"length":1,"stats":{"Line":1}},{"line":18,"address":[2313985],"length":1,"stats":{"Line":1}},{"line":23,"address":[2314032],"length":1,"stats":{"Line":1}},{"line":24,"address":[2314040],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","from.rs"],"content":"use crate::ast::{dml::plan::select::scan::ScanType, types::TableName};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DeleteFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","mod.rs"],"content":"pub mod delete_plan;\npub mod from;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","mod.rs"],"content":"pub mod delete;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","filter.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct FilterPlan {\n    pub expression: SQLExpression,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","from.rs"],"content":"use crate::ast::types::TableName;\n\nuse super::scan::ScanType;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct SelectFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","join.rs"],"content":"use crate::ast::{\n    dml::parts::join::JoinType,\n    types::{Index, SQLExpression, TableName},\n};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct JoinPlan {\n    pub left: TableName,\n    pub right: TableName,\n    pub join_type: JoinType,\n    pub join_scan_type: JoinScanType,\n    pub select_columns: Vec\u003cString\u003e,\n    pub index: Option\u003cIndex\u003e,\n    pub filter: Option\u003cSQLExpression\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum JoinScanType {\n    NestedLoop,\n    Hash,\n    Merge,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","limit_offset.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct LimitOffsetPlan {\n    pub limit: Option\u003cu32\u003e,\n    pub offset: Option\u003cu32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","mod.rs"],"content":"pub mod filter;\npub mod from;\npub mod join;\npub mod limit_offset;\npub mod scan;\npub mod select_plan;\npub mod subquery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","no_from.rs"],"content":"use crate::ast::predule::{Index, TableName};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectNoFromPlan {\n    select_columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","scan.rs"],"content":"use crate::ast::types::Index;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum ScanType {\n    FullScan,\n    IndexScan(Index),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","select_plan.rs"],"content":"use crate::ast::dml::parts::{group_by::GroupByClause, order_by::OrderByClause};\n\nuse super::{\n    filter::FilterPlan, from::SelectFromPlan, join::JoinPlan, limit_offset::LimitOffsetPlan,\n    subquery::SelectSubqueryPlan,\n};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectPlan {\n    pub list: Vec\u003cSelectPlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SelectPlanItem {\n    From(SelectFromPlan),\n    Subquery(SelectSubqueryPlan),\n    Join(JoinPlan),\n    Order(OrderByClause),\n    Group(GroupByClause),\n    GroupAll,\n    LimitOffset(LimitOffsetPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cSelectFromPlan\u003e for SelectPlanItem {\n    fn from(value: SelectFromPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::From(value)\n    }\n}\n\nimpl From\u003cSelectSubqueryPlan\u003e for SelectPlanItem {\n    fn from(value: SelectSubqueryPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Subquery(value)\n    }\n}\n\nimpl From\u003cJoinPlan\u003e for SelectPlanItem {\n    fn from(value: JoinPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Join(value)\n    }\n}\n\nimpl From\u003cOrderByClause\u003e for SelectPlanItem {\n    fn from(value: OrderByClause) -\u003e SelectPlanItem {\n        SelectPlanItem::Order(value)\n    }\n}\n\nimpl From\u003cGroupByClause\u003e for SelectPlanItem {\n    fn from(value: GroupByClause) -\u003e SelectPlanItem {\n        SelectPlanItem::Group(value)\n    }\n}\n\nimpl From\u003cLimitOffsetPlan\u003e for SelectPlanItem {\n    fn from(value: LimitOffsetPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::LimitOffset(value)\n    }\n}\n\nimpl From\u003cFilterPlan\u003e for SelectPlanItem {\n    fn from(value: FilterPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Filter(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::{\n            parts::join::JoinType,\n            plan::select::{from::SelectFromPlan, join::JoinScanType, scan::ScanType},\n        },\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_SelectFromPlan_for_SelectPlanItem() {\n        let select_from = SelectFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let select_plan_item: SelectPlanItem = select_from.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::From(select_from));\n    }\n\n    #[test]\n    fn From_SelectSubqueryPlan_for_SelectPlanItem() {\n        let select_subquery = SelectSubqueryPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            select_columns: vec![],\n            index: None,\n            filter: None,\n        };\n        let select_plan_item: SelectPlanItem = select_subquery.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Subquery(select_subquery));\n    }\n\n    #[test]\n    fn From_JoinPlan_for_SelectPlanItem() {\n        let join = JoinPlan {\n            join_type: JoinType::InnerJoin,\n            left: TableName::new(None, \"l\".into()),\n            right: TableName::new(None, \"r\".into()),\n            join_scan_type: JoinScanType::Hash,\n            select_columns: vec![],\n            index: None,\n            filter: None,\n        };\n        let select_plan_item: SelectPlanItem = join.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Join(join));\n    }\n\n    #[test]\n    fn From_OrderByClause_for_SelectPlanItem() {\n        let order_by = OrderByClause {\n            order_by_items: vec![],\n        };\n        let select_plan_item: SelectPlanItem = order_by.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Order(order_by));\n    }\n\n    #[test]\n    fn From_GroupByClause_for_SelectPlanItem() {\n        let group_by = GroupByClause {\n            group_by_items: vec![],\n        };\n        let select_plan_item: SelectPlanItem = group_by.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Group(group_by));\n    }\n\n    #[test]\n    fn From_LimitOffsetPlan_for_SelectPlanItem() {\n        let limit_offset = LimitOffsetPlan {\n            limit: None,\n            offset: None,\n        };\n        let select_plan_item: SelectPlanItem = limit_offset.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::LimitOffset(limit_offset));\n    }\n\n    #[test]\n    fn From_FilterPlan_for_SelectPlanItem() {\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let select_plan_item: SelectPlanItem = filter.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Filter(filter));\n    }\n}\n","traces":[{"line":26,"address":[5271888],"length":1,"stats":{"Line":1}},{"line":27,"address":[5271905],"length":1,"stats":{"Line":1}},{"line":32,"address":[5271952],"length":1,"stats":{"Line":1}},{"line":33,"address":[5271969],"length":1,"stats":{"Line":1}},{"line":38,"address":[5272016],"length":1,"stats":{"Line":1}},{"line":39,"address":[5272024],"length":1,"stats":{"Line":1}},{"line":44,"address":[5272048],"length":1,"stats":{"Line":1}},{"line":45,"address":[5272051],"length":1,"stats":{"Line":1}},{"line":50,"address":[5272096],"length":1,"stats":{"Line":1}},{"line":51,"address":[5272099],"length":1,"stats":{"Line":1}},{"line":56,"address":[5272144],"length":1,"stats":{"Line":1}},{"line":57,"address":[5272147],"length":1,"stats":{"Line":1}},{"line":62,"address":[5272176],"length":1,"stats":{"Line":1}},{"line":63,"address":[5272193],"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","subquery.rs"],"content":"use crate::ast::types::{Index, SQLExpression, TableName};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectSubqueryPlan {\n    pub table_name: TableName,\n    pub select_columns: Vec\u003cString\u003e,\n    pub index: Option\u003cIndex\u003e,\n    pub filter: Option\u003cSQLExpression\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","from.rs"],"content":"use crate::ast::{dml::plan::select::scan::ScanType, types::TableName};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct UpdateFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","mod.rs"],"content":"pub mod from;\npub mod update_plan;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","update_plan.rs"],"content":"use crate::ast::dml::plan::select::filter::FilterPlan;\n\nuse super::from::UpdateFromPlan;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdatePlan {\n    pub list: Vec\u003cUpdatePlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum UpdatePlanItem {\n    UpdateFrom(UpdateFromPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cFilterPlan\u003e for UpdatePlanItem {\n    fn from(value: FilterPlan) -\u003e UpdatePlanItem {\n        UpdatePlanItem::Filter(value)\n    }\n}\n\nimpl From\u003cUpdateFromPlan\u003e for UpdatePlanItem {\n    fn from(value: UpdateFromPlan) -\u003e UpdatePlanItem {\n        UpdatePlanItem::UpdateFrom(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::plan::select::scan::ScanType,\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_FilterPlan_for_UpdatePlanItem() {\n        use super::UpdatePlanItem;\n\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let update_plan_item: UpdatePlanItem = filter.clone().into();\n        assert_eq!(update_plan_item, UpdatePlanItem::Filter(filter));\n    }\n\n    #[test]\n    fn From_UpdateFromPlan_for_UpdatePlanItem() {\n        use super::UpdateFromPlan;\n\n        let update_from = UpdateFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let update_plan_item: UpdatePlanItem = update_from.clone().into();\n        assert_eq!(update_plan_item, UpdatePlanItem::UpdateFrom(update_from));\n    }\n}\n","traces":[{"line":17,"address":[7931392],"length":1,"stats":{"Line":1}},{"line":18,"address":[7931409],"length":1,"stats":{"Line":1}},{"line":23,"address":[7931456],"length":1,"stats":{"Line":1}},{"line":24,"address":[7931464],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","select.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::ast::{\n    ddl::drop_database::SQLStatement,\n    types::{SQLExpression, SelectColumn, TableName},\n    DMLStatement,\n};\n\nuse super::{\n    expressions::subquery::SubqueryExpression,\n    parts::{\n        _where::WhereClause,\n        from::{FromClause, FromTarget},\n        group_by::{GroupByClause, GroupByItem},\n        having::HavingClause,\n        join::JoinClause,\n        order_by::{OrderByClause, OrderByItem},\n        select_item::{SelectItem, SelectKind, SelectWildCard},\n    },\n};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct SelectQuery {\n    pub select_items: Vec\u003cSelectKind\u003e,\n    pub has_aggregate: bool,\n    pub from_table: Option\u003cFromClause\u003e,\n    pub join_clause: Vec\u003cJoinClause\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n    pub order_by_clause: Option\u003cOrderByClause\u003e,\n    pub group_by_clause: Option\u003cGroupByClause\u003e,\n    pub having_clause: Option\u003cHavingClause\u003e,\n    pub limit: Option\u003cu32\u003e,\n    pub offset: Option\u003cu32\u003e,\n}\n\nimpl SelectQuery {\n    pub fn builder() -\u003e Self {\n        SelectQuery {\n            select_items: vec![],\n            from_table: None,\n            join_clause: vec![],\n            where_clause: None,\n            group_by_clause: None,\n            having_clause: None,\n            order_by_clause: None,\n            limit: None,\n            offset: None,\n            has_aggregate: false,\n        }\n    }\n\n    pub fn add_select_item(mut self, item: SelectItem) -\u003e Self {\n        self.select_items.push(SelectKind::SelectItem(item));\n        self\n    }\n\n    pub fn add_select_wildcard(mut self, item: SelectWildCard) -\u003e Self {\n        self.select_items.push(SelectKind::WildCard(item));\n        self\n    }\n\n    pub fn set_from_table(mut self, from: TableName) -\u003e Self {\n        self.from_table = Some(from.into());\n        self\n    }\n\n    pub fn has_from_table(\u0026self) -\u003e bool {\n        self.from_table.is_some()\n    }\n\n    pub fn set_from_subquery(mut self, from: SubqueryExpression) -\u003e Self {\n        self.from_table = Some(FromClause {\n            from: FromTarget::Subquery(from),\n            alias: None,\n        });\n        self\n    }\n\n    pub fn set_from_alias(mut self, alias: String) -\u003e Self {\n        if self.from_table.is_some() {\n            self.from_table = self.from_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn add_join(mut self, join: JoinClause) -\u003e Self {\n        self.join_clause.push(join);\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn add_order_by(mut self, item: OrderByItem) -\u003e Self {\n        match self.order_by_clause {\n            Some(ref mut order_by_clause) =\u003e {\n                order_by_clause.order_by_items.push(item);\n            }\n            None =\u003e {\n                self.order_by_clause = Some(OrderByClause {\n                    order_by_items: vec![item],\n                })\n            }\n        }\n\n        self\n    }\n\n    pub fn add_group_by(mut self, item: GroupByItem) -\u003e Self {\n        match self.group_by_clause {\n            Some(ref mut group_by_clause) =\u003e {\n                group_by_clause.group_by_items.push(item);\n            }\n            None =\u003e {\n                self.group_by_clause = Some(GroupByClause {\n                    group_by_items: vec![item],\n                })\n            }\n        }\n\n        self\n    }\n\n    pub fn has_group_by(\u0026self) -\u003e bool {\n        match self.group_by_clause {\n            Some(ref group_by_clause) =\u003e !group_by_clause.group_by_items.is_empty(),\n            None =\u003e false,\n        }\n    }\n\n    pub fn set_having(mut self, having_clause: HavingClause) -\u003e Self {\n        self.having_clause = Some(having_clause);\n        self\n    }\n\n    pub fn set_offset(mut self, offset: u32) -\u003e Self {\n        self.offset = Some(offset);\n        self\n    }\n\n    pub fn set_limit(mut self, limit: u32) -\u003e Self {\n        self.limit = Some(limit);\n        self\n    }\n\n    pub fn set_has_aggregate(mut self, has_aggregate: bool) -\u003e Self {\n        self.has_aggregate = has_aggregate;\n        self\n    }\n\n    pub fn has_aggregate(\u0026self) -\u003e bool {\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n\n                    if item.has_aggregate() {\n                        return true;\n                    }\n                }\n                SelectKind::WildCard(_) =\u003e return false,\n            }\n        }\n\n        false\n    }\n\n    pub fn get_non_aggregate_column(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        let mut list = vec![];\n\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n                    let mut none_aggregate_columns = item.find_non_aggregate_columns();\n                    list.append(\u0026mut none_aggregate_columns);\n                }\n                SelectKind::WildCard(_) =\u003e {}\n            }\n        }\n\n        list\n    }\n\n    pub fn get_aggregate_column(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        let mut list = vec![];\n\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n                    let mut aggregate_columns = item.find_aggregate_columns();\n                    list.append(\u0026mut aggregate_columns);\n                }\n                SelectKind::WildCard(_) =\u003e {}\n            }\n        }\n\n        list\n    }\n\n    pub fn build(self) -\u003e SelectQuery {\n        self\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SQLStatement {\n    fn from(value: SelectQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::SelectQuery(value))\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SubqueryExpression {\n    fn from(value: SelectQuery) -\u003e SubqueryExpression {\n        SubqueryExpression::Select(Box::new(value))\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SQLExpression {\n    fn from(value: SelectQuery) -\u003e SQLExpression {\n        SQLExpression::Subquery(SubqueryExpression::Select(Box::new(value)))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::expressions::call::CallExpression,\n        types::{AggregateFunction, BuiltInFunction, Function},\n    };\n\n    use super::*;\n\n    #[test]\n    fn test_from_table() {\n        let select_query = SelectQuery::builder()\n            .set_from_table(TableName::new(None, \"table\".into()))\n            .build();\n\n        assert!(select_query.has_from_table());\n    }\n\n    #[test]\n    fn test_has_group_by() {\n        let select_query = SelectQuery::builder().build();\n\n        assert_eq!(select_query.has_group_by(), false);\n\n        let select_query = SelectQuery::builder()\n            .add_group_by(GroupByItem {\n                item: SelectColumn {\n                    table_name: None,\n                    column_name: \"foo\".into(),\n                },\n            })\n            .build();\n\n        assert_eq!(select_query.has_group_by(), true);\n    }\n\n    #[test]\n    fn test_get_aggregate_column() {\n        let select_query = SelectQuery::builder()\n            .add_select_item(\n                SelectItem::builder()\n                    .set_item(SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(BuiltInFunction::Aggregate(\n                            AggregateFunction::Count,\n                        )),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn {\n                            table_name: None,\n                            column_name: \"bar\".into(),\n                        })],\n                    }))\n                    .build(),\n            )\n            .build();\n\n        let aggregate_columns = select_query.get_aggregate_column();\n\n        assert_eq!(aggregate_columns.len(), 1);\n        assert_eq!(aggregate_columns[0].column_name, \"bar\");\n    }\n}\n","traces":[{"line":37,"address":[1832992,1833462,1833441],"length":1,"stats":{"Line":2}},{"line":39,"address":[1833013],"length":1,"stats":{"Line":2}},{"line":41,"address":[1833038],"length":1,"stats":{"Line":2}},{"line":52,"address":[1833650,1833488],"length":1,"stats":{"Line":1}},{"line":53,"address":[1833518],"length":1,"stats":{"Line":1}},{"line":54,"address":[1833627],"length":1,"stats":{"Line":1}},{"line":57,"address":[1833680,1833814],"length":1,"stats":{"Line":1}},{"line":58,"address":[1833708],"length":1,"stats":{"Line":1}},{"line":59,"address":[1833791],"length":1,"stats":{"Line":1}},{"line":62,"address":[1834115,1833840],"length":1,"stats":{"Line":1}},{"line":63,"address":[1833873,1833934],"length":1,"stats":{"Line":2}},{"line":64,"address":[1834092],"length":1,"stats":{"Line":1}},{"line":67,"address":[1834144],"length":1,"stats":{"Line":1}},{"line":68,"address":[1834149],"length":1,"stats":{"Line":1}},{"line":71,"address":[1834176,1834543],"length":1,"stats":{"Line":1}},{"line":72,"address":[1834248,1834491],"length":1,"stats":{"Line":2}},{"line":73,"address":[1834214],"length":1,"stats":{"Line":1}},{"line":74,"address":[1834240],"length":1,"stats":{"Line":1}},{"line":76,"address":[1834520],"length":1,"stats":{"Line":1}},{"line":79,"address":[1835032,1835208,1834576],"length":1,"stats":{"Line":1}},{"line":80,"address":[1834610,1834718,1834950],"length":1,"stats":{"Line":3}},{"line":81,"address":[1834788],"length":1,"stats":{"Line":2}},{"line":82,"address":[2160215,2160107],"length":1,"stats":{"Line":2}},{"line":83,"address":[2160242],"length":1,"stats":{"Line":1}},{"line":86,"address":[1834734],"length":1,"stats":{"Line":1}},{"line":89,"address":[1835248,1835357],"length":1,"stats":{"Line":1}},{"line":90,"address":[1835288],"length":1,"stats":{"Line":1}},{"line":91,"address":[1835337],"length":1,"stats":{"Line":2}},{"line":94,"address":[1835606,1835376],"length":1,"stats":{"Line":1}},{"line":95,"address":[1835403,1835554],"length":1,"stats":{"Line":2}},{"line":96,"address":[1835586],"length":1,"stats":{"Line":1}},{"line":99,"address":[1836265,1835632],"length":1,"stats":{"Line":1}},{"line":100,"address":[1835659],"length":1,"stats":{"Line":1}},{"line":101,"address":[1835741],"length":1,"stats":{"Line":1}},{"line":102,"address":[1835753,1836239],"length":1,"stats":{"Line":2}},{"line":105,"address":[1836022],"length":1,"stats":{"Line":1}},{"line":106,"address":[1835716,1835866],"length":1,"stats":{"Line":2}},{"line":111,"address":[1836216],"length":1,"stats":{"Line":1}},{"line":114,"address":[1836852,1836288],"length":1,"stats":{"Line":1}},{"line":115,"address":[1836315],"length":1,"stats":{"Line":1}},{"line":116,"address":[1836394],"length":1,"stats":{"Line":1}},{"line":117,"address":[1836406,1836826],"length":1,"stats":{"Line":2}},{"line":120,"address":[1836633],"length":1,"stats":{"Line":1}},{"line":121,"address":[1836501,1836372],"length":1,"stats":{"Line":2}},{"line":126,"address":[1836803],"length":1,"stats":{"Line":1}},{"line":129,"address":[1836880],"length":1,"stats":{"Line":1}},{"line":130,"address":[1836894],"length":1,"stats":{"Line":1}},{"line":131,"address":[1836937],"length":1,"stats":{"Line":1}},{"line":132,"address":[1836925],"length":1,"stats":{"Line":1}},{"line":136,"address":[1837105,1836976],"length":1,"stats":{"Line":1}},{"line":137,"address":[1837006,1837073],"length":1,"stats":{"Line":2}},{"line":138,"address":[1837085],"length":1,"stats":{"Line":1}},{"line":141,"address":[1837136],"length":1,"stats":{"Line":3}},{"line":142,"address":[1837151],"length":1,"stats":{"Line":3}},{"line":143,"address":[1837183],"length":1,"stats":{"Line":3}},{"line":146,"address":[1837216],"length":1,"stats":{"Line":1}},{"line":147,"address":[1837231],"length":1,"stats":{"Line":1}},{"line":148,"address":[1837263],"length":1,"stats":{"Line":1}},{"line":151,"address":[1837296],"length":1,"stats":{"Line":1}},{"line":152,"address":[1837319],"length":1,"stats":{"Line":1}},{"line":153,"address":[1837327],"length":1,"stats":{"Line":1}},{"line":156,"address":[1837360],"length":1,"stats":{"Line":1}},{"line":157,"address":[1837432,1837369],"length":1,"stats":{"Line":2}},{"line":158,"address":[1837446],"length":1,"stats":{"Line":1}},{"line":159,"address":[1837503],"length":1,"stats":{"Line":1}},{"line":160,"address":[1837566,1837508],"length":1,"stats":{"Line":2}},{"line":162,"address":[1837571],"length":1,"stats":{"Line":1}},{"line":163,"address":[1837585],"length":1,"stats":{"Line":1}},{"line":166,"address":[1837492],"length":1,"stats":{"Line":1}},{"line":170,"address":[1837425],"length":1,"stats":{"Line":1}},{"line":173,"address":[1837600,1838078],"length":1,"stats":{"Line":1}},{"line":174,"address":[1837635],"length":1,"stats":{"Line":1}},{"line":176,"address":[1837709,1837816,1837645],"length":1,"stats":{"Line":3}},{"line":177,"address":[1837834],"length":1,"stats":{"Line":1}},{"line":178,"address":[1837873],"length":1,"stats":{"Line":1}},{"line":179,"address":[1837977,1837881],"length":1,"stats":{"Line":2}},{"line":180,"address":[1837993],"length":1,"stats":{"Line":1}},{"line":181,"address":[1838013],"length":1,"stats":{"Line":1}},{"line":187,"address":[1837782],"length":1,"stats":{"Line":1}},{"line":190,"address":[1838590,1838112],"length":1,"stats":{"Line":1}},{"line":191,"address":[1838147],"length":1,"stats":{"Line":1}},{"line":193,"address":[1838157,1838221,1838328],"length":1,"stats":{"Line":3}},{"line":194,"address":[1838346],"length":1,"stats":{"Line":1}},{"line":195,"address":[1838385],"length":1,"stats":{"Line":1}},{"line":196,"address":[1838489,1838393],"length":1,"stats":{"Line":2}},{"line":197,"address":[1838505],"length":1,"stats":{"Line":1}},{"line":198,"address":[1838525],"length":1,"stats":{"Line":1}},{"line":204,"address":[1838294],"length":1,"stats":{"Line":1}},{"line":207,"address":[1838624],"length":1,"stats":{"Line":1}},{"line":208,"address":[1838632],"length":1,"stats":{"Line":1}},{"line":213,"address":[5051632],"length":1,"stats":{"Line":3}},{"line":214,"address":[5051649],"length":1,"stats":{"Line":3}},{"line":219,"address":[2892528],"length":1,"stats":{"Line":1}},{"line":220,"address":[2892626],"length":1,"stats":{"Line":1}},{"line":225,"address":[8201296],"length":1,"stats":{"Line":1}},{"line":226,"address":[8201414],"length":1,"stats":{"Line":1}}],"covered":96,"coverable":96},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","update.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::parts::{_where::WhereClause, target::UpdateTarget, update_item::UpdateItem};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdateQuery {\n    pub target_table: Option\u003cUpdateTarget\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n    pub update_items: Vec\u003cUpdateItem\u003e,\n}\n\nimpl UpdateQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            update_items: vec![],\n            target_table: None,\n            where_clause: None,\n        }\n    }\n\n    pub fn add_update_item(mut self, item: UpdateItem) -\u003e Self {\n        self.update_items.push(item);\n        self\n    }\n\n    pub fn set_target_table(mut self, from: TableName) -\u003e Self {\n        self.target_table = Some(from.into());\n        self\n    }\n\n    pub fn set_target_alias(mut self, alias: String) -\u003e Self {\n        if self.target_table.is_some() {\n            self.target_table = self.target_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cUpdateQuery\u003e for SQLStatement {\n    fn from(value: UpdateQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::UpdateQuery(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    use super::*;\n\n    #[test]\n    fn test_builder_all() {\n        let update_query = UpdateQuery::builder()\n            .set_target_table(TableName::new(None, \"table\".into()))\n            .add_update_item(UpdateItem {\n                column: \"a\".into(),\n                value: SQLExpression::String(\"b\".into()),\n            })\n            .set_where(WhereClause {\n                expression: SQLExpression::String(\"a\".into()),\n            })\n            .set_target_alias(\"alias\".into())\n            .build();\n        assert_eq!(\n            update_query,\n            UpdateQuery {\n                target_table: Some(UpdateTarget {\n                    table: TableName::new(None, \"table\".into()),\n                    alias: Some(\"alias\".into()),\n                }),\n                where_clause: Some(WhereClause {\n                    expression: SQLExpression::String(\"a\".into()),\n                }),\n                update_items: vec![UpdateItem {\n                    column: \"a\".into(),\n                    value: SQLExpression::String(\"b\".into()),\n                }],\n            }\n        );\n    }\n}\n","traces":[{"line":13,"address":[3643280],"length":1,"stats":{"Line":1}},{"line":15,"address":[3643296],"length":1,"stats":{"Line":1}},{"line":21,"address":[3643545,3643440],"length":1,"stats":{"Line":1}},{"line":22,"address":[3643480],"length":1,"stats":{"Line":1}},{"line":23,"address":[3643525],"length":1,"stats":{"Line":1}},{"line":26,"address":[3643568,3643843],"length":1,"stats":{"Line":1}},{"line":27,"address":[3643601,3643662],"length":1,"stats":{"Line":2}},{"line":28,"address":[3643820],"length":1,"stats":{"Line":1}},{"line":31,"address":[3644384,3643872,3644319],"length":1,"stats":{"Line":1}},{"line":32,"address":[3643906,3644014,3644237],"length":1,"stats":{"Line":3}},{"line":33,"address":[3192102,3191920],"length":1,"stats":{"Line":2}},{"line":34,"address":[3192055,3191947],"length":1,"stats":{"Line":2}},{"line":35,"address":[3192082],"length":1,"stats":{"Line":1}},{"line":38,"address":[3644030],"length":1,"stats":{"Line":1}},{"line":41,"address":[3644416,3644634],"length":1,"stats":{"Line":1}},{"line":42,"address":[3644443,3644585],"length":1,"stats":{"Line":2}},{"line":43,"address":[3644614],"length":1,"stats":{"Line":1}},{"line":46,"address":[3644656],"length":1,"stats":{"Line":1}},{"line":47,"address":[3644664],"length":1,"stats":{"Line":1}},{"line":52,"address":[5051712],"length":1,"stats":{"Line":2}},{"line":53,"address":[5051729],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","mod.rs"],"content":"pub mod commands;\npub mod dcl;\npub mod ddl;\npub mod dml;\npub mod other;\npub mod tcl;\npub mod types;\n\nuse crate::ast::{\n    ddl::{\n        alter_database::AlterDatabaseQuery, alter_table::AlterTableQuery,\n        create_database::CreateDatabaseQuery, create_index::CreateIndexQuery,\n        create_table::CreateTableQuery, drop_database::DropDatabaseQuery,\n        drop_table::DropTableQuery,\n    },\n    dml::{delete::DeleteQuery, insert::InsertQuery, select::SelectQuery, update::UpdateQuery},\n    other::{\n        desc_table::DescTableQuery, show_databases::ShowDatabasesQuery,\n        show_tables::ShowTablesQuery, use_database::UseDatabaseQuery,\n    },\n};\n\nuse self::tcl::{BeginTransactionQuery, CommitQuery, RollbackQuery};\n\n#[derive(Clone, Debug, PartialEq, Default)]\npub enum SQLStatement {\n    DDL(DDLStatement),\n    DML(DMLStatement),\n    DCL(DCLStatement),\n    TCL(TCLStatement),\n    Other(OtherStatement),\n    #[default]\n    None,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DDLStatement {\n    CreateDatabaseQuery(CreateDatabaseQuery),\n    AlterDatabase(AlterDatabaseQuery),\n    DropDatabaseQuery(DropDatabaseQuery),\n    CreateTableQuery(CreateTableQuery),\n    AlterTableQuery(AlterTableQuery),\n    DropTableQuery(DropTableQuery),\n    CreateIndexQuery(CreateIndexQuery),\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DMLStatement {\n    InsertQuery(InsertQuery),\n    UpdateQuery(UpdateQuery),\n    DeleteQuery(DeleteQuery),\n    SelectQuery(SelectQuery),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DCLStatement {}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum OtherStatement {\n    ShowDatabases(ShowDatabasesQuery),\n    UseDatabase(UseDatabaseQuery),\n    ShowTables(ShowTablesQuery),\n    DescTable(DescTableQuery),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum TCLStatement {\n    BeginTransaction(BeginTransactionQuery),\n    Commit(CommitQuery),\n    Rollback(RollbackQuery),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","desc_table.rs"],"content":"use crate::ast::{types::TableName, OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DescTableQuery {\n    pub table_name: TableName,\n}\n\nimpl From\u003cDescTableQuery\u003e for SQLStatement {\n    fn from(value: DescTableQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::DescTable(value))\n    }\n}\n","traces":[{"line":9,"address":[5051808],"length":1,"stats":{"Line":1}},{"line":10,"address":[5051822],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","mod.rs"],"content":"pub mod desc_table;\npub mod show_databases;\npub mod show_tables;\npub mod use_database;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","show_databases.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShowDatabasesQuery {}\n\nimpl From\u003cShowDatabasesQuery\u003e for SQLStatement {\n    fn from(value: ShowDatabasesQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::ShowDatabases(value))\n    }\n}\n","traces":[{"line":7,"address":[5051904],"length":1,"stats":{"Line":1}},{"line":8,"address":[5051921],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","show_tables.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShowTablesQuery {\n    pub database: String,\n}\n\nimpl From\u003cShowTablesQuery\u003e for SQLStatement {\n    fn from(value: ShowTablesQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::ShowTables(value))\n    }\n}\n","traces":[{"line":9,"address":[5051984],"length":1,"stats":{"Line":1}},{"line":10,"address":[5052001],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","use_database.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct UseDatabaseQuery {\n    pub database_name: String,\n}\n\nimpl From\u003cUseDatabaseQuery\u003e for SQLStatement {\n    fn from(value: UseDatabaseQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::UseDatabase(value))\n    }\n}\n","traces":[{"line":9,"address":[5052096],"length":1,"stats":{"Line":1}},{"line":10,"address":[5052113],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","begin_transaction.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct BeginTransactionQuery {}\n\nimpl From\u003cBeginTransactionQuery\u003e for SQLStatement {\n    fn from(value: BeginTransactionQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::BeginTransaction(value))\n    }\n}\n","traces":[{"line":7,"address":[5052208],"length":1,"stats":{"Line":1}},{"line":8,"address":[5052211],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","commit.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct CommitQuery {}\n\nimpl From\u003cCommitQuery\u003e for SQLStatement {\n    fn from(value: CommitQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::Commit(value))\n    }\n}\n","traces":[{"line":7,"address":[5052240],"length":1,"stats":{"Line":1}},{"line":8,"address":[5052243],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","mod.rs"],"content":"mod begin_transaction;\nmod commit;\nmod rollback;\n\npub use begin_transaction::*;\npub use commit::*;\npub use rollback::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","rollback.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RollbackQuery {}\n\nimpl From\u003cRollbackQuery\u003e for SQLStatement {\n    fn from(value: RollbackQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::Rollback(value))\n    }\n}\n","traces":[{"line":7,"address":[5052272],"length":1,"stats":{"Line":1}},{"line":8,"address":[5052275],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","column.rs"],"content":"use crate::ast::types::DataType;\nuse serde::{Deserialize, Serialize};\n\nuse super::expression::SQLExpression;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct Column {\n    pub name: String,\n    pub data_type: DataType,\n    pub comment: String,\n    pub default: Option\u003cSQLExpression\u003e,\n    pub not_null: bool,\n    pub primary_key: bool,\n}\n\nimpl Column {\n    pub fn builder() -\u003e ColumnBuilder {\n        ColumnBuilder::default()\n    }\n}\n\n#[derive(Default)]\npub struct ColumnBuilder {\n    name: Option\u003cString\u003e,\n    data_type: Option\u003cDataType\u003e,\n    comment: Option\u003cString\u003e,\n    default: Option\u003cSQLExpression\u003e,\n    not_null: Option\u003cbool\u003e,\n    primary_key: Option\u003cbool\u003e,\n}\n\nimpl ColumnBuilder {\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.name = Some(name);\n        self\n    }\n\n    pub fn set_data_type(mut self, data_type: DataType) -\u003e Self {\n        self.data_type = Some(data_type);\n        self\n    }\n\n    pub fn set_comment(mut self, comment: String) -\u003e Self {\n        self.comment = Some(comment);\n        self\n    }\n\n    pub fn set_default(mut self, default: SQLExpression) -\u003e Self {\n        self.default = Some(default);\n        self\n    }\n\n    pub fn set_not_null(mut self, not_null: bool) -\u003e Self {\n        self.not_null = Some(not_null);\n        self\n    }\n\n    pub fn set_primary_key(mut self, primary_key: bool) -\u003e Self {\n        self.primary_key = Some(primary_key);\n        if primary_key {\n            self.not_null = Some(true);\n        }\n        self\n    }\n\n    pub fn build(self) -\u003e Column {\n        Column {\n            name: self.name.unwrap(),\n            data_type: self.data_type.unwrap(),\n            comment: self.comment.unwrap_or_else(|| \"\".into()),\n            default: self.default,\n            not_null: self.not_null.unwrap_or(false),\n            primary_key: self.primary_key.unwrap_or(false),\n        }\n    }\n}\n\n// [column_name.]table_name\n// 컬럼명을 가리키는 값입니다.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ColumnName {\n    pub table_name: Option\u003cString\u003e,\n    pub column_name: String,\n}\n\nimpl ColumnName {\n    pub fn new(table_name: Option\u003cString\u003e, column_name: String) -\u003e Self {\n        ColumnName {\n            table_name,\n            column_name,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_column_builder() {\n        let column = Column::builder()\n            .set_name(\"id\".into())\n            .set_data_type(DataType::Int)\n            .set_comment(\"id column\".into())\n            .set_default(SQLExpression::Integer(1))\n            .set_not_null(true)\n            .set_primary_key(true)\n            .build();\n\n        assert_eq!(column.name, \"id\");\n        assert_eq!(column.data_type, DataType::Int);\n        assert_eq!(column.comment, \"id column\");\n        assert_eq!(column.default, Some(SQLExpression::Integer(1)));\n        assert_eq!(column.not_null, true);\n        assert_eq!(column.primary_key, true);\n    }\n\n    #[test]\n    fn test_column_name() {\n        let column_name = ColumnName::new(Some(\"table\".into()), \"column\".into());\n        assert_eq!(column_name.table_name, Some(\"table\".into()));\n        assert_eq!(column_name.column_name, \"column\");\n    }\n}\n","traces":[{"line":17,"address":[1844608],"length":1,"stats":{"Line":1}},{"line":18,"address":[1844616],"length":1,"stats":{"Line":1}},{"line":33,"address":[1844802,1844640],"length":1,"stats":{"Line":1}},{"line":34,"address":[1844667,1844755],"length":1,"stats":{"Line":2}},{"line":35,"address":[1844782],"length":1,"stats":{"Line":1}},{"line":38,"address":[1844832],"length":1,"stats":{"Line":1}},{"line":39,"address":[1844853],"length":1,"stats":{"Line":1}},{"line":40,"address":[1844880],"length":1,"stats":{"Line":1}},{"line":43,"address":[1844912,1845074],"length":1,"stats":{"Line":1}},{"line":44,"address":[1844939,1845027],"length":1,"stats":{"Line":2}},{"line":45,"address":[1845054],"length":1,"stats":{"Line":1}},{"line":48,"address":[1845104,1845316],"length":1,"stats":{"Line":1}},{"line":49,"address":[1845267,1845131],"length":1,"stats":{"Line":2}},{"line":50,"address":[1845296],"length":1,"stats":{"Line":1}},{"line":53,"address":[1845344],"length":1,"stats":{"Line":1}},{"line":54,"address":[1845367],"length":1,"stats":{"Line":1}},{"line":55,"address":[1845383],"length":1,"stats":{"Line":1}},{"line":58,"address":[1845408],"length":1,"stats":{"Line":1}},{"line":59,"address":[1845438],"length":1,"stats":{"Line":1}},{"line":60,"address":[1845511,1845457],"length":1,"stats":{"Line":2}},{"line":61,"address":[1845496],"length":1,"stats":{"Line":1}},{"line":63,"address":[1845471],"length":1,"stats":{"Line":1}},{"line":66,"address":[1846272,1845520,1846332],"length":1,"stats":{"Line":1}},{"line":68,"address":[1845542],"length":1,"stats":{"Line":1}},{"line":69,"address":[1845723],"length":1,"stats":{"Line":1}},{"line":70,"address":[1845894],"length":1,"stats":{"Line":3}},{"line":71,"address":[1845958],"length":1,"stats":{"Line":1}},{"line":72,"address":[1846029],"length":1,"stats":{"Line":1}},{"line":73,"address":[1846097],"length":1,"stats":{"Line":1}},{"line":87,"address":[1846368],"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","data_types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// SQL 데이터 타입\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum DataType {\n    Int,\n    Float,\n    Boolean,\n    Varchar(i64),\n}\n\nimpl DataType {\n    pub fn type_code(\u0026self) -\u003e isize {\n        match self {\n            DataType::Int =\u003e 1,\n            DataType::Float =\u003e 2,\n            DataType::Boolean =\u003e 3,\n            DataType::Varchar(_) =\u003e 4,\n        }\n    }\n}\n\nimpl From\u003cDataType\u003e for String {\n    fn from(value: DataType) -\u003e Self {\n        match value {\n            DataType::Int =\u003e \"integer\".into(),\n            DataType::Float =\u003e \"float\".into(),\n            DataType::Boolean =\u003e \"boolean\".into(),\n            DataType::Varchar(number) =\u003e format!(\"varchar({})\", number),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_data_type_type_code() {\n        assert_eq!(DataType::Int.type_code(), 1);\n        assert_eq!(DataType::Float.type_code(), 2);\n        assert_eq!(DataType::Boolean.type_code(), 3);\n        assert_eq!(DataType::Varchar(255).type_code(), 4);\n    }\n\n    #[test]\n    fn test_data_type_into_string() {\n        assert_eq!(String::from(DataType::Int), \"integer\");\n        assert_eq!(String::from(DataType::Float), \"float\");\n        assert_eq!(String::from(DataType::Boolean), \"boolean\");\n        assert_eq!(String::from(DataType::Varchar(255)), \"varchar(255)\");\n    }\n}\n","traces":[{"line":13,"address":[3117072],"length":1,"stats":{"Line":1}},{"line":14,"address":[3117077],"length":1,"stats":{"Line":1}},{"line":15,"address":[3117108],"length":1,"stats":{"Line":1}},{"line":16,"address":[3117119],"length":1,"stats":{"Line":1}},{"line":17,"address":[3117130],"length":1,"stats":{"Line":1}},{"line":18,"address":[3117141],"length":1,"stats":{"Line":1}},{"line":24,"address":[1988400],"length":1,"stats":{"Line":1}},{"line":25,"address":[1988426],"length":1,"stats":{"Line":1}},{"line":26,"address":[1988463],"length":1,"stats":{"Line":1}},{"line":27,"address":[1988497],"length":1,"stats":{"Line":1}},{"line":28,"address":[1988531],"length":1,"stats":{"Line":1}},{"line":29,"address":[1988561,1988659],"length":1,"stats":{"Line":2}}],"covered":12,"coverable":12},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","expression.rs"],"content":"use crate::{\n    ast::dml::{\n        expressions::{\n            between::BetweenExpression, binary::BinaryOperatorExpression, call::CallExpression,\n            list::ListExpression, not_between::NotBetweenExpression,\n            parentheses::ParenthesesExpression, subquery::SubqueryExpression,\n            unary::UnaryOperatorExpression,\n        },\n        parts::_where::WhereClause,\n    },\n    executor::config::row::TableDataFieldType,\n    utils::collection::join_vec,\n};\n\nuse serde::{Deserialize, Serialize};\n\nuse super::select_column::SelectColumn;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SQLExpression {\n    // 복합 표현식\n    Unary(Box\u003cUnaryOperatorExpression\u003e),     // 단항 연산식\n    Binary(Box\u003cBinaryOperatorExpression\u003e),   // 2항 연산식\n    Between(Box\u003cBetweenExpression\u003e),         // BETWEEN 식\n    NotBetween(Box\u003cNotBetweenExpression\u003e),   // NOT BETWEEN 식\n    Parentheses(Box\u003cParenthesesExpression\u003e), // 소괄호 표현식\n    FunctionCall(CallExpression),            // 함수호출 표현식\n    Subquery(SubqueryExpression),            // SQL 서브쿼리 (미구현)\n\n    // 끝단 Primitive 값\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    String(String),\n    List(ListExpression),\n    SelectColumn(SelectColumn),\n    Null,\n}\n\nimpl SQLExpression {\n    pub fn is_unary(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self.clone() {\n            Self::Unary(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    // Select 절의 표현식 목록에서 실제로 DB에서 가져와야하는 대상 컬럼 목록을 추출합니다.\n    pub fn get_select_column_list(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::get_select_column_list_recursion(self)\n    }\n\n    fn get_select_column_list_recursion(expression: \u0026Self) -\u003e Vec\u003cSelectColumn\u003e {\n        match expression {\n            SQLExpression::Integer(_)\n            | SQLExpression::Float(_)\n            | SQLExpression::Boolean(_)\n            | SQLExpression::String(_)\n            | SQLExpression::Null =\u003e {\n                vec![]\n            }\n            SQLExpression::List(list) =\u003e list\n                .value\n                .iter()\n                .flat_map(Self::get_select_column_list_recursion)\n                .collect(),\n            SQLExpression::SelectColumn(column) =\u003e {\n                vec![column.to_owned()]\n            }\n            SQLExpression::Unary(unary) =\u003e Self::get_select_column_list(\u0026unary.operand),\n            SQLExpression::Binary(binary) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026binary.lhs),\n                Self::get_select_column_list(\u0026binary.rhs)\n            ),\n            SQLExpression::Between(between) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026between.a),\n                Self::get_select_column_list(\u0026between.x),\n                Self::get_select_column_list(\u0026between.y)\n            ),\n            SQLExpression::NotBetween(between) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026between.a),\n                Self::get_select_column_list(\u0026between.x),\n                Self::get_select_column_list(\u0026between.y)\n            ),\n            SQLExpression::Parentheses(paren) =\u003e Self::get_select_column_list(\u0026paren.expression),\n            SQLExpression::FunctionCall(function_call) =\u003e function_call\n                .arguments\n                .iter()\n                .flat_map(Self::get_select_column_list_recursion)\n                .collect(),\n            SQLExpression::Subquery(_subquery) =\u003e unimplemented!(),\n        }\n    }\n\n    pub fn has_aggregate(\u0026self) -\u003e bool {\n        Self::has_aggregate_recursion(self)\n    }\n\n    fn has_aggregate_recursion(this: \u0026Self) -\u003e bool {\n        match this {\n            Self::Unary(unary) =\u003e Self::has_aggregate_recursion(\u0026unary.operand),\n            Self::Binary(binary) =\u003e {\n                Self::has_aggregate_recursion(\u0026binary.lhs)\n                    | Self::has_aggregate_recursion(\u0026binary.rhs)\n            }\n            Self::Between(between) =\u003e {\n                Self::has_aggregate_recursion(\u0026between.a)\n                    | Self::has_aggregate_recursion(\u0026between.x)\n                    | Self::has_aggregate_recursion(\u0026between.y)\n            }\n            Self::NotBetween(not_between) =\u003e {\n                Self::has_aggregate_recursion(\u0026not_between.a)\n                    | Self::has_aggregate_recursion(\u0026not_between.x)\n                    | Self::has_aggregate_recursion(\u0026not_between.y)\n            }\n            Self::Parentheses(paren) =\u003e Self::has_aggregate_recursion(\u0026paren.expression),\n            Self::FunctionCall(call) =\u003e call.function.is_aggregate(),\n            _ =\u003e false,\n        }\n    }\n\n    pub fn find_non_aggregate_columns(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::find_non_aggregate_columns_recursion(self)\n    }\n\n    fn find_non_aggregate_columns_recursion(this: \u0026Self) -\u003e Vec\u003cSelectColumn\u003e {\n        match this {\n            Self::Unary(unary) =\u003e Self::find_non_aggregate_columns_recursion(\u0026unary.operand),\n            Self::Binary(binary) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026binary.lhs),\n                Self::find_non_aggregate_columns_recursion(\u0026binary.rhs)\n            ),\n            Self::Between(between) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026between.a),\n                Self::find_non_aggregate_columns_recursion(\u0026between.x),\n                Self::find_non_aggregate_columns_recursion(\u0026between.y)\n            ),\n            Self::NotBetween(not_between) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.a),\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.x),\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.y)\n            ),\n            Self::Parentheses(paren) =\u003e {\n                Self::find_non_aggregate_columns_recursion(\u0026paren.expression)\n            }\n            Self::FunctionCall(call) =\u003e {\n                if call.function.is_aggregate() {\n                    vec![]\n                } else {\n                    call.arguments\n                        .iter()\n                        .cloned()\n                        .flat_map(|e| Self::find_non_aggregate_columns_recursion(\u0026e))\n                        .collect()\n                }\n            }\n            Self::SelectColumn(column) =\u003e vec![column.to_owned()],\n            _ =\u003e vec![],\n        }\n    }\n\n    pub fn find_aggregate_columns(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::find_aggregate_columns_recursion(self, Default::default())\n    }\n\n    fn find_aggregate_columns_recursion(\n        this: \u0026Self,\n        mut context: RecursionContext,\n    ) -\u003e Vec\u003cSelectColumn\u003e {\n        match this {\n            Self::Unary(unary) =\u003e Self::find_aggregate_columns_recursion(\u0026unary.operand, context),\n            Self::Binary(binary) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026binary.lhs, context),\n                Self::find_aggregate_columns_recursion(\u0026binary.rhs, context)\n            ),\n            Self::Between(between) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026between.a, context),\n                Self::find_aggregate_columns_recursion(\u0026between.x, context),\n                Self::find_aggregate_columns_recursion(\u0026between.y, context)\n            ),\n            Self::NotBetween(not_between) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026not_between.a, context),\n                Self::find_aggregate_columns_recursion(\u0026not_between.x, context),\n                Self::find_aggregate_columns_recursion(\u0026not_between.y, context)\n            ),\n            Self::Parentheses(paren) =\u003e {\n                Self::find_aggregate_columns_recursion(\u0026paren.expression, context)\n            }\n            Self::FunctionCall(call) =\u003e {\n                if call.function.is_aggregate() {\n                    context.in_aggregate = true;\n                    call.arguments\n                        .iter()\n                        .cloned()\n                        .flat_map(|e| Self::find_aggregate_columns_recursion(\u0026e, context))\n                        .collect()\n                } else {\n                    vec![]\n                }\n            }\n            Self::SelectColumn(column) =\u003e {\n                if context.in_aggregate {\n                    vec![column.to_owned()]\n                } else {\n                    vec![]\n                }\n            }\n            _ =\u003e vec![],\n        }\n    }\n}\n\nimpl From\u003cSQLExpression\u003e for WhereClause {\n    fn from(value: SQLExpression) -\u003e WhereClause {\n        WhereClause { expression: value }\n    }\n}\n\nimpl From\u003cSQLExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: SQLExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(value))\n    }\n}\n\nimpl From\u003cTableDataFieldType\u003e for SQLExpression {\n    fn from(value: TableDataFieldType) -\u003e SQLExpression {\n        match value {\n            TableDataFieldType::Integer(value) =\u003e SQLExpression::Integer(value),\n            TableDataFieldType::Float(value) =\u003e SQLExpression::Float(value.into()),\n            TableDataFieldType::Boolean(value) =\u003e SQLExpression::Boolean(value),\n            TableDataFieldType::String(value) =\u003e SQLExpression::String(value),\n            TableDataFieldType::Null =\u003e SQLExpression::Null,\n            TableDataFieldType::Array(value) =\u003e SQLExpression::List(\n                value\n                    .into_iter()\n                    .map(|e| e.into())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .into(),\n            ),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Default, Copy)]\nstruct RecursionContext {\n    pub in_aggregate: bool,\n}\n\n#[allow(non_snake_case)]\n#[cfg(test)]\nmod tests {\n    use crate::ast::{\n        dml::expressions::{\n            between::BetweenExpression,\n            binary::BinaryOperatorExpression,\n            call::CallExpression,\n            not_between::NotBetweenExpression,\n            operators::{BinaryOperator, UnaryOperator},\n            parentheses::ParenthesesExpression,\n            unary::UnaryOperatorExpression,\n        },\n        types::{AggregateFunction, ConditionalFunction, Function, SQLExpression, SelectColumn},\n    };\n\n    #[test]\n    fn test_SQLExpression_get_select_column_list() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"List 필드\".into(),\n                expression: SQLExpression::List(\n                    vec![\n                        SQLExpression::Integer(1),\n                        SQLExpression::Integer(2),\n                        SQLExpression::Integer(3),\n                    ]\n                    .into(),\n                ),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"유효한 Select 필드\".into(),\n                expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 단항연산 필드\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 이항연산 필드\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![\n                    SelectColumn::new(None, \"id\".into()),\n                    SelectColumn::new(None, \"name\".into()),\n                ],\n            },\n            TestCase {\n                name: \"유효한 BETWEEN 필드\".into(),\n                expression: SQLExpression::Between(Box::new(\n                    crate::ast::dml::expressions::between::BetweenExpression {\n                        a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(10),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 NOT BETWEEN 필드\".into(),\n                expression: SQLExpression::NotBetween(Box::new(\n                    crate::ast::dml::expressions::not_between::NotBetweenExpression {\n                        a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(10),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 소괄호 필드\".into(),\n                expression: SQLExpression::Parentheses(Box::new(\n                    crate::ast::dml::expressions::parentheses::ParenthesesExpression {\n                        expression: SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        )),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 함수호출 필드\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(AggregateFunction::Count.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.get_select_column_list(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExpression_has_aggregate() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: false,\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::Integer(4444),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::Integer(1),\n                    rhs: SQLExpression::Integer(2),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    rhs: SQLExpression::Integer(2),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::Integer(1),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::Integer(1),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::Integer(1),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                })),\n                expected: true,\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.has_aggregate(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExperssion_find_aggregate_columns() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"이항 중첩 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"함수호출 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(ConditionalFunction::NullIf.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.find_aggregate_columns(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_From_SQLExpression_for_Option_Box_SQLExpression() {\n        let expression = SQLExpression::Integer(1);\n        let expected = Some(Box::new(expression.clone()));\n\n        assert_eq!(Option::\u003cBox\u003cSQLExpression\u003e\u003e::from(expression), expected);\n    }\n\n    #[test]\n    fn test_From_TableDataFieldType_for_SQLExpression() {\n        use crate::executor::config::row::TableDataFieldType;\n\n        struct TestCase {\n            name: String,\n            value: TableDataFieldType,\n            expected: SQLExpression,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"정수형\".into(),\n                value: TableDataFieldType::Integer(1),\n                expected: SQLExpression::Integer(1),\n            },\n            TestCase {\n                name: \"실수형\".into(),\n                value: TableDataFieldType::Float(1.0.into()),\n                expected: SQLExpression::Float(1.0),\n            },\n            TestCase {\n                name: \"부울형\".into(),\n                value: TableDataFieldType::Boolean(true),\n                expected: SQLExpression::Boolean(true),\n            },\n            TestCase {\n                name: \"문자열형\".into(),\n                value: TableDataFieldType::String(\"hello\".into()),\n                expected: SQLExpression::String(\"hello\".into()),\n            },\n            TestCase {\n                name: \"배열형\".into(),\n                value: TableDataFieldType::Array(vec![\n                    TableDataFieldType::Integer(1),\n                    TableDataFieldType::Integer(2),\n                    TableDataFieldType::Integer(3),\n                ]),\n                expected: SQLExpression::List(\n                    vec![\n                        SQLExpression::Integer(1),\n                        SQLExpression::Integer(2),\n                        SQLExpression::Integer(3),\n                    ]\n                    .into(),\n                ),\n            },\n            TestCase {\n                name: \"NULL 값\".into(),\n                value: TableDataFieldType::Null,\n                expected: SQLExpression::Null,\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                SQLExpression::from(test_case.value),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExpression_find_non_aggregate_columns() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단일 Select 필드\".into(),\n                expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![\n                    SelectColumn::new(None, \"id\".into()),\n                    SelectColumn::new(None, \"name\".into()),\n                ],\n            },\n            TestCase {\n                name: \"이항 중첩 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![SelectColumn::new(None, \"name\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"함수호출 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(ConditionalFunction::Coalesce.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.find_non_aggregate_columns(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n}\n","traces":[{"line":41,"address":[8202448],"length":1,"stats":{"Line":2}},{"line":43,"address":[8202460],"length":1,"stats":{"Line":2}},{"line":50,"address":[8202544],"length":1,"stats":{"Line":1}},{"line":51,"address":[8202561],"length":1,"stats":{"Line":1}},{"line":54,"address":[8202576,8203484,8203456],"length":1,"stats":{"Line":1}},{"line":55,"address":[8202606],"length":1,"stats":{"Line":1}},{"line":61,"address":[8203140],"length":1,"stats":{"Line":1}},{"line":63,"address":[8203155],"length":1,"stats":{"Line":1}},{"line":68,"address":[8203218],"length":1,"stats":{"Line":1}},{"line":69,"address":[8203245,8204284],"length":1,"stats":{"Line":1}},{"line":71,"address":[8202716],"length":1,"stats":{"Line":1}},{"line":72,"address":[8202750],"length":1,"stats":{"Line":1}},{"line":73,"address":[8202765],"length":1,"stats":{"Line":1}},{"line":74,"address":[8202795],"length":1,"stats":{"Line":1}},{"line":76,"address":[8202826],"length":1,"stats":{"Line":1}},{"line":77,"address":[8202846],"length":1,"stats":{"Line":1}},{"line":78,"address":[8203536,8202876],"length":1,"stats":{"Line":2}},{"line":79,"address":[8203544],"length":1,"stats":{"Line":1}},{"line":81,"address":[8202907],"length":1,"stats":{"Line":1}},{"line":82,"address":[8202927],"length":1,"stats":{"Line":1}},{"line":83,"address":[8203929,8202957],"length":1,"stats":{"Line":2}},{"line":84,"address":[8203937],"length":1,"stats":{"Line":1}},{"line":86,"address":[8202993],"length":1,"stats":{"Line":1}},{"line":87,"address":[8203027],"length":1,"stats":{"Line":1}},{"line":96,"address":[8204432],"length":1,"stats":{"Line":1}},{"line":97,"address":[8204437],"length":1,"stats":{"Line":1}},{"line":100,"address":[8204464],"length":1,"stats":{"Line":1}},{"line":101,"address":[8204478],"length":1,"stats":{"Line":1}},{"line":102,"address":[8204557],"length":1,"stats":{"Line":1}},{"line":103,"address":[8204594],"length":1,"stats":{"Line":1}},{"line":104,"address":[8204606,8204645],"length":1,"stats":{"Line":2}},{"line":105,"address":[8204626],"length":1,"stats":{"Line":1}},{"line":107,"address":[8204663],"length":1,"stats":{"Line":1}},{"line":108,"address":[8204747,8204675,8204719],"length":1,"stats":{"Line":3}},{"line":109,"address":[8204695],"length":1,"stats":{"Line":1}},{"line":110,"address":[8204725],"length":1,"stats":{"Line":1}},{"line":112,"address":[8204765],"length":1,"stats":{"Line":1}},{"line":113,"address":[8204821,8204777,8204849],"length":1,"stats":{"Line":3}},{"line":114,"address":[8204797],"length":1,"stats":{"Line":1}},{"line":115,"address":[8204827],"length":1,"stats":{"Line":1}},{"line":117,"address":[8204864],"length":1,"stats":{"Line":1}},{"line":118,"address":[8204898],"length":1,"stats":{"Line":1}},{"line":119,"address":[8204542],"length":1,"stats":{"Line":1}},{"line":123,"address":[8204944],"length":1,"stats":{"Line":1}},{"line":124,"address":[8204961],"length":1,"stats":{"Line":1}},{"line":127,"address":[8205720,8205692,8204976],"length":1,"stats":{"Line":1}},{"line":128,"address":[8205006],"length":1,"stats":{"Line":1}},{"line":129,"address":[8205135],"length":1,"stats":{"Line":1}},{"line":130,"address":[8205169],"length":1,"stats":{"Line":1}},{"line":131,"address":[8205184],"length":1,"stats":{"Line":1}},{"line":132,"address":[8205214],"length":1,"stats":{"Line":1}},{"line":134,"address":[8205245],"length":1,"stats":{"Line":1}},{"line":135,"address":[8205265],"length":1,"stats":{"Line":1}},{"line":136,"address":[8205295,8205772],"length":1,"stats":{"Line":2}},{"line":137,"address":[8205780],"length":1,"stats":{"Line":1}},{"line":139,"address":[8205326],"length":1,"stats":{"Line":1}},{"line":140,"address":[8205346],"length":1,"stats":{"Line":1}},{"line":141,"address":[8205376,8206165],"length":1,"stats":{"Line":2}},{"line":142,"address":[8206173],"length":1,"stats":{"Line":1}},{"line":144,"address":[8205412],"length":1,"stats":{"Line":1}},{"line":145,"address":[8205427],"length":1,"stats":{"Line":1}},{"line":147,"address":[8205443],"length":1,"stats":{"Line":1}},{"line":148,"address":[8205451],"length":1,"stats":{"Line":1}},{"line":149,"address":[8206588],"length":1,"stats":{"Line":1}},{"line":151,"address":[8206517],"length":1,"stats":{"Line":1}},{"line":154,"address":[3125212,3125184],"length":1,"stats":{"Line":2}},{"line":158,"address":[8206606,8205478],"length":1,"stats":{"Line":1}},{"line":159,"address":[8205115],"length":1,"stats":{"Line":1}},{"line":163,"address":[8206752],"length":1,"stats":{"Line":1}},{"line":164,"address":[8206776],"length":1,"stats":{"Line":1}},{"line":167,"address":[8206816,8207576,8207604],"length":1,"stats":{"Line":1}},{"line":171,"address":[8206854],"length":1,"stats":{"Line":1}},{"line":172,"address":[8206983],"length":1,"stats":{"Line":1}},{"line":173,"address":[8207026],"length":1,"stats":{"Line":1}},{"line":174,"address":[8207041],"length":1,"stats":{"Line":1}},{"line":175,"address":[8207079],"length":1,"stats":{"Line":1}},{"line":177,"address":[8207118],"length":1,"stats":{"Line":1}},{"line":178,"address":[8207138],"length":1,"stats":{"Line":1}},{"line":179,"address":[8207176,8207656],"length":1,"stats":{"Line":2}},{"line":180,"address":[8207664],"length":1,"stats":{"Line":1}},{"line":182,"address":[8207215],"length":1,"stats":{"Line":1}},{"line":183,"address":[8207235],"length":1,"stats":{"Line":1}},{"line":184,"address":[8207273,8208057],"length":1,"stats":{"Line":2}},{"line":185,"address":[8208065],"length":1,"stats":{"Line":1}},{"line":187,"address":[8207317],"length":1,"stats":{"Line":1}},{"line":188,"address":[8207332],"length":1,"stats":{"Line":1}},{"line":190,"address":[8207357],"length":1,"stats":{"Line":1}},{"line":191,"address":[8207365],"length":1,"stats":{"Line":1}},{"line":192,"address":[8208432],"length":1,"stats":{"Line":1}},{"line":193,"address":[8208437],"length":1,"stats":{"Line":1}},{"line":196,"address":[3125296,3125324],"length":1,"stats":{"Line":2}},{"line":199,"address":[8208417],"length":1,"stats":{"Line":1}},{"line":202,"address":[8207392],"length":1,"stats":{"Line":1}},{"line":203,"address":[8207409],"length":1,"stats":{"Line":1}},{"line":204,"address":[8208533],"length":1,"stats":{"Line":1}},{"line":206,"address":[8208513],"length":1,"stats":{"Line":1}},{"line":209,"address":[8206963],"length":1,"stats":{"Line":1}},{"line":215,"address":[3977424],"length":1,"stats":{"Line":1}},{"line":221,"address":[7770448],"length":1,"stats":{"Line":1}},{"line":222,"address":[7770546],"length":1,"stats":{"Line":1}},{"line":227,"address":[8208720],"length":1,"stats":{"Line":1}},{"line":228,"address":[8208741],"length":1,"stats":{"Line":1}},{"line":229,"address":[8208781],"length":1,"stats":{"Line":1}},{"line":230,"address":[8208819],"length":1,"stats":{"Line":1}},{"line":231,"address":[8208882],"length":1,"stats":{"Line":1}},{"line":232,"address":[8208930],"length":1,"stats":{"Line":1}},{"line":233,"address":[8209164],"length":1,"stats":{"Line":1}},{"line":235,"address":[8209033],"length":1,"stats":{"Line":1}},{"line":237,"address":[3125436,3125408],"length":1,"stats":{"Line":2}}],"covered":109,"coverable":109},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","foreign_key.rs"],"content":"use crate::ast::types::TableName;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct ForeignKey {\n    pub key_name: String,\n    pub table: TableName,\n    pub columns: Vec\u003cString\u003e,\n    pub referenced_table: TableName,\n    pub referenced_columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","function.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum Function {\n    BuiltIn(BuiltInFunction),         // 내장함수\n    UserDefined(UserDefinedFunction), // 사용자 정의 함수\n}\n\nimpl Function {\n    pub fn is_aggregate(\u0026self) -\u003e bool {\n        match self {\n            Self::BuiltIn(built_in) =\u003e match built_in {\n                BuiltInFunction::Aggregate(_) =\u003e true,\n                BuiltInFunction::Conditional(_) =\u003e false,\n            },\n            Self::UserDefined(_) =\u003e false,\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum BuiltInFunction {\n    Aggregate(AggregateFunction),\n    Conditional(ConditionalFunction),\n}\n\nimpl From\u003cBuiltInFunction\u003e for Function {\n    fn from(value: BuiltInFunction) -\u003e Function {\n        Function::BuiltIn(value)\n    }\n}\n\n// 집합 함수\n// 참고 https://www.postgresql.org/docs/9.5/functions-aggregate.html\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum AggregateFunction {\n    Sum,\n    Count,\n    Max,\n    Min,\n    Avg,\n    Every,\n    ArrayAgg,\n    StringAgg,\n}\n\nimpl From\u003cAggregateFunction\u003e for BuiltInFunction {\n    fn from(value: AggregateFunction) -\u003e BuiltInFunction {\n        BuiltInFunction::Aggregate(value)\n    }\n}\n\nimpl From\u003cAggregateFunction\u003e for Function {\n    fn from(value: AggregateFunction) -\u003e Function {\n        BuiltInFunction::Aggregate(value).into()\n    }\n}\n\nimpl TryFrom\u003cString\u003e for BuiltInFunction {\n    type Error = ();\n\n    fn try_from(function_name: String) -\u003e Result\u003cBuiltInFunction, Self::Error\u003e {\n        match function_name.to_uppercase().as_str() {\n            \"SUM\" =\u003e Ok(AggregateFunction::Sum.into()),\n            \"COUNT\" =\u003e Ok(AggregateFunction::Count.into()),\n            \"MAX\" =\u003e Ok(AggregateFunction::Max.into()),\n            \"MIN\" =\u003e Ok(AggregateFunction::Min.into()),\n            \"AVG\" =\u003e Ok(AggregateFunction::Avg.into()),\n            \"EVERY\" =\u003e Ok(AggregateFunction::Every.into()),\n            \"ARRAYAGG\" =\u003e Ok(AggregateFunction::ArrayAgg.into()),\n            \"STRINGAGG\" =\u003e Ok(AggregateFunction::StringAgg.into()),\n            \"NULLIF\" =\u003e Ok(ConditionalFunction::NullIf.into()),\n            \"COALESCE\" =\u003e Ok(ConditionalFunction::Coalesce.into()),\n            \"GREATEST\" =\u003e Ok(ConditionalFunction::Greatest.into()),\n            \"LEAST\" =\u003e Ok(ConditionalFunction::Least.into()),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n// 집합 함수\n// 참고 https://www.postgresql.org/docs/9.5/functions-aggregate.html\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum ConditionalFunction {\n    NullIf,\n    Coalesce,\n    Greatest,\n    Least,\n}\n\nimpl From\u003cConditionalFunction\u003e for BuiltInFunction {\n    fn from(value: ConditionalFunction) -\u003e BuiltInFunction {\n        BuiltInFunction::Conditional(value)\n    }\n}\n\nimpl From\u003cConditionalFunction\u003e for Function {\n    fn from(value: ConditionalFunction) -\u003e Function {\n        BuiltInFunction::Conditional(value).into()\n    }\n}\n\n// 함수명을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UserDefinedFunction {\n    pub database_name: Option\u003cString\u003e,\n    pub function_name: String,\n}\n\nimpl From\u003cUserDefinedFunction\u003e for Function {\n    fn from(value: UserDefinedFunction) -\u003e Function {\n        Function::UserDefined(value)\n    }\n}\n\nimpl UserDefinedFunction {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_function_is_aggregate() {\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Sum)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Count)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Max)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Min)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Avg)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Every)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::ArrayAgg))\n                .is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::StringAgg))\n                .is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::NullIf))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Coalesce))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Greatest))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Least))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::UserDefined(UserDefinedFunction {\n                database_name: None,\n                function_name: \"my_function\".into()\n            })\n            .is_aggregate(),\n            false\n        );\n    }\n\n    #[allow(non_snake_case)]\n    #[test]\n    fn test_From_AggregateFunction_for_Function() {\n        assert_eq!(\n            Function::from(AggregateFunction::Sum),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Sum))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Count),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Count))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Max),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Max))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Min),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Min))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Avg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Avg))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Every),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Every))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::ArrayAgg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::ArrayAgg))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::StringAgg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::StringAgg))\n        );\n    }\n}\n","traces":[{"line":10,"address":[4139936],"length":1,"stats":{"Line":1}},{"line":11,"address":[4139946],"length":1,"stats":{"Line":1}},{"line":12,"address":[4139981],"length":1,"stats":{"Line":1}},{"line":13,"address":[4140016],"length":1,"stats":{"Line":1}},{"line":14,"address":[4140023],"length":1,"stats":{"Line":1}},{"line":16,"address":[4140009],"length":1,"stats":{"Line":1}},{"line":28,"address":[4140048],"length":1,"stats":{"Line":1}},{"line":29,"address":[4140072],"length":1,"stats":{"Line":1}},{"line":48,"address":[4140096],"length":1,"stats":{"Line":1}},{"line":49,"address":[4140103],"length":1,"stats":{"Line":4}},{"line":54,"address":[4140128],"length":1,"stats":{"Line":1}},{"line":55,"address":[4140147],"length":1,"stats":{"Line":1}},{"line":62,"address":[4141695,4140192],"length":1,"stats":{"Line":2}},{"line":63,"address":[4140272,4140204,4140358],"length":1,"stats":{"Line":6}},{"line":64,"address":[4140374,4140440,4141649],"length":1,"stats":{"Line":2}},{"line":65,"address":[4140417,4140485,4141625,4140524],"length":1,"stats":{"Line":6}},{"line":66,"address":[4141601,4140569,4140501,4140608],"length":1,"stats":{"Line":4}},{"line":67,"address":[4140585,4141577,4140653,4140692],"length":1,"stats":{"Line":4}},{"line":68,"address":[4140669,4140737,4140776,4141553],"length":1,"stats":{"Line":4}},{"line":69,"address":[4140753,4140821,4141529,4140860],"length":1,"stats":{"Line":4}},{"line":70,"address":[4140905,4141505,4140944,4140837],"length":1,"stats":{"Line":4}},{"line":71,"address":[4140921,4141028,4140989,4141484],"length":1,"stats":{"Line":4}},{"line":72,"address":[4141463,4141073,4141005,4141112],"length":1,"stats":{"Line":4}},{"line":73,"address":[4141089,4141157,4141442,4141196],"length":1,"stats":{"Line":6}},{"line":74,"address":[4141241,4141173,4141421,4141280],"length":1,"stats":{"Line":2}},{"line":75,"address":[4141335,4141257,4141400,4141322],"length":1,"stats":{"Line":2}},{"line":76,"address":[4141328],"length":1,"stats":{"Line":1}},{"line":92,"address":[4141728],"length":1,"stats":{"Line":2}},{"line":93,"address":[4141735],"length":1,"stats":{"Line":2}},{"line":98,"address":[4141760],"length":1,"stats":{"Line":1}},{"line":99,"address":[4141779],"length":1,"stats":{"Line":1}},{"line":111,"address":[4141824],"length":1,"stats":{"Line":1}},{"line":112,"address":[4141832],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":33},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","index.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Index {\n    pub index_name: String,\n    pub database_name: Option\u003cString\u003e,\n    pub columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","mod.rs"],"content":"pub mod column;\npub use column::*;\n\npub mod table;\npub use table::*;\n\npub mod foreign_key;\npub use foreign_key::*;\n\npub mod unique_key;\npub use unique_key::*;\n\npub mod table_options;\npub use table_options::*;\n\npub mod data_types;\npub use data_types::*;\n\npub mod select_column;\npub use select_column::*;\n\npub mod function;\npub use function::*;\n\npub mod expression;\npub use expression::*;\n\npub mod index;\npub use index::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","select_column.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\n// [table_alias.]column_name\n// SELECT시 컬럼 지정을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash)]\npub struct SelectColumn {\n    pub table_name: Option\u003cString\u003e,\n    pub column_name: String,\n}\n\nimpl SelectColumn {\n    pub fn new(table_name: Option\u003cString\u003e, column_name: String) -\u003e Self {\n        SelectColumn {\n            column_name,\n            table_name,\n        }\n    }\n}\n\nimpl From\u003cSelectColumn\u003e for SQLExpression {\n    fn from(value: SelectColumn) -\u003e SQLExpression {\n        SQLExpression::SelectColumn(value)\n    }\n}\n","traces":[{"line":13,"address":[2314064],"length":1,"stats":{"Line":3}},{"line":22,"address":[8202384],"length":1,"stats":{"Line":1}},{"line":23,"address":[8202401],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","table.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::ast::dml::parts::from::{FromClause, FromTarget};\n\n// [database_name.]table_name\n// 테이블명을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash, Default)]\npub struct TableName {\n    pub database_name: Option\u003cString\u003e,\n    pub table_name: String,\n}\n\nimpl TableName {\n    pub fn new(database_name: Option\u003cString\u003e, table_name: String) -\u003e Self {\n        TableName {\n            database_name,\n            table_name,\n        }\n    }\n}\n\nimpl From\u003cTableName\u003e for FromClause {\n    fn from(value: TableName) -\u003e FromClause {\n        FromClause {\n            from: FromTarget::Table(value),\n            alias: None,\n        }\n    }\n}\n","traces":[{"line":14,"address":[1690704],"length":1,"stats":{"Line":1}},{"line":23,"address":[8183024],"length":1,"stats":{"Line":1}},{"line":25,"address":[8183037],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","table_options.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct TableOptions {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","unique_key.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UniqueKey {\n    pub key_name: String,\n    pub database_name: Option\u003cString\u003e,\n    pub columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","init.rs"],"content":"use serde::Deserialize;\n\nuse clap::Args;\n\n/// Config options for the build system.\n#[derive(Clone, Debug, Default, Deserialize, Args)]\npub struct ConfigOptions {\n    /// 파일이 세팅될 경로\n    #[clap(long, short)]\n    pub config_path: Option\u003cString\u003e,\n}\n\n#[derive(Clone, Debug, Args)]\n#[clap(name = \"init\")]\npub struct Command {\n    #[clap(flatten)]\n    pub init: ConfigOptions,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","mod.rs"],"content":"pub mod init;\npub mod run;\n\nuse clap::Parser;\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about, long_about = None)]\npub struct Command {\n    #[clap(subcommand)]\n    pub action: SubCommand,\n}\n\n#[derive(clap::Subcommand, Debug)]\npub enum SubCommand {\n    /// 설정 파일 및 저장공간 초기화\n    Init(init::Command),\n    /// DB 서버 실행\n    Run(run::Command),\n    /// DB 클라이언트 실행\n    Client,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","run.rs"],"content":"use serde::Deserialize;\n\nuse clap::Args;\n\n/// Config options for the build system.\n#[derive(Clone, Debug, Default, Deserialize, Args)]\npub struct ConfigOptions {\n    #[clap(name = \"config\", long, help = \"config file path\")]\n    pub config: Option\u003cString\u003e,\n}\n\n#[derive(Clone, Debug, Args)]\n#[clap(name = \"run\")]\npub struct Command {\n    #[clap(flatten)]\n    pub value: ConfigOptions,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","constants.rs"],"content":"// 기본 데이터베이스 이름\npub const DEFAULT_DATABASE_NAME: \u0026str = \"rrdb\";\n\n// 기본 설정파일 이름.\npub const DEFAULT_CONFIG_FILENAME: \u0026str = \"rrdb.config\";\n\n// 기본 Data 디렉터리 이름\npub const DEFAULT_DATA_DIRNAME: \u0026str = \"data\";\n\n// 운영체제별 기본 저장 경로를 반환합니다.\n#[cfg(target_os = \"linux\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = \"/var/lib/rrdb\";\n\n#[cfg(target_os = \"windows\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = r\"C:\\Program Files\\rrdb\";\n\n#[cfg(target_os = \"macos\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = \"/var/lib/rrdb\";\n\npub const LAUNCHD_PLIST_PATH: \u0026str = \"/Library/LaunchDaemons/io.github.myyrakle.rrdb.plist\";\n\n#[cfg(target_os = \"linux\")]\npub const SYSTEMD_DAEMON_SCRIPT: \u0026str = r#\"[Unit]\nDescription=RRDB\n\n[Service]\nType=simple\nRestart=on-failure\nExecStart=/usr/bin/rrdb run\nRemainAfterExit=on\nUser=root\nStandardOutput=file:/var/log/rrdb.stdout.log\nStandardError=file:/var/log/rrdb.stderr.log\n\n[Install]\nWantedBy=multi-user.target\"#;\n\n#[cfg(target_os = \"macos\")]\npub const LAUNCHD_DAEMON_SCRIPT: \u0026str = r#\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e\n\u003cplist version=\"1.0\"\u003e\n\u003cdict\u003e\n        \u003ckey\u003eLabel\u003c/key\u003e\n        \u003cstring\u003emyyrakle.github.io.rrdb\u003c/string\u003e\n        \u003ckey\u003eUserName\u003c/key\u003e\n        \u003cstring\u003eroot\u003c/string\u003e\n        \u003ckey\u003eProgram\u003c/key\u003e\n        \u003cstring\u003e/usr/local/bin/rrdb\u003c/string\u003e\n        \u003ckey\u003eProgramArguments\u003c/key\u003e\n        \u003carray\u003e\n            \u003cstring\u003erun\u003c/string\u003e\n        \u003c/array\u003e\n        \u003ckey\u003eRunAtLoad\u003c/key\u003e\n        \u003ctrue/\u003e\n        \u003ckey\u003eStandardOutPath\u003c/key\u003e\n        \u003cstring\u003e/var/log/rrdb.stdout.log\u003c/string\u003e\n        \u003ckey\u003eStandardErrorPath\u003c/key\u003e\n        \u003cstring\u003e/var/log/rrdb.stderr.log\u003c/string\u003e\n\u003c/dict\u003e\n\u003c/plist\u003e\"#;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","execute_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ExecuteError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ExecuteError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ExecuteError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ExecuteError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ExecuteError {}\n\nimpl std::fmt::Display for ExecuteError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"{}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_execute_error_eq() {\n        let error1 = ExecuteError::wrap(\"test\");\n        let error2 = ExecuteError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_execute_error_display() {\n        let error = ExecuteError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"test\"));\n    }\n}\n","traces":[{"line":10,"address":[4000496],"length":1,"stats":{"Line":1}},{"line":11,"address":[4000510],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[4000544],"length":1,"stats":{"Line":1}},{"line":28,"address":[4000565,4000626],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","into_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct IntoError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for IntoError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl IntoError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::IntoError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for IntoError {}\n\nimpl std::fmt::Display for IntoError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error(into error): {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_error_eq() {\n        let error1 = IntoError::wrap(\"test\");\n        let error2 = IntoError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_into_error_display() {\n        let error = IntoError::wrap(\"test\");\n\n        assert!(error\n            .to_string()\n            .contains(\"parsing error(into error): test\"));\n    }\n}\n","traces":[{"line":10,"address":[5642256],"length":1,"stats":{"Line":1}},{"line":11,"address":[5642270],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[5642304],"length":1,"stats":{"Line":1}},{"line":28,"address":[5642386,5642325],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","lexing_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct LexingError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for LexingError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl LexingError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::LexingError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for LexingError {}\n\nimpl std::fmt::Display for LexingError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"lexing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_lexing_error_eq() {\n        let error1 = LexingError::wrap(\"test\");\n        let error2 = LexingError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_lexing_error_display() {\n        let error = LexingError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"lexing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[7765136],"length":1,"stats":{"Line":1}},{"line":11,"address":[7765150],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[7765184],"length":1,"stats":{"Line":1}},{"line":28,"address":[7765205,7765266],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","mod.rs"],"content":"pub mod execute_error;\npub mod into_error;\npub mod lexing_error;\npub mod parsing_error;\npub mod predule;\npub mod server_error;\npub mod type_error;\n\n#[derive(Debug, PartialEq)]\npub enum RRDBError {\n    ExecuteError(execute_error::ExecuteError),\n    IntoError(into_error::IntoError),\n    LexingError(lexing_error::LexingError),\n    ParsingError(parsing_error::ParsingError),\n    ServerError(server_error::ServerError),\n    TypeError(type_error::TypeError),\n}\n\nimpl ToString for RRDBError {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            RRDBError::ExecuteError(e) =\u003e e.to_string(),\n            RRDBError::IntoError(e) =\u003e e.to_string(),\n            RRDBError::LexingError(e) =\u003e e.to_string(),\n            RRDBError::ParsingError(e) =\u003e e.to_string(),\n            RRDBError::ServerError(e) =\u003e e.to_string(),\n            RRDBError::TypeError(e) =\u003e e.to_string(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use predule::{ExecuteError, IntoError, LexingError, ParsingError, ServerError, TypeError};\n\n    use super::*;\n\n    #[test]\n    fn test_rrdb_error_to_string() {\n        let error = ExecuteError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = IntoError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = LexingError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = ParsingError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = ServerError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = TypeError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n    }\n}\n","traces":[{"line":20,"address":[8183136],"length":1,"stats":{"Line":1}},{"line":21,"address":[8183159],"length":1,"stats":{"Line":1}},{"line":22,"address":[8183199],"length":1,"stats":{"Line":1}},{"line":23,"address":[8183224],"length":1,"stats":{"Line":1}},{"line":24,"address":[8183249],"length":1,"stats":{"Line":1}},{"line":25,"address":[8183274],"length":1,"stats":{"Line":1}},{"line":26,"address":[8183299],"length":1,"stats":{"Line":1}},{"line":27,"address":[8183324],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","parsing_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ParsingError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ParsingError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ParsingError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ParsingError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ParsingError {}\n\nimpl std::fmt::Display for ParsingError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parsing_error_eq() {\n        let error1 = ParsingError::wrap(\"test\");\n        let error2 = ParsingError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_parsing_error_display() {\n        let error = ParsingError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"parsing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[1850048],"length":1,"stats":{"Line":1}},{"line":11,"address":[1850062],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[1850096],"length":1,"stats":{"Line":1}},{"line":28,"address":[1850117,1850178],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","predule.rs"],"content":"pub use super::execute_error::*;\npub use super::into_error::*;\npub use super::lexing_error::*;\npub use super::parsing_error::*;\npub use super::server_error::*;\npub use super::type_error::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","server_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ServerError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ServerError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ServerError {\n    pub fn new\u003cT: ToString\u003e(message: T) -\u003e Self {\n        Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        }\n    }\n\n    pub fn boxed\u003cT: ToString\u003e(message: T) -\u003e Box\u003cSelf\u003e {\n        Box::new(Self::new(message))\n    }\n}\n\nimpl ServerError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ServerError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ServerError {}\n\nimpl std::fmt::Display for ServerError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"server error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_server_error_eq() {\n        let error1 = ServerError::wrap(\"test\");\n        let error2 = ServerError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_server_error_display() {\n        let error = ServerError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"server error: test\"));\n    }\n\n    #[test]\n    fn test_server_error_new() {\n        let error = ServerError::new(\"test\");\n\n        assert_eq!(error.message, \"test\");\n    }\n\n    #[test]\n    fn test_server_error_boxed() {\n        let error = ServerError::boxed(\"test\");\n\n        assert_eq!(error.message, \"test\");\n    }\n}\n","traces":[{"line":10,"address":[1850256],"length":1,"stats":{"Line":1}},{"line":11,"address":[1850270],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[1850304],"length":1,"stats":{"Line":1}},{"line":41,"address":[1850325,1850386],"length":1,"stats":{"Line":2}}],"covered":13,"coverable":13},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","type_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct TypeError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for TypeError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl TypeError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::TypeError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for TypeError {}\n\nimpl std::fmt::Display for TypeError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_type_error_eq() {\n        let error1 = TypeError::wrap(\"test\");\n        let error2 = TypeError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_type_error_display() {\n        let error = TypeError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"parsing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[4000704],"length":1,"stats":{"Line":1}},{"line":11,"address":[4000718],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[4000752],"length":1,"stats":{"Line":2}},{"line":28,"address":[4000773,4000834],"length":1,"stats":{"Line":4}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","common.rs"],"content":"use std::io::ErrorKind;\n\nuse super::config::table::TableConfig;\nuse super::encoder::storage::StorageEncoder;\nuse super::predule::Executor;\nuse crate::ast::types::TableName;\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\n\nimpl Executor {\n    pub async fn get_table_config(\u0026self, table_name: TableName) -\u003e Result\u003cTableConfig, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = table_name;\n\n        let database_name = database_name.unwrap();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // config data 파일 내용 변경\n        let config_path = table_path.clone().join(\"table.config\");\n\n        match tokio::fs::read(\u0026config_path).await {\n            Ok(data) =\u003e {\n                let table_config: Option\u003cTableConfig\u003e = encoder.decode(data.as_slice());\n\n                match table_config {\n                    Some(table_config) =\u003e Ok(table_config),\n                    None =\u003e Err(ExecuteError::wrap(\"invalid config data\")),\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"table not found\")),\n                _ =\u003e Err(ExecuteError::wrap(format!(\"{:?}\", error))),\n            },\n        }\n    }\n}\n","traces":[{"line":11,"address":[2868016,2868114,2868245,2871641,2869635,2869797,2868060],"length":1,"stats":{"Line":0}},{"line":12,"address":[2868238],"length":1,"stats":{"Line":0}},{"line":14,"address":[2868338],"length":1,"stats":{"Line":0}},{"line":17,"address":[2868357],"length":1,"stats":{"Line":0}},{"line":18,"address":[2868416],"length":1,"stats":{"Line":0}},{"line":21,"address":[2868480],"length":1,"stats":{"Line":0}},{"line":23,"address":[2868719,2868636],"length":1,"stats":{"Line":0}},{"line":24,"address":[2868889],"length":1,"stats":{"Line":0}},{"line":27,"address":[2869258],"length":1,"stats":{"Line":0}},{"line":29,"address":[2868272,2869563,2869469,2869829,2868107,2870096],"length":1,"stats":{"Line":0}},{"line":30,"address":[2870131],"length":1,"stats":{"Line":0}},{"line":31,"address":[2870163,2870316],"length":1,"stats":{"Line":0}},{"line":33,"address":[2870323],"length":1,"stats":{"Line":0}},{"line":34,"address":[2870385],"length":1,"stats":{"Line":0}},{"line":35,"address":[2870358,2870439],"length":1,"stats":{"Line":0}},{"line":38,"address":[2870211,2870631],"length":1,"stats":{"Line":0}},{"line":39,"address":[2870652,2870775],"length":1,"stats":{"Line":0}},{"line":40,"address":[2870845],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","database.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct DatabaseConfig {\n    pub database_name: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","global.rs"],"content":"use std::path::PathBuf;\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::constants::{DEFAULT_CONFIG_BASEPATH, DEFAULT_CONFIG_FILENAME, DEFAULT_DATA_DIRNAME};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct GlobalConfig {\n    pub port: u32,\n    pub host: String,\n    pub data_directory: String,\n}\n\n#[allow(clippy::derivable_impls)]\nimpl std::default::Default for GlobalConfig {\n    fn default() -\u003e Self {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n\n        Self {\n            port: 22208,\n            host: \"0.0.0.0\".to_string(),\n            data_directory: base_path\n                .join(DEFAULT_DATA_DIRNAME)\n                .to_str()\n                .unwrap()\n                .to_string(),\n        }\n    }\n}\n\nimpl GlobalConfig {\n    pub fn default_config_path() -\u003e PathBuf {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n        base_path.join(DEFAULT_CONFIG_FILENAME)\n    }\n\n    pub fn load_from_path(filepath: Option\u003cString\u003e) -\u003e anyhow::Result\u003cSelf\u003e {\n        let filepath = match filepath {\n            Some(path) =\u003e PathBuf::from(path),\n            None =\u003e Self::default_config_path(),\n        };\n\n        let config = std::fs::read_to_string(filepath)?;\n        let decoded = toml::from_str(\u0026config)?;\n\n        Ok(decoded)\n    }\n}\n","traces":[{"line":16,"address":[1230194,1229600,1230169],"length":1,"stats":{"Line":1}},{"line":17,"address":[1229617],"length":1,"stats":{"Line":1}},{"line":21,"address":[1229639],"length":1,"stats":{"Line":1}},{"line":22,"address":[1229774,1229878,1230022,1229709],"length":1,"stats":{"Line":4}},{"line":32,"address":[1230208,1230359],"length":1,"stats":{"Line":0}},{"line":33,"address":[1230222],"length":1,"stats":{"Line":0}},{"line":34,"address":[1230318,1230254],"length":1,"stats":{"Line":0}},{"line":37,"address":[1230384,1230967],"length":1,"stats":{"Line":0}},{"line":38,"address":[1230406],"length":1,"stats":{"Line":0}},{"line":39,"address":[1230453],"length":1,"stats":{"Line":0}},{"line":40,"address":[1230436],"length":1,"stats":{"Line":0}},{"line":43,"address":[1230494,1230687],"length":1,"stats":{"Line":0}},{"line":44,"address":[1230911,1230665,1230779],"length":1,"stats":{"Line":0}},{"line":46,"address":[1230875],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":14},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","mod.rs"],"content":"pub mod database;\npub mod global;\npub mod row;\npub mod table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","row.rs"],"content":"use itertools::Itertools;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{ast::types::TableName, utils::float::Float64};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, PartialOrd, Eq, Hash)]\npub enum TableDataFieldType {\n    // 끝단 Primitive 값\n    Integer(i64),\n    Float(Float64),\n    Boolean(bool),\n    String(String),\n    Array(Vec\u003cTableDataFieldType\u003e),\n    Null,\n}\n\nimpl TableDataFieldType {\n    pub fn type_code(\u0026self) -\u003e isize {\n        match self {\n            TableDataFieldType::Integer(_) =\u003e 1,\n            TableDataFieldType::Float(_) =\u003e 2,\n            TableDataFieldType::Boolean(_) =\u003e 3,\n            TableDataFieldType::String(_) =\u003e 4,\n            TableDataFieldType::Array(_) =\u003e 5,\n            TableDataFieldType::Null =\u003e 0,\n        }\n    }\n\n    pub fn to_array(self) -\u003e Self {\n        Self::Array(vec![self])\n    }\n\n    pub fn push(\u0026mut self, value: Self) {\n        #[allow(clippy::single_match)]\n        match self {\n            TableDataFieldType::Array(array) =\u003e array.push(value),\n            _ =\u003e {}\n        }\n    }\n\n    pub fn is_null(\u0026self) -\u003e bool {\n        self.type_code() == 0\n    }\n\n    pub fn is_array(\u0026self) -\u003e bool {\n        self.type_code() == 5\n    }\n}\n\nimpl ToString for TableDataFieldType {\n    fn to_string(\u0026self) -\u003e String {\n        #[allow(unstable_name_collisions)]\n        match self {\n            TableDataFieldType::Integer(value) =\u003e value.to_string(),\n            TableDataFieldType::Float(value) =\u003e value.to_string(),\n            TableDataFieldType::Boolean(value) =\u003e value.to_string(),\n            TableDataFieldType::String(value) =\u003e value.to_owned(),\n            TableDataFieldType::Array(value) =\u003e value\n                .iter()\n                .map(|e| e.to_string())\n                .intersperse(\", \".to_owned())\n                .collect(),\n            TableDataFieldType::Null =\u003e \"NULL\".into(),\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq, Hash)]\npub struct TableDataField {\n    pub table_name: TableName,\n    pub column_name: String,\n    pub data: TableDataFieldType,\n}\n\nimpl TableDataField {\n    pub fn to_array(self) -\u003e Self {\n        Self {\n            table_name: self.table_name,\n            column_name: self.column_name,\n            data: self.data.to_array(),\n        }\n    }\n\n    pub fn push(\u0026mut self, value: TableDataFieldType) {\n        #[allow(clippy::single_match)]\n        match \u0026mut self.data {\n            TableDataFieldType::Array(array) =\u003e array.push(value),\n            _ =\u003e {}\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct TableDataRow {\n    pub fields: Vec\u003cTableDataField\u003e,\n}\n","traces":[{"line":18,"address":[5033232],"length":1,"stats":{"Line":0}},{"line":19,"address":[5033237],"length":1,"stats":{"Line":0}},{"line":20,"address":[5033268],"length":1,"stats":{"Line":0}},{"line":21,"address":[5033279],"length":1,"stats":{"Line":0}},{"line":22,"address":[5033290],"length":1,"stats":{"Line":0}},{"line":23,"address":[5033301],"length":1,"stats":{"Line":0}},{"line":24,"address":[5033312],"length":1,"stats":{"Line":0}},{"line":25,"address":[5033323],"length":1,"stats":{"Line":0}},{"line":29,"address":[5033597,5033619,5033344],"length":1,"stats":{"Line":0}},{"line":30,"address":[5033363,5033437],"length":1,"stats":{"Line":0}},{"line":33,"address":[5033632],"length":1,"stats":{"Line":0}},{"line":35,"address":[5033650],"length":1,"stats":{"Line":0}},{"line":36,"address":[5033678],"length":1,"stats":{"Line":0}},{"line":41,"address":[5033776],"length":1,"stats":{"Line":0}},{"line":42,"address":[5033781],"length":1,"stats":{"Line":0}},{"line":45,"address":[5033808],"length":1,"stats":{"Line":0}},{"line":46,"address":[5033813],"length":1,"stats":{"Line":0}},{"line":51,"address":[5033840],"length":1,"stats":{"Line":0}},{"line":53,"address":[5033870],"length":1,"stats":{"Line":0}},{"line":54,"address":[5033911],"length":1,"stats":{"Line":0}},{"line":55,"address":[5033944],"length":1,"stats":{"Line":0}},{"line":56,"address":[5033976],"length":1,"stats":{"Line":0}},{"line":57,"address":[5034008],"length":1,"stats":{"Line":0}},{"line":58,"address":[5034036,5034115],"length":1,"stats":{"Line":0}},{"line":60,"address":[4939267,4939232],"length":1,"stats":{"Line":0}},{"line":61,"address":[5034084],"length":1,"stats":{"Line":0}},{"line":63,"address":[5034152],"length":1,"stats":{"Line":0}},{"line":76,"address":[5034457,5034436,5034192],"length":1,"stats":{"Line":0}},{"line":78,"address":[5034208],"length":1,"stats":{"Line":0}},{"line":79,"address":[5034234],"length":1,"stats":{"Line":0}},{"line":80,"address":[5034252],"length":1,"stats":{"Line":0}},{"line":84,"address":[5034480],"length":1,"stats":{"Line":0}},{"line":86,"address":[5034493],"length":1,"stats":{"Line":0}},{"line":87,"address":[5034534],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","table.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::ast::{\n    ddl::create_table::CreateTableQuery,\n    types::{Column, ForeignKey, TableName, UniqueKey},\n};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct TableConfig {\n    pub table: TableName,\n    pub columns: Vec\u003cColumn\u003e,\n    pub primary_key: Vec\u003cString\u003e,\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub unique_keys: Vec\u003cUniqueKey\u003e,\n}\n\nimpl TableConfig {\n    pub fn get_columns_map(\u0026self) -\u003e HashMap\u003cString, Column\u003e {\n        HashMap::from_iter(self.columns.iter().cloned().map(|e| (e.name.clone(), e)))\n    }\n\n    pub fn get_required_columns(\u0026self) -\u003e Vec\u003cColumn\u003e {\n        self.columns\n            .iter()\n            .filter(|e| e.not_null \u0026\u0026 e.default.is_none())\n            .cloned()\n            .collect()\n    }\n}\n\nimpl From\u003cCreateTableQuery\u003e for TableConfig {\n    fn from(query: CreateTableQuery) -\u003e Self {\n        Self {\n            table: query.table.unwrap(),\n            columns: query.columns,\n            primary_key: query.primary_key,\n            foreign_keys: query.foreign_keys,\n            unique_keys: query.unique_keys,\n        }\n    }\n}\n","traces":[{"line":20,"address":[5727600],"length":1,"stats":{"Line":0}},{"line":21,"address":[5727632],"length":1,"stats":{"Line":0}},{"line":24,"address":[5727712],"length":1,"stats":{"Line":0}},{"line":25,"address":[5727744],"length":1,"stats":{"Line":0}},{"line":27,"address":[6077936,6077955],"length":1,"stats":{"Line":0}},{"line":34,"address":[5728295,5727824,5728353],"length":1,"stats":{"Line":0}},{"line":36,"address":[5727845],"length":1,"stats":{"Line":0}},{"line":37,"address":[5727975],"length":1,"stats":{"Line":0}},{"line":38,"address":[5728007],"length":1,"stats":{"Line":0}},{"line":39,"address":[5728043],"length":1,"stats":{"Line":0}},{"line":40,"address":[5728079],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","encoder","mod.rs"],"content":"pub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","encoder","storage.rs"],"content":"use serde::{Deserialize, Serialize};\n\npub struct StorageEncoder {}\n\n#[allow(clippy::new_without_default)]\nimpl StorageEncoder {\n    pub fn new() -\u003e Self {\n        StorageEncoder {}\n    }\n\n    pub fn encode(\u0026self, data: impl Serialize) -\u003e Vec\u003cu8\u003e {\n        bson::to_vec(\u0026data).unwrap()\n    }\n\n    pub fn decode\u003c'a, T\u003e(\u0026self, data: \u0026'a [u8]) -\u003e Option\u003cT\u003e\n    where\n        T: Deserialize\u003c'a\u003e,\n    {\n        match bson::from_slice(data) {\n            Ok(data) =\u003e Some(data),\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[7515568,7514992,7515280],"length":1,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","executor.rs"],"content":"use std::sync::Arc;\n\nuse crate::ast::{DDLStatement, DMLStatement, OtherStatement, SQLStatement};\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::ExecuteResult;\nuse crate::logger::predule::Logger;\n\nuse super::config::global::GlobalConfig;\nuse super::mocking::{CommandRunner, FileSystem, RealCommandRunner, RealFileSystem};\n\npub struct Executor {\n    pub(crate) config: Arc\u003cGlobalConfig\u003e,\n    pub(crate) file_system: Arc\u003cdyn FileSystem + Send + Sync\u003e,\n    pub(crate) command_runner: Arc\u003cdyn CommandRunner + Send + Sync\u003e,\n}\n\nimpl Executor {\n    pub fn new(config: Arc\u003cGlobalConfig\u003e) -\u003e Self {\n        Self {\n            config,\n            file_system: Arc::new(RealFileSystem {}),\n            command_runner: Arc::new(RealCommandRunner {}),\n        }\n    }\n\n    // 쿼리 최적화 및 실행, 결과 반환\n    pub async fn process_query(\n        \u0026self,\n        statement: SQLStatement,\n        _connection_id: String,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        Logger::info(format!(\"AST echo: {:?}\", statement));\n\n        // 쿼리 실행\n        let result = match statement {\n            SQLStatement::DDL(DDLStatement::CreateDatabaseQuery(query)) =\u003e {\n                self.create_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::AlterDatabase(query)) =\u003e {\n                self.alter_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::DropDatabaseQuery(query)) =\u003e {\n                self.drop_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::CreateTableQuery(query)) =\u003e {\n                self.create_table(query).await\n            }\n            SQLStatement::DDL(DDLStatement::AlterTableQuery(query)) =\u003e {\n                self.alter_table(query).await\n            }\n            SQLStatement::DDL(DDLStatement::DropTableQuery(query)) =\u003e self.drop_table(query).await,\n            SQLStatement::DML(DMLStatement::InsertQuery(query)) =\u003e self.insert(query).await,\n            SQLStatement::DML(DMLStatement::SelectQuery(query)) =\u003e self.select(query).await,\n            SQLStatement::DML(DMLStatement::UpdateQuery(query)) =\u003e self.update(query).await,\n            SQLStatement::DML(DMLStatement::DeleteQuery(query)) =\u003e self.delete(query).await,\n            SQLStatement::Other(OtherStatement::ShowDatabases(query)) =\u003e {\n                self.show_databases(query).await\n            }\n            SQLStatement::Other(OtherStatement::UseDatabase(query)) =\u003e {\n                self.use_databases(query).await\n            }\n            SQLStatement::Other(OtherStatement::ShowTables(query)) =\u003e self.show_tables(query).await,\n            SQLStatement::Other(OtherStatement::DescTable(query)) =\u003e self.desc_table(query).await,\n            _ =\u003e unimplemented!(\"no execute implementation\"),\n        };\n\n        match result {\n            Ok(result) =\u003e Ok(result),\n            Err(error) =\u003e Err(ExecuteError::wrap(error.to_string())),\n        }\n    }\n}\n","traces":[{"line":19,"address":[5579870,5579680],"length":1,"stats":{"Line":0}},{"line":22,"address":[5579704,5579752],"length":1,"stats":{"Line":0}},{"line":23,"address":[5579769],"length":1,"stats":{"Line":0}},{"line":28,"address":[5579904],"length":1,"stats":{"Line":0}},{"line":33,"address":[4145918,4146382],"length":1,"stats":{"Line":0}},{"line":36,"address":[4146570,4146470],"length":1,"stats":{"Line":0}},{"line":37,"address":[4146797],"length":1,"stats":{"Line":0}},{"line":38,"address":[4828134],"length":1,"stats":{"Line":0}},{"line":40,"address":[4146884],"length":1,"stats":{"Line":0}},{"line":41,"address":[4147477,4146066,4146968,4149813],"length":1,"stats":{"Line":0}},{"line":43,"address":[4146986],"length":1,"stats":{"Line":0}},{"line":44,"address":[4828178],"length":1,"stats":{"Line":0}},{"line":46,"address":[4147065],"length":1,"stats":{"Line":0}},{"line":47,"address":[4828200],"length":1,"stats":{"Line":0}},{"line":49,"address":[4147159],"length":1,"stats":{"Line":0}},{"line":50,"address":[4147243,4146129,4147750,4150830],"length":1,"stats":{"Line":0}},{"line":52,"address":[4828244],"length":1,"stats":{"Line":0}},{"line":53,"address":[4828266],"length":1,"stats":{"Line":0}},{"line":54,"address":[4148613,4148245,4151844,4146192],"length":1,"stats":{"Line":0}},{"line":55,"address":[4146213,4152180,4148063,4148437],"length":1,"stats":{"Line":0}},{"line":56,"address":[4152516,4148157,4148525,4146234],"length":1,"stats":{"Line":0}},{"line":58,"address":[4828354],"length":1,"stats":{"Line":0}},{"line":60,"address":[4148719],"length":1,"stats":{"Line":0}},{"line":61,"address":[4146276,4149091,4153188,4148788],"length":1,"stats":{"Line":0}},{"line":63,"address":[4148806,4149179,4146297,4153524],"length":1,"stats":{"Line":0}},{"line":64,"address":[4148893,4146318,4149267,4153860],"length":1,"stats":{"Line":0}},{"line":68,"address":[4149769],"length":1,"stats":{"Line":0}},{"line":69,"address":[4154196],"length":1,"stats":{"Line":0}},{"line":70,"address":[4154410,4154270],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","alter_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::alter_database::{AlterDatabaseAction, AlterDatabaseQuery};\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn alter_database(\n        \u0026self,\n        query: AlterDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        #[allow(clippy::single_match)]\n        match query.action {\n            Some(action) =\u003e match action {\n                AlterDatabaseAction::RenameTo(rename) =\u003e {\n                    // 기존 데이터베이스명\n                    let from_database_name = query\n                        .database_name\n                        .clone()\n                        .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n                    // 변경할 데이터베이스명\n                    let to_database_name = rename.name;\n\n                    // 실제 데이터베이스 디렉터리 경로\n                    let mut from_path = base_path.clone();\n                    let mut to_path = base_path.clone();\n\n                    from_path.push(from_database_name);\n                    to_path.push(to_database_name.clone());\n\n                    // 디렉터리명 변경\n                    let result = tokio::fs::rename(\u0026from_path, \u0026to_path).await;\n\n                    if let Err(error) = result {\n                        match error.kind() {\n                            ErrorKind::NotFound =\u003e {\n                                return Err(ExecuteError::wrap(\"database not found\"))\n                            }\n                            _ =\u003e {\n                                return Err(ExecuteError::wrap(\"database alter failed\"));\n                            }\n                        }\n                    }\n\n                    // config data 파일 내용 변경\n                    let mut config_path = to_path.clone();\n                    config_path.push(\"database.config\");\n\n                    match tokio::fs::read(\u0026config_path).await {\n                        Ok(data) =\u003e {\n                            let database_config: Option\u003cDatabaseConfig\u003e =\n                                encoder.decode(data.as_slice());\n\n                            match database_config {\n                                Some(mut database_config) =\u003e {\n                                    database_config.database_name = to_database_name;\n                                    if let Err(_error) = tokio::fs::write(\n                                        config_path,\n                                        encoder.encode(database_config),\n                                    )\n                                    .await\n                                    {\n                                        return Err(ExecuteError::wrap(\"no database name\"));\n                                    }\n                                }\n                                None =\u003e {\n                                    return Err(ExecuteError::wrap(\"invalid config data\"));\n                                }\n                            }\n                        }\n                        Err(error) =\u003e match error.kind() {\n                            ErrorKind::NotFound =\u003e {\n                                return Err(ExecuteError::wrap(\"database not found\"));\n                            }\n                            _ =\u003e {\n                                return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                            }\n                        },\n                    }\n                }\n            },\n            None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(\"alter database\".into())],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5580016],"length":1,"stats":{"Line":0}},{"line":16,"address":[1199620],"length":1,"stats":{"Line":0}},{"line":18,"address":[1199771],"length":1,"stats":{"Line":0}},{"line":21,"address":[1199790,1199422],"length":1,"stats":{"Line":0}},{"line":22,"address":[1199857],"length":1,"stats":{"Line":0}},{"line":23,"address":[1199902],"length":1,"stats":{"Line":0}},{"line":25,"address":[1200359,1200880,1199953,1200042],"length":1,"stats":{"Line":0}},{"line":28,"address":[1200279,1207120,1207132],"length":1,"stats":{"Line":0}},{"line":31,"address":[1200181],"length":1,"stats":{"Line":0}},{"line":34,"address":[1200247],"length":1,"stats":{"Line":0}},{"line":35,"address":[1200443],"length":1,"stats":{"Line":0}},{"line":37,"address":[1200520],"length":1,"stats":{"Line":0}},{"line":38,"address":[1200643],"length":1,"stats":{"Line":0}},{"line":41,"address":[1199660,1200934,1200717,1200808],"length":1,"stats":{"Line":0}},{"line":43,"address":[1201164],"length":1,"stats":{"Line":0}},{"line":44,"address":[1201239,1201333],"length":1,"stats":{"Line":0}},{"line":46,"address":[1201408,1201354],"length":1,"stats":{"Line":0}},{"line":49,"address":[1201381,1201453],"length":1,"stats":{"Line":0}},{"line":55,"address":[1201250,1201794],"length":1,"stats":{"Line":0}},{"line":56,"address":[1201809],"length":1,"stats":{"Line":0}},{"line":58,"address":[1202604,1201985,1199681,1202305,1201891],"length":1,"stats":{"Line":0}},{"line":59,"address":[1202646],"length":1,"stats":{"Line":0}},{"line":60,"address":[1202682,1202843],"length":1,"stats":{"Line":0}},{"line":63,"address":[1202865],"length":1,"stats":{"Line":0}},{"line":64,"address":[1202937],"length":1,"stats":{"Line":0}},{"line":65,"address":[1203125,1202988,1203220],"length":1,"stats":{"Line":0}},{"line":67,"address":[1203273],"length":1,"stats":{"Line":0}},{"line":68,"address":[1203334],"length":1,"stats":{"Line":0}},{"line":70,"address":[4728843],"length":1,"stats":{"Line":0}},{"line":72,"address":[1204527,1204620],"length":1,"stats":{"Line":0}},{"line":76,"address":[1203070,1202907],"length":1,"stats":{"Line":0}},{"line":80,"address":[1203721,1202732],"length":1,"stats":{"Line":0}},{"line":82,"address":[1203742,1203865],"length":1,"stats":{"Line":0}},{"line":85,"address":[1203913],"length":1,"stats":{"Line":0}},{"line":94,"address":[1206650],"length":1,"stats":{"Line":0}},{"line":95,"address":[1206881,1205824,1199839,1205730,1205784],"length":1,"stats":{"Line":0}},{"line":96,"address":[1205738],"length":1,"stats":{"Line":0}},{"line":97,"address":[1205816],"length":1,"stats":{"Line":0}},{"line":99,"address":[1206049,1206103,1206845,1206876,1206141,1206425],"length":1,"stats":{"Line":0}},{"line":100,"address":[1206121,1206178,1206840],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","alter_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::alter_table::{AlterColumnAction, AlterTableAction, AlterTableQuery};\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn alter_table(\u0026self, query: AlterTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = query.table.clone().unwrap();\n\n        let database_name = database_name.unwrap();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        match query.action {\n            AlterTableAction::AlterTableRenameTo(action) =\u003e {\n                let change_name = action.name;\n                let change_path = database_path.clone().join(\u0026change_name);\n\n                // table 디렉터리명 변경\n                if let Err(error) = tokio::fs::rename(\u0026table_path, \u0026change_path).await {\n                    return Err(ExecuteError::wrap(format!(\n                        \"table rename failed: {}\",\n                        error\n                    )));\n                }\n\n                // config data 파일 내용 변경\n                let config_path = change_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                table_config.table.table_name = change_name;\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::AddColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let column_to_add = action.column;\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if table_config.columns.contains(\u0026column_to_add) {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' already exists \",\n                        column_to_add.name\n                    )));\n                }\n\n                table_config.columns.push(column_to_add);\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::AlterColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                let column_name = action.column_name;\n\n                match action.action {\n                    AlterColumnAction::AlterColumnSetDefault(action) =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                        let target = table_config\n                            .columns\n                            .iter_mut()\n                            .find(|e| e.name == column_name);\n\n                        match target {\n                            Some(target) =\u003e {\n                                target.default = Some(action.expression);\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists \",\n                                    column_name\n                                )));\n                            }\n                        }\n\n                        if let Err(error) =\n                            tokio::fs::write(config_path, encoder.encode(table_config)).await\n                        {\n                            return Err(ExecuteError::wrap(error.to_string()));\n                        }\n                    }\n                    AlterColumnAction::AlterColumnDropDefault(_) =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.default = None;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnSetNotNull =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.not_null = true;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnDropNotNull =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.not_null = false;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnSetType(action) =\u003e {\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.data_type = action.data_type;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                }\n            }\n            AlterTableAction::DropColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if !table_config\n                    .columns\n                    .iter()\n                    .any(|e| e.name == action.column_name)\n                {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' not exists \",\n                        action.column_name\n                    )));\n                }\n\n                table_config\n                    .columns\n                    .retain(|e| e.name != action.column_name);\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::RenameColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if table_config\n                    .columns\n                    .iter()\n                    .any(|e| e.name == action.to_name)\n                {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' already exists \",\n                        action.to_name\n                    )));\n                }\n\n                let target = table_config\n                    .columns\n                    .iter_mut()\n                    .find(|e| e.name == action.from_name);\n\n                match target {\n                    Some(target) =\u003e {\n                        target.name = action.to_name;\n                    }\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(format!(\n                            \"column '{}' not exists \",\n                            action.from_name\n                        )));\n                    }\n                }\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(\"alter table\".into())],\n            }]),\n        })\n    }\n}\n","traces":[{"line":14,"address":[4336147,4336090,4335968,4339484,4343750,4336689,4368310],"length":1,"stats":{"Line":0}},{"line":15,"address":[4336679],"length":1,"stats":{"Line":0}},{"line":17,"address":[4337158],"length":1,"stats":{"Line":0}},{"line":19,"address":[4337187],"length":1,"stats":{"Line":0}},{"line":20,"address":[4337341],"length":1,"stats":{"Line":0}},{"line":21,"address":[4337404],"length":1,"stats":{"Line":0}},{"line":24,"address":[4337457],"length":1,"stats":{"Line":0}},{"line":26,"address":[4337685,4337771],"length":1,"stats":{"Line":0}},{"line":27,"address":[4337953],"length":1,"stats":{"Line":0}},{"line":29,"address":[4338355,4336137],"length":1,"stats":{"Line":0}},{"line":30,"address":[4338422],"length":1,"stats":{"Line":0}},{"line":31,"address":[4338475],"length":1,"stats":{"Line":0}},{"line":32,"address":[4339171,4338528],"length":1,"stats":{"Line":0}},{"line":35,"address":[4343782,4336719,4339353],"length":1,"stats":{"Line":0}},{"line":36,"address":[4344210],"length":1,"stats":{"Line":0}},{"line":43,"address":[4344434],"length":1,"stats":{"Line":0}},{"line":45,"address":[4336740,4345380,4344660,4344930,4344835],"length":1,"stats":{"Line":0}},{"line":47,"address":[4345578,4345493,4345298],"length":1,"stats":{"Line":0}},{"line":48,"address":[4345616,4345982,4336761,4345914,4345992,4346206],"length":1,"stats":{"Line":0}},{"line":51,"address":[4346655,4346539],"length":1,"stats":{"Line":0}},{"line":54,"address":[4338561],"length":1,"stats":{"Line":0}},{"line":58,"address":[4338630,4339549],"length":1,"stats":{"Line":0}},{"line":60,"address":[4339734],"length":1,"stats":{"Line":0}},{"line":62,"address":[4340029,4347062,4336782,4339804,4347471,4348500],"length":1,"stats":{"Line":0}},{"line":64,"address":[4347647,4347430],"length":1,"stats":{"Line":0}},{"line":65,"address":[4347790,4348280],"length":1,"stats":{"Line":0}},{"line":71,"address":[4347689],"length":1,"stats":{"Line":0}},{"line":73,"address":[4348261,4348627,4347891,4336803,4348183,4348251],"length":1,"stats":{"Line":0}},{"line":76,"address":[4349059,4348935],"length":1,"stats":{"Line":0}},{"line":79,"address":[4338663],"length":1,"stats":{"Line":0}},{"line":82,"address":[4338778],"length":1,"stats":{"Line":0}},{"line":84,"address":[4338814],"length":1,"stats":{"Line":0}},{"line":85,"address":[4340262],"length":1,"stats":{"Line":0}},{"line":87,"address":[4341823,4340363],"length":1,"stats":{"Line":0}},{"line":89,"address":[4342183,4336824,4342008,4349289,4349698,4351027],"length":1,"stats":{"Line":0}},{"line":91,"address":[4349874,4349657,4349952],"length":1,"stats":{"Line":0}},{"line":94,"address":[4349929,4370640,4370657],"length":1,"stats":{"Line":0}},{"line":96,"address":[4349983],"length":1,"stats":{"Line":0}},{"line":97,"address":[4350109],"length":1,"stats":{"Line":0}},{"line":98,"address":[4350133,4350560,4350617],"length":1,"stats":{"Line":0}},{"line":101,"address":[4350325,4350012],"length":1,"stats":{"Line":0}},{"line":108,"address":[4351279],"length":1,"stats":{"Line":0}},{"line":111,"address":[4351324,4351433],"length":1,"stats":{"Line":0}},{"line":116,"address":[4340396,4342331],"length":1,"stats":{"Line":0}},{"line":118,"address":[4342531,4351721,4336866,4342625,4352023],"length":1,"stats":{"Line":0}},{"line":119,"address":[4352065],"length":1,"stats":{"Line":0}},{"line":120,"address":[4352283,4352101],"length":1,"stats":{"Line":0}},{"line":123,"address":[4352305],"length":1,"stats":{"Line":0}},{"line":124,"address":[4352374],"length":1,"stats":{"Line":0}},{"line":125,"address":[4352428,4352585,4352663],"length":1,"stats":{"Line":0}},{"line":128,"address":[4370705,4352640,4370688],"length":1,"stats":{"Line":0}},{"line":130,"address":[4352694],"length":1,"stats":{"Line":0}},{"line":131,"address":[4352817],"length":1,"stats":{"Line":0}},{"line":132,"address":[4352851,4353029,4353086],"length":1,"stats":{"Line":0}},{"line":135,"address":[4352723,4352873],"length":1,"stats":{"Line":0}},{"line":143,"address":[4353149],"length":1,"stats":{"Line":0}},{"line":144,"address":[4353210],"length":1,"stats":{"Line":0}},{"line":146,"address":[4353423,4336887,4353463,4353994,4354147],"length":1,"stats":{"Line":0}},{"line":148,"address":[4354369,4354260],"length":1,"stats":{"Line":0}},{"line":152,"address":[4352466,4352347],"length":1,"stats":{"Line":0}},{"line":156,"address":[4352160,4353581],"length":1,"stats":{"Line":0}},{"line":158,"address":[4353725,4353602],"length":1,"stats":{"Line":0}},{"line":161,"address":[4353773],"length":1,"stats":{"Line":0}},{"line":168,"address":[4340196,4340939],"length":1,"stats":{"Line":0}},{"line":170,"address":[4354765,4341233,4341139,4336908,4355067],"length":1,"stats":{"Line":0}},{"line":171,"address":[4355109],"length":1,"stats":{"Line":0}},{"line":172,"address":[4355145,4355327],"length":1,"stats":{"Line":0}},{"line":175,"address":[4355349],"length":1,"stats":{"Line":0}},{"line":176,"address":[4355418],"length":1,"stats":{"Line":0}},{"line":177,"address":[4355472,4355707,4355629],"length":1,"stats":{"Line":0}},{"line":180,"address":[4355684,4370736,4370753],"length":1,"stats":{"Line":0}},{"line":182,"address":[4355738],"length":1,"stats":{"Line":0}},{"line":183,"address":[4355864],"length":1,"stats":{"Line":0}},{"line":184,"address":[4355880],"length":1,"stats":{"Line":0}},{"line":187,"address":[4355767,4356060],"length":1,"stats":{"Line":0}},{"line":195,"address":[4355887],"length":1,"stats":{"Line":0}},{"line":196,"address":[4355948],"length":1,"stats":{"Line":0}},{"line":198,"address":[4336929,4356883,4357036,4356312,4356352],"length":1,"stats":{"Line":0}},{"line":200,"address":[4357149,4357258],"length":1,"stats":{"Line":0}},{"line":204,"address":[4355510,4355391],"length":1,"stats":{"Line":0}},{"line":208,"address":[4356470,4355204],"length":1,"stats":{"Line":0}},{"line":210,"address":[4356491,4356614],"length":1,"stats":{"Line":0}},{"line":213,"address":[4356662],"length":1,"stats":{"Line":0}},{"line":220,"address":[4341378,4340229],"length":1,"stats":{"Line":0}},{"line":222,"address":[4341578,4357956,4336950,4357654,4341672],"length":1,"stats":{"Line":0}},{"line":223,"address":[4357998],"length":1,"stats":{"Line":0}},{"line":224,"address":[4358216,4358034],"length":1,"stats":{"Line":0}},{"line":227,"address":[4358238],"length":1,"stats":{"Line":0}},{"line":228,"address":[4358307],"length":1,"stats":{"Line":0}},{"line":229,"address":[4358596,4358361,4358518],"length":1,"stats":{"Line":0}},{"line":232,"address":[4358573,4370784,4370801],"length":1,"stats":{"Line":0}},{"line":234,"address":[4358627],"length":1,"stats":{"Line":0}},{"line":235,"address":[4358753],"length":1,"stats":{"Line":0}},{"line":236,"address":[4358769],"length":1,"stats":{"Line":0}},{"line":239,"address":[4358656,4358949],"length":1,"stats":{"Line":0}},{"line":247,"address":[4358776],"length":1,"stats":{"Line":0}},{"line":248,"address":[4358837],"length":1,"stats":{"Line":0}},{"line":250,"address":[4336971,4359241,4359772,4359201,4359925],"length":1,"stats":{"Line":0}},{"line":252,"address":[4360038,4360147],"length":1,"stats":{"Line":0}},{"line":256,"address":[4358399,4358280],"length":1,"stats":{"Line":0}},{"line":260,"address":[4359359,4358093],"length":1,"stats":{"Line":0}},{"line":262,"address":[4359503,4359380],"length":1,"stats":{"Line":0}},{"line":265,"address":[4359551],"length":1,"stats":{"Line":0}},{"line":270,"address":[4340127],"length":1,"stats":{"Line":0}},{"line":271,"address":[4340163,4340479],"length":1,"stats":{"Line":0}},{"line":273,"address":[4336992,4360845,4360543,4340773,4340679],"length":1,"stats":{"Line":0}},{"line":274,"address":[4360887],"length":1,"stats":{"Line":0}},{"line":275,"address":[4361105,4360923],"length":1,"stats":{"Line":0}},{"line":278,"address":[4361127],"length":1,"stats":{"Line":0}},{"line":279,"address":[4361196],"length":1,"stats":{"Line":0}},{"line":280,"address":[4361250,4361485,4361407],"length":1,"stats":{"Line":0}},{"line":283,"address":[4370849,4370832,4361462],"length":1,"stats":{"Line":0}},{"line":285,"address":[4361516],"length":1,"stats":{"Line":0}},{"line":286,"address":[4361642],"length":1,"stats":{"Line":0}},{"line":287,"address":[4361658],"length":1,"stats":{"Line":0}},{"line":290,"address":[4361545,4361860],"length":1,"stats":{"Line":0}},{"line":298,"address":[4361687],"length":1,"stats":{"Line":0}},{"line":299,"address":[4361748],"length":1,"stats":{"Line":0}},{"line":301,"address":[4362836,4362112,4337013,4362152,4362683],"length":1,"stats":{"Line":0}},{"line":303,"address":[4363058,4362949],"length":1,"stats":{"Line":0}},{"line":307,"address":[4361288,4361169],"length":1,"stats":{"Line":0}},{"line":311,"address":[4360982,4362270],"length":1,"stats":{"Line":0}},{"line":313,"address":[4362291,4362414],"length":1,"stats":{"Line":0}},{"line":316,"address":[4362462],"length":1,"stats":{"Line":0}},{"line":323,"address":[4338890],"length":1,"stats":{"Line":0}},{"line":327,"address":[4342775,4338941],"length":1,"stats":{"Line":0}},{"line":329,"address":[4342960,4363863,4363454,4364847,4337034,4343135],"length":1,"stats":{"Line":0}},{"line":331,"address":[4363822,4364039,4364117],"length":1,"stats":{"Line":0}},{"line":334,"address":[4370880,4370905,4364094],"length":1,"stats":{"Line":0}},{"line":336,"address":[4364144,4364273],"length":1,"stats":{"Line":0}},{"line":342,"address":[4364263,4364238],"length":1,"stats":{"Line":0}},{"line":344,"address":[4370953,4364256,4370928],"length":1,"stats":{"Line":0}},{"line":346,"address":[4365098],"length":1,"stats":{"Line":0}},{"line":349,"address":[4365143,4365252],"length":1,"stats":{"Line":0}},{"line":352,"address":[4338974],"length":1,"stats":{"Line":0}},{"line":356,"address":[4339054,4343292],"length":1,"stats":{"Line":0}},{"line":358,"address":[4365386,4365795,4367269,4343652,4337076,4343477],"length":1,"stats":{"Line":0}},{"line":360,"address":[4365971,4365754,4366049],"length":1,"stats":{"Line":0}},{"line":363,"address":[4371001,4366026,4370976],"length":1,"stats":{"Line":0}},{"line":365,"address":[4366114,4367116],"length":1,"stats":{"Line":0}},{"line":371,"address":[4366297,4366076,4366231],"length":1,"stats":{"Line":0}},{"line":374,"address":[4366274,4371024,4371041],"length":1,"stats":{"Line":0}},{"line":376,"address":[4366322],"length":1,"stats":{"Line":0}},{"line":377,"address":[4366445],"length":1,"stats":{"Line":0}},{"line":378,"address":[4366757,4366466,4366689],"length":1,"stats":{"Line":0}},{"line":381,"address":[4366351,4366537],"length":1,"stats":{"Line":0}},{"line":388,"address":[4367097,4367300,4367084,4366781,4337097],"length":1,"stats":{"Line":0}},{"line":391,"address":[4367551,4367660],"length":1,"stats":{"Line":0}},{"line":397,"address":[4369426],"length":1,"stats":{"Line":0}},{"line":398,"address":[4370083,4368597,4339097,4368503,4368557],"length":1,"stats":{"Line":0}},{"line":399,"address":[4368511],"length":1,"stats":{"Line":0}},{"line":400,"address":[4368589],"length":1,"stats":{"Line":0}},{"line":402,"address":[4370078,4370044,4368917,4368879,4369201,4368825],"length":1,"stats":{"Line":0}},{"line":403,"address":[4370039,4368954,4368897],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":154},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","create_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn create_database(\n        \u0026self,\n        query: CreateDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let database_name = query\n            .database_name\n            .clone()\n            .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        if let Err(error) = tokio::fs::create_dir(database_path.clone()).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e {\n                    if query.if_not_exists {\n                        return Ok(ExecuteResult {\n                            columns: (vec![ExecuteColumn {\n                                name: \"desc\".into(),\n                                data_type: ExecuteColumnType::String,\n                            }]),\n                            rows: (vec![ExecuteRow {\n                                fields: vec![ExecuteField::String(\n                                    \"database already exists\".into(),\n                                )],\n                            }]),\n                        });\n                    } else {\n                        return Err(ExecuteError::wrap(\"already exists database\"));\n                    }\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"database create failed\"));\n                }\n            }\n        }\n\n        // tables 경로 추가\n        let tables_path = database_path.clone().join(\"tables\");\n\n        if let Err(error) = tokio::fs::create_dir(\u0026tables_path).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e {\n                    return Err(ExecuteError::wrap(\"already exists tables\"))\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"tables create failed\"));\n                }\n            }\n        }\n\n        // 각 데이터베이스 단위 설정파일 생성\n        let config_path = database_path.clone().join(\"database.config\");\n        let database_info = DatabaseConfig {\n            database_name: database_name.clone(),\n        };\n\n        if let Err(error) = tokio::fs::write(config_path, encoder.encode(database_info)).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database created: {}\",\n                    database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5580176],"length":1,"stats":{"Line":0}},{"line":16,"address":[3109306],"length":1,"stats":{"Line":0}},{"line":18,"address":[3109453],"length":1,"stats":{"Line":0}},{"line":20,"address":[3109214,3109794,3110203,3109472,3109564],"length":1,"stats":{"Line":0}},{"line":23,"address":[3109714,3115488,3115500],"length":1,"stats":{"Line":0}},{"line":25,"address":[3109684,3109883],"length":1,"stats":{"Line":0}},{"line":27,"address":[4732324],"length":1,"stats":{"Line":0}},{"line":28,"address":[3110537,3110624],"length":1,"stats":{"Line":0}},{"line":30,"address":[3110645],"length":1,"stats":{"Line":0}},{"line":31,"address":[3111713],"length":1,"stats":{"Line":0}},{"line":32,"address":[3110728,3111871,3110799,3110853,3110893],"length":1,"stats":{"Line":0}},{"line":33,"address":[3110807],"length":1,"stats":{"Line":0}},{"line":34,"address":[3110885],"length":1,"stats":{"Line":0}},{"line":36,"address":[3111861,3111479,3111183,3111142,3111079],"length":1,"stats":{"Line":0}},{"line":37,"address":[3111160,3111223,3111277,3111856],"length":1,"stats":{"Line":0}},{"line":38,"address":[3111231],"length":1,"stats":{"Line":0}},{"line":43,"address":[3110691,3110743],"length":1,"stats":{"Line":0}},{"line":47,"address":[3111876,3110661],"length":1,"stats":{"Line":0}},{"line":53,"address":[3111933],"length":1,"stats":{"Line":0}},{"line":55,"address":[4732343],"length":1,"stats":{"Line":0}},{"line":56,"address":[3112524,3112605],"length":1,"stats":{"Line":0}},{"line":58,"address":[3112626,3112680],"length":1,"stats":{"Line":0}},{"line":61,"address":[3112725,3112653],"length":1,"stats":{"Line":0}},{"line":67,"address":[3112859,3112782],"length":1,"stats":{"Line":0}},{"line":69,"address":[3113037],"length":1,"stats":{"Line":0}},{"line":72,"address":[3113379,3113100,3109388,3113366],"length":1,"stats":{"Line":0}},{"line":73,"address":[3113649,3113758],"length":1,"stats":{"Line":0}},{"line":76,"address":[3115045],"length":1,"stats":{"Line":0}},{"line":77,"address":[3114046,3115449,3114157,3114117],"length":1,"stats":{"Line":0}},{"line":78,"address":[3114071],"length":1,"stats":{"Line":0}},{"line":79,"address":[3114149],"length":1,"stats":{"Line":0}},{"line":81,"address":[3114895,3114492,3114454,3114400,3115444],"length":1,"stats":{"Line":0}},{"line":82,"address":[3114637,3114472,3115439,3114529],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","create_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn create_table(\u0026self, query: CreateTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = query.table.clone().unwrap().database_name.unwrap();\n        let table_name = query.table.clone().unwrap().table_name;\n\n        let base_path = self.get_data_directory();\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        if let Err(error) = tokio::fs::create_dir(\u0026table_path).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e return Err(ExecuteError::wrap(\"already exists table\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"table create failed\"));\n                }\n            }\n        }\n\n        // 각 데이터베이스 단위 설정파일 생성\n        let config_path = table_path.clone().join(\"table.config\");\n        let table_info: TableConfig = query.into();\n\n        if let Err(error) = tokio::fs::write(\u0026config_path, encoder.encode(table_info)).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        let rows_path = table_path.clone().join(\"rows\");\n\n        // 데이터 경로 생성\n        if let Err(error) = tokio::fs::create_dir(\u0026rows_path).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        let index_path = table_path.clone().join(\"index\");\n\n        // 인덱스 경로 생성\n        if let Err(error) = tokio::fs::create_dir(\u0026index_path).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        // TODO: primary key 데이터 생성\n        // TODO: unique key 데이터 생성\n        // TODO: foreign key 데이터 생성\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"table created: {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5580240,5580275],"length":1,"stats":{"Line":0}},{"line":13,"address":[1961277],"length":1,"stats":{"Line":0}},{"line":15,"address":[1961706,1961441,1961544],"length":1,"stats":{"Line":0}},{"line":16,"address":[1961923,1961820],"length":1,"stats":{"Line":0}},{"line":18,"address":[1962039],"length":1,"stats":{"Line":0}},{"line":19,"address":[1962061,1962150],"length":1,"stats":{"Line":0}},{"line":21,"address":[1962332],"length":1,"stats":{"Line":0}},{"line":23,"address":[4725665],"length":1,"stats":{"Line":0}},{"line":24,"address":[1963167,1963254],"length":1,"stats":{"Line":0}},{"line":25,"address":[1963329,1963275],"length":1,"stats":{"Line":0}},{"line":27,"address":[1963374,1963302],"length":1,"stats":{"Line":0}},{"line":33,"address":[1963431],"length":1,"stats":{"Line":0}},{"line":34,"address":[1963657],"length":1,"stats":{"Line":0}},{"line":36,"address":[1963921,1963747,1961338],"length":1,"stats":{"Line":0}},{"line":37,"address":[1964187,1964296],"length":1,"stats":{"Line":0}},{"line":40,"address":[1964431],"length":1,"stats":{"Line":0}},{"line":43,"address":[1961359,1964766,1964651],"length":1,"stats":{"Line":0}},{"line":44,"address":[1965017,1965126],"length":1,"stats":{"Line":0}},{"line":47,"address":[1965261],"length":1,"stats":{"Line":0}},{"line":50,"address":[1965590,1961380,1965475],"length":1,"stats":{"Line":0}},{"line":51,"address":[1965950,1965841],"length":1,"stats":{"Line":0}},{"line":58,"address":[1967366],"length":1,"stats":{"Line":0}},{"line":59,"address":[1966448,1966377,1966488,1968067],"length":1,"stats":{"Line":0}},{"line":60,"address":[1966402],"length":1,"stats":{"Line":0}},{"line":61,"address":[1966480],"length":1,"stats":{"Line":0}},{"line":63,"address":[1966808,1966770,1967213,1968062,1966716],"length":1,"stats":{"Line":0}},{"line":64,"address":[1968057,1966955,1966845,1966788],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","drop_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::drop_database::DropDatabaseQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn drop_database(\n        \u0026self,\n        query: DropDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let base_path = self.get_data_directory();\n        let mut database_path = base_path.clone();\n\n        let database_name = query\n            .database_name\n            .clone()\n            .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n        database_path.push(\u0026database_name);\n\n        if let Err(error) = tokio::fs::remove_dir_all(database_path.clone()).await {\n            match error.kind() {\n                ErrorKind::NotFound =\u003e return Err(ExecuteError::wrap(\"database not found\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"database drop failed\"));\n                }\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database dropped: {}\",\n                    database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":10,"address":[5580320],"length":1,"stats":{"Line":0}},{"line":14,"address":[5642589],"length":1,"stats":{"Line":0}},{"line":15,"address":[5642686],"length":1,"stats":{"Line":0}},{"line":17,"address":[5643054,5642537,5642837,5643258,5642751],"length":1,"stats":{"Line":0}},{"line":20,"address":[5645248,5642977,5645260],"length":1,"stats":{"Line":0}},{"line":22,"address":[5642951],"length":1,"stats":{"Line":0}},{"line":24,"address":[4727590],"length":1,"stats":{"Line":0}},{"line":25,"address":[5643559,5643640],"length":1,"stats":{"Line":0}},{"line":26,"address":[5643715,5643661],"length":1,"stats":{"Line":0}},{"line":28,"address":[5643688,5643760],"length":1,"stats":{"Line":0}},{"line":33,"address":[5644936],"length":1,"stats":{"Line":0}},{"line":34,"address":[5645236,5644032,5644072,5643961],"length":1,"stats":{"Line":0}},{"line":35,"address":[5643986],"length":1,"stats":{"Line":0}},{"line":36,"address":[5644064],"length":1,"stats":{"Line":0}},{"line":38,"address":[5644348,5644294,5644386,5644786,5645231],"length":1,"stats":{"Line":0}},{"line":39,"address":[5644423,5645226,5644366,5644528],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","drop_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn drop_table(\u0026self, query: DropTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = query.table.unwrap();\n\n        let table_path = base_path\n            .clone()\n            .join(database_name.unwrap())\n            .join(\"tables\")\n            .join(\u0026table_name);\n\n        if let Err(error) = tokio::fs::remove_dir_all(table_path).await {\n            match error.kind() {\n                ErrorKind::NotFound =\u003e return Err(ExecuteError::wrap(\"table not found\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"table drop failed\"));\n                }\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"table dropped: {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":11,"address":[1911858,1915238,1913122,1911647,1911704,1911600],"length":1,"stats":{"Line":0}},{"line":12,"address":[1911839],"length":1,"stats":{"Line":0}},{"line":14,"address":[1911949],"length":1,"stats":{"Line":0}},{"line":15,"address":[1912117],"length":1,"stats":{"Line":0}},{"line":16,"address":[1912164],"length":1,"stats":{"Line":0}},{"line":19,"address":[1912202,1912758,1912631,1912545,1912303],"length":1,"stats":{"Line":0}},{"line":21,"address":[1912361],"length":1,"stats":{"Line":0}},{"line":23,"address":[1912320,1912577,1912765,1912684],"length":1,"stats":{"Line":0}},{"line":25,"address":[1911888,1911694,1912967,1913163],"length":1,"stats":{"Line":0}},{"line":26,"address":[1913422,1913503],"length":1,"stats":{"Line":0}},{"line":27,"address":[1913578,1913524],"length":1,"stats":{"Line":0}},{"line":29,"address":[1913551,1913623],"length":1,"stats":{"Line":0}},{"line":34,"address":[1914861],"length":1,"stats":{"Line":0}},{"line":35,"address":[1913931,1913971,1913860,1915157],"length":1,"stats":{"Line":0}},{"line":36,"address":[1913885],"length":1,"stats":{"Line":0}},{"line":37,"address":[1913963],"length":1,"stats":{"Line":0}},{"line":39,"address":[1914214,1915152,1914306,1914711,1914268],"length":1,"stats":{"Line":0}},{"line":40,"address":[1914453,1915147,1914286,1914343],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","mod.rs"],"content":"pub mod alter_database;\npub mod alter_table;\npub mod create_database;\npub mod create_table;\npub mod drop_database;\npub mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","delete.rs"],"content":"use std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::delete::DeleteQuery;\nuse crate::ast::dml::plan::delete::delete_plan::DeletePlanItem;\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataFieldType;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::executor::result::ExecuteColumnType;\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn delete(\u0026self, query: DeleteQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let table = query.from_table.as_ref().unwrap().table.clone();\n\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let plan = optimizer.optimize_delete(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        for each_plan in plan.list {\n            match each_plan {\n                // From 처리\n                DeletePlanItem::DeleteFrom(from) =\u003e {\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias, table_name.clone());\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result =\n                                self.full_scan(table_name).await?.into_iter().collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                // 필터링 처리\n                DeletePlanItem::Filter(filter) =\u003e {\n                    let total_count = rows.len();\n                    let futures = rows.iter().cloned().map(|(path, row)| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(row.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((path, row, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((path, row, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, _, boolean)| *boolean)\n                        .map(|(path, row, _)| (path, row))\n                        .collect();\n                }\n            }\n        }\n\n        // 삭제 작업\n        for (path, _) in rows.into_iter() {\n            if let Err(error) = tokio::fs::remove_file(\u0026path).await {\n                return Err(ExecuteError::wrap(format!(\n                    \"file {:?} remove failed: {}\",\n                    path, error\n                )));\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"deleted from {:?}\",\n                    table.table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":19,"address":[1661600,1662529,1661719,1661662,1661950,1663564,1671934],"length":1,"stats":{"Line":0}},{"line":20,"address":[1662214,1661917],"length":1,"stats":{"Line":0}},{"line":23,"address":[1662236],"length":1,"stats":{"Line":0}},{"line":25,"address":[1661980,1662972,1663522,1662457,1661709,1662290,1662561],"length":1,"stats":{"Line":0}},{"line":27,"address":[1662947],"length":1,"stats":{"Line":0}},{"line":28,"address":[1663133],"length":1,"stats":{"Line":0}},{"line":30,"address":[1663199],"length":1,"stats":{"Line":0}},{"line":32,"address":[1663419,1664697,1663280,1664633],"length":1,"stats":{"Line":0}},{"line":33,"address":[1664737],"length":1,"stats":{"Line":0}},{"line":35,"address":[1664990],"length":1,"stats":{"Line":0}},{"line":36,"address":[1665059,1665292],"length":1,"stats":{"Line":0}},{"line":38,"address":[1662001,1663573,1665307,1665439,1665992,1667845],"length":1,"stats":{"Line":0}},{"line":40,"address":[1665915],"length":1,"stats":{"Line":0}},{"line":42,"address":[1666153],"length":1,"stats":{"Line":0}},{"line":43,"address":[1666252,1666515,1666395],"length":1,"stats":{"Line":0}},{"line":46,"address":[1666344],"length":1,"stats":{"Line":0}},{"line":48,"address":[1662022,1666782,1666534,1667749,1663608],"length":1,"stats":{"Line":0}},{"line":51,"address":[1667319],"length":1,"stats":{"Line":0}},{"line":53,"address":[1666635],"length":1,"stats":{"Line":0}},{"line":59,"address":[1665094],"length":1,"stats":{"Line":0}},{"line":60,"address":[1665180,1668639],"length":1,"stats":{"Line":0}},{"line":61,"address":[1672014,1672460,1672493,1671984,1668642],"length":1,"stats":{"Line":0}},{"line":62,"address":[1672089,1672150],"length":1,"stats":{"Line":0}},{"line":63,"address":[1672158],"length":1,"stats":{"Line":0}},{"line":64,"address":[1672563,1673422,1672608,1674810,1672225,1672720,1673395,1672528],"length":1,"stats":{"Line":0}},{"line":65,"address":[1672975,1672616],"length":1,"stats":{"Line":0}},{"line":66,"address":[1672817,1672700],"length":1,"stats":{"Line":0}},{"line":67,"address":[1672849],"length":1,"stats":{"Line":0}},{"line":68,"address":[1672916],"length":1,"stats":{"Line":0}},{"line":69,"address":[1672963],"length":1,"stats":{"Line":0}},{"line":72,"address":[1673339,1673309,1673921,1673087,1673552,1673704],"length":1,"stats":{"Line":0}},{"line":73,"address":[1673173,1673104],"length":1,"stats":{"Line":0}},{"line":74,"address":[1673332,1672601,1672747,1673454,1673632,1673369,1673841],"length":1,"stats":{"Line":0}},{"line":76,"address":[1673801],"length":1,"stats":{"Line":0}},{"line":77,"address":[1673984],"length":1,"stats":{"Line":0}},{"line":78,"address":[1674260],"length":1,"stats":{"Line":0}},{"line":79,"address":[1674566,1673954],"length":1,"stats":{"Line":0}},{"line":86,"address":[1663788,1664240,1663939,1668853,1668883],"length":1,"stats":{"Line":0}},{"line":87,"address":[1663820,1668876,1663643,1662043,1663675,1668916],"length":1,"stats":{"Line":0}},{"line":91,"address":[1664330,1664094,1664500],"length":1,"stats":{"Line":0}},{"line":93,"address":[1675162,1675152],"length":1,"stats":{"Line":0}},{"line":94,"address":[1675192,1675184],"length":1,"stats":{"Line":0}},{"line":95,"address":[1664473],"length":1,"stats":{"Line":0}},{"line":101,"address":[1670279,1664788,1670343],"length":1,"stats":{"Line":0}},{"line":102,"address":[1670379,1669027,1662064,1668998,1669284,1671799],"length":1,"stats":{"Line":0}},{"line":103,"address":[1669583,1669329],"length":1,"stats":{"Line":0}},{"line":110,"address":[1671422],"length":1,"stats":{"Line":0}},{"line":111,"address":[1670533,1670422,1670493,1671778],"length":1,"stats":{"Line":0}},{"line":112,"address":[1670447],"length":1,"stats":{"Line":0}},{"line":113,"address":[1670525],"length":1,"stats":{"Line":0}},{"line":115,"address":[1670772,1671773,1670826,1670864,1671269],"length":1,"stats":{"Line":0}},{"line":116,"address":[1670901,1671011,1671768,1670844],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","insert.rs"],"content":"use std::collections::HashSet;\nuse std::io::ErrorKind;\n\nuse crate::ast::dml::insert::{InsertData, InsertQuery};\nuse crate::ast::types::SQLExpression;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::{TableDataField, TableDataRow};\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn insert(\u0026self, query: InsertQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let into_table = query.into_table.as_ref().unwrap();\n\n        let database_name = into_table.clone().database_name.unwrap();\n        let table_name = into_table.clone().table_name;\n\n        let base_path = self.get_data_directory();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // 데이터 행 파일 경로\n        let rows_path = table_path.clone().join(\"rows\");\n\n        // 설정파일 경로\n        let config_path = table_path.join(\"table.config\");\n\n        let table_config = match tokio::fs::read(\u0026config_path).await {\n            Ok(data) =\u003e {\n                let table_config: Option\u003cTableConfig\u003e = encoder.decode(data.as_slice());\n\n                match table_config {\n                    Some(table_config) =\u003e table_config,\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                    }\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e {\n                    return Err(ExecuteError::wrap(\"table not found\"));\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                }\n            },\n        };\n\n        // 입력된 컬럼\n        let input_columns_set: HashSet\u003cString\u003e = HashSet::from_iter(query.columns.iter().cloned());\n\n        // 필수 컬럼\n        let required_columns = table_config.get_required_columns();\n\n        // 테이블 컬럼 맵\n        let columns_map = table_config.get_columns_map();\n\n        // 필수 입력 컬럼값 검증\n        for required_column in required_columns {\n            if !input_columns_set.contains(\u0026required_column.name) {\n                return Err(ExecuteError::wrap(format!(\n                    \"column '{}' is required, but it was not provided\",\n                    \u0026required_column.name\n                )));\n            }\n        }\n\n        let remain_columns = table_config\n            .columns\n            .iter()\n            .filter(|e| !query.columns.contains(\u0026(*e).clone().name))\n            .map(|e| \u0026e.name);\n\n        match \u0026query.data {\n            InsertData::Values(values) =\u003e {\n                let mut rows = vec![];\n\n                for value in values {\n                    let mut fields = vec![];\n\n                    // 명시적으로 전달된 컬럼값 리스트 처리\n                    for (i, column_name) in query.columns.iter().enumerate() {\n                        let column_config_info = columns_map.get(column_name).unwrap();\n\n                        let default_value = match \u0026column_config_info.default {\n                            Some(default) =\u003e default.to_owned(),\n                            None =\u003e SQLExpression::Null,\n                        };\n\n                        let value = value.list[i].clone().unwrap_or(default_value);\n\n                        let data = self.reduce_expression(value, Default::default()).await?;\n\n                        match columns_map.get(column_name) {\n                            Some(column) =\u003e {\n                                if column.not_null \u0026\u0026 data.type_code() == 0 {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' is not null column\n                                        \",\n                                        column_name\n                                    )));\n                                }\n\n                                if column.data_type.type_code() != data.type_code()\n                                    \u0026\u0026 data.type_code() != 0\n                                {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' type mismatch\n                                        \",\n                                        column_name\n                                    )));\n                                }\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists\",\n                                    column_name\n                                )))\n                            }\n                        }\n\n                        let column_name = column_name.to_owned();\n\n                        fields.push(TableDataField {\n                            column_name,\n                            data,\n                            table_name: into_table.clone(),\n                        });\n                    }\n\n                    // 명시되지 않은 컬럼 리스트 처리\n                    for column_name in remain_columns.clone() {\n                        let column_config_info = columns_map.get(column_name).unwrap();\n\n                        let default_value = match \u0026column_config_info.default {\n                            Some(default) =\u003e default.to_owned(),\n                            None =\u003e {\n                                if column_config_info.not_null {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' is not null column\n                                        \",\n                                        column_name\n                                    )));\n                                }\n\n                                SQLExpression::Null\n                            }\n                        };\n\n                        let data = self\n                            .reduce_expression(default_value, Default::default())\n                            .await?;\n\n                        match columns_map.get(column_name) {\n                            Some(column) =\u003e {\n                                if column.data_type.type_code() != data.type_code()\n                                    \u0026\u0026 data.type_code() != 0\n                                {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' type mismatch\n                                        \",\n                                        column_name\n                                    )));\n                                }\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists\",\n                                    column_name\n                                )))\n                            }\n                        }\n\n                        let column_name = column_name.to_owned();\n\n                        fields.push(TableDataField {\n                            column_name,\n                            data,\n                            table_name: into_table.clone(),\n                        });\n                    }\n\n                    let row = TableDataRow { fields };\n                    rows.push(row);\n                }\n\n                for row in rows {\n                    let file_name = uuid::Uuid::new_v4().to_string();\n\n                    let row_file_path = rows_path.join(file_name);\n\n                    if let Err(error) = tokio::fs::write(row_file_path, encoder.encode(row)).await {\n                        return Err(ExecuteError::wrap(error.to_string()));\n                    }\n                }\n            }\n            InsertData::Select(_select) =\u003e {\n                todo!(\"아직 미구현\")\n            }\n            InsertData::None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"inserted into {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":16,"address":[2048064,2060629,2048141,2048198,2048433,2050363],"length":1,"stats":{"Line":0}},{"line":17,"address":[2048423],"length":1,"stats":{"Line":0}},{"line":19,"address":[2048733,2048583],"length":1,"stats":{"Line":0}},{"line":21,"address":[2048928,2048736],"length":1,"stats":{"Line":0}},{"line":22,"address":[2049042],"length":1,"stats":{"Line":0}},{"line":24,"address":[2049180],"length":1,"stats":{"Line":0}},{"line":26,"address":[2049295,2049206],"length":1,"stats":{"Line":0}},{"line":28,"address":[2049477],"length":1,"stats":{"Line":0}},{"line":31,"address":[2049879],"length":1,"stats":{"Line":0}},{"line":34,"address":[2050105],"length":1,"stats":{"Line":0}},{"line":36,"address":[2050291,2050404,2048463,2050194,2048188],"length":1,"stats":{"Line":0}},{"line":37,"address":[2050652],"length":1,"stats":{"Line":0}},{"line":38,"address":[2050858,2050684],"length":1,"stats":{"Line":0}},{"line":40,"address":[2050865],"length":1,"stats":{"Line":0}},{"line":41,"address":[2050979],"length":1,"stats":{"Line":0}},{"line":43,"address":[2051044,2050900],"length":1,"stats":{"Line":0}},{"line":47,"address":[2052991,2050741],"length":1,"stats":{"Line":0}},{"line":49,"address":[2053135,2053012],"length":1,"stats":{"Line":0}},{"line":52,"address":[2053183],"length":1,"stats":{"Line":0}},{"line":58,"address":[2051172,2051274],"length":1,"stats":{"Line":0}},{"line":61,"address":[2051470,2051378],"length":1,"stats":{"Line":0}},{"line":64,"address":[2051485],"length":1,"stats":{"Line":0}},{"line":67,"address":[2051878,2051565,2051682,2051809],"length":1,"stats":{"Line":0}},{"line":68,"address":[2051880,2052569],"length":1,"stats":{"Line":0}},{"line":69,"address":[2052709],"length":1,"stats":{"Line":0}},{"line":71,"address":[2052575],"length":1,"stats":{"Line":0}},{"line":76,"address":[2051920,2052033],"length":1,"stats":{"Line":0}},{"line":79,"address":[2052013,2063504,2063532],"length":1,"stats":{"Line":0}},{"line":80,"address":[2063709,2063696],"length":1,"stats":{"Line":0}},{"line":82,"address":[2052070],"length":1,"stats":{"Line":0}},{"line":83,"address":[2052195],"length":1,"stats":{"Line":0}},{"line":84,"address":[2052203],"length":1,"stats":{"Line":0}},{"line":86,"address":[2052467,2055262,2055136,2052368],"length":1,"stats":{"Line":0}},{"line":87,"address":[2055285],"length":1,"stats":{"Line":0}},{"line":90,"address":[2058479,2055800,2055455],"length":1,"stats":{"Line":0}},{"line":91,"address":[2056057,2055847],"length":1,"stats":{"Line":0}},{"line":93,"address":[2056065],"length":1,"stats":{"Line":0}},{"line":94,"address":[2056154,2056264],"length":1,"stats":{"Line":0}},{"line":95,"address":[2056111],"length":1,"stats":{"Line":0}},{"line":98,"address":[2056185,2056342],"length":1,"stats":{"Line":0}},{"line":100,"address":[2057203,2058724,2056752,2048484,2058676,2053310,2056475,2058703],"length":1,"stats":{"Line":0}},{"line":102,"address":[2057160,2057365],"length":1,"stats":{"Line":0}},{"line":103,"address":[2057496],"length":1,"stats":{"Line":0}},{"line":104,"address":[2057520,2057712],"length":1,"stats":{"Line":0}},{"line":105,"address":[2057741,2057833],"length":1,"stats":{"Line":0}},{"line":112,"address":[2057686,2057968],"length":1,"stats":{"Line":0}},{"line":113,"address":[2058043],"length":1,"stats":{"Line":0}},{"line":115,"address":[2058066,2058506],"length":1,"stats":{"Line":0}},{"line":123,"address":[2057402,2057538],"length":1,"stats":{"Line":0}},{"line":130,"address":[2057998],"length":1,"stats":{"Line":0}},{"line":132,"address":[2058329,2058163],"length":1,"stats":{"Line":0}},{"line":133,"address":[2058182],"length":1,"stats":{"Line":0}},{"line":134,"address":[2058214],"length":1,"stats":{"Line":0}},{"line":135,"address":[2058254],"length":1,"stats":{"Line":0}},{"line":140,"address":[2055055,2054817,2055903,2054903,2055770],"length":1,"stats":{"Line":0}},{"line":141,"address":[2055078,2058832],"length":1,"stats":{"Line":0}},{"line":143,"address":[2058840],"length":1,"stats":{"Line":0}},{"line":144,"address":[2058904,2059294],"length":1,"stats":{"Line":0}},{"line":146,"address":[2058888],"length":1,"stats":{"Line":0}},{"line":147,"address":[2059167,2058950],"length":1,"stats":{"Line":0}},{"line":154,"address":[2058930],"length":1,"stats":{"Line":0}},{"line":158,"address":[2053481,2053908,2053680,2059044,2059345,2059415,2059661],"length":1,"stats":{"Line":0}},{"line":159,"address":[2059474,2059384,2059061,2059299,2059453],"length":1,"stats":{"Line":0}},{"line":160,"address":[2053828,2059448,2059408,2053377,2048505,2053561,2053345],"length":1,"stats":{"Line":0}},{"line":162,"address":[2053785,2053990],"length":1,"stats":{"Line":0}},{"line":163,"address":[2054121],"length":1,"stats":{"Line":0}},{"line":164,"address":[2054303,2054137],"length":1,"stats":{"Line":0}},{"line":165,"address":[2054384],"length":1,"stats":{"Line":0}},{"line":167,"address":[2054413,2059503],"length":1,"stats":{"Line":0}},{"line":175,"address":[2054155,2054027],"length":1,"stats":{"Line":0}},{"line":182,"address":[2054339],"length":1,"stats":{"Line":0}},{"line":184,"address":[2054682,2054510],"length":1,"stats":{"Line":0}},{"line":185,"address":[2054532],"length":1,"stats":{"Line":0}},{"line":186,"address":[2054564],"length":1,"stats":{"Line":0}},{"line":187,"address":[2054604],"length":1,"stats":{"Line":0}},{"line":191,"address":[2054940],"length":1,"stats":{"Line":0}},{"line":192,"address":[2055025],"length":1,"stats":{"Line":0}},{"line":195,"address":[2060799,2060851,2055186,2055310,2060915],"length":1,"stats":{"Line":0}},{"line":196,"address":[2060968,2062887],"length":1,"stats":{"Line":0}},{"line":198,"address":[2063000,2062922],"length":1,"stats":{"Line":0}},{"line":200,"address":[2059758,2059999,2059729,2063063,2063329,2063377,2048526],"length":1,"stats":{"Line":0}},{"line":201,"address":[2060044,2060161],"length":1,"stats":{"Line":0}},{"line":205,"address":[2052173],"length":1,"stats":{"Line":0}},{"line":211,"address":[2061986],"length":1,"stats":{"Line":0}},{"line":212,"address":[2061072,2062847,2061112,2052238,2061018],"length":1,"stats":{"Line":0}},{"line":213,"address":[2061026],"length":1,"stats":{"Line":0}},{"line":214,"address":[2061104],"length":1,"stats":{"Line":0}},{"line":216,"address":[2061336,2061390,2061833,2062842,2061428],"length":1,"stats":{"Line":0}},{"line":217,"address":[2062837,2061465,2061408,2061575],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","mod.rs"],"content":"pub mod delete;\npub mod insert;\npub mod scan;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","scan.rs"],"content":"use std::io::ErrorKind;\nuse std::path::PathBuf;\n\nuse futures::future::join_all;\n\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataRow;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::Executor;\n\nimpl Executor {\n    pub async fn full_scan(\n        \u0026self,\n        table_name: TableName,\n    ) -\u003e Result\u003cVec\u003c(PathBuf, TableDataRow)\u003e, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = table_name.database_name.unwrap();\n        let table_name = table_name.table_name;\n\n        let base_path = self.get_data_directory();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // 데이터 행 파일 경로\n        let rows_path = table_path.clone().join(\"rows\");\n\n        match std::fs::read_dir(\u0026rows_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_file() {\n                                    let path = entry.path();\n\n                                    match tokio::fs::read(\u0026path).await {\n                                        Ok(result) =\u003e {\n                                            match encoder.decode::\u003cTableDataRow\u003e(result.as_slice())\n                                            {\n                                                Some(decoded) =\u003e Ok((path.to_path_buf(), decoded)),\n                                                None =\u003e Err(ExecuteError::wrap(format!(\n                                                    \"full scan failed {:?}\",\n                                                    path\n                                                ))),\n                                            }\n                                        }\n                                        Err(error) =\u003e Err(ExecuteError::wrap(format!(\n                                            \"full scan failed {}\",\n                                            error\n                                        ))),\n                                    }\n                                } else {\n                                    Err(ExecuteError::wrap(\"full scan failed\"))\n                                }\n                            }\n                            Err(error) =\u003e {\n                                Err(ExecuteError::wrap(format!(\"full scan failed {}\", error)))\n                            }\n                        },\n                        Err(error) =\u003e Err(ExecuteError::wrap(format!(\"full scan failed {}\", error))),\n                    }\n                });\n\n                let rows = join_all(futures)\n                    .await\n                    .into_iter()\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n                match rows {\n                    Ok(rows) =\u003e Ok(rows),\n                    Err(error) =\u003e Err(ExecuteError::wrap(error.to_string())),\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists (3)\")),\n                _ =\u003e Err(ExecuteError::wrap(\"full scan failed\")),\n            },\n        }\n    }\n\n    pub async fn index_scan(\u0026self, _table_name: TableName) {}\n}\n","traces":[{"line":14,"address":[5580624],"length":1,"stats":{"Line":0}},{"line":18,"address":[6167102,6163826],"length":1,"stats":{"Line":0}},{"line":20,"address":[6163921],"length":1,"stats":{"Line":0}},{"line":21,"address":[6164089],"length":1,"stats":{"Line":0}},{"line":23,"address":[6164134],"length":1,"stats":{"Line":0}},{"line":25,"address":[6164290,6164204],"length":1,"stats":{"Line":0}},{"line":27,"address":[6164457],"length":1,"stats":{"Line":0}},{"line":30,"address":[6164826],"length":1,"stats":{"Line":0}},{"line":32,"address":[6165037,6163695,6165120],"length":1,"stats":{"Line":0}},{"line":33,"address":[6165152,6165174],"length":1,"stats":{"Line":0}},{"line":34,"address":[6167203,6167973,6167248,6168463,6165193,6165167,6167168,6167288,6167072,6168558,6167107],"length":1,"stats":{"Line":0}},{"line":35,"address":[6167256,6167241],"length":1,"stats":{"Line":0}},{"line":36,"address":[6167548,6167328],"length":1,"stats":{"Line":0}},{"line":37,"address":[6167562],"length":1,"stats":{"Line":0}},{"line":38,"address":[6167576,6167719],"length":1,"stats":{"Line":0}},{"line":39,"address":[6167752],"length":1,"stats":{"Line":0}},{"line":41,"address":[4746545],"length":1,"stats":{"Line":0}},{"line":42,"address":[6168859],"length":1,"stats":{"Line":0}},{"line":43,"address":[6169118,6168891],"length":1,"stats":{"Line":0}},{"line":45,"address":[6169249,6169462],"length":1,"stats":{"Line":0}},{"line":46,"address":[6169160,6169310],"length":1,"stats":{"Line":0}},{"line":52,"address":[6168936,6169823],"length":1,"stats":{"Line":0}},{"line":58,"address":[6167725,6167779],"length":1,"stats":{"Line":0}},{"line":61,"address":[6167599],"length":1,"stats":{"Line":0}},{"line":62,"address":[6168026],"length":1,"stats":{"Line":0}},{"line":65,"address":[6168224,6167387],"length":1,"stats":{"Line":0}},{"line":69,"address":[6165960,6165368,6166070,6165338],"length":1,"stats":{"Line":0}},{"line":70,"address":[4710441],"length":1,"stats":{"Line":0}},{"line":74,"address":[6166100],"length":1,"stats":{"Line":0}},{"line":75,"address":[6166126],"length":1,"stats":{"Line":0}},{"line":76,"address":[6166239],"length":1,"stats":{"Line":0}},{"line":79,"address":[6165226,6165480],"length":1,"stats":{"Line":0}},{"line":80,"address":[6165501,6165555],"length":1,"stats":{"Line":0}},{"line":81,"address":[6165600,6165528],"length":1,"stats":{"Line":0}},{"line":86,"address":[5580704,5580739],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","select.rs"],"content":"use std::cmp::Ordering;\nuse std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::parts::order_by::{OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectKind};\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::ast::dml::plan::select::select_plan::SelectPlanItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::{TableDataField, TableDataFieldType, TableDataRow};\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn select(\u0026self, query: SelectQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let select_items = query.select_items.clone();\n\n        let plan = optimizer.optimize_select(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_alias_reverse_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        let mut no_from_clause = true;\n\n        for each_plan in plan.list {\n            match each_plan {\n                // Select From 처리\n                SelectPlanItem::From(from) =\u003e {\n                    no_from_clause = false;\n\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias.clone(), table_name.clone());\n                        table_alias_reverse_map.insert(table_name.clone().table_name, alias);\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result = self\n                                .full_scan(table_name)\n                                .await?\n                                .into_iter()\n                                .map(|(_, e)| e)\n                                .collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                SelectPlanItem::Filter(filter) =\u003e {\n                    let futures = rows.iter().cloned().map(|e| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(e.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((e, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((e, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, boolean)| *boolean)\n                        .map(|(e, _)| e)\n                        .collect();\n                }\n                SelectPlanItem::Group(ref group_by_clause) =\u003e {\n                    let mut grouped_map =\n                        HashMap::\u003cVec\u003cTableDataField\u003e, Vec\u003cTableDataField\u003e\u003e::new();\n\n                    for row in rows {\n                        let mut group_key = vec![];\n                        let mut group_value = vec![];\n\n                        for field in row.fields {\n                            // group by 절에 포함된 컬럼일 경우 키값으로 사용\n                            if let Some(_found) = group_by_clause.group_by_items.iter().find(|e| {\n                                let mut table_name_matched = false;\n\n                                if let Some(table_name) = \u0026e.item.table_name {\n                                    if table_name == \u0026field.table_name.table_name {\n                                        table_name_matched = true;\n                                    } else if let Some(table_name) = table_alias_map.get(table_name)\n                                    {\n                                        if table_name.table_name == field.table_name.table_name {\n                                            table_name_matched = true;\n                                        }\n                                    } else if let Some(table_name) =\n                                        table_alias_reverse_map.get(table_name)\n                                    {\n                                        if table_name == \u0026field.table_name.table_name {\n                                            table_name_matched = true;\n                                        }\n                                    }\n                                } else {\n                                    table_name_matched = true;\n                                }\n\n                                e.item.column_name == field.column_name \u0026\u0026 table_name_matched\n                            }) {\n                                group_key.push(field);\n                            }\n                            // 미포함된 컬럼일 경우 배열 형태로 값 중첩\n                            else {\n                                group_value.push(field);\n                            }\n                        }\n\n                        match grouped_map.get_mut(\u0026group_key) {\n                            Some(value) =\u003e {\n                                for i in 0..value.len() {\n                                    value[i].push(group_value[i].data.clone());\n                                }\n                            }\n                            None =\u003e {\n                                grouped_map.insert(\n                                    group_key,\n                                    group_value\n                                        .into_iter()\n                                        .map(|e| e.to_array())\n                                        .collect::\u003cVec\u003c_\u003e\u003e(),\n                                );\n                            }\n                        }\n                    }\n\n                    rows = grouped_map\n                        .into_iter()\n                        .map(|(mut key, mut value)| {\n                            key.append(\u0026mut value);\n                            TableDataRow { fields: key }\n                        })\n                        .collect();\n                }\n                SelectPlanItem::GroupAll =\u003e {\n                    let mut fields = vec![];\n\n                    for row in rows {\n                        if fields.is_empty() {\n                            for field in row.fields {\n                                fields.push(field.to_array());\n                            }\n                        } else {\n                            for (i, field) in row.fields.into_iter().enumerate() {\n                                fields[i].push(field.data)\n                            }\n                        }\n                    }\n\n                    rows = vec![TableDataRow { fields }];\n                }\n                SelectPlanItem::LimitOffset(limit_offset) =\u003e {\n                    let offset = limit_offset.offset.unwrap_or(0) as usize;\n\n                    match limit_offset.limit {\n                        Some(limit) =\u003e {\n                            rows = rows.drain(offset..(offset + limit as usize)).collect()\n                        }\n                        None =\u003e rows = rows.drain(offset..).collect(),\n                    }\n                }\n                SelectPlanItem::Order(ref order_by_clause) =\u003e {\n                    let futures = rows.into_iter().map(|e| {\n                        let table_alias_map = table_alias_map.clone();\n\n                        async move {\n                            let mut order_by_values = vec![];\n\n                            let reduce_context = ReduceContext {\n                                row: Some(e.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            for order_by_item in \u0026order_by_clause.order_by_items {\n                                let expression = \u0026order_by_item.item;\n\n                                let value = match self\n                                    .reduce_expression(expression.clone(), reduce_context.clone())\n                                    .await\n                                {\n                                    Ok(value) =\u003e value,\n                                    Err(error) =\u003e return Err(error),\n                                };\n\n                                order_by_values.push(value);\n                            }\n\n                            Ok((e, order_by_values))\n                        }\n                    });\n\n                    let mut order_by_rows = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    let order_by_items = \u0026order_by_clause.order_by_items;\n\n                    order_by_rows.sort_by(|(_, l), (_, r)| {\n                        for (i, order_by_item) in order_by_items.iter().enumerate() {\n                            let lhs = \u0026l[i];\n                            let rhs = \u0026r[i];\n\n                            if lhs.is_null() \u0026\u0026 rhs.is_null() {\n                                continue;\n                            }\n\n                            if lhs.is_null() {\n                                match order_by_item.nulls {\n                                    OrderByNulls::First =\u003e {\n                                        return Ordering::Less;\n                                    }\n                                    OrderByNulls::Last =\u003e {\n                                        return Ordering::Greater;\n                                    }\n                                }\n                            }\n\n                            if rhs.is_null() {\n                                match order_by_item.nulls {\n                                    OrderByNulls::First =\u003e {\n                                        return Ordering::Greater;\n                                    }\n                                    OrderByNulls::Last =\u003e {\n                                        return Ordering::Less;\n                                    }\n                                }\n                            }\n\n                            match order_by_item.order_type {\n                                OrderByType::Asc =\u003e {\n                                    if lhs \u003c rhs {\n                                        return Ordering::Less;\n                                    } else if lhs \u003e rhs {\n                                        return Ordering::Greater;\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                OrderByType::Desc =\u003e {\n                                    if lhs \u003c rhs {\n                                        return Ordering::Greater;\n                                    } else if lhs \u003e rhs {\n                                        return Ordering::Less;\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n\n                        Ordering::Equal\n                    });\n\n                    rows = order_by_rows.into_iter().map(|(e, _)| e).collect();\n                }\n                _ =\u003e unimplemented!(\"미구현\"),\n            }\n        }\n\n        if no_from_clause {\n            rows.push(TableDataRow {\n                fields: vec![TableDataField {\n                    table_name: TableName::new(None, \"no_table\".into()),\n                    column_name: \"result\".into(),\n                    data: TableDataFieldType::Null,\n                }],\n            });\n        }\n\n        let config_columns = table_infos\n            .into_iter()\n            .flat_map(|table_info| {\n                table_info\n                    .columns\n                    .iter()\n                    .cloned()\n                    .map(|column| (table_info.table.to_owned(), column))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // *까지 전부 유효한 항목으로 펼침\n        let select_items = select_items\n            .into_iter()\n            .flat_map(|e| match e {\n                SelectKind::SelectItem(item) =\u003e vec![item],\n                SelectKind::WildCard(wildcard) =\u003e match wildcard.alias {\n                    // a.* 와 같은 형태일 경우\n                    Some(alias) =\u003e match table_alias_map.get(\u0026alias) {\n                        Some(found_table_name) =\u003e config_columns\n                            .iter()\n                            .filter(|(table_name, _)| {\n                                found_table_name.table_name == table_name.table_name\n                            })\n                            .map(|(table_name, column_name)| {\n                                SelectItem::builder()\n                                    .set_item(\n                                        SelectColumn::new(\n                                            Some(table_name.table_name.clone()),\n                                            column_name.name.clone(),\n                                        )\n                                        .into(),\n                                    )\n                                    .build()\n                            })\n                            .collect(),\n                        None =\u003e config_columns\n                            .iter()\n                            .filter(|(table_name, _)| alias == table_name.table_name)\n                            .map(|(table_name, column_name)| {\n                                SelectItem::builder()\n                                    .set_item(\n                                        SelectColumn::new(\n                                            Some(table_name.table_name.clone()),\n                                            column_name.name.clone(),\n                                        )\n                                        .into(),\n                                    )\n                                    .build()\n                            })\n                            .collect(),\n                    },\n                    None =\u003e config_columns\n                        .iter()\n                        .map(|(table_name, column_name)| {\n                            SelectItem::builder()\n                                .set_item(\n                                    SelectColumn::new(\n                                        Some(table_name.table_name.clone()),\n                                        column_name.name.clone(),\n                                    )\n                                    .into(),\n                                )\n                                .build()\n                        })\n                        .collect(),\n                },\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // 필요한 SELECT Item만 최종 계산\n        let total_count = rows.len();\n        let rows = rows.into_iter().map(|row| {\n            let table_alias_map = table_alias_map.clone();\n            let select_items = select_items.clone();\n            async move {\n                let fields = select_items.iter().map(|select_item| {\n                    let table_alias_map = table_alias_map.clone();\n                    let row = row.clone();\n                    async move {\n                        let reduce_context = ReduceContext {\n                            row: Some(row.clone()),\n                            table_alias_map: table_alias_map.clone(),\n                            config_columns: vec![],\n                            total_count,\n                        };\n\n                        let value = self\n                            .reduce_expression(\n                                select_item.item.as_ref().unwrap().clone(),\n                                reduce_context.clone(),\n                            )\n                            .await;\n\n                        match value {\n                            Ok(value) =\u003e Ok(ExecuteField::from(value)),\n                            Err(error) =\u003e Err(error),\n                        }\n                    }\n                });\n\n                let fields = join_all(fields)\n                    .await\n                    .into_iter()\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n                match fields {\n                    Ok(fields) =\u003e Ok(ExecuteRow { fields }),\n                    Err(error) =\u003e Err(error),\n                }\n            }\n        });\n\n        let rows = join_all(rows)\n            .await\n            .into_iter()\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n        let reduce_context = ReduceContext {\n            row: None,\n            table_alias_map,\n            config_columns,\n            total_count: 0,\n        };\n\n        let columns = select_items\n            .into_iter()\n            .map(|e| {\n                let item = e.item.unwrap();\n\n                let name = match e.alias {\n                    Some(alias) =\u003e alias,\n                    None =\u003e match \u0026item {\n                        SQLExpression::SelectColumn(column) =\u003e column.column_name.to_owned(),\n                        _ =\u003e \"?column?\".into(),\n                    },\n                };\n                let data_type = self.reduce_type(item, reduce_context.clone())?;\n\n                Ok(ExecuteColumn { name, data_type })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        match rows {\n            Ok(rows) =\u003e Ok(ExecuteResult { columns, rows }),\n            Err(error) =\u003e Err(error),\n        }\n    }\n\n    pub async fn filter(\u0026self) {}\n\n    pub async fn order_by(\u0026self) {}\n\n    pub async fn inner_join(\u0026self) {}\n}\n","traces":[{"line":21,"address":[3737801,3721059,3718768,3718845,3719877,3719335,3718902],"length":1,"stats":{"Line":0}},{"line":23,"address":[3719325],"length":1,"stats":{"Line":0}},{"line":25,"address":[3719531,3719602],"length":1,"stats":{"Line":0}},{"line":27,"address":[3719617,3719805,3720320,3719909,3721016,3718892,3719365],"length":1,"stats":{"Line":0}},{"line":29,"address":[3720295],"length":1,"stats":{"Line":0}},{"line":30,"address":[3720496],"length":1,"stats":{"Line":0}},{"line":31,"address":[3720578],"length":1,"stats":{"Line":0}},{"line":33,"address":[3720659],"length":1,"stats":{"Line":0}},{"line":35,"address":[3720759],"length":1,"stats":{"Line":0}},{"line":37,"address":[3720789,3722190,3720913,3722363,3722296],"length":1,"stats":{"Line":0}},{"line":38,"address":[3722432],"length":1,"stats":{"Line":0}},{"line":40,"address":[3724155],"length":1,"stats":{"Line":0}},{"line":41,"address":[3724239],"length":1,"stats":{"Line":0}},{"line":43,"address":[3724254,3724723],"length":1,"stats":{"Line":0}},{"line":45,"address":[3727650,3724738,3721068,3719386,3724870,3725423],"length":1,"stats":{"Line":0}},{"line":47,"address":[3725346],"length":1,"stats":{"Line":0}},{"line":49,"address":[3725584,3726257],"length":1,"stats":{"Line":0}},{"line":50,"address":[3725687,3726262,3725822,3725787],"length":1,"stats":{"Line":0}},{"line":51,"address":[3726009],"length":1,"stats":{"Line":0}},{"line":54,"address":[3725736],"length":1,"stats":{"Line":0}},{"line":56,"address":[3726571,3726713,3726316,3726877,3727045,3726407,3727554],"length":1,"stats":{"Line":0}},{"line":57,"address":[3726331],"length":1,"stats":{"Line":0}},{"line":58,"address":[3726793,3719407,3721103,3726604,3726564,3726965],"length":1,"stats":{"Line":0}},{"line":60,"address":[3737884,3737856],"length":1,"stats":{"Line":0}},{"line":63,"address":[3727124],"length":1,"stats":{"Line":0}},{"line":65,"address":[3726417],"length":1,"stats":{"Line":0}},{"line":70,"address":[3724519],"length":1,"stats":{"Line":0}},{"line":71,"address":[3738286,3734072,3737936,3724620],"length":1,"stats":{"Line":0}},{"line":72,"address":[3738056,3737971],"length":1,"stats":{"Line":0}},{"line":73,"address":[3738064],"length":1,"stats":{"Line":0}},{"line":74,"address":[3738488,3738355,3738400,3738320,3739157,3738133,3740314,3739184],"length":1,"stats":{"Line":0}},{"line":75,"address":[3738408,3738728],"length":1,"stats":{"Line":0}},{"line":76,"address":[3738585,3738468],"length":1,"stats":{"Line":0}},{"line":77,"address":[3738617],"length":1,"stats":{"Line":0}},{"line":78,"address":[3738681],"length":1,"stats":{"Line":0}},{"line":82,"address":[3738849,3739071,3739466,3739101,3739683,3739314],"length":1,"stats":{"Line":0}},{"line":83,"address":[3738866,3738935],"length":1,"stats":{"Line":0}},{"line":84,"address":[3738393,3738515,3739216,3739094,3739603,3739394,3739131],"length":1,"stats":{"Line":0}},{"line":86,"address":[3739563],"length":1,"stats":{"Line":0}},{"line":87,"address":[3739746],"length":1,"stats":{"Line":0}},{"line":88,"address":[3739955],"length":1,"stats":{"Line":0}},{"line":89,"address":[3740194,3739716],"length":1,"stats":{"Line":0}},{"line":96,"address":[3734550,3734221,3734851,3734434,3734286],"length":1,"stats":{"Line":0}},{"line":97,"address":[3734279,3721138,3719428,3734319,3734466],"length":1,"stats":{"Line":0}},{"line":101,"address":[3734705,3734941,3735111],"length":1,"stats":{"Line":0}},{"line":103,"address":[3740576,3740586],"length":1,"stats":{"Line":0}},{"line":104,"address":[3740608,3740616],"length":1,"stats":{"Line":0}},{"line":105,"address":[3735084],"length":1,"stats":{"Line":0}},{"line":107,"address":[3724393],"length":1,"stats":{"Line":0}},{"line":108,"address":[3724431],"length":1,"stats":{"Line":0}},{"line":111,"address":[3729034,3729084,3730671,3728907,3728782],"length":1,"stats":{"Line":0}},{"line":112,"address":[3729132],"length":1,"stats":{"Line":0}},{"line":113,"address":[3729383],"length":1,"stats":{"Line":0}},{"line":115,"address":[3731423,3729689,3729562,3729750,3729451],"length":1,"stats":{"Line":0}},{"line":117,"address":[3729870,3730919,3740640],"length":1,"stats":{"Line":0}},{"line":118,"address":[3740663],"length":1,"stats":{"Line":0}},{"line":120,"address":[3740668,3740763],"length":1,"stats":{"Line":0}},{"line":121,"address":[3740728,3740824],"length":1,"stats":{"Line":0}},{"line":122,"address":[3740819],"length":1,"stats":{"Line":0}},{"line":123,"address":[3740772,3740830],"length":1,"stats":{"Line":0}},{"line":125,"address":[3740840,3740935],"length":1,"stats":{"Line":0}},{"line":126,"address":[3740930],"length":1,"stats":{"Line":0}},{"line":128,"address":[3740941,3740877],"length":1,"stats":{"Line":0}},{"line":129,"address":[3740858],"length":1,"stats":{"Line":0}},{"line":131,"address":[3740951,3740986],"length":1,"stats":{"Line":0}},{"line":132,"address":[3740981],"length":1,"stats":{"Line":0}},{"line":136,"address":[3740758],"length":1,"stats":{"Line":0}},{"line":139,"address":[3740912,3740988],"length":1,"stats":{"Line":0}},{"line":141,"address":[3731124,3731413],"length":1,"stats":{"Line":0}},{"line":145,"address":[3731270,3731428],"length":1,"stats":{"Line":0}},{"line":149,"address":[3729912,3729976],"length":1,"stats":{"Line":0}},{"line":150,"address":[3730124],"length":1,"stats":{"Line":0}},{"line":151,"address":[3730378,3730148],"length":1,"stats":{"Line":0}},{"line":152,"address":[3730731,3730552],"length":1,"stats":{"Line":0}},{"line":156,"address":[3730253],"length":1,"stats":{"Line":0}},{"line":157,"address":[3730013],"length":1,"stats":{"Line":0}},{"line":158,"address":[3730223,3730061],"length":1,"stats":{"Line":0}},{"line":160,"address":[3741052,3741024],"length":1,"stats":{"Line":0}},{"line":167,"address":[3729142],"length":1,"stats":{"Line":0}},{"line":169,"address":[3741093,3741072,3741290],"length":1,"stats":{"Line":0}},{"line":170,"address":[3741148],"length":1,"stats":{"Line":0}},{"line":171,"address":[3741190],"length":1,"stats":{"Line":0}},{"line":176,"address":[3724449],"length":1,"stats":{"Line":0}},{"line":178,"address":[3731791,3731664,3731841,3731539,3732738],"length":1,"stats":{"Line":0}},{"line":179,"address":[3731889,3732244],"length":1,"stats":{"Line":0}},{"line":180,"address":[3732313,3733137,3733010,3733190],"length":1,"stats":{"Line":0}},{"line":181,"address":[3733318],"length":1,"stats":{"Line":0}},{"line":184,"address":[3732514,3732567,3732250,3732961,3732395],"length":1,"stats":{"Line":0}},{"line":185,"address":[3732703,3732788],"length":1,"stats":{"Line":0}},{"line":190,"address":[3731913],"length":1,"stats":{"Line":0}},{"line":192,"address":[3724459],"length":1,"stats":{"Line":0}},{"line":193,"address":[3733406,3724482],"length":1,"stats":{"Line":0}},{"line":195,"address":[3733421],"length":1,"stats":{"Line":0}},{"line":196,"address":[3733474],"length":1,"stats":{"Line":0}},{"line":197,"address":[3733488,3733768],"length":1,"stats":{"Line":0}},{"line":199,"address":[3733439,3733548],"length":1,"stats":{"Line":0}},{"line":202,"address":[3724289],"length":1,"stats":{"Line":0}},{"line":203,"address":[3741521,3724314,3728574,3741328],"length":1,"stats":{"Line":0}},{"line":204,"address":[3741357],"length":1,"stats":{"Line":0}},{"line":206,"address":[3741632,3741732,3742295,3741418,3741587,3741552,3742271,3743706],"length":1,"stats":{"Line":0}},{"line":207,"address":[3741640],"length":1,"stats":{"Line":0}},{"line":209,"address":[3741829,3742031],"length":1,"stats":{"Line":0}},{"line":210,"address":[3741900,3741841],"length":1,"stats":{"Line":0}},{"line":211,"address":[3741923],"length":1,"stats":{"Line":0}},{"line":212,"address":[3741984],"length":1,"stats":{"Line":0}},{"line":216,"address":[3743299,3741625,3742225,3743027,3742148],"length":1,"stats":{"Line":0}},{"line":217,"address":[3743315],"length":1,"stats":{"Line":0}},{"line":219,"address":[3743522,3742622,3742451,3743323,3743592],"length":1,"stats":{"Line":0}},{"line":220,"address":[3743635,3743447,3743345,3743412,3743561],"length":1,"stats":{"Line":0}},{"line":221,"address":[3742353,3743622,3743585,3742531,3741759,3742327],"length":1,"stats":{"Line":0}},{"line":223,"address":[3742652],"length":1,"stats":{"Line":0}},{"line":224,"address":[3742791],"length":1,"stats":{"Line":0}},{"line":227,"address":[3742724],"length":1,"stats":{"Line":0}},{"line":230,"address":[3743078],"length":1,"stats":{"Line":0}},{"line":234,"address":[3721469,3728679,3728709,3721318,3721769],"length":1,"stats":{"Line":0}},{"line":235,"address":[3728702,3721173,3721205,3719449,3721350,3728742],"length":1,"stats":{"Line":0}},{"line":239,"address":[3721624],"length":1,"stats":{"Line":0}},{"line":241,"address":[3743855,3721663,3721867,3743824],"length":1,"stats":{"Line":0}},{"line":242,"address":[3744033,3743889],"length":1,"stats":{"Line":0}},{"line":243,"address":[3744071],"length":1,"stats":{"Line":0}},{"line":244,"address":[3744117],"length":1,"stats":{"Line":0}},{"line":246,"address":[3744142,3744229],"length":1,"stats":{"Line":0}},{"line":250,"address":[3744189],"length":1,"stats":{"Line":0}},{"line":251,"address":[3744264],"length":1,"stats":{"Line":0}},{"line":253,"address":[3744560],"length":1,"stats":{"Line":0}},{"line":256,"address":[3744570],"length":1,"stats":{"Line":0}},{"line":261,"address":[3744249],"length":1,"stats":{"Line":0}},{"line":262,"address":[3744311],"length":1,"stats":{"Line":0}},{"line":264,"address":[3744540],"length":1,"stats":{"Line":0}},{"line":267,"address":[3744550],"length":1,"stats":{"Line":0}},{"line":272,"address":[3744291],"length":1,"stats":{"Line":0}},{"line":274,"address":[3744339],"length":1,"stats":{"Line":0}},{"line":275,"address":[3744457],"length":1,"stats":{"Line":0}},{"line":276,"address":[3744419],"length":1,"stats":{"Line":0}},{"line":277,"address":[3744467],"length":1,"stats":{"Line":0}},{"line":283,"address":[3744379],"length":1,"stats":{"Line":0}},{"line":284,"address":[3744520],"length":1,"stats":{"Line":0}},{"line":285,"address":[3744482],"length":1,"stats":{"Line":0}},{"line":286,"address":[3744530],"length":1,"stats":{"Line":0}},{"line":294,"address":[3744018],"length":1,"stats":{"Line":0}},{"line":297,"address":[3744592,3721874,3744620],"length":1,"stats":{"Line":0}},{"line":303,"address":[3722518],"length":1,"stats":{"Line":0}},{"line":304,"address":[3723235,3722614],"length":1,"stats":{"Line":0}},{"line":305,"address":[3722915,3724119,3724091,3724145,3722646],"length":1,"stats":{"Line":0}},{"line":306,"address":[3724103,3722677,3724126],"length":1,"stats":{"Line":0}},{"line":307,"address":[3722829],"length":1,"stats":{"Line":0}},{"line":308,"address":[3722907],"length":1,"stats":{"Line":0}},{"line":313,"address":[3723345,3722535],"length":1,"stats":{"Line":0}},{"line":315,"address":[3744672,3744872],"length":1,"stats":{"Line":0}},{"line":316,"address":[3744766,3744704],"length":1,"stats":{"Line":0}},{"line":320,"address":[3744896,3744926],"length":1,"stats":{"Line":0}},{"line":326,"address":[3723397,3723577],"length":1,"stats":{"Line":0}},{"line":328,"address":[3723536,3745123,3745860,3745088],"length":1,"stats":{"Line":0}},{"line":329,"address":[3745247,3745882],"length":1,"stats":{"Line":0}},{"line":330,"address":[3745166],"length":1,"stats":{"Line":0}},{"line":332,"address":[3745524,3745407],"length":1,"stats":{"Line":0}},{"line":333,"address":[3745592,3745768],"length":1,"stats":{"Line":0}},{"line":335,"address":[3746141,3746128],"length":1,"stats":{"Line":0}},{"line":336,"address":[3746149],"length":1,"stats":{"Line":0}},{"line":338,"address":[3746618,3746176,3746214],"length":1,"stats":{"Line":0}},{"line":339,"address":[3746255,3746573,3746524],"length":1,"stats":{"Line":0}},{"line":341,"address":[3746494,3746447],"length":1,"stats":{"Line":0}},{"line":342,"address":[3746281,3746346],"length":1,"stats":{"Line":0}},{"line":343,"address":[3746386],"length":1,"stats":{"Line":0}},{"line":350,"address":[3745566,3745644],"length":1,"stats":{"Line":0}},{"line":352,"address":[3746669,3746656],"length":1,"stats":{"Line":0}},{"line":353,"address":[3746742,3747146,3746704],"length":1,"stats":{"Line":0}},{"line":354,"address":[3747052,3747101,3746783],"length":1,"stats":{"Line":0}},{"line":356,"address":[3746975,3747022],"length":1,"stats":{"Line":0}},{"line":357,"address":[3746809,3746874],"length":1,"stats":{"Line":0}},{"line":358,"address":[3746914],"length":1,"stats":{"Line":0}},{"line":366,"address":[3745356],"length":1,"stats":{"Line":0}},{"line":368,"address":[3747184,3747222,3747626],"length":1,"stats":{"Line":0}},{"line":369,"address":[3747263,3747581,3747532],"length":1,"stats":{"Line":0}},{"line":371,"address":[3747502,3747455],"length":1,"stats":{"Line":0}},{"line":372,"address":[3747289,3747354],"length":1,"stats":{"Line":0}},{"line":373,"address":[3747394],"length":1,"stats":{"Line":0}},{"line":385,"address":[3723740,3723629],"length":1,"stats":{"Line":0}},{"line":386,"address":[3747956,3747664,3723743],"length":1,"stats":{"Line":0}},{"line":387,"address":[3747699],"length":1,"stats":{"Line":0}},{"line":388,"address":[3747756],"length":1,"stats":{"Line":0}},{"line":389,"address":[3748094,3747816,3747984,3748019,3748384,3748064,3749011,3749106],"length":1,"stats":{"Line":0}},{"line":390,"address":[3748072,3748181,3749152,3749392],"length":1,"stats":{"Line":0}},{"line":391,"address":[3749192],"length":1,"stats":{"Line":0}},{"line":392,"address":[3749210],"length":1,"stats":{"Line":0}},{"line":393,"address":[3749504,3750835,3749273,3749459,3749424,3749537,3750284],"length":1,"stats":{"Line":0}},{"line":394,"address":[3749761,3749512],"length":1,"stats":{"Line":0}},{"line":395,"address":[3749520,3749614],"length":1,"stats":{"Line":0}},{"line":396,"address":[3749637],"length":1,"stats":{"Line":0}},{"line":397,"address":[3749703],"length":1,"stats":{"Line":0}},{"line":398,"address":[3749747],"length":1,"stats":{"Line":0}},{"line":401,"address":[3750100,3749858,3750211,3750422],"length":1,"stats":{"Line":0}},{"line":403,"address":[3750015,3749872],"length":1,"stats":{"Line":0}},{"line":404,"address":[3750030],"length":1,"stats":{"Line":0}},{"line":406,"address":[3749497,3749564,3750325,3750502,3750241,3750163],"length":1,"stats":{"Line":0}},{"line":408,"address":[3750558],"length":1,"stats":{"Line":0}},{"line":409,"address":[3750584,3750693],"length":1,"stats":{"Line":0}},{"line":410,"address":[3750639],"length":1,"stats":{"Line":0}},{"line":415,"address":[3748303,3748333,3748520,3748621],"length":1,"stats":{"Line":0}},{"line":416,"address":[3748416,3748121,3748552,3748360,3748057,3748326],"length":1,"stats":{"Line":0}},{"line":420,"address":[3748651],"length":1,"stats":{"Line":0}},{"line":421,"address":[3748681],"length":1,"stats":{"Line":0}},{"line":422,"address":[3748839],"length":1,"stats":{"Line":0}},{"line":427,"address":[3723942,3735790,3735674,3724015],"length":1,"stats":{"Line":0}},{"line":428,"address":[3724008,3735561,3735706,3719470,3724048],"length":1,"stats":{"Line":0}},{"line":439,"address":[3736560,3736099,3736262],"length":1,"stats":{"Line":0}},{"line":441,"address":[3750960,3752141,3736223,3752175],"length":1,"stats":{"Line":0}},{"line":442,"address":[3751003,3751191],"length":1,"stats":{"Line":0}},{"line":444,"address":[3751199],"length":1,"stats":{"Line":0}},{"line":445,"address":[3751276],"length":1,"stats":{"Line":0}},{"line":446,"address":[3751229],"length":1,"stats":{"Line":0}},{"line":447,"address":[3751369,3751483],"length":1,"stats":{"Line":0}},{"line":448,"address":[3751598,3751401],"length":1,"stats":{"Line":0}},{"line":451,"address":[3751979,3751490,3751600,3751757,3752131],"length":1,"stats":{"Line":0}},{"line":453,"address":[3751806],"length":1,"stats":{"Line":0}},{"line":457,"address":[3736449],"length":1,"stats":{"Line":0}},{"line":458,"address":[3736593],"length":1,"stats":{"Line":0}},{"line":459,"address":[3736845],"length":1,"stats":{"Line":0}},{"line":463,"address":[5580872,5580864],"length":1,"stats":{"Line":0}},{"line":465,"address":[5580888,5580880],"length":1,"stats":{"Line":0}},{"line":467,"address":[5580904,5580896],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":221},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","update.rs"],"content":"use std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::ast::dml::plan::update::update_plan::UpdatePlanItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataFieldType;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::executor::result::ExecuteColumnType;\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn update(\u0026self, query: UpdateQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let table = query.target_table.clone().unwrap().table;\n        let update_items = query.update_items.clone();\n\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let plan = optimizer.optimize_update(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        for each_plan in plan.list {\n            match each_plan {\n                // Select From 처리\n                UpdatePlanItem::UpdateFrom(from) =\u003e {\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias, table_name.clone());\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result =\n                                self.full_scan(table_name).await?.into_iter().collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                // 필터링 처리\n                UpdatePlanItem::Filter(filter) =\u003e {\n                    let futures = rows.iter().cloned().map(|(path, row)| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(row.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((path, row, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((path, row, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, _, boolean)| *boolean)\n                        .map(|(path, row, _)| (path, row))\n                        .collect();\n                }\n            }\n        }\n\n        let config_columns = table_infos\n            .into_iter()\n            .flat_map(|table_info| {\n                table_info\n                    .columns\n                    .iter()\n                    .cloned()\n                    .map(|column| (table_info.table.to_owned(), column))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // 수정 작업\n        for (path, mut row) in rows.into_iter() {\n            let reduce_context = ReduceContext {\n                row: None,\n                table_alias_map: table_alias_map.clone(),\n                config_columns: config_columns.clone(),\n                total_count: 0,\n            };\n\n            for update_item in \u0026update_items {\n                let column_name = update_item.column.clone();\n                let set_value = update_item.value.clone();\n\n                let set_value = self\n                    .reduce_expression(set_value, reduce_context.clone())\n                    .await?;\n\n                let found = row.fields.iter_mut().find(|e| e.column_name == column_name);\n\n                match found {\n                    Some(found) =\u003e found.data = set_value,\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(format!(\n                            \"column '{}' not found in data row\",\n                            column_name\n                        )));\n                    }\n                }\n            }\n\n            if let Err(error) = tokio::fs::write(\u0026path, encoder.encode(row)).await {\n                return Err(ExecuteError::wrap(format!(\n                    \"path '{:?}' write failed: {}\",\n                    path, error\n                )));\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"updated from {:?}\",\n                    table.table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":20,"address":[5580947,5580912],"length":1,"stats":{"Line":0}},{"line":21,"address":[5651874],"length":1,"stats":{"Line":0}},{"line":23,"address":[5652183,5652080],"length":1,"stats":{"Line":0}},{"line":24,"address":[5652302],"length":1,"stats":{"Line":0}},{"line":27,"address":[5652334],"length":1,"stats":{"Line":0}},{"line":29,"address":[4706453],"length":1,"stats":{"Line":0}},{"line":31,"address":[5653042],"length":1,"stats":{"Line":0}},{"line":32,"address":[5653228],"length":1,"stats":{"Line":0}},{"line":34,"address":[5653309],"length":1,"stats":{"Line":0}},{"line":36,"address":[5654826,5653548,5653409,5654762],"length":1,"stats":{"Line":0}},{"line":37,"address":[5654866],"length":1,"stats":{"Line":0}},{"line":39,"address":[5655295],"length":1,"stats":{"Line":0}},{"line":40,"address":[5655588,5655364],"length":1,"stats":{"Line":0}},{"line":42,"address":[4706475],"length":1,"stats":{"Line":0}},{"line":44,"address":[5656211],"length":1,"stats":{"Line":0}},{"line":46,"address":[5656449],"length":1,"stats":{"Line":0}},{"line":47,"address":[5656691,5656811,5656548],"length":1,"stats":{"Line":0}},{"line":50,"address":[5656640],"length":1,"stats":{"Line":0}},{"line":52,"address":[4706783,4706823,4706497],"length":1,"stats":{"Line":0}},{"line":55,"address":[5657615],"length":1,"stats":{"Line":0}},{"line":57,"address":[5656931],"length":1,"stats":{"Line":0}},{"line":63,"address":[5655399],"length":1,"stats":{"Line":0}},{"line":64,"address":[5665618,5665168,5658935,5655485,5665651,5665198],"length":1,"stats":{"Line":0}},{"line":65,"address":[5665273,5665334],"length":1,"stats":{"Line":0}},{"line":66,"address":[5665342],"length":1,"stats":{"Line":0}},{"line":67,"address":[5665872,5665680,5666544,5666571,5665715,5665760,5667959,5665409],"length":1,"stats":{"Line":0}},{"line":68,"address":[5666115,5665768],"length":1,"stats":{"Line":0}},{"line":69,"address":[5665969,5665852],"length":1,"stats":{"Line":0}},{"line":70,"address":[5666001],"length":1,"stats":{"Line":0}},{"line":71,"address":[5666068],"length":1,"stats":{"Line":0}},{"line":75,"address":[5666236,5666458,5666488,5666701,5666853,5667070],"length":1,"stats":{"Line":0}},{"line":76,"address":[5666253,5666322],"length":1,"stats":{"Line":0}},{"line":77,"address":[5666990,5666781,5665753,5666518,5666481,5665899,5666603],"length":1,"stats":{"Line":0}},{"line":79,"address":[5666950],"length":1,"stats":{"Line":0}},{"line":80,"address":[5667133],"length":1,"stats":{"Line":0}},{"line":81,"address":[5667409],"length":1,"stats":{"Line":0}},{"line":82,"address":[5667103,5667715],"length":1,"stats":{"Line":0}},{"line":89,"address":[5659110,5654068,5653917,5654369,5659140],"length":1,"stats":{"Line":0}},{"line":90,"address":[4706519],"length":1,"stats":{"Line":0}},{"line":94,"address":[5654459,5654223,5654629],"length":1,"stats":{"Line":0}},{"line":96,"address":[5668298,5668288],"length":1,"stats":{"Line":0}},{"line":97,"address":[5668320,5668328],"length":1,"stats":{"Line":0}},{"line":98,"address":[5654602],"length":1,"stats":{"Line":0}},{"line":103,"address":[5654917],"length":1,"stats":{"Line":0}},{"line":105,"address":[5668448,5668648],"length":1,"stats":{"Line":0}},{"line":106,"address":[5668480,5668542],"length":1,"stats":{"Line":0}},{"line":110,"address":[5668702,5668672],"length":1,"stats":{"Line":0}},{"line":116,"address":[5655046,5655185,5660429,5660496],"length":1,"stats":{"Line":0}},{"line":119,"address":[5660601],"length":1,"stats":{"Line":0}},{"line":120,"address":[5662214],"length":1,"stats":{"Line":0}},{"line":124,"address":[5662410,5662691,5662499],"length":1,"stats":{"Line":0}},{"line":125,"address":[5662712],"length":1,"stats":{"Line":0}},{"line":126,"address":[5662882],"length":1,"stats":{"Line":0}},{"line":128,"address":[5663136,5662952,5663380,5663544,5664526,5663764,5663241],"length":1,"stats":{"Line":0}},{"line":129,"address":[5664937,5662972,5664958,5663175],"length":1,"stats":{"Line":0}},{"line":130,"address":[4706541],"length":1,"stats":{"Line":0}},{"line":132,"address":[5663649,5668881,5668864,5663848],"length":1,"stats":{"Line":0}},{"line":134,"address":[5663939],"length":1,"stats":{"Line":0}},{"line":135,"address":[5664062,5664368,5664447],"length":1,"stats":{"Line":0}},{"line":137,"address":[5664136,5663968],"length":1,"stats":{"Line":0}},{"line":145,"address":[4706563],"length":1,"stats":{"Line":0}},{"line":146,"address":[5659651,5659908],"length":1,"stats":{"Line":0}},{"line":153,"address":[5661650],"length":1,"stats":{"Line":0}},{"line":154,"address":[5660644,5660761,5662169,5660721],"length":1,"stats":{"Line":0}},{"line":155,"address":[5660675],"length":1,"stats":{"Line":0}},{"line":156,"address":[5660753],"length":1,"stats":{"Line":0}},{"line":158,"address":[5661054,5662164,5661092,5660994,5661497],"length":1,"stats":{"Line":0}},{"line":159,"address":[5661129,5661072,5661239,5662159],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":68},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","mod.rs"],"content":"pub mod ddl;\npub mod dml;\npub mod other;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","desc_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::other::desc_table::DescTableQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn desc_table(\u0026self, query: DescTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = query.table_name.database_name.unwrap();\n        let table_name = query.table_name.table_name;\n\n        let base_path = self.get_data_directory();\n        let table_path = base_path\n            .join(database_name)\n            .join(\"tables\")\n            .join(\u0026table_name);\n        let config_path = table_path.join(\"table.config\");\n\n        match std::fs::read(config_path) {\n            Ok(read_result) =\u003e {\n                let table_info: TableConfig = encoder\n                    .decode(read_result.as_slice())\n                    .ok_or_else(|| ExecuteError::wrap(\"config decode error\"))?;\n\n                Ok(ExecuteResult {\n                    columns: (vec![\n                        ExecuteColumn {\n                            name: \"Field\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Type\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Null\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Default\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Comment\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                    ]),\n                    rows: table_info\n                        .columns\n                        .iter()\n                        .map(|e| ExecuteRow {\n                            fields: vec![\n                                ExecuteField::String(e.name.to_owned()),\n                                ExecuteField::String(e.data_type.to_owned().into()),\n                                ExecuteField::String(if e.not_null { \"NO\" } else { \"YES\" }.into()),\n                                ExecuteField::String(format!(\"{:?}\", e.default)), // TODO: 표현식 역 parsing 구현\n                                ExecuteField::String(e.comment.to_owned()),\n                            ],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(format!(\n                    \"table '{}' not exists\",\n                    table_name\n                ))),\n                _ =\u003e Err(ExecuteError::wrap(\"database listup failed\")),\n            },\n        }\n    }\n}\n","traces":[{"line":13,"address":[3983003,3982800,3986997,3982839,3982885,3986953,3985860],"length":1,"stats":{"Line":0}},{"line":14,"address":[3982996],"length":1,"stats":{"Line":0}},{"line":16,"address":[3983262,3983066],"length":1,"stats":{"Line":0}},{"line":17,"address":[3983270],"length":1,"stats":{"Line":0}},{"line":19,"address":[3983318],"length":1,"stats":{"Line":0}},{"line":20,"address":[3983513,3983377,3983611,3983746],"length":1,"stats":{"Line":0}},{"line":21,"address":[3983457],"length":1,"stats":{"Line":0}},{"line":23,"address":[3983670,3983551,3983753],"length":1,"stats":{"Line":0}},{"line":24,"address":[3983884],"length":1,"stats":{"Line":0}},{"line":26,"address":[3984012,3982883,3983961],"length":1,"stats":{"Line":0}},{"line":27,"address":[3984047],"length":1,"stats":{"Line":0}},{"line":28,"address":[3984216,3984479],"length":1,"stats":{"Line":0}},{"line":29,"address":[3984079],"length":1,"stats":{"Line":0}},{"line":30,"address":[3987052,3987040,3984399],"length":1,"stats":{"Line":0}},{"line":32,"address":[3985636],"length":1,"stats":{"Line":0}},{"line":33,"address":[3986071,3986023,3984384,3984611,3984557,3985007,3985139,3984875,3984743,3985241,3985895],"length":1,"stats":{"Line":0}},{"line":34,"address":[3984651],"length":1,"stats":{"Line":0}},{"line":35,"address":[3984565],"length":1,"stats":{"Line":0}},{"line":36,"address":[3984643],"length":1,"stats":{"Line":0}},{"line":38,"address":[3984783],"length":1,"stats":{"Line":0}},{"line":39,"address":[3984697],"length":1,"stats":{"Line":0}},{"line":40,"address":[3984775],"length":1,"stats":{"Line":0}},{"line":42,"address":[3984915],"length":1,"stats":{"Line":0}},{"line":43,"address":[3984829],"length":1,"stats":{"Line":0}},{"line":44,"address":[3984907],"length":1,"stats":{"Line":0}},{"line":46,"address":[3985047],"length":1,"stats":{"Line":0}},{"line":47,"address":[3984961],"length":1,"stats":{"Line":0}},{"line":48,"address":[3985039],"length":1,"stats":{"Line":0}},{"line":50,"address":[3985179],"length":1,"stats":{"Line":0}},{"line":51,"address":[3985093],"length":1,"stats":{"Line":0}},{"line":52,"address":[3985171],"length":1,"stats":{"Line":0}},{"line":55,"address":[3985492,3985567],"length":1,"stats":{"Line":0}},{"line":58,"address":[3988141,3987088,3988200],"length":1,"stats":{"Line":0}},{"line":59,"address":[3987661,3987136,3987914,3987834,3987176,3987255,3988179,3987484],"length":1,"stats":{"Line":0}},{"line":60,"address":[3987213,3987151],"length":1,"stats":{"Line":0}},{"line":61,"address":[3987294,3987233],"length":1,"stats":{"Line":0}},{"line":62,"address":[3987521,3987369],"length":1,"stats":{"Line":0}},{"line":63,"address":[3987693,3987569],"length":1,"stats":{"Line":0}},{"line":64,"address":[3987803,3987866],"length":1,"stats":{"Line":0}},{"line":70,"address":[3984108,3986433],"length":1,"stats":{"Line":0}},{"line":71,"address":[3986580],"length":1,"stats":{"Line":0}},{"line":75,"address":[3986550,3986724],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","mod.rs"],"content":"pub mod desc_table;\npub mod show_databases;\npub mod show_tables;\npub mod use_database;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","show_databases.rs"],"content":"use std::io::ErrorKind;\n\nuse futures::future::join_all;\n\nuse crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn show_databases(\n        \u0026self,\n        _query: ShowDatabasesQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        match std::fs::read_dir(\u0026base_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_dir() {\n                                    let mut path = entry.path();\n                                    path.push(\"database.config\");\n\n                                    match tokio::fs::read(path).await {\n                                        Ok(result) =\u003e {\n                                            let database_config: DatabaseConfig =\n                                                encoder.decode(result.as_slice()).unwrap();\n\n                                            Some(database_config.database_name)\n                                        }\n                                        Err(_) =\u003e None,\n                                    }\n                                } else {\n                                    None\n                                }\n                            }\n                            Err(_) =\u003e None,\n                        },\n                        Err(_) =\u003e None,\n                    }\n                });\n\n                let database_list = join_all(futures).await.into_iter().flatten();\n\n                Ok(ExecuteResult {\n                    columns: (vec![ExecuteColumn {\n                        name: \"database name\".into(),\n                        data_type: ExecuteColumnType::String,\n                    }]),\n                    rows: database_list\n                        .map(|e| ExecuteRow {\n                            fields: vec![ExecuteField::String(e)],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists\")),\n                _ =\u003e Err(ExecuteError::wrap(\"database listup failed\")),\n            },\n        }\n    }\n\n    pub async fn find_database(\u0026self, database_name: String) -\u003e Result\u003cbool, RRDBError\u003e {\n        let result = self.show_databases(ShowDatabasesQuery {}).await?;\n\n        Ok(result.rows.iter().any(|e| {\n            if let ExecuteField::String(name) = \u0026e.fields[0] {\n                name == \u0026database_name\n            } else {\n                false\n            }\n        }))\n    }\n}\n","traces":[{"line":15,"address":[5581072],"length":1,"stats":{"Line":0}},{"line":19,"address":[4371349,4373118],"length":1,"stats":{"Line":0}},{"line":21,"address":[4371448],"length":1,"stats":{"Line":0}},{"line":23,"address":[4371464,4371305,4371529],"length":1,"stats":{"Line":0}},{"line":24,"address":[4371555,4371568],"length":1,"stats":{"Line":0}},{"line":25,"address":[4373304,4374837,4371587,4373862,4371564,4373219,4373264,4373910,4373184,4373123,4373088],"length":1,"stats":{"Line":0}},{"line":26,"address":[4373257,4373272],"length":1,"stats":{"Line":0}},{"line":27,"address":[4373468,4373344],"length":1,"stats":{"Line":0}},{"line":28,"address":[4373482],"length":1,"stats":{"Line":0}},{"line":29,"address":[4373612,4373496,4373588],"length":1,"stats":{"Line":0}},{"line":30,"address":[4373614],"length":1,"stats":{"Line":0}},{"line":31,"address":[4373664],"length":1,"stats":{"Line":0}},{"line":33,"address":[4373737,4373942,4373331],"length":1,"stats":{"Line":0}},{"line":34,"address":[4374195],"length":1,"stats":{"Line":0}},{"line":36,"address":[4374351,4374221],"length":1,"stats":{"Line":0}},{"line":38,"address":[4374453],"length":1,"stats":{"Line":0}},{"line":40,"address":[4374262],"length":1,"stats":{"Line":0}},{"line":43,"address":[4373594],"length":1,"stats":{"Line":0}},{"line":46,"address":[4373519],"length":1,"stats":{"Line":0}},{"line":48,"address":[4373400],"length":1,"stats":{"Line":0}},{"line":52,"address":[4371383,4372087,4371766,4371711],"length":1,"stats":{"Line":0}},{"line":54,"address":[4372858],"length":1,"stats":{"Line":0}},{"line":55,"address":[4372485,4372445,4372337,4372391,4373057],"length":1,"stats":{"Line":0}},{"line":56,"address":[4372399],"length":1,"stats":{"Line":0}},{"line":57,"address":[4372477],"length":1,"stats":{"Line":0}},{"line":59,"address":[4372851,4372690],"length":1,"stats":{"Line":0}},{"line":60,"address":[4375219,4375194,4375160,4374912],"length":1,"stats":{"Line":0}},{"line":61,"address":[4375014,4374938],"length":1,"stats":{"Line":0}},{"line":66,"address":[4371614,4371875],"length":1,"stats":{"Line":0}},{"line":67,"address":[4371896,4371950],"length":1,"stats":{"Line":0}},{"line":68,"address":[4371923,4371995],"length":1,"stats":{"Line":0}},{"line":73,"address":[4376335,4376240,4375372,4375267,4375232,4375312,4375528],"length":1,"stats":{"Line":0}},{"line":74,"address":[4375365,4375305,4375560,4375399,4375952,4375470],"length":1,"stats":{"Line":0}},{"line":76,"address":[4376112,4376368,4375932],"length":1,"stats":{"Line":0}},{"line":77,"address":[4376400],"length":1,"stats":{"Line":0}},{"line":78,"address":[4376471],"length":1,"stats":{"Line":0}},{"line":80,"address":[4376503],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","show_tables.rs"],"content":"use std::io::ErrorKind;\n\nuse futures::future::join_all;\n\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn show_tables(\u0026self, query: ShowTablesQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n        let database_path = base_path.clone().join(query.database);\n        let tables_path = database_path.join(\"tables\");\n\n        match std::fs::read_dir(\u0026tables_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_dir() {\n                                    let mut path = entry.path();\n                                    path.push(\"table.config\");\n\n                                    match tokio::fs::read(path).await {\n                                        Ok(result) =\u003e {\n                                            let table_config: TableConfig =\n                                                match encoder.decode(result.as_slice()) {\n                                                    Some(decoded) =\u003e decoded,\n                                                    None =\u003e return None,\n                                                };\n\n                                            Some(table_config.table.table_name)\n                                        }\n                                        Err(_) =\u003e None,\n                                    }\n                                } else {\n                                    None\n                                }\n                            }\n                            Err(_) =\u003e None,\n                        },\n                        Err(_) =\u003e None,\n                    }\n                });\n\n                let table_list = join_all(futures).await.into_iter().flatten();\n\n                Ok(ExecuteResult {\n                    columns: (vec![ExecuteColumn {\n                        name: \"table name\".into(),\n                        data_type: ExecuteColumnType::String,\n                    }]),\n                    rows: table_list\n                        .map(|e| ExecuteRow {\n                            fields: vec![ExecuteField::String(e)],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists\")),\n                _ =\u003e Err(ExecuteError::wrap(\"table listup failed\")),\n            },\n        }\n    }\n}\n","traces":[{"line":15,"address":[5581152,5581160],"length":1,"stats":{"Line":0}},{"line":16,"address":[4295118,4292738],"length":1,"stats":{"Line":0}},{"line":18,"address":[4292835],"length":1,"stats":{"Line":0}},{"line":19,"address":[4292851,4292919],"length":1,"stats":{"Line":0}},{"line":20,"address":[4293110],"length":1,"stats":{"Line":0}},{"line":22,"address":[4293175,4292649,4293243],"length":1,"stats":{"Line":0}},{"line":23,"address":[4293272,4293291],"length":1,"stats":{"Line":0}},{"line":24,"address":[4296930,4295219,4295264,4295868,4295123,4293310,4295088,4293284,4295184,4295916,4295304],"length":1,"stats":{"Line":0}},{"line":25,"address":[4295257,4295272],"length":1,"stats":{"Line":0}},{"line":26,"address":[4295344,4295468],"length":1,"stats":{"Line":0}},{"line":27,"address":[4295482],"length":1,"stats":{"Line":0}},{"line":28,"address":[4295612,4295588,4295496],"length":1,"stats":{"Line":0}},{"line":29,"address":[4295614],"length":1,"stats":{"Line":0}},{"line":30,"address":[4295664],"length":1,"stats":{"Line":0}},{"line":32,"address":[4749886],"length":1,"stats":{"Line":0}},{"line":33,"address":[4296204],"length":1,"stats":{"Line":0}},{"line":35,"address":[4296365,4296233],"length":1,"stats":{"Line":0}},{"line":36,"address":[4296490],"length":1,"stats":{"Line":0}},{"line":37,"address":[4296417],"length":1,"stats":{"Line":0}},{"line":40,"address":[4296517],"length":1,"stats":{"Line":0}},{"line":42,"address":[4296275],"length":1,"stats":{"Line":0}},{"line":45,"address":[4295594],"length":1,"stats":{"Line":0}},{"line":48,"address":[4295519],"length":1,"stats":{"Line":0}},{"line":50,"address":[4295400],"length":1,"stats":{"Line":0}},{"line":54,"address":[4293498,4292772,4293443,4293867],"length":1,"stats":{"Line":0}},{"line":56,"address":[4294659],"length":1,"stats":{"Line":0}},{"line":57,"address":[4294126,4294997,4294183,4294237,4294277],"length":1,"stats":{"Line":0}},{"line":58,"address":[4294191],"length":1,"stats":{"Line":0}},{"line":59,"address":[4294269],"length":1,"stats":{"Line":0}},{"line":61,"address":[4294485,4294652],"length":1,"stats":{"Line":0}},{"line":62,"address":[4297360,4297642,4297667,4297608],"length":1,"stats":{"Line":0}},{"line":63,"address":[4297386,4297462],"length":1,"stats":{"Line":0}},{"line":68,"address":[4293340,4293612],"length":1,"stats":{"Line":0}},{"line":69,"address":[4293633,4293687],"length":1,"stats":{"Line":0}},{"line":70,"address":[4293660,4293732],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","use_database.rs"],"content":"use crate::{\n    ast::other::use_database::UseDatabaseQuery,\n    errors::RRDBError,\n    executor::predule::{\n        ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n    },\n};\n\nimpl Executor {\n    pub async fn use_databases(\u0026self, query: UseDatabaseQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database changed: {}\",\n                    query.database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":10,"address":[5581208,5581200],"length":1,"stats":{"Line":0}},{"line":11,"address":[7766450],"length":1,"stats":{"Line":0}},{"line":12,"address":[7765457,7765627,7765587,7766688,7765533],"length":1,"stats":{"Line":0}},{"line":13,"address":[7765541],"length":1,"stats":{"Line":0}},{"line":14,"address":[7765619],"length":1,"stats":{"Line":0}},{"line":16,"address":[7766683,7765804,7765899,7765861,7766300],"length":1,"stats":{"Line":0}},{"line":17,"address":[7765936,7766678,7765879,7766042],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","initializer.rs"],"content":"use std::path::PathBuf;\nuse std::process::{Command, Output};\n\nuse std::io::Error;\n\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::constants::{DEFAULT_CONFIG_BASEPATH, DEFAULT_CONFIG_FILENAME, DEFAULT_DATABASE_NAME};\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\n\nuse super::config::global::GlobalConfig;\nuse super::predule::Executor;\n\n#[cfg(target_os = \"macos\")]\nuse crate::constants::LAUNCHD_PLIST_PATH;\n\nimpl Executor {\n    // 기본 설정파일 세팅\n    pub async fn init_config(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // 1. 루트 디렉터리 생성 (없다면)\n        self.create_top_level_directory_if_not_exists().await?;\n\n        // 2. 전역 설정파일 생성 (없다면)\n        self.create_global_config_if_not_exists().await?;\n\n        // 3. 데이터 디렉터리 생성 (없다면)\n        self.create_data_directory_if_not_exists().await?;\n\n        // 4. 데몬 설정파일 생성 (없다면)\n        self.create_daemon_config_if_not_exists().await?;\n\n        // 5. 데몬 실행\n        self.start_daemon().await?;\n\n        Ok(())\n    }\n\n    pub async fn init_database(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // 6. 기본 데이터베이스 생성 (rrdb)\n        self.create_database(\n            CreateDatabaseQuery::builder()\n                .set_name(DEFAULT_DATABASE_NAME.into())\n                .set_if_not_exists(true),\n        )\n        .await?;\n\n        Ok(())\n    }\n\n    async fn create_top_level_directory_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let base_path = DEFAULT_CONFIG_BASEPATH;\n\n        if let Err(error) = self.file_system.create_dir(base_path).await {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                println!(\"path {:?}\", base_path);\n                println!(\"error: {:?}\", error.to_string());\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn create_global_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n\n        let mut global_path = base_path;\n        global_path.push(DEFAULT_CONFIG_FILENAME);\n\n        let global_info = GlobalConfig::default();\n        let global_config = toml::to_string(\u0026global_info).unwrap();\n\n        if let Err(error) = self\n            .file_system\n            .write_file(\n                global_path.to_str().unwrap_or_default(),\n                global_config.as_bytes(),\n            )\n            .await\n        {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        Ok(())\n    }\n\n    async fn create_data_directory_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let data_path = self.config.data_directory.clone();\n\n        if let Err(error) = self.file_system.create_dir(\u0026data_path).await {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n\n        Ok(())\n    }\n\n    #[cfg(target_os = \"linux\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        use crate::constants::SYSTEMD_DAEMON_SCRIPT;\n\n        let base_path = PathBuf::from(\"/etc/systemd/system/rrdb.service\");\n\n        self.write_and_check_err(base_path, SYSTEMD_DAEMON_SCRIPT)\n            .await\n    }\n\n    #[cfg(target_os = \"macos\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        use crate::constants::LAUNCHD_DAEMON_SCRIPT;\n\n        let base_path = PathBuf::from(LAUNCHD_PLIST_PATH);\n\n        self.write_and_check_err(base_path, LAUNCHD_DAEMON_SCRIPT)\n            .await\n    }\n\n    #[cfg(target_os = \"windows\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        Command::new(\"winget\").args([\"install\", \"--accept-package-agreements\", \"nssm\"]);\n\n        let output = Command::new(\"nssm.exe\")\n            .args([\n                \"install\",\n                \"rrdb\",\n                \"C:\\\\Program Files\\\\rrdb\\\\rrdb.exe\",\n                \"run\",\n            ])\n            .output();\n\n        self.check_output_status(output)\n    }\n\n    async fn write_and_check_err(\n        \u0026self,\n        base_path: PathBuf,\n        contents: \u0026str,\n    ) -\u003e Result\u003c(), RRDBError\u003e {\n        if let Err(error) = self\n            .file_system\n            .write_file(base_path.to_str().unwrap_or_default(), contents.as_bytes())\n            .await\n        {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n        Ok(())\n    }\n\n    async fn start_daemon(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let (program, args) = self.get_daemon_start_command();\n        let output = self.command_runner.run(Command::new(program).args(args));\n\n        self.check_output_status(output)\n    }\n\n    #[cfg(target_os = \"linux\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"systemctl\", vec![\"enable\", \"--now\", \"rrdb.service\"])\n    }\n\n    #[cfg(target_os = \"macos\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"launchctl\", vec![\"load\", LAUNCHD_PLIST_PATH])\n    }\n\n    #[cfg(target_os = \"windows\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"sc.exe\", vec![\"start\", \"rrdb\"])\n    }\n\n    fn check_output_status(\u0026self, output: Result\u003cOutput, Error\u003e) -\u003e Result\u003c(), RRDBError\u003e {\n        if output.is_err() {\n            Err(ExecuteError::wrap(\"failed to start daemon\"))\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[cfg(target_os = \"linux\")]\n    #[tokio::test]\n    async fn test_init_config() {\n        use mockall::predicate::eq;\n\n        use crate::executor::mocking::{\n            CommandRunner, FileSystem, MockCommandRunner, MockFileSystem,\n        };\n\n        use super::*;\n        use std::sync::Arc;\n\n        const CONFIG: \u0026[u8] = br##\"port = 22208\nhost = \"0.0.0.0\"\ndata_directory = \"/var/lib/rrdb/data\"\n\"##;\n\n        use crate::constants::SYSTEMD_DAEMON_SCRIPT;\n\n        struct TestCase {\n            name: \u0026'static str,\n            want_error: bool,\n            mock_file_system: Box\u003cdyn Fn() -\u003e Arc\u003cdyn FileSystem + Send + Sync\u003e\u003e,\n            mock_command_runner: Box\u003cdyn Fn() -\u003e Arc\u003cdyn CommandRunner + Send + Sync\u003e\u003e,\n            mock_config: Box\u003cdyn Fn() -\u003e Arc\u003cGlobalConfig\u003e\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"init 정상 동작 (linux)\",\n                want_error: false,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run().returning(|_| {\n                        Ok(Output {\n                            stderr: Vec::new(),\n                            stdout: Vec::new(),\n                            status: Default::default(),\n                        })\n                    });\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"최종 Command 실행 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run()\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"데몬 설정파일 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run()\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"데이터 디렉터리 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"전역 설정파일 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"최상위 디렉터리 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n        ];\n\n        for test_case in test_cases[..5].iter() {\n            let executor = Executor {\n                config: (test_case.mock_config)(),\n                file_system: (test_case.mock_file_system)(),\n                command_runner: (test_case.mock_command_runner)(),\n            };\n\n            let result = executor.init_config().await;\n\n            assert_eq!(\n                test_case.want_error,\n                result.is_err(),\n                \"{} - wanr_eror = {}, error = {:?}\",\n                test_case.name,\n                test_case.want_error,\n                result.err(),\n            );\n        }\n    }\n}\n","traces":[{"line":19,"address":[3646242,3645965,3645923,3646012,3646124,3645888,3646788],"length":1,"stats":{"Line":5}},{"line":21,"address":[3646039,3646184,3646274,3646566,3646741,3645985,3645958],"length":1,"stats":{"Line":2}},{"line":24,"address":[3647279,3646542,3646683,3647095,3646797,3646057],"length":1,"stats":{"Line":4}},{"line":27,"address":[3647071,3647221,3647766,3647284,3647582,3646075],"length":1,"stats":{"Line":4}},{"line":30,"address":[3646093,3647708,3647771,3648069,3648254,3647558],"length":1,"stats":{"Line":4}},{"line":33,"address":[3646111,3648549,3648195,3648259,3648045],"length":1,"stats":{"Line":3}},{"line":35,"address":[3648532],"length":1,"stats":{"Line":1}},{"line":38,"address":[3648752,3648804,3648707,3649041,3649218,3648672],"length":1,"stats":{"Line":0}},{"line":40,"address":[3649706,3649500,3649796,3649109,3649139,3649354],"length":1,"stats":{"Line":0}},{"line":41,"address":[3648966,3648797,3649034],"length":1,"stats":{"Line":0}},{"line":42,"address":[3648844,3649190,3649211,3648879,3649005],"length":1,"stats":{"Line":0}},{"line":45,"address":[3649132,3649434,3648831,3649166,3649622,3649259,3648745],"length":1,"stats":{"Line":0}},{"line":47,"address":[3649736],"length":1,"stats":{"Line":0}},{"line":50,"address":[3650010,3649962,3651215,3649843,3649885,3649808,3650169],"length":1,"stats":{"Line":5}},{"line":51,"address":[3649917],"length":1,"stats":{"Line":1}},{"line":53,"address":[3649941,3650201,3650064,3649878,3649989],"length":1,"stats":{"Line":2}},{"line":54,"address":[3650443,3650537],"length":1,"stats":{"Line":0}},{"line":55,"address":[3650602,3650689],"length":1,"stats":{"Line":0}},{"line":56,"address":[3650758,3650881],"length":1,"stats":{"Line":0}},{"line":57,"address":[3651013],"length":1,"stats":{"Line":0}},{"line":61,"address":[3651242],"length":1,"stats":{"Line":1}},{"line":64,"address":[3651280,3651446,3651489,3652400,3653012,3651327,3651384],"length":1,"stats":{"Line":5}},{"line":65,"address":[3651419],"length":1,"stats":{"Line":1}},{"line":67,"address":[3651539],"length":1,"stats":{"Line":1}},{"line":68,"address":[3651571],"length":1,"stats":{"Line":1}},{"line":70,"address":[3651650],"length":1,"stats":{"Line":1}},{"line":71,"address":[3651769,3651669],"length":1,"stats":{"Line":2}},{"line":73,"address":[3652017,3652357,3652302,3652541,3652630],"length":1,"stats":{"Line":5}},{"line":76,"address":[3652121],"length":1,"stats":{"Line":1}},{"line":77,"address":[3652240],"length":1,"stats":{"Line":1}},{"line":79,"address":[3652432,3652373,3652330,3651374,3651476,3652565],"length":1,"stats":{"Line":3}},{"line":81,"address":[3652784,3652675],"length":1,"stats":{"Line":2}},{"line":84,"address":[3653021],"length":1,"stats":{"Line":1}},{"line":87,"address":[3654322,3653257,3653300,3653104,3653205,3653151,3653628],"length":1,"stats":{"Line":5}},{"line":88,"address":[3653245,3653352],"length":1,"stats":{"Line":2}},{"line":90,"address":[3653481,3653287,3653384,3653195,3653660],"length":1,"stats":{"Line":2}},{"line":91,"address":[3653926,3654023],"length":1,"stats":{"Line":2}},{"line":92,"address":[3654088],"length":1,"stats":{"Line":1}},{"line":96,"address":[3654349],"length":1,"stats":{"Line":1}},{"line":100,"address":[3654451,3654416,3654493,3654732,3654546,3655033,3654583],"length":1,"stats":{"Line":5}},{"line":103,"address":[3654522],"length":1,"stats":{"Line":1}},{"line":105,"address":[3654632,3654685,3654858],"length":1,"stats":{"Line":3}},{"line":106,"address":[3654938,3654764,3654486,3654573,3654678,3654709],"length":1,"stats":{"Line":3}},{"line":135,"address":[5581376],"length":1,"stats":{"Line":1}},{"line":140,"address":[3655619,3655954,3655860,3655674,3655264],"length":1,"stats":{"Line":5}},{"line":142,"address":[3655422],"length":1,"stats":{"Line":1}},{"line":143,"address":[3655147,3655321,3655647,3655749,3655892,3655690],"length":1,"stats":{"Line":3}},{"line":145,"address":[3656015,3656112],"length":1,"stats":{"Line":2}},{"line":146,"address":[3656177],"length":1,"stats":{"Line":1}},{"line":149,"address":[3656485],"length":1,"stats":{"Line":1}},{"line":152,"address":[3657304,3656660,3656574,3656544,3657342],"length":1,"stats":{"Line":4}},{"line":153,"address":[3656653,3656731],"length":1,"stats":{"Line":2}},{"line":154,"address":[3656915,3656807],"length":1,"stats":{"Line":2}},{"line":156,"address":[3657130],"length":1,"stats":{"Line":1}},{"line":160,"address":[5581456],"length":1,"stats":{"Line":1}},{"line":161,"address":[5581474,5581649],"length":1,"stats":{"Line":1}},{"line":174,"address":[5581680,5581846],"length":1,"stats":{"Line":1}},{"line":175,"address":[5581713,5581776,5581758,5581844],"length":1,"stats":{"Line":4}},{"line":176,"address":[5581829,5581778],"length":1,"stats":{"Line":2}},{"line":178,"address":[5581769],"length":1,"stats":{"Line":1}}],"covered":50,"coverable":60},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","mocking.rs"],"content":"use std::process::{Command, Output};\n\nuse futures::io;\n\n#[mockall::automock]\n#[async_trait::async_trait]\npub trait FileSystem {\n    async fn create_dir(\u0026self, path: \u0026str) -\u003e io::Result\u003c()\u003e;\n    async fn write_file(\u0026self, path: \u0026str, content: \u0026[u8]) -\u003e io::Result\u003c()\u003e;\n}\n\npub struct RealFileSystem;\n\n#[async_trait::async_trait]\nimpl FileSystem for RealFileSystem {\n    async fn create_dir(\u0026self, path: \u0026str) -\u003e io::Result\u003c()\u003e {\n        tokio::fs::create_dir(path).await\n    }\n\n    async fn write_file(\u0026self, path: \u0026str, content: \u0026[u8]) -\u003e io::Result\u003c()\u003e {\n        tokio::fs::write(path, content).await\n    }\n}\n\n#[mockall::automock]\npub trait CommandRunner {\n    fn run(\u0026self, command: \u0026mut Command) -\u003e io::Result\u003cOutput\u003e;\n}\n\npub struct RealCommandRunner;\n\nimpl CommandRunner for RealCommandRunner {\n    fn run(\u0026self, command: \u0026mut Command) -\u003e io::Result\u003cOutput\u003e {\n        command.output()\n    }\n}\n","traces":[{"line":16,"address":[1851756],"length":1,"stats":{"Line":0}},{"line":17,"address":[4717440],"length":1,"stats":{"Line":0}},{"line":20,"address":[1851999],"length":1,"stats":{"Line":0}},{"line":21,"address":[4717573],"length":1,"stats":{"Line":0}},{"line":33,"address":[1850464],"length":1,"stats":{"Line":0}},{"line":34,"address":[1850499],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","mod.rs"],"content":"pub mod common;\npub mod config;\npub mod encoder;\n#[allow(clippy::module_inception)]\npub mod executor;\npub mod implements;\npub mod initializer;\npub mod mocking;\npub mod predule;\npub mod reduce;\npub mod result;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","predule.rs"],"content":"#![allow(unused_imports)]\npub use super::common::*;\npub use super::config::*;\npub use super::encoder::*;\npub use super::executor::*;\npub use super::implements::*;\npub use super::reduce::*;\npub use super::result::*;\npub use super::util::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","reduce.rs"],"content":"\n\nuse std::collections::HashMap;\n\nuse futures::future::join_all;\nuse itertools::Itertools;\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::types::{ AggregateFunction, BuiltInFunction, Column, Function, SQLExpression, TableName};\nuse crate::errors::predule::{TypeError, ExecuteError};\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ Executor, ExecuteColumnType};\n\nuse super::config::row::{TableDataFieldType, TableDataRow};\n\n#[derive(Debug, Default, Clone)]\npub struct ReduceContext {\n    pub table_alias_map: HashMap\u003cString, TableName\u003e,\n    pub row: Option\u003cTableDataRow\u003e,\n    pub config_columns: Vec\u003c(TableName, Column)\u003e,\n    pub total_count: usize,\n}\n\nimpl Executor {\n    pub async fn reduce_expression(\n        \u0026self,\n        expression: SQLExpression,\n        context: ReduceContext\n    ) -\u003e Result\u003cTableDataFieldType, RRDBError\u003e {\n        match expression {\n            SQLExpression::Integer(value) =\u003e Ok(TableDataFieldType::Integer(value)),\n            SQLExpression::Boolean(value) =\u003e Ok(TableDataFieldType::Boolean(value)),\n            SQLExpression::Float(value) =\u003e Ok(TableDataFieldType::Float(value.into())),\n            SQLExpression::String(value) =\u003e Ok(TableDataFieldType::String(value)),\n            SQLExpression::Null =\u003e Ok(TableDataFieldType::Null),\n            SQLExpression::List(list) =\u003e  {\n                let futures = list.value.into_iter().map(|e|{self.reduce_expression(e, context.clone())});\n                let fields = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, \n                _\u003e\u003e()?;\n\n                #[allow(unstable_name_collisions)]\n                let serialized: String = fields.into_iter().map(|e|e.to_string()).intersperse(\", \".to_owned()).collect();\n\n                Ok(TableDataFieldType::String(format!(\"({})\", serialized)))\n            }\n            SQLExpression::Unary(unary) =\u003e match unary.operator {\n                UnaryOperator::Neg =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Integer(value) =\u003e {\n                            Ok(TableDataFieldType::Integer(-value))\n                        }\n                        TableDataFieldType::Float(value) =\u003e {\n                            Ok(TableDataFieldType::Float(-value))\n                        }\n                        TableDataFieldType::Array(mut array) =\u003e {\n                            for e in \u0026mut array {\n                                match e {\n                                    TableDataFieldType::Integer(value) =\u003e {\n                                        *e = TableDataFieldType::Integer(-*value);\n                                    }\n                                    TableDataFieldType::Float(value) =\u003e {\n                                        *e = TableDataFieldType::Float(-*value);\n                                    }\n                                    _ =\u003e return  Err(TypeError::wrap(\n                                        \"unary '!' operator is valid only for integer and float types.\",\n                                    )),\n                                }\n                            }\n                            Ok(TableDataFieldType::Array(array))\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '-' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n                UnaryOperator::Pos =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Integer(_) =\u003e Ok(operand),\n                        TableDataFieldType::Float(_) =\u003e Ok(operand),\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '+' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n                UnaryOperator::Not =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Boolean(value) =\u003e {\n                            Ok(TableDataFieldType::Boolean(!value))\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '!' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n            },\n            SQLExpression::Binary(binary) =\u003e {\n                let lhs = Box::pin(self.reduce_expression(binary.lhs.clone(), context.clone())).await?;\n                let rhs = Box::pin(self.reduce_expression(binary.rhs.clone(), context.clone())).await?;\n\n                if lhs.type_code() != rhs.type_code() {\n                    return Err(TypeError::wrap(\n                        \"The types of lhs and rhs do not match.\",\n                    ));\n                }\n\n                if let TableDataFieldType::Array(ref left_array) = lhs {\n                    if let TableDataFieldType::Array(ref right_array) = rhs{\n                        let futures = (0..left_array.len()).map(|i|\n                           {\n                            let binary = binary.clone(); \n                            let context = context.clone(); \n                       \n                            async move {\n                                let expression = BinaryOperatorExpression {\n                                    operator: binary.operator.clone(),\n                                    lhs: left_array[i].clone().into(), \n                                    rhs: right_array[i].clone().into(),\n                                };\n                            \n                                match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                                    Ok(expression)=\u003e Ok(expression), \n                                    Err(error)=\u003eErr(error),\n                                }\n                            }\n                        });\n    \n                        let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                        return Ok(TableDataFieldType::Array(result));\n                    } else {\n                        let futures = left_array.iter().map(|e|async {\n                            let expression = BinaryOperatorExpression {\n                                operator: binary.operator.clone(),\n                                lhs: e.clone().into(), \n                                rhs: rhs.clone().into(),\n                            };\n                        \n                            match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                                Ok(expression)=\u003e Ok(expression), \n                                Err(error)=\u003eErr(error),\n                            }\n                        });\n\n                        let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                        return Ok(TableDataFieldType::Array(result));\n                    }\n                } else if let TableDataFieldType::Array(ref right_array) = rhs{\n                    let futures = right_array.iter().map(|e|async {\n                        let expression = BinaryOperatorExpression {\n                            operator: binary.operator.clone(),\n                            lhs: lhs.clone().into(), \n                            rhs: e.clone().into(),\n                        };\n                    \n                        match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                            Ok(expression)=\u003e Ok(expression), \n                            Err(error)=\u003eErr(error),\n                        }\n                    });\n\n                    let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                    return Ok(TableDataFieldType::Array(result));\n                }\n\n                match binary.operator {\n                    BinaryOperator::Add =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::String(\n                                    lhs_value + rhs_value.as_str(),\n                                ));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '-' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Sub =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value -rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '-' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::Mul =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value *rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value * rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '*' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::Div =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value / rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value / rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '/' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::And =\u003e match lhs {\n                        TableDataFieldType::Boolean(lhs_value) =\u003e {\n                            if let TableDataFieldType::Boolean(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u0026\u0026 rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary 'And' operator is valid only for boolean type.\",\n                        )),\n                    },\n                    BinaryOperator::Or =\u003e match lhs {\n                        TableDataFieldType::Boolean(lhs_value) =\u003e {\n                            if let TableDataFieldType::Boolean(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value || rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary 'Or' operator is valid only for boolean type.\",\n                        )),\n                    },\n                    BinaryOperator::Lt =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003c' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Gt =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003e' operator is valid only for integer and float and string types.\",\n                        )),\n                    }, \n                    BinaryOperator::Lte =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003c=' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Gte =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003e=' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Eq =\u003e\n                         Ok(TableDataFieldType::Boolean(lhs == rhs)),    \n                    BinaryOperator::Neq =\u003e\n                         Ok(TableDataFieldType::Boolean(lhs != rhs)),    \n                    BinaryOperator::Like =\u003e unimplemented!(\"미구현\"),   \n                    BinaryOperator::NotLike =\u003e unimplemented!(\"미구현\"),  \n                    BinaryOperator::In =\u003e unimplemented!(\"미구현\"),      \n                    BinaryOperator::NotIn =\u003e unimplemented!(\"미구현\"),  \n                    BinaryOperator::Is =\u003e unimplemented!(\"미구현\"),      \n                    BinaryOperator::IsNot =\u003e unimplemented!(\"미구현\"),  \n                }\n            }\n            SQLExpression::Between(between) =\u003e {\n                let _a =  Box::pin(self.reduce_expression(between.a, context.clone())).await?;\n                let _x =  Box::pin(self.reduce_expression(between.x, context.clone())).await?;\n                let _y =  Box::pin(self.reduce_expression(between.y, context)).await?;\n           \n                //Ok(TableDataFieldType::Boolean(x \u003c= a \u0026\u0026 a \u003c= y ))\n\n                unimplemented!(\"미구현\")\n            },\n            SQLExpression::NotBetween(_between) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::Parentheses(paren) =\u003e {\n                Box::pin(self.reduce_expression(paren.expression, context)).await\n            }\n            SQLExpression::FunctionCall(call) =\u003e {\n                match call.function {\n                    Function::BuiltIn(builtin)=\u003e{\n                        match builtin {\n                            BuiltInFunction::Aggregate(aggregate)=\u003e{\n                                match aggregate {\n                                    AggregateFunction::Count =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Count function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        let argument = call.arguments[0].clone();\n                                        let value = Box::pin(self.reduce_expression(argument, context.clone())).await?;\n\n                                        match value {\n                                            TableDataFieldType::Array(array) =\u003e {\n                                                \n                                                let value = array.into_iter().filter(|e|{\n                                                    #[allow(clippy::match_like_matches_macro)]\n                                                    match e {\n                                                        TableDataFieldType::Null =\u003e {\n                                                            false\n                                                        }, \n                                                        _ =\u003e true,\n                                                    }\n                                                }).count();\n\n                                                Ok(TableDataFieldType::Integer(value as i64))\n                                            }\n                                            TableDataFieldType::Null=\u003e {\n                                                Ok(TableDataFieldType::Integer(0))\n                                            }\n                                            _ =\u003e {\n                                                match context.row {\n                                                    Some(row) =\u003e {\n                                                        if let TableDataFieldType::Array(array) = \u0026row.fields[0].data {\n                                                            Ok(TableDataFieldType::Integer(array.len() as i64))\n                                                        }\n                                                        else {\n                                                            Ok(TableDataFieldType::Integer(0))\n                                                        }\n                                                    }\n                                                    None=\u003e {\n                                                        Ok(TableDataFieldType::Integer(0))\n                                                    }\n                                                }\n                                                \n                                            }\n                                        }\n                                    }\n                                    AggregateFunction::Sum =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Sum function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        let argument = call.arguments[0].clone();\n                                        let value = Box::pin(self.reduce_expression(argument, context.clone())).await?;\n\n                                        match value {\n                                            TableDataFieldType::Array(array) =\u003e {\n                                                let value = array.into_iter().fold(TableDataFieldType::Null, |acc, e|{\n                                                    match e {\n                                                        TableDataFieldType::Integer(integer) =\u003e {\n                                                            if let TableDataFieldType::Integer(acc_value) = acc  {\n                                                                TableDataFieldType::Integer(acc_value + integer)\n                                                            } else {\n                                                                TableDataFieldType::Integer(integer)\n                                                            }\n                                                        }, \n                                                        TableDataFieldType::Float(integer) =\u003e {\n                                                            if let TableDataFieldType::Float(acc_value) = acc  {\n                                                                TableDataFieldType::Float(acc_value + integer)\n                                                            } else {\n                                                                TableDataFieldType::Float(integer)\n                                                            }\n                                                        }, \n                                                        _ =\u003e acc,\n                                                    }\n                                                });\n\n                                                Ok(value)\n                                            }\n                                            _ =\u003e {\n                                                unimplemented!(\"미구현\");\n                                            }\n                                        } \n                                    }\n                                    AggregateFunction::Max =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Max function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        unimplemented!(\"미구현\");\n                                    }\n                                    AggregateFunction::Min =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Min function takes only one parameter.\",\n                                            ));\n                                        }\n                                        \n                                        unimplemented!(\"미구현\");\n                                    }\n                                    _ =\u003e unimplemented!(\"미구현\")\n                                }\n                            }\n                            BuiltInFunction::Conditional(_)=\u003e{\n                                unimplemented!(\"미구현\")\n                            }\n                        }\n                    }\n                    Function::UserDefined(_)=\u003eunimplemented!(\"미구현\"),\n                }\n            },\n            SQLExpression::Subquery(_) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::SelectColumn(select_column) =\u003e {\n                let column_name  = select_column.column_name.clone();\n\n                match context.row {\n                    Some(ref row) =\u003e {\n                        let same_name_datas = row.fields.iter().filter(|e|e.column_name == column_name).cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n                        // 없으면 오류\n                        if same_name_datas.is_empty() {\n                            return Err(ExecuteError::wrap(\n                                format!(\"1 column select '{:?}' not exists\", select_column),\n                            ));\n                        }\n\n                        // 테이블명 선택한게 있으면 \n                        match select_column.table_name {\n                            Some(ref table_name)=\u003e {\n                                \n                                if let Some(found) = same_name_datas.iter().find(|e|{\n                            \n                                    // alias가 있으면\n                                    if let Some(table_name) = context.table_alias_map.get(table_name) {\n                                        *table_name == e.table_name\n                                    }\n                                    // 없으면 자체 테이블명 비교\n                                    else {\n                                        table_name == \u0026e.table_name.table_name\n                                    }\n                                }) \n                                {\n                                    Ok(found.data.to_owned())\n                                } else{\n                                    Err(ExecuteError::wrap(\n                                        format!(\"column select '{:?}' is ambiguous\", select_column),\n                                    ))\n                                }\n                            }\n                            None=\u003e{\n                                if same_name_datas.len()\u003e=2 {\n                                     Err(ExecuteError::wrap(\n                                        format!(\"column select '{:?}' is ambiguous\", select_column),\n                                    ))\n                                } else {\n                                    Ok(same_name_datas[0].data.to_owned())\n                                }\n                            }\n                        }\n                    }\n                    None =\u003e {\n                        Err(ExecuteError::wrap(\n                            format!(\"column select '{:?}' not exists\", select_column),\n                        ))\n                    }\n                }\n                \n            },\n        }\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    pub fn reduce_type(\n        \u0026self,\n        expression: SQLExpression,\n        context: ReduceContext\n    ) -\u003e Result\u003cExecuteColumnType, RRDBError\u003e {\n        match expression {\n            SQLExpression::Integer(_) =\u003e Ok(ExecuteColumnType::Integer),\n            SQLExpression::Boolean(_) =\u003e Ok(ExecuteColumnType::Bool),\n            SQLExpression::Float(_) =\u003e Ok(ExecuteColumnType::Float),\n            SQLExpression::String(_) =\u003e Ok(ExecuteColumnType::String),\n            SQLExpression::Null =\u003e Ok(ExecuteColumnType::Null),\n            SQLExpression::List(_list) =\u003e  {\n                unimplemented!()\n            }\n            SQLExpression::Unary(unary) =\u003e match unary.operator {\n                UnaryOperator::Neg | UnaryOperator::Pos | UnaryOperator::Not =\u003e {\n                    self.reduce_type(unary.operand, context)\n                }\n            },\n            SQLExpression::Binary(binary) =\u003e {\n                let lhs = self.reduce_type(binary.lhs, context.clone())?;\n                let rhs = self.reduce_type(binary.rhs, context)?;\n\n                match binary.operator {\n                    BinaryOperator::Add | BinaryOperator::Sub | BinaryOperator::Mul | BinaryOperator::Div =\u003e {\n                        if let ExecuteColumnType::Null = lhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n        \n                        if let ExecuteColumnType::Null = rhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n\n                        Ok(lhs)\n                    },\n                    BinaryOperator::And | BinaryOperator::Or | BinaryOperator::Lt | BinaryOperator::Gt | BinaryOperator::Lte | BinaryOperator::Gte |  BinaryOperator::Eq | BinaryOperator::Neq | BinaryOperator::Like | BinaryOperator::NotLike | BinaryOperator::In | BinaryOperator::NotIn =\u003e {\n                        if let ExecuteColumnType::Null = lhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n        \n                        if let ExecuteColumnType::Null = rhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n\n                        Ok(ExecuteColumnType::Bool)\n                    },   \n                    BinaryOperator::Is | BinaryOperator::IsNot =\u003e {\n                        Ok(ExecuteColumnType::Bool)\n                    }\n                }\n            }\n            SQLExpression::Between(_) =\u003e {\n                Ok(ExecuteColumnType::Bool)\n            },\n            SQLExpression::NotBetween(_between) =\u003e Ok(ExecuteColumnType::Bool),\n            SQLExpression::Parentheses(paren) =\u003e {\n                 self.reduce_type(paren.expression, context)\n            }\n            SQLExpression::FunctionCall(call) =\u003e match call.function {\n                Function::BuiltIn(builtin) =\u003e {\n                    match builtin  {\n                        BuiltInFunction::Aggregate(aggregate)=\u003e {\n                            match aggregate {\n                                AggregateFunction::Sum =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Count =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Max =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Min =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                _ =\u003e unimplemented!(\"미구현\"),\n                            }\n                        }\n                        BuiltInFunction::Conditional(_)=\u003eunimplemented!(\"미구현\"),\n                    }\n                }\n                Function::UserDefined(_)=\u003e{\n                    unimplemented!(\"미구현\")\n                }\n            },\n            SQLExpression::Subquery(_) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::SelectColumn(select_column) =\u003e {\n                let column_name  = select_column.column_name.clone();\n                \n                if context.config_columns.is_empty() {\n                    return Err(ExecuteError::wrap(\n                        format!(\"column select '{:?}' not exists\", select_column),\n                    ));\n                }\n\n                let same_name_columns = context.config_columns.iter().filter(|(_, e)|e.name == column_name).cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n                // 테이블명 선택한게 있으면 \n                match select_column.table_name {\n                    Some(ref table_name)=\u003e {\n                        \n                        if let Some(found) = context.config_columns.iter().find(|(each_table_name, _)|{\n                    \n                            // alias가 있으면\n                            if let Some(table_name) = context.table_alias_map.get(table_name) {\n                                table_name == each_table_name\n                            }\n                            // 없으면 자체 테이블명 비교\n                            else {\n                                table_name == \u0026each_table_name.table_name\n                            }\n                        }) \n                        {\n                            Ok(found.1.data_type.to_owned().into())\n                        } else{\n                             Err(ExecuteError::wrap(\n                                format!(\"column select '{:?}' is ambiguous\", select_column),\n                            ))\n                        }\n                    }\n                    None=\u003e{\n                        if same_name_columns.len()\u003e=2 {\n                             Err(ExecuteError::wrap(\n                                format!(\"column select '{:?}' is ambiguous\", select_column),\n                            ))\n                        } else {\n                            Ok(same_name_columns[0].1.data_type.to_owned().into())\n                        }\n                    }\n                }\n            },\n        }\n    }\n}\n","traces":[{"line":26,"address":[5581872],"length":1,"stats":{"Line":0}},{"line":31,"address":[4056313,4056787],"length":1,"stats":{"Line":0}},{"line":32,"address":[4057707],"length":1,"stats":{"Line":0}},{"line":33,"address":[4057878],"length":1,"stats":{"Line":0}},{"line":34,"address":[4057827,4064558],"length":1,"stats":{"Line":0}},{"line":35,"address":[4058002],"length":1,"stats":{"Line":0}},{"line":36,"address":[4058371],"length":1,"stats":{"Line":0}},{"line":37,"address":[4058192],"length":1,"stats":{"Line":0}},{"line":38,"address":[4058230,4094864,4094889,4064656],"length":1,"stats":{"Line":0}},{"line":39,"address":[4067066,4056893,4064976,4064748,4067596],"length":1,"stats":{"Line":0}},{"line":43,"address":[4067629,4095132,4068203,4067680,4068224,4095104,4067450],"length":1,"stats":{"Line":0}},{"line":45,"address":[4068014],"length":1,"stats":{"Line":0}},{"line":47,"address":[4057200],"length":1,"stats":{"Line":0}},{"line":49,"address":[4059756,4059258,4068262,4068706,4058525,4056914,4070505],"length":1,"stats":{"Line":0}},{"line":51,"address":[4068639],"length":1,"stats":{"Line":0}},{"line":52,"address":[4068849],"length":1,"stats":{"Line":0}},{"line":53,"address":[4069013,4068873,4069112],"length":1,"stats":{"Line":0}},{"line":55,"address":[4068894],"length":1,"stats":{"Line":0}},{"line":56,"address":[4069210,4068912],"length":1,"stats":{"Line":0}},{"line":58,"address":[4068931],"length":1,"stats":{"Line":0}},{"line":59,"address":[4069361,4069634,4068979],"length":1,"stats":{"Line":0}},{"line":60,"address":[4069658],"length":1,"stats":{"Line":0}},{"line":61,"address":[4069730],"length":1,"stats":{"Line":0}},{"line":62,"address":[4069837,4069745],"length":1,"stats":{"Line":0}},{"line":64,"address":[4069782],"length":1,"stats":{"Line":0}},{"line":65,"address":[4070043,4069797],"length":1,"stats":{"Line":0}},{"line":67,"address":[4070209,4069692],"length":1,"stats":{"Line":0}},{"line":72,"address":[4069449],"length":1,"stats":{"Line":0}},{"line":74,"address":[4068819,4070346],"length":1,"stats":{"Line":0}},{"line":80,"address":[4058671,4056935,4059169,4070535,4070955,4058460],"length":1,"stats":{"Line":0}},{"line":82,"address":[4070908],"length":1,"stats":{"Line":0}},{"line":83,"address":[4071098],"length":1,"stats":{"Line":0}},{"line":84,"address":[4071251],"length":1,"stats":{"Line":0}},{"line":85,"address":[4071068,4071451],"length":1,"stats":{"Line":0}},{"line":91,"address":[4056956,4071520,4060355,4058590,4071972,4072319,4059845],"length":1,"stats":{"Line":0}},{"line":93,"address":[4071953],"length":1,"stats":{"Line":0}},{"line":94,"address":[4072085],"length":1,"stats":{"Line":0}},{"line":95,"address":[4072104],"length":1,"stats":{"Line":0}},{"line":97,"address":[4072201,4072286],"length":1,"stats":{"Line":0}},{"line":103,"address":[4057285],"length":1,"stats":{"Line":0}},{"line":104,"address":[4060428,4060463,4072776,4060841,4073395,4072334,4060922,4057307,4056977],"length":1,"stats":{"Line":0}},{"line":105,"address":[4073307,4073437,4056998,4073385,4072889,4072924,4072724,4084599,4073856],"length":1,"stats":{"Line":0}},{"line":107,"address":[4074120,4073823],"length":1,"stats":{"Line":0}},{"line":108,"address":[4084568,4074194],"length":1,"stats":{"Line":0}},{"line":113,"address":[4074224,4074171],"length":1,"stats":{"Line":0}},{"line":114,"address":[4074311,4074258],"length":1,"stats":{"Line":0}},{"line":115,"address":[4095437,4074336,4095216,4074415],"length":1,"stats":{"Line":0}},{"line":117,"address":[4095259],"length":1,"stats":{"Line":0}},{"line":118,"address":[4095277],"length":1,"stats":{"Line":0}},{"line":120,"address":[4095595,4095552,4095472,4097041,4096480,4095507,4095345],"length":1,"stats":{"Line":0}},{"line":121,"address":[4095910,4095560],"length":1,"stats":{"Line":0}},{"line":122,"address":[4095568],"length":1,"stats":{"Line":0}},{"line":123,"address":[4095696],"length":1,"stats":{"Line":0}},{"line":124,"address":[4095869,4095781],"length":1,"stats":{"Line":0}},{"line":127,"address":[4096521,4096074,4096407,4096470,4095622,4095545,4096153],"length":1,"stats":{"Line":0}},{"line":128,"address":[4096785],"length":1,"stats":{"Line":0}},{"line":129,"address":[4096927],"length":1,"stats":{"Line":0}},{"line":134,"address":[4084646,4074552,4057019,4074713,4085143],"length":1,"stats":{"Line":0}},{"line":135,"address":[4085006],"length":1,"stats":{"Line":0}},{"line":137,"address":[4097152,4074366,4097368,4097293,4097251,4097328,4097216,4097171,4074802,4098147],"length":1,"stats":{"Line":0}},{"line":138,"address":[4097301,4097584],"length":1,"stats":{"Line":0}},{"line":139,"address":[4097309],"length":1,"stats":{"Line":0}},{"line":140,"address":[4097432],"length":1,"stats":{"Line":0}},{"line":141,"address":[4097550,4097486],"length":1,"stats":{"Line":0}},{"line":144,"address":[4098188,4097355,4097821,4097745,4098079,4097286,4098137],"length":1,"stats":{"Line":0}},{"line":145,"address":[4098443],"length":1,"stats":{"Line":0}},{"line":146,"address":[4098585],"length":1,"stats":{"Line":0}},{"line":150,"address":[4057040,4085755,4075118,4085258,4074957],"length":1,"stats":{"Line":0}},{"line":151,"address":[4085618],"length":1,"stats":{"Line":0}},{"line":153,"address":[4075191,4074281],"length":1,"stats":{"Line":0}},{"line":154,"address":[4075214,4098803,4098880,4099699,4098688,4098845,4075307,4098768,4098920,4098714],"length":1,"stats":{"Line":0}},{"line":155,"address":[4099136,4098853],"length":1,"stats":{"Line":0}},{"line":156,"address":[4098861],"length":1,"stats":{"Line":0}},{"line":157,"address":[4098984],"length":1,"stats":{"Line":0}},{"line":158,"address":[4099038,4099102],"length":1,"stats":{"Line":0}},{"line":161,"address":[4098907,4099373,4099297,4099631,4098838,4099689,4099740],"length":1,"stats":{"Line":0}},{"line":162,"address":[4099995],"length":1,"stats":{"Line":0}},{"line":163,"address":[4100137],"length":1,"stats":{"Line":0}},{"line":167,"address":[4086367,4057061,4075623,4085870,4075462],"length":1,"stats":{"Line":0}},{"line":168,"address":[4086230],"length":1,"stats":{"Line":0}},{"line":171,"address":[4075237],"length":1,"stats":{"Line":0}},{"line":172,"address":[4075696],"length":1,"stats":{"Line":0}},{"line":173,"address":[4076456],"length":1,"stats":{"Line":0}},{"line":174,"address":[4076487,4076695],"length":1,"stats":{"Line":0}},{"line":175,"address":[4076718,4076781,4076875],"length":1,"stats":{"Line":0}},{"line":179,"address":[4076517],"length":1,"stats":{"Line":0}},{"line":180,"address":[4076551,4076935],"length":1,"stats":{"Line":0}},{"line":181,"address":[4076960,4077018],"length":1,"stats":{"Line":0}},{"line":185,"address":[4076581],"length":1,"stats":{"Line":0}},{"line":186,"address":[4077116,4076657],"length":1,"stats":{"Line":0}},{"line":187,"address":[4077377],"length":1,"stats":{"Line":0}},{"line":188,"address":[4077527,4077281,4077554,4077169],"length":1,"stats":{"Line":0}},{"line":193,"address":[4076426,4077605],"length":1,"stats":{"Line":0}},{"line":197,"address":[4075773],"length":1,"stats":{"Line":0}},{"line":198,"address":[4077686],"length":1,"stats":{"Line":0}},{"line":199,"address":[4077717,4077812],"length":1,"stats":{"Line":0}},{"line":200,"address":[4077995,4077835,4077898],"length":1,"stats":{"Line":0}},{"line":204,"address":[4077740],"length":1,"stats":{"Line":0}},{"line":205,"address":[4078025,4077774],"length":1,"stats":{"Line":0}},{"line":206,"address":[4078050,4078108],"length":1,"stats":{"Line":0}},{"line":210,"address":[4077656,4078206],"length":1,"stats":{"Line":0}},{"line":214,"address":[4075830],"length":1,"stats":{"Line":0}},{"line":215,"address":[4078267],"length":1,"stats":{"Line":0}},{"line":216,"address":[4078298,4078393],"length":1,"stats":{"Line":0}},{"line":217,"address":[4078480,4078416,4078577],"length":1,"stats":{"Line":0}},{"line":221,"address":[4078321],"length":1,"stats":{"Line":0}},{"line":222,"address":[4078607,4078355],"length":1,"stats":{"Line":0}},{"line":223,"address":[4078632,4078690],"length":1,"stats":{"Line":0}},{"line":227,"address":[4078237,4078788],"length":1,"stats":{"Line":0}},{"line":231,"address":[4075887],"length":1,"stats":{"Line":0}},{"line":232,"address":[4078849],"length":1,"stats":{"Line":0}},{"line":233,"address":[4078967,4078880],"length":1,"stats":{"Line":0}},{"line":234,"address":[4078998,4079055,4079229],"length":1,"stats":{"Line":0}},{"line":238,"address":[4078903],"length":1,"stats":{"Line":0}},{"line":239,"address":[4078937,4079259],"length":1,"stats":{"Line":0}},{"line":240,"address":[4079284,4079342],"length":1,"stats":{"Line":0}},{"line":244,"address":[4078819,4079440],"length":1,"stats":{"Line":0}},{"line":248,"address":[4075944],"length":1,"stats":{"Line":0}},{"line":249,"address":[4079471],"length":1,"stats":{"Line":0}},{"line":250,"address":[4079561,4079501],"length":1,"stats":{"Line":0}},{"line":251,"address":[4079592,4079631],"length":1,"stats":{"Line":0}},{"line":255,"address":[4079762,4079524],"length":1,"stats":{"Line":0}},{"line":259,"address":[4075974],"length":1,"stats":{"Line":0}},{"line":260,"address":[4079793],"length":1,"stats":{"Line":0}},{"line":261,"address":[4079823,4079883],"length":1,"stats":{"Line":0}},{"line":262,"address":[4079960,4079914],"length":1,"stats":{"Line":0}},{"line":266,"address":[4079846,4080084],"length":1,"stats":{"Line":0}},{"line":270,"address":[4076004],"length":1,"stats":{"Line":0}},{"line":271,"address":[4080145],"length":1,"stats":{"Line":0}},{"line":272,"address":[4080176,4080367],"length":1,"stats":{"Line":0}},{"line":273,"address":[4080390],"length":1,"stats":{"Line":0}},{"line":277,"address":[4080206],"length":1,"stats":{"Line":0}},{"line":278,"address":[4080527,4080231],"length":1,"stats":{"Line":0}},{"line":279,"address":[4080568,4080622],"length":1,"stats":{"Line":0}},{"line":283,"address":[4080261],"length":1,"stats":{"Line":0}},{"line":284,"address":[4080329,4080720],"length":1,"stats":{"Line":0}},{"line":285,"address":[4080884,4080789],"length":1,"stats":{"Line":0}},{"line":289,"address":[4080115,4081030],"length":1,"stats":{"Line":0}},{"line":293,"address":[4076081],"length":1,"stats":{"Line":0}},{"line":294,"address":[4081091],"length":1,"stats":{"Line":0}},{"line":295,"address":[4081122,4081313],"length":1,"stats":{"Line":0}},{"line":296,"address":[4081336],"length":1,"stats":{"Line":0}},{"line":300,"address":[4081152],"length":1,"stats":{"Line":0}},{"line":301,"address":[4081177,4081473],"length":1,"stats":{"Line":0}},{"line":302,"address":[4081568,4081514],"length":1,"stats":{"Line":0}},{"line":306,"address":[4081207],"length":1,"stats":{"Line":0}},{"line":307,"address":[4081275,4081666],"length":1,"stats":{"Line":0}},{"line":308,"address":[4081735,4081830],"length":1,"stats":{"Line":0}},{"line":312,"address":[4081976,4081061],"length":1,"stats":{"Line":0}},{"line":316,"address":[4076158],"length":1,"stats":{"Line":0}},{"line":317,"address":[4082037],"length":1,"stats":{"Line":0}},{"line":318,"address":[4082259,4082068],"length":1,"stats":{"Line":0}},{"line":319,"address":[4082282],"length":1,"stats":{"Line":0}},{"line":323,"address":[4082098],"length":1,"stats":{"Line":0}},{"line":324,"address":[4082123,4082419],"length":1,"stats":{"Line":0}},{"line":325,"address":[4082514,4082460],"length":1,"stats":{"Line":0}},{"line":329,"address":[4082153],"length":1,"stats":{"Line":0}},{"line":330,"address":[4082221,4082612],"length":1,"stats":{"Line":0}},{"line":331,"address":[4082780,4082665],"length":1,"stats":{"Line":0}},{"line":335,"address":[4082007,4082926],"length":1,"stats":{"Line":0}},{"line":339,"address":[4076235],"length":1,"stats":{"Line":0}},{"line":340,"address":[4082987],"length":1,"stats":{"Line":0}},{"line":341,"address":[4083209,4083018],"length":1,"stats":{"Line":0}},{"line":342,"address":[4083232],"length":1,"stats":{"Line":0}},{"line":346,"address":[4083048],"length":1,"stats":{"Line":0}},{"line":347,"address":[4083369,4083073],"length":1,"stats":{"Line":0}},{"line":348,"address":[4083464,4083410],"length":1,"stats":{"Line":0}},{"line":352,"address":[4083103],"length":1,"stats":{"Line":0}},{"line":353,"address":[4083562,4083171],"length":1,"stats":{"Line":0}},{"line":354,"address":[4083726,4083631],"length":1,"stats":{"Line":0}},{"line":358,"address":[4082957,4083872],"length":1,"stats":{"Line":0}},{"line":363,"address":[4083910,4076312],"length":1,"stats":{"Line":0}},{"line":365,"address":[4076354,4084015],"length":1,"stats":{"Line":0}},{"line":374,"address":[4057355],"length":1,"stats":{"Line":0}},{"line":375,"address":[4061490,4057415,4087973,4060949,4057082,4086786,4087307,4061396,4061469],"length":1,"stats":{"Line":0}},{"line":376,"address":[4057103,4087223,4087428,4089179,4088001,4088505,4087966,4087945,4087878],"length":1,"stats":{"Line":0}},{"line":377,"address":[4057124,4089206,4088435,4089641,4089118,4088628],"length":1,"stats":{"Line":0}},{"line":384,"address":[4057516],"length":1,"stats":{"Line":0}},{"line":385,"address":[4061638,4057546,4057145,4062148,4090297],"length":1,"stats":{"Line":0}},{"line":387,"address":[4057611],"length":1,"stats":{"Line":0}},{"line":388,"address":[4057651],"length":1,"stats":{"Line":0}},{"line":389,"address":[4062221],"length":1,"stats":{"Line":0}},{"line":390,"address":[4062258],"length":1,"stats":{"Line":0}},{"line":391,"address":[4062283],"length":1,"stats":{"Line":0}},{"line":392,"address":[4062297],"length":1,"stats":{"Line":0}},{"line":394,"address":[4062386,4063283],"length":1,"stats":{"Line":0}},{"line":395,"address":[4063330,4063941],"length":1,"stats":{"Line":0}},{"line":400,"address":[4063289,4063376],"length":1,"stats":{"Line":0}},{"line":401,"address":[4063383,4063840,4063913,4057166,4063934,4090665,4091080],"length":1,"stats":{"Line":0}},{"line":403,"address":[4091038],"length":1,"stats":{"Line":0}},{"line":404,"address":[4091244],"length":1,"stats":{"Line":0}},{"line":406,"address":[4100240,4091300,4091472],"length":1,"stats":{"Line":0}},{"line":408,"address":[4100250],"length":1,"stats":{"Line":0}},{"line":414,"address":[4100260],"length":1,"stats":{"Line":0}},{"line":416,"address":[4091512],"length":1,"stats":{"Line":0}},{"line":419,"address":[4091310],"length":1,"stats":{"Line":0}},{"line":422,"address":[4091193],"length":1,"stats":{"Line":0}},{"line":423,"address":[4091725],"length":1,"stats":{"Line":0}},{"line":424,"address":[4091854,4091778,4092001],"length":1,"stats":{"Line":0}},{"line":425,"address":[4091893,4092008],"length":1,"stats":{"Line":0}},{"line":428,"address":[4091905],"length":1,"stats":{"Line":0}},{"line":432,"address":[4091627],"length":1,"stats":{"Line":0}},{"line":440,"address":[4062566,4062353],"length":1,"stats":{"Line":0}},{"line":441,"address":[4063224,4062613],"length":1,"stats":{"Line":0}},{"line":446,"address":[4062572,4062659],"length":1,"stats":{"Line":0}},{"line":447,"address":[4063196,4062666,4063217,4057187,4092719,4063123,4092259],"length":1,"stats":{"Line":0}},{"line":449,"address":[4092700],"length":1,"stats":{"Line":0}},{"line":450,"address":[4092832],"length":1,"stats":{"Line":0}},{"line":451,"address":[4092888,4092945,4100682,4100272,4100748],"length":1,"stats":{"Line":0}},{"line":452,"address":[4100304],"length":1,"stats":{"Line":0}},{"line":453,"address":[4100402],"length":1,"stats":{"Line":0}},{"line":454,"address":[4100482,4100416,4100542,4100523],"length":1,"stats":{"Line":0}},{"line":455,"address":[4100491,4100535,4100544],"length":1,"stats":{"Line":0}},{"line":457,"address":[4100516],"length":1,"stats":{"Line":0}},{"line":460,"address":[4100437],"length":1,"stats":{"Line":0}},{"line":461,"address":[4100680,4100615,4100660,4100454],"length":1,"stats":{"Line":0}},{"line":462,"address":[4100672,4100629],"length":1,"stats":{"Line":0}},{"line":464,"address":[4100652],"length":1,"stats":{"Line":0}},{"line":467,"address":[4100352],"length":1,"stats":{"Line":0}},{"line":471,"address":[4092984],"length":1,"stats":{"Line":0}},{"line":479,"address":[4062419,4063980],"length":1,"stats":{"Line":0}},{"line":480,"address":[4063988,4064078],"length":1,"stats":{"Line":0}},{"line":488,"address":[4062452,4064117],"length":1,"stats":{"Line":0}},{"line":489,"address":[4064215,4064125],"length":1,"stats":{"Line":0}},{"line":508,"address":[4058288],"length":1,"stats":{"Line":0}},{"line":509,"address":[4058341],"length":1,"stats":{"Line":0}},{"line":511,"address":[4065089],"length":1,"stats":{"Line":0}},{"line":512,"address":[4065227],"length":1,"stats":{"Line":0}},{"line":513,"address":[4065480,4100784,4065250,4100801],"length":1,"stats":{"Line":0}},{"line":516,"address":[4065657,4065596],"length":1,"stats":{"Line":0}},{"line":517,"address":[4066872],"length":1,"stats":{"Line":0}},{"line":518,"address":[4066783],"length":1,"stats":{"Line":0}},{"line":523,"address":[4065663],"length":1,"stats":{"Line":0}},{"line":524,"address":[4065822],"length":1,"stats":{"Line":0}},{"line":526,"address":[4066760,4066633,4065846,4100832,4066280],"length":1,"stats":{"Line":0}},{"line":529,"address":[4100859],"length":1,"stats":{"Line":0}},{"line":530,"address":[4100920],"length":1,"stats":{"Line":0}},{"line":534,"address":[4100946],"length":1,"stats":{"Line":0}},{"line":538,"address":[4066442,4066557],"length":1,"stats":{"Line":0}},{"line":540,"address":[4066727],"length":1,"stats":{"Line":0}},{"line":541,"address":[4066638],"length":1,"stats":{"Line":0}},{"line":546,"address":[4065880,4066259,4065807],"length":1,"stats":{"Line":0}},{"line":547,"address":[4066226],"length":1,"stats":{"Line":0}},{"line":548,"address":[4066137],"length":1,"stats":{"Line":0}},{"line":551,"address":[4066024,4065886],"length":1,"stats":{"Line":0}},{"line":557,"address":[4065409],"length":1,"stats":{"Line":0}},{"line":558,"address":[4065320],"length":1,"stats":{"Line":0}},{"line":568,"address":[5587609,5581984,5583179],"length":1,"stats":{"Line":0}},{"line":573,"address":[5582039],"length":1,"stats":{"Line":0}},{"line":574,"address":[5582480],"length":1,"stats":{"Line":0}},{"line":575,"address":[5582556],"length":1,"stats":{"Line":0}},{"line":576,"address":[5582518],"length":1,"stats":{"Line":0}},{"line":577,"address":[5582594],"length":1,"stats":{"Line":0}},{"line":578,"address":[5582771],"length":1,"stats":{"Line":0}},{"line":579,"address":[5582632],"length":1,"stats":{"Line":0}},{"line":582,"address":[5582145],"length":1,"stats":{"Line":0}},{"line":584,"address":[5582801],"length":1,"stats":{"Line":0}},{"line":587,"address":[5582170],"length":1,"stats":{"Line":0}},{"line":588,"address":[5584507,5584623,5582190,5583206,5583466,5583553],"length":1,"stats":{"Line":0}},{"line":589,"address":[5583506,5584031,5584502,5583682],"length":1,"stats":{"Line":0}},{"line":591,"address":[5583959],"length":1,"stats":{"Line":0}},{"line":593,"address":[5584136],"length":1,"stats":{"Line":0}},{"line":594,"address":[5584221],"length":1,"stats":{"Line":0}},{"line":597,"address":[5584248],"length":1,"stats":{"Line":0}},{"line":598,"address":[5584291],"length":1,"stats":{"Line":0}},{"line":601,"address":[5584326],"length":1,"stats":{"Line":0}},{"line":604,"address":[5584152],"length":1,"stats":{"Line":0}},{"line":605,"address":[5584369],"length":1,"stats":{"Line":0}},{"line":608,"address":[5584399],"length":1,"stats":{"Line":0}},{"line":609,"address":[5584421],"length":1,"stats":{"Line":0}},{"line":612,"address":[5584459],"length":1,"stats":{"Line":0}},{"line":615,"address":[5584183],"length":1,"stats":{"Line":0}},{"line":620,"address":[5582241],"length":1,"stats":{"Line":0}},{"line":622,"address":[5582287],"length":1,"stats":{"Line":0}},{"line":623,"address":[5582350],"length":1,"stats":{"Line":0}},{"line":624,"address":[5584704,5582362],"length":1,"stats":{"Line":0}},{"line":626,"address":[5582405],"length":1,"stats":{"Line":0}},{"line":627,"address":[5584968],"length":1,"stats":{"Line":0}},{"line":628,"address":[5584999],"length":1,"stats":{"Line":0}},{"line":629,"address":[5585024],"length":1,"stats":{"Line":0}},{"line":630,"address":[5585038],"length":1,"stats":{"Line":0}},{"line":632,"address":[5585102],"length":1,"stats":{"Line":0}},{"line":635,"address":[5585137],"length":1,"stats":{"Line":0}},{"line":638,"address":[5585172],"length":1,"stats":{"Line":0}},{"line":641,"address":[5585207],"length":1,"stats":{"Line":0}},{"line":654,"address":[5582697],"length":1,"stats":{"Line":0}},{"line":655,"address":[5582733],"length":1,"stats":{"Line":0}},{"line":657,"address":[5585744,5585682],"length":1,"stats":{"Line":0}},{"line":658,"address":[5587078],"length":1,"stats":{"Line":0}},{"line":659,"address":[5586989],"length":1,"stats":{"Line":0}},{"line":663,"address":[4100992,4101008],"length":1,"stats":{"Line":0}},{"line":666,"address":[5586004],"length":1,"stats":{"Line":0}},{"line":667,"address":[5586067],"length":1,"stats":{"Line":0}},{"line":669,"address":[4101056,4101078],"length":1,"stats":{"Line":0}},{"line":672,"address":[4101086],"length":1,"stats":{"Line":0}},{"line":673,"address":[4101142],"length":1,"stats":{"Line":0}},{"line":677,"address":[4101170],"length":1,"stats":{"Line":0}},{"line":681,"address":[5586780,5586653],"length":1,"stats":{"Line":0}},{"line":683,"address":[5586914],"length":1,"stats":{"Line":0}},{"line":684,"address":[5586825],"length":1,"stats":{"Line":0}},{"line":689,"address":[5586497,5586148,5586047],"length":1,"stats":{"Line":0}},{"line":690,"address":[5586464],"length":1,"stats":{"Line":0}},{"line":691,"address":[5586375],"length":1,"stats":{"Line":0}},{"line":694,"address":[5586286,5586154],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":304},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","result.rs"],"content":"use itertools::Itertools;\n\nuse crate::{ast::types::DataType, pgwire::protocol::DataTypeOid};\n\nuse super::config::row::TableDataFieldType;\n\n#[derive(Debug, Clone)]\npub struct ExecuteResult {\n    pub rows: Vec\u003cExecuteRow\u003e,       // 데이터 행 -\u003e 실 데이터\n    pub columns: Vec\u003cExecuteColumn\u003e, // 데이터 열에 대한 메타데이터\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ExecuteColumn {\n    pub data_type: ExecuteColumnType,\n    pub name: String,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct ExecuteRow {\n    pub fields: Vec\u003cExecuteField\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum ExecuteColumnType {\n    Bool,\n    Integer,\n    Float,\n    String,\n    Null,\n}\n\nimpl From\u003cExecuteColumnType\u003e for DataTypeOid {\n    fn from(value: ExecuteColumnType) -\u003e DataTypeOid {\n        match value {\n            ExecuteColumnType::Bool =\u003e DataTypeOid::Bool,\n            ExecuteColumnType::Integer =\u003e DataTypeOid::Int8,\n            ExecuteColumnType::Float =\u003e DataTypeOid::Float8,\n            ExecuteColumnType::String =\u003e DataTypeOid::Text,\n            ExecuteColumnType::Null =\u003e DataTypeOid::Unspecified,\n        }\n    }\n}\n\nimpl From\u003cDataType\u003e for ExecuteColumnType {\n    fn from(value: DataType) -\u003e ExecuteColumnType {\n        match value {\n            DataType::Boolean =\u003e ExecuteColumnType::Bool,\n            DataType::Int =\u003e ExecuteColumnType::Integer,\n            DataType::Float =\u003e ExecuteColumnType::Float,\n            DataType::Varchar(_) =\u003e ExecuteColumnType::String,\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum ExecuteField {\n    Bool(bool),\n    Integer(i64),\n    Float(f64),\n    String(String),\n    Null,\n}\n\nimpl From\u003cTableDataFieldType\u003e for ExecuteField {\n    fn from(value: TableDataFieldType) -\u003e ExecuteField {\n        #[allow(unstable_name_collisions)]\n        match value {\n            TableDataFieldType::Boolean(value) =\u003e ExecuteField::Bool(value),\n            TableDataFieldType::Integer(value) =\u003e ExecuteField::Integer(value),\n            TableDataFieldType::Float(value) =\u003e ExecuteField::Float(value.into()),\n            TableDataFieldType::String(value) =\u003e ExecuteField::String(value),\n            TableDataFieldType::Array(value) =\u003e ExecuteField::String(\n                value\n                    .iter()\n                    .map(|e| e.to_string())\n                    .intersperse(\", \".to_owned())\n                    .collect(),\n            ),\n            TableDataFieldType::Null =\u003e ExecuteField::Null,\n        }\n    }\n}\n","traces":[{"line":34,"address":[7766736],"length":1,"stats":{"Line":0}},{"line":35,"address":[7766743],"length":1,"stats":{"Line":0}},{"line":36,"address":[7766776],"length":1,"stats":{"Line":0}},{"line":37,"address":[7766786],"length":1,"stats":{"Line":0}},{"line":38,"address":[7766796],"length":1,"stats":{"Line":0}},{"line":39,"address":[7766806],"length":1,"stats":{"Line":0}},{"line":40,"address":[7766816],"length":1,"stats":{"Line":0}},{"line":46,"address":[4187264],"length":1,"stats":{"Line":0}},{"line":47,"address":[4187274],"length":1,"stats":{"Line":0}},{"line":48,"address":[4187321],"length":1,"stats":{"Line":0}},{"line":49,"address":[4187307],"length":1,"stats":{"Line":0}},{"line":50,"address":[4187314],"length":1,"stats":{"Line":0}},{"line":51,"address":[4187328],"length":1,"stats":{"Line":0}},{"line":66,"address":[4187344,4187954],"length":1,"stats":{"Line":0}},{"line":68,"address":[4187366],"length":1,"stats":{"Line":0}},{"line":69,"address":[4187510],"length":1,"stats":{"Line":0}},{"line":70,"address":[4187407],"length":1,"stats":{"Line":0}},{"line":71,"address":[4187446],"length":1,"stats":{"Line":0}},{"line":72,"address":[4187559],"length":1,"stats":{"Line":0}},{"line":74,"address":[4187651,4187866,4187749],"length":1,"stats":{"Line":0}},{"line":76,"address":[1681107,1681072],"length":1,"stats":{"Line":0}},{"line":77,"address":[4187813],"length":1,"stats":{"Line":0}},{"line":80,"address":[4187673],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","util.rs"],"content":"use std::path::PathBuf;\n\nuse crate::executor::predule::Executor;\n\nimpl Executor {\n    // 데이터 저장 경로를 반환합니다..\n    pub fn get_data_directory(\u0026self) -\u003e PathBuf {\n        PathBuf::from(self.config.data_directory.clone())\n    }\n}\n","traces":[{"line":7,"address":[5587632],"length":1,"stats":{"Line":0}},{"line":8,"address":[5587662],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","mod.rs"],"content":"pub mod operator_token;\npub mod predule;\npub mod tokenizer;\npub mod tokens;\n\npub(crate) mod test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","operator_token.rs"],"content":"use crate::{\n    ast::dml::expressions::operators::{BinaryOperator, UnaryOperator},\n    errors::{predule::IntoError, RRDBError},\n};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum OperatorToken {\n    Plus,     // +\n    Minus,    // -\n    Asterisk, // *\n    Slash,    // /\n    Lt,       // A \u003c B\n    Gt,       // A \u003e B\n    Lte,      // A \u003c= B\n    Gte,      // A \u003e= B\n    Eq,       // A = B\n    Neq,      // A != B, A \u003c\u003e B\n    Not,      // !A\n}\n\nimpl OperatorToken {\n    pub fn is_binary_operator(\u0026self) -\u003e bool {\n        [\n            Self::Plus,\n            Self::Minus,\n            Self::Asterisk,\n            Self::Slash,\n            Self::Lt,\n            Self::Gt,\n            Self::Lte,\n            Self::Gte,\n            Self::Eq,\n            Self::Neq,\n        ]\n        .contains(self)\n    }\n\n    pub fn is_unary_operator(\u0026self) -\u003e bool {\n        [Self::Plus, Self::Minus, Self::Not].contains(self)\n    }\n}\n\nimpl TryInto\u003cBinaryOperator\u003e for OperatorToken {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cBinaryOperator, Self::Error\u003e {\n        match self {\n            Self::Plus =\u003e Ok(BinaryOperator::Add),\n            Self::Minus =\u003e Ok(BinaryOperator::Sub),\n            Self::Asterisk =\u003e Ok(BinaryOperator::Mul),\n            Self::Slash =\u003e Ok(BinaryOperator::Div),\n            Self::Lt =\u003e Ok(BinaryOperator::Lt),\n            Self::Gt =\u003e Ok(BinaryOperator::Gt),\n            Self::Lte =\u003e Ok(BinaryOperator::Lte),\n            Self::Gte =\u003e Ok(BinaryOperator::Gte),\n            Self::Eq =\u003e Ok(BinaryOperator::Eq),\n            Self::Neq =\u003e Ok(BinaryOperator::Neq),\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n}\n\nimpl TryInto\u003cUnaryOperator\u003e for OperatorToken {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cUnaryOperator, Self::Error\u003e {\n        match self {\n            Self::Plus =\u003e Ok(UnaryOperator::Pos),\n            Self::Minus =\u003e Ok(UnaryOperator::Neg),\n            Self::Not =\u003e Ok(UnaryOperator::Not),\n            _ =\u003e Err(IntoError::wrap(\"UnaryOperator Cast Error\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_operator_token_is_binary_operator() {\n        use super::OperatorToken;\n\n        let test_cases = vec![\n            (OperatorToken::Plus, true),\n            (OperatorToken::Minus, true),\n            (OperatorToken::Asterisk, true),\n            (OperatorToken::Slash, true),\n            (OperatorToken::Lt, true),\n            (OperatorToken::Gt, true),\n            (OperatorToken::Lte, true),\n            (OperatorToken::Gte, true),\n            (OperatorToken::Eq, true),\n            (OperatorToken::Neq, true),\n            (OperatorToken::Not, false),\n        ];\n\n        for (input, expected) in test_cases {\n            let got = input.is_binary_operator();\n            assert_eq!(got, expected);\n        }\n    }\n\n    #[test]\n    fn test_operator_token_is_unary_operator() {\n        use super::OperatorToken;\n\n        let test_cases = vec![\n            (OperatorToken::Plus, true),\n            (OperatorToken::Minus, true),\n            (OperatorToken::Asterisk, false),\n            (OperatorToken::Slash, false),\n            (OperatorToken::Lt, false),\n            (OperatorToken::Gt, false),\n            (OperatorToken::Lte, false),\n            (OperatorToken::Gte, false),\n            (OperatorToken::Eq, false),\n            (OperatorToken::Neq, false),\n            (OperatorToken::Not, true),\n        ];\n\n        for (input, expected) in test_cases {\n            let got = input.is_unary_operator();\n            assert_eq!(got, expected);\n        }\n    }\n\n    #[test]\n    fn test_operator_token_try_into_binary_operator() {\n        use super::{BinaryOperator, OperatorToken};\n        use std::convert::TryInto;\n\n        struct TestCase {\n            name: String,\n            input: OperatorToken,\n            want_error: bool,\n            expected: BinaryOperator,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"연산자: +\".to_owned(),\n                input: OperatorToken::Plus,\n                want_error: false,\n                expected: BinaryOperator::Add,\n            },\n            TestCase {\n                name: \"연산자: -\".to_owned(),\n                input: OperatorToken::Minus,\n                want_error: false,\n                expected: BinaryOperator::Sub,\n            },\n            TestCase {\n                name: \"연산자: *\".to_owned(),\n                input: OperatorToken::Asterisk,\n                want_error: false,\n                expected: BinaryOperator::Mul,\n            },\n            TestCase {\n                name: \"연산자: /\".to_owned(),\n                input: OperatorToken::Slash,\n                want_error: false,\n                expected: BinaryOperator::Div,\n            },\n            TestCase {\n                name: \"연산자: \u003c\".to_owned(),\n                input: OperatorToken::Lt,\n                want_error: false,\n                expected: BinaryOperator::Lt,\n            },\n            TestCase {\n                name: \"연산자: \u003e\".to_owned(),\n                input: OperatorToken::Gt,\n                want_error: false,\n                expected: BinaryOperator::Gt,\n            },\n            TestCase {\n                name: \"연산자: \u003c=\".to_owned(),\n                input: OperatorToken::Lte,\n                want_error: false,\n                expected: BinaryOperator::Lte,\n            },\n            TestCase {\n                name: \"연산자: \u003e=\".to_owned(),\n                input: OperatorToken::Gte,\n                want_error: false,\n                expected: BinaryOperator::Gte,\n            },\n            TestCase {\n                name: \"연산자: =\".to_owned(),\n                input: OperatorToken::Eq,\n                want_error: false,\n                expected: BinaryOperator::Eq,\n            },\n            TestCase {\n                name: \"연산자: !=\".to_owned(),\n                input: OperatorToken::Neq,\n                want_error: false,\n                expected: BinaryOperator::Neq,\n            },\n            TestCase {\n                name: \"연산자: !\".to_owned(),\n                input: OperatorToken::Not,\n                want_error: true,\n                expected: BinaryOperator::Neq,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cBinaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n\n    #[test]\n    fn test_operator_token_try_into_unary_operator() {\n        use super::{OperatorToken, UnaryOperator};\n        use std::convert::TryInto;\n\n        struct TestCase {\n            name: String,\n            input: OperatorToken,\n            want_error: bool,\n            expected: UnaryOperator,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"연산자: +\".to_owned(),\n                input: OperatorToken::Plus,\n                want_error: false,\n                expected: UnaryOperator::Pos,\n            },\n            TestCase {\n                name: \"연산자: -\".to_owned(),\n                input: OperatorToken::Minus,\n                want_error: false,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: *\".to_owned(),\n                input: OperatorToken::Asterisk,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: /\".to_owned(),\n                input: OperatorToken::Slash,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003c\".to_owned(),\n                input: OperatorToken::Lt,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003e\".to_owned(),\n                input: OperatorToken::Gt,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003c=\".to_owned(),\n                input: OperatorToken::Lte,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003e=\".to_owned(),\n                input: OperatorToken::Gte,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: =\".to_owned(),\n                input: OperatorToken::Eq,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: !=\".to_owned(),\n                input: OperatorToken::Neq,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: !\".to_owned(),\n                input: OperatorToken::Not,\n                want_error: false,\n                expected: UnaryOperator::Not,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cUnaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[3537456],"length":1,"stats":{"Line":1}},{"line":38,"address":[3537488],"length":1,"stats":{"Line":1}},{"line":39,"address":[3537496],"length":1,"stats":{"Line":1}},{"line":46,"address":[3537520,3537571],"length":1,"stats":{"Line":1}},{"line":47,"address":[3537540],"length":1,"stats":{"Line":1}},{"line":48,"address":[3537577],"length":1,"stats":{"Line":1}},{"line":49,"address":[3537605],"length":1,"stats":{"Line":1}},{"line":50,"address":[3537633],"length":1,"stats":{"Line":1}},{"line":51,"address":[3537661],"length":1,"stats":{"Line":1}},{"line":52,"address":[3537689],"length":1,"stats":{"Line":1}},{"line":53,"address":[3537717],"length":1,"stats":{"Line":1}},{"line":54,"address":[3537745],"length":1,"stats":{"Line":1}},{"line":55,"address":[3537770],"length":1,"stats":{"Line":1}},{"line":56,"address":[3537795],"length":1,"stats":{"Line":1}},{"line":57,"address":[3537820],"length":1,"stats":{"Line":1}},{"line":58,"address":[3537841],"length":1,"stats":{"Line":1}},{"line":66,"address":[3537904],"length":1,"stats":{"Line":1}},{"line":67,"address":[3537925],"length":1,"stats":{"Line":1}},{"line":68,"address":[3538017],"length":1,"stats":{"Line":1}},{"line":69,"address":[3538043],"length":1,"stats":{"Line":1}},{"line":70,"address":[3538069],"length":1,"stats":{"Line":1}},{"line":71,"address":[3537968],"length":1,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","predule.rs"],"content":"pub use super::operator_token::*;\npub use super::tokenizer::*;\npub use super::tokens::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","comment.rs"],"content":"#[cfg(test)]\nuse crate::lexer::predule::{Token, Tokenizer};\n\n#[test]\npub fn comment_1() {\n    let text = r#\"SELECT 1 -- asdf\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Integer(1),\n            Token::CodeComment(\" asdf\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn comment_2() {\n    let text = r#\"SELECT /*asdf*/1\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::CodeComment(\"asdf\".to_owned()),\n            Token::Integer(1),\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","mod.rs"],"content":"pub(crate) mod comment;\npub(crate) mod select;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","select.rs"],"content":"#[cfg(test)]\nuse crate::lexer::predule::OperatorToken;\n#[cfg(test)]\nuse crate::lexer::predule::{Token, Tokenizer};\n\n#[test]\npub fn test_number_literal() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"한자리수 정수\".to_owned(),\n            input: \"SELECT 1\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Integer(1)],\n        },\n        TestCase {\n            name: \"여러자리 정수\".to_owned(),\n            input: \"SELECT 1432\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Integer(1432)],\n        },\n        TestCase {\n            name: \"정수 파싱 실패\".to_owned(),\n            input: \"SELECT 1444444444444444444444444444444444444444444444444444444432\".to_owned(),\n            want_error: true,\n            expected: vec![],\n        },\n        TestCase {\n            name: \"실수: 3.14\".to_owned(),\n            input: \"SELECT 3.14\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Float(3.14)],\n        },\n        TestCase {\n            name: \"실수 파싱 실패: 3..14\".to_owned(),\n            input: \"SELECT 3..14\".to_owned(),\n            want_error: true,\n            expected: vec![],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn select_text() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"문자열: 'I''m Sam'\".to_owned(),\n        input: r#\"SELECT 'I''m Sam'\"#.to_owned(),\n        want_error: false,\n        expected: vec![Token::Select, Token::String(\"I'm Sam\".to_owned())],\n    }];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn test_errors() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"예상하지 못한 특수문자\".to_owned(),\n            input: r#\"SELECT @\"#.to_owned(),\n            want_error: true,\n        },\n        // TestCase {\n        //     name: \"예상하지 못한 특수문자: $\".to_owned(),\n        //     input: r#\"SELECT $\"#.to_owned(),\n        //     want_error: true,\n        // },\n        TestCase {\n            name: \"예상하지 못한 특수문자: $$$\".to_owned(),\n            input: r#\"SELECT $$$\"#.to_owned(),\n            want_error: true,\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n    }\n}\n\n#[test]\npub fn test_operators() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"연산자: /\".to_owned(),\n            input: r#\"SELECT 1 / 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Slash),\n                Token::Integer(2),\n            ],\n        },\n        TestCase {\n            name: \"연산자: \u003c\".to_owned(),\n            input: r#\"SELECT 1 \u003c 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Lt),\n                Token::Integer(2),\n            ],\n        },\n        TestCase {\n            name: \"연산자: \u003e\".to_owned(),\n            input: r#\"SELECT 1 \u003e 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Gt),\n                Token::Integer(2),\n            ],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn test_identifier() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"백틱 파싱\".to_owned(),\n            input: r#\"SELECT `foo`\"#.to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Identifier(\"foo\".to_owned())],\n        },\n        TestCase {\n            name: \"백틱 안에 백틱 파싱\".to_owned(),\n            input: r#\"SELECT `foo``bar`\"#.to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Identifier(\"foo`bar\".to_owned())],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn select_from_1() {\n    let text = r#\"SELECT name from person\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Identifier(\"name\".to_owned()),\n            Token::From,\n            Token::Identifier(\"person\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn select_from_2() {\n    let text = r#\"SELECT 1 from \"boom\"\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Integer(1),\n            Token::From,\n            Token::Identifier(\"boom\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn select_from_where_1() {\n    let text = r#\"SELECT name from person where\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Identifier(\"name\".to_owned()),\n            Token::From,\n            Token::Identifier(\"person\".to_owned()),\n            Token::Where,\n        ]\n    );\n}\n\n// #[test]\n// pub fn inner_join() {\n//     let text = r#\"\n//         SELECT\n//             p.name as name,\n//             s.name as schoolName\n//         from person as p\n//         inner join school as s\n//         on 1=1\n//             and p.school_id = s.id\n//     \"#\n//     .to_owned();\n\n//     let tokens = Tokenizer::string_to_tokens(text);\n\n//     assert_eq!(\n//         tokens,\n//         vec![\n//             Token::Select,\n//             Token::Identifier(\"p.name\".to_owned()),\n//             Token::As,\n//             Token::Identifier(\"name\".to_owned()),\n//             Token::From,\n//             Token::Identifier(\"person\".to_owned()),\n//             Token::Where,\n//         ]\n//     );\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","tokenizer.rs"],"content":"use crate::errors::predule::LexingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::logger::predule::Logger;\n\n#[derive(Debug)]\npub struct Tokenizer {\n    buffer: Vec\u003cchar\u003e,\n    buffer_index: usize,\n    last_char: char,\n}\n\nimpl Tokenizer {\n    pub fn new(text: String) -\u003e Self {\n        Logger::info(format!(\"SQL echo: {:?}\", text));\n        Self {\n            last_char: ' ',\n            buffer: text.chars().collect(),\n            buffer_index: 0,\n        }\n    }\n\n    pub fn is_whitespace(\u0026self) -\u003e bool {\n        self.last_char == ' ' || self.last_char == '\\n' || self.last_char == '\\t'\n    }\n\n    pub fn is_digit(\u0026self) -\u003e bool {\n        self.last_char.is_ascii_digit()\n    }\n\n    pub fn is_alphabet(\u0026self) -\u003e bool {\n        self.last_char.is_alphabetic()\n    }\n\n    pub fn is_alphabet_or_number(\u0026self) -\u003e bool {\n        self.last_char.is_alphanumeric()\n    }\n\n    pub fn is_underscore(\u0026self) -\u003e bool {\n        self.last_char == '_'\n    }\n\n    pub fn is_special_character(\u0026self) -\u003e bool {\n        ['+', '-', '*', '/', ',', '\u003e', '\u003c', '=', '!', '\\\\', '@'].contains(\u0026self.last_char)\n    }\n\n    pub fn is_quote(\u0026self) -\u003e bool {\n        ['\\'', '\"'].contains(\u0026self.last_char)\n    }\n\n    pub fn is_semicolon(\u0026self) -\u003e bool {\n        self.last_char == ';'\n    }\n\n    pub fn is_dot(\u0026self) -\u003e bool {\n        self.last_char == '.'\n    }\n\n    pub fn is_backtick(\u0026self) -\u003e bool {\n        self.last_char == '`'\n    }\n\n    pub fn is_parentheses(\u0026self) -\u003e bool {\n        self.last_char == '(' || self.last_char == ')'\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.buffer_index \u003e= self.buffer.len()\n    }\n\n    // 버퍼에서 문자 하나를 읽어서 last_char에 보관합니다.\n    pub fn read_char(\u0026mut self) {\n        if self.buffer_index \u003e= self.buffer.len() {\n            self.last_char = ' ';\n        } else {\n            self.last_char = self.buffer[self.buffer_index];\n            self.buffer_index += 1;\n        }\n    }\n\n    // 보관했던 문자 하나를 다시 버퍼에 돌려놓습니다.\n    pub fn unread_char(\u0026mut self) {\n        if self.buffer_index != 0 {\n            self.buffer_index -= 1;\n            self.last_char = self.buffer[self.buffer_index];\n        }\n    }\n\n    // 주어진 텍스트에서 토큰을 순서대로 획득해 반환합니다.\n    // 끝을 만날 경우 Token::EOF를 반환합니다.\n    pub fn get_token(\u0026mut self) -\u003e Result\u003cToken, RRDBError\u003e {\n        // 화이트 스페이스 삼킴\n        while self.is_whitespace() \u0026\u0026 !self.is_eof() {\n            self.read_char();\n        }\n\n        // 첫번째 글짜가 알파벳일 경우 식별자 및 키워드로 인식\n        let token = if self.is_alphabet() || self.is_underscore() {\n            let mut identifier = vec![self.last_char];\n\n            self.read_char();\n            while self.is_alphabet_or_number() || self.is_underscore() {\n                identifier.push(self.last_char);\n                self.read_char();\n            }\n\n            let identifier: String = identifier.into_iter().collect::\u003cString\u003e();\n\n            let token = match identifier.to_uppercase().as_str() {\n                \"SELECT\" =\u003e Token::Select,\n                \"FROM\" =\u003e Token::From,\n                \"WHERE\" =\u003e Token::Where,\n                \"AS\" =\u003e Token::As,\n                \"ORDER\" =\u003e Token::Order,\n                \"BY\" =\u003e Token::By,\n                \"ASC\" =\u003e Token::Asc,\n                \"DESC\" =\u003e Token::Desc,\n                \"GROUP\" =\u003e Token::Group,\n                \"HAVING\" =\u003e Token::Having,\n                \"LIMIT\" =\u003e Token::Limit,\n                \"OFFSET\" =\u003e Token::Offset,\n                \"INSERT\" =\u003e Token::Insert,\n                \"INTO\" =\u003e Token::Into,\n                \"VALUES\" =\u003e Token::Values,\n                \"UPDATE\" =\u003e Token::Update,\n                \"SET\" =\u003e Token::Set,\n                \"DELETE\" =\u003e Token::Delete,\n                \"JOIN\" =\u003e Token::Join,\n                \"INNER\" =\u003e Token::Inner,\n                \"LEFT\" =\u003e Token::Left,\n                \"RIGHT\" =\u003e Token::Right,\n                \"FULL\" =\u003e Token::Full,\n                \"OUTER\" =\u003e Token::Outer,\n                \"CREATE\" =\u003e Token::Create,\n                \"ALTER\" =\u003e Token::Alter,\n                \"DROP\" =\u003e Token::Drop,\n                \"DATABASE\" =\u003e Token::Database,\n                \"TABLE\" =\u003e Token::Table,\n                \"COLUMN\" =\u003e Token::Column,\n                \"COMMENT\" =\u003e Token::Comment,\n                \"PRIMARY\" =\u003e Token::Primary,\n                \"FOREIGN\" =\u003e Token::Foreign,\n                \"KEY\" =\u003e Token::Key,\n                \"ADD\" =\u003e Token::Add,\n                \"RENAME\" =\u003e Token::Rename,\n                \"TO\" =\u003e Token::To,\n                \"SHOW\" =\u003e Token::Show,\n                \"DATABASES\" =\u003e Token::Databases,\n                \"TABLES\" =\u003e Token::Tables,\n                \"AND\" =\u003e Token::And,\n                \"OR\" =\u003e Token::Or,\n                \"NOT\" =\u003e Token::Not,\n                \"BETWEEN\" =\u003e Token::Between,\n                \"LIKE\" =\u003e Token::Like,\n                \"IN\" =\u003e Token::In,\n                \"IS\" =\u003e Token::Is,\n                \"TRUE\" =\u003e Token::Boolean(true),\n                \"FALSE\" =\u003e Token::Boolean(false),\n                \"NULL\" =\u003e Token::Null,\n                \"DEFAULT\" =\u003e Token::Default,\n                \"IF\" =\u003e Token::If,\n                \"EXISTS\" =\u003e Token::Exists,\n                \"ON\" =\u003e Token::On,\n                \"USE\" =\u003e Token::Use,\n                \"DATA\" =\u003e Token::Data,\n                \"TYPE\" =\u003e Token::Type,\n                \"NULLS\" =\u003e Token::Nulls,\n                \"FIRST\" =\u003e Token::First,\n                \"LAST\" =\u003e Token::Last,\n                \"BEGIN\" =\u003e Token::Begin,\n                \"TRANSACTION\" =\u003e Token::Transaction,\n                \"COMMIT\" =\u003e Token::Commit,\n                \"ROLLBACK\" =\u003e Token::Rollback,\n                _ =\u003e Token::Identifier(identifier),\n            };\n\n            return Ok(token);\n        }\n        // 첫번째 글자가 숫자일 경우 정수 및 실수값으로 인식\n        else if self.is_digit() {\n            let mut number_string = vec![self.last_char];\n\n            // 숫자나 .이 나올 때까지만 버퍼에서 읽어서 number_string에 저장\n            loop {\n                self.read_char();\n                if self.is_digit() || self.is_dot() {\n                    number_string.push(self.last_char);\n                    continue;\n                } else if self.is_eof() {\n                    break;\n                } else {\n                    self.unread_char();\n                    break;\n                }\n            }\n\n            let number_string: String =\n                number_string.into_iter().collect::\u003cString\u003e().to_uppercase();\n\n            // .이 있을 경우 실수, 아닌 경우 정수로 인식\n            if number_string.contains('.') {\n                let number = number_string.parse::\u003cf64\u003e();\n\n                match number {\n                    Ok(number) =\u003e Token::Float(number),\n                    Err(_) =\u003e {\n                        return Err(LexingError::wrap(format!(\n                            \"invalid floating point number format: {}\",\n                            number_string\n                        )))\n                    }\n                }\n            } else {\n                let number = number_string.parse::\u003ci64\u003e();\n\n                match number {\n                    Ok(number) =\u003e Token::Integer(number),\n                    Err(_) =\u003e {\n                        return Err(LexingError::wrap(format!(\n                            \"invalid integer number format: {}\",\n                            number_string\n                        )))\n                    }\n                }\n            }\n        }\n        // 특수문자일 경우\n        else if self.is_special_character() {\n            match self.last_char {\n                ',' =\u003e Token::Comma,\n                '\\\\' =\u003e Token::Backslash,\n                '-' =\u003e {\n                    // 다음 문자가 또 -일 경우 행 단위 주석으로 처리\n                    self.read_char();\n\n                    if self.last_char == '-' {\n                        let mut comment = vec![];\n\n                        while !self.is_eof() {\n                            self.read_char();\n\n                            if self.last_char == '\\n' {\n                                break;\n                            } else {\n                                comment.push(self.last_char);\n                            }\n                        }\n\n                        let comment: String = comment.into_iter().collect();\n                        Token::CodeComment(comment)\n                    } else {\n                        self.unread_char();\n                        Token::Operator(OperatorToken::Minus)\n                    }\n                }\n                '/' =\u003e {\n                    // 다음 문자가 *일 경우 블록 단위 주석으로 처리\n\n                    self.read_char();\n\n                    if self.last_char == '*' {\n                        let mut comment = vec![];\n\n                        self.read_char();\n                        while !self.is_eof() {\n                            if self.last_char == '*' {\n                                self.read_char();\n                                if self.last_char == '/' {\n                                    break;\n                                }\n                            } else {\n                                comment.push(self.last_char);\n                            }\n\n                            self.read_char();\n                        }\n\n                        let comment: String = comment.into_iter().collect();\n                        Token::CodeComment(comment)\n                    } else {\n                        self.unread_char();\n                        Token::Operator(OperatorToken::Slash)\n                    }\n                }\n                '+' =\u003e Token::Operator(OperatorToken::Plus),\n                '*' =\u003e Token::Operator(OperatorToken::Asterisk),\n                '!' =\u003e Token::Operator(OperatorToken::Not), // TODO: != 연산자 처리\n                '=' =\u003e Token::Operator(OperatorToken::Eq),\n                '\u003c' =\u003e Token::Operator(OperatorToken::Lt), // TODO: \u003c= 연산자 처리\n                '\u003e' =\u003e Token::Operator(OperatorToken::Gt), // TODO: \u003e= 연산자 처리\n                _ =\u003e {\n                    return Err(LexingError::wrap(format!(\n                        \"unexpected operator: {:?}\",\n                        self.last_char\n                    )))\n                }\n            }\n        }\n        // 따옴표일 경우 처리\n        else if self.is_quote() {\n            if self.last_char == '\"' {\n                let mut identifier = vec![];\n\n                self.read_char();\n                while self.last_char != '\"' {\n                    identifier.push(self.last_char);\n                    self.read_char();\n                }\n\n                let identifier: String = identifier.into_iter().collect::\u003cString\u003e();\n\n                Token::Identifier(identifier)\n            } else {\n                let mut string = vec![];\n\n                self.read_char();\n                while !self.is_eof() {\n                    if self.last_char == '\\'' {\n                        self.read_char();\n\n                        // '' 의 형태일 경우 '로 이스케이프\n                        // 아닐 경우 문자열 종료\n                        if self.last_char == '\\'' {\n                            string.push(self.last_char);\n                        } else {\n                            self.unread_char();\n                            break;\n                        }\n                    } else {\n                        string.push(self.last_char);\n                    }\n\n                    self.read_char();\n                }\n\n                let string: String = string.into_iter().collect::\u003cString\u003e();\n\n                Token::String(string)\n            }\n        } else if self.is_backtick() {\n            let mut string = vec![];\n\n            self.read_char();\n            while !self.is_eof() {\n                if self.last_char == '`' {\n                    self.read_char();\n\n                    // `` 의 형태일 경우 `로 이스케이프\n                    // 아닐 경우 문자열 종료\n                    if self.last_char == '`' {\n                        string.push(self.last_char);\n                    } else {\n                        self.unread_char();\n                        break;\n                    }\n                } else {\n                    string.push(self.last_char);\n                }\n\n                self.read_char();\n            }\n\n            let string: String = string.into_iter().collect::\u003cString\u003e();\n\n            Token::Identifier(string)\n        }\n        // 세미콜론\n        else if self.is_semicolon() {\n            Token::SemiColon\n        }\n        // 마침표\n        else if self.is_dot() {\n            Token::Period\n        }\n        // 괄호\n        else if self.is_parentheses() {\n            if self.last_char == '(' {\n                Token::LeftParentheses\n            } else {\n                Token::RightParentheses\n            }\n        }\n        // 아무것도 해당되지 않을 경우 예외처리\n        else if self.is_eof() {\n            Token::EOF\n        } else {\n            return Err(LexingError::wrap(format!(\n                \"unexpected character: {:?}\",\n                self.last_char\n            )));\n        };\n\n        self.last_char = ' ';\n\n        Ok(token)\n    }\n\n    // Tokenizer 생성 없이 토큰 목록을 가져올 수 있는 유틸 함수입니다.\n    pub fn string_to_tokens(text: String) -\u003e Result\u003cVec\u003cToken\u003e, RRDBError\u003e {\n        let mut tokenizer = Tokenizer::new(text);\n\n        let mut tokens = vec![];\n\n        while !tokenizer.is_eof() {\n            tokens.push(tokenizer.get_token()?);\n        }\n\n        Ok(tokens)\n    }\n}\n","traces":[{"line":14,"address":[2036528,2036902],"length":1,"stats":{"Line":1}},{"line":15,"address":[2036671],"length":1,"stats":{"Line":1}},{"line":18,"address":[2036752],"length":1,"stats":{"Line":1}},{"line":23,"address":[2036928],"length":1,"stats":{"Line":1}},{"line":24,"address":[2036938],"length":1,"stats":{"Line":1}},{"line":27,"address":[2036992],"length":1,"stats":{"Line":2}},{"line":28,"address":[2036997],"length":1,"stats":{"Line":2}},{"line":31,"address":[2037024],"length":1,"stats":{"Line":2}},{"line":32,"address":[2037029],"length":1,"stats":{"Line":2}},{"line":35,"address":[2037056],"length":1,"stats":{"Line":2}},{"line":36,"address":[2037061],"length":1,"stats":{"Line":2}},{"line":39,"address":[2037088],"length":1,"stats":{"Line":3}},{"line":40,"address":[2037093],"length":1,"stats":{"Line":3}},{"line":43,"address":[2037120],"length":1,"stats":{"Line":1}},{"line":44,"address":[2037128],"length":1,"stats":{"Line":1}},{"line":47,"address":[2037168],"length":1,"stats":{"Line":2}},{"line":48,"address":[2037176],"length":1,"stats":{"Line":2}},{"line":51,"address":[2037216],"length":1,"stats":{"Line":1}},{"line":52,"address":[2037221],"length":1,"stats":{"Line":1}},{"line":55,"address":[2037248],"length":1,"stats":{"Line":1}},{"line":56,"address":[2037253],"length":1,"stats":{"Line":1}},{"line":59,"address":[2037280],"length":1,"stats":{"Line":2}},{"line":60,"address":[2037285],"length":1,"stats":{"Line":2}},{"line":63,"address":[2037312],"length":1,"stats":{"Line":1}},{"line":64,"address":[2037322],"length":1,"stats":{"Line":1}},{"line":67,"address":[2037376],"length":1,"stats":{"Line":1}},{"line":68,"address":[2037385],"length":1,"stats":{"Line":1}},{"line":72,"address":[2037424],"length":1,"stats":{"Line":1}},{"line":73,"address":[2037547,2037438,2037531],"length":1,"stats":{"Line":4}},{"line":74,"address":[2037524],"length":1,"stats":{"Line":1}},{"line":76,"address":[2037470],"length":1,"stats":{"Line":1}},{"line":77,"address":[2037543,2037499,2037549],"length":1,"stats":{"Line":2}},{"line":82,"address":[2037584],"length":1,"stats":{"Line":1}},{"line":83,"address":[2037598,2037678],"length":1,"stats":{"Line":2}},{"line":84,"address":[2037615,2037680],"length":1,"stats":{"Line":1}},{"line":85,"address":[2037649],"length":1,"stats":{"Line":1}},{"line":91,"address":[2039158,2037696,2039126],"length":1,"stats":{"Line":1}},{"line":93,"address":[2037843,2037735],"length":1,"stats":{"Line":2}},{"line":94,"address":[2037860],"length":1,"stats":{"Line":1}},{"line":98,"address":[2037824,2037875],"length":1,"stats":{"Line":4}},{"line":99,"address":[2042728,2042783,2037886],"length":1,"stats":{"Line":4}},{"line":101,"address":[2042845,2042768],"length":1,"stats":{"Line":4}},{"line":102,"address":[2042855,2042928],"length":1,"stats":{"Line":5}},{"line":103,"address":[2042903],"length":1,"stats":{"Line":2}},{"line":104,"address":[2047188],"length":1,"stats":{"Line":3}},{"line":107,"address":[2042934],"length":1,"stats":{"Line":3}},{"line":109,"address":[2043044,2043112,2043207],"length":1,"stats":{"Line":9}},{"line":110,"address":[2043223,2043289],"length":1,"stats":{"Line":6}},{"line":111,"address":[2043345,2043266,2043306],"length":1,"stats":{"Line":3}},{"line":112,"address":[2043322,2043362,2043401],"length":1,"stats":{"Line":3}},{"line":113,"address":[2043378,2043418,2043457],"length":1,"stats":{"Line":3}},{"line":114,"address":[2043474,2043434,2043513],"length":1,"stats":{"Line":3}},{"line":115,"address":[2043530,2043490,2043569],"length":1,"stats":{"Line":3}},{"line":116,"address":[2043586,2043546,2043625],"length":1,"stats":{"Line":3}},{"line":117,"address":[2043642,2043681,2043602],"length":1,"stats":{"Line":3}},{"line":118,"address":[2043698,2043737,2043658],"length":1,"stats":{"Line":3}},{"line":119,"address":[2043714,2043754,2043793],"length":1,"stats":{"Line":3}},{"line":120,"address":[2043810,2043849,2043770],"length":1,"stats":{"Line":3}},{"line":121,"address":[2043826,2043905,2043866],"length":1,"stats":{"Line":5}},{"line":122,"address":[2043922,2043882,2043961],"length":1,"stats":{"Line":6}},{"line":123,"address":[2043938,2044017,2043978],"length":1,"stats":{"Line":6}},{"line":124,"address":[2044034,2044073,2043994],"length":1,"stats":{"Line":5}},{"line":125,"address":[2044050,2044129,2044090],"length":1,"stats":{"Line":4}},{"line":126,"address":[2044185,2044106,2044146],"length":1,"stats":{"Line":4}},{"line":127,"address":[2044202,2044241,2044162],"length":1,"stats":{"Line":2}},{"line":128,"address":[2044258,2044218,2044297],"length":1,"stats":{"Line":3}},{"line":129,"address":[2044274,2044314,2044353],"length":1,"stats":{"Line":3}},{"line":130,"address":[2044409,2044330,2044370],"length":1,"stats":{"Line":4}},{"line":131,"address":[2044426,2044465,2044386],"length":1,"stats":{"Line":3}},{"line":132,"address":[2044482,2044442,2044521],"length":1,"stats":{"Line":3}},{"line":133,"address":[2044577,2044538,2044498],"length":1,"stats":{"Line":3}},{"line":134,"address":[2044594,2044633,2044554],"length":1,"stats":{"Line":5}},{"line":135,"address":[2044689,2044610,2044650],"length":1,"stats":{"Line":6}},{"line":136,"address":[2044706,2044745,2044666],"length":1,"stats":{"Line":3}},{"line":137,"address":[2044801,2044722,2044762],"length":1,"stats":{"Line":4}},{"line":138,"address":[2044857,2044778,2044818],"length":1,"stats":{"Line":4}},{"line":139,"address":[2044834,2044874,2044913],"length":1,"stats":{"Line":3}},{"line":140,"address":[2044969,2044930,2044890],"length":1,"stats":{"Line":2}},{"line":141,"address":[2044946,2044986,2045025],"length":1,"stats":{"Line":3}},{"line":142,"address":[2045081,2045042,2045002],"length":1,"stats":{"Line":2}},{"line":143,"address":[2045137,2045098,2045058],"length":1,"stats":{"Line":3}},{"line":144,"address":[2045114,2045193,2045154],"length":1,"stats":{"Line":4}},{"line":145,"address":[2045249,2045170,2045210],"length":1,"stats":{"Line":3}},{"line":146,"address":[2045226,2045266,2045305],"length":1,"stats":{"Line":3}},{"line":147,"address":[2045282,2045361,2045322],"length":1,"stats":{"Line":4}},{"line":148,"address":[2045378,2045338,2045417],"length":1,"stats":{"Line":3}},{"line":149,"address":[2045434,2045473,2045394],"length":1,"stats":{"Line":3}},{"line":150,"address":[2045490,2045450,2045529],"length":1,"stats":{"Line":3}},{"line":151,"address":[2045546,2045585,2045506],"length":1,"stats":{"Line":4}},{"line":152,"address":[2045562,2045602,2045641],"length":1,"stats":{"Line":5}},{"line":153,"address":[2045618,2045658,2045697],"length":1,"stats":{"Line":5}},{"line":154,"address":[2045714,2045674,2045753],"length":1,"stats":{"Line":4}},{"line":155,"address":[2045809,2045730,2045770],"length":1,"stats":{"Line":5}},{"line":156,"address":[2045826,2045865,2045786],"length":1,"stats":{"Line":4}},{"line":157,"address":[2045842,2045882,2045921],"length":1,"stats":{"Line":5}},{"line":158,"address":[2045898,2045985,2045946],"length":1,"stats":{"Line":3}},{"line":159,"address":[2046049,2046010,2045962],"length":1,"stats":{"Line":5}},{"line":160,"address":[2046026,2046066,2046105],"length":1,"stats":{"Line":5}},{"line":161,"address":[2046082,2046122,2046161],"length":1,"stats":{"Line":5}},{"line":162,"address":[2046217,2046138,2046178],"length":1,"stats":{"Line":5}},{"line":163,"address":[2046234,2046273,2046194],"length":1,"stats":{"Line":5}},{"line":164,"address":[2046329,2046250,2046290],"length":1,"stats":{"Line":5}},{"line":165,"address":[2046385,2046306,2046346],"length":1,"stats":{"Line":5}},{"line":166,"address":[2046402,2046441,2046362],"length":1,"stats":{"Line":5}},{"line":167,"address":[2046418,2046458,2046497],"length":1,"stats":{"Line":6}},{"line":168,"address":[2046553,2046514,2046474],"length":1,"stats":{"Line":5}},{"line":169,"address":[2046530,2046570,2046609],"length":1,"stats":{"Line":5}},{"line":170,"address":[2046665,2046626,2046586],"length":1,"stats":{"Line":5}},{"line":171,"address":[2046642,2046682,2046721],"length":1,"stats":{"Line":5}},{"line":172,"address":[2046698,2046777,2046738],"length":1,"stats":{"Line":5}},{"line":173,"address":[2046914,2046794,2046754],"length":1,"stats":{"Line":5}},{"line":174,"address":[2046800],"length":1,"stats":{"Line":2}},{"line":177,"address":[2046989],"length":1,"stats":{"Line":3}},{"line":180,"address":[2042541,2037952],"length":1,"stats":{"Line":3}},{"line":181,"address":[2041313,2041352,2037980],"length":1,"stats":{"Line":2}},{"line":184,"address":[2041342],"length":1,"stats":{"Line":1}},{"line":185,"address":[2041381],"length":1,"stats":{"Line":1}},{"line":186,"address":[2041522,2041437],"length":1,"stats":{"Line":2}},{"line":187,"address":[2042686,2041494],"length":1,"stats":{"Line":2}},{"line":189,"address":[2041536],"length":1,"stats":{"Line":1}},{"line":192,"address":[2041571,2041645],"length":1,"stats":{"Line":2}},{"line":197,"address":[2041647,2041578],"length":1,"stats":{"Line":2}},{"line":201,"address":[2042432,2041855,2042080],"length":1,"stats":{"Line":3}},{"line":202,"address":[2041969,2042360],"length":1,"stats":{"Line":2}},{"line":204,"address":[2042379],"length":1,"stats":{"Line":1}},{"line":205,"address":[2042397],"length":1,"stats":{"Line":1}},{"line":207,"address":[2042546],"length":1,"stats":{"Line":1}},{"line":214,"address":[2042011,2041938],"length":1,"stats":{"Line":2}},{"line":216,"address":[2042030],"length":1,"stats":{"Line":1}},{"line":217,"address":[2042048],"length":1,"stats":{"Line":1}},{"line":219,"address":[2042200],"length":1,"stats":{"Line":1}},{"line":228,"address":[2037969],"length":1,"stats":{"Line":1}},{"line":229,"address":[2038065],"length":1,"stats":{"Line":1}},{"line":230,"address":[2040158],"length":1,"stats":{"Line":1}},{"line":231,"address":[2040171],"length":1,"stats":{"Line":1}},{"line":234,"address":[2040192],"length":1,"stats":{"Line":1}},{"line":236,"address":[2040532,2040205,2040831],"length":1,"stats":{"Line":3}},{"line":237,"address":[2040466],"length":1,"stats":{"Line":1}},{"line":239,"address":[2040545,2040607],"length":1,"stats":{"Line":2}},{"line":240,"address":[2040621],"length":1,"stats":{"Line":1}},{"line":242,"address":[2040703],"length":1,"stats":{"Line":1}},{"line":245,"address":[2040717],"length":1,"stats":{"Line":1}},{"line":249,"address":[2040628,2040740],"length":1,"stats":{"Line":2}},{"line":250,"address":[2040767],"length":1,"stats":{"Line":1}},{"line":252,"address":[2040497],"length":1,"stats":{"Line":1}},{"line":253,"address":[2040502],"length":1,"stats":{"Line":1}},{"line":259,"address":[2040228],"length":1,"stats":{"Line":1}},{"line":261,"address":[2041271,2040241,2040937],"length":1,"stats":{"Line":3}},{"line":262,"address":[2040858],"length":1,"stats":{"Line":1}},{"line":264,"address":[2040983,2040887],"length":1,"stats":{"Line":2}},{"line":265,"address":[2040993],"length":1,"stats":{"Line":1}},{"line":266,"address":[2041028],"length":1,"stats":{"Line":1}},{"line":267,"address":[2041111],"length":1,"stats":{"Line":1}},{"line":268,"address":[2041152],"length":1,"stats":{"Line":1}},{"line":272,"address":[2041173,2041126],"length":1,"stats":{"Line":2}},{"line":275,"address":[2041175,2041166],"length":1,"stats":{"Line":2}},{"line":278,"address":[2041180,2041036],"length":1,"stats":{"Line":2}},{"line":279,"address":[2041207],"length":1,"stats":{"Line":1}},{"line":281,"address":[2040902],"length":1,"stats":{"Line":1}},{"line":282,"address":[2040907],"length":1,"stats":{"Line":1}},{"line":285,"address":[2040256],"length":1,"stats":{"Line":1}},{"line":286,"address":[2040291],"length":1,"stats":{"Line":1}},{"line":287,"address":[2040326],"length":1,"stats":{"Line":1}},{"line":288,"address":[2040361],"length":1,"stats":{"Line":1}},{"line":289,"address":[2040396],"length":1,"stats":{"Line":1}},{"line":290,"address":[2040431],"length":1,"stats":{"Line":1}},{"line":292,"address":[2039942,2040024],"length":1,"stats":{"Line":2}},{"line":300,"address":[2038046],"length":1,"stats":{"Line":1}},{"line":301,"address":[2038141,2039907,2039483],"length":1,"stats":{"Line":4}},{"line":302,"address":[2039167],"length":1,"stats":{"Line":1}},{"line":304,"address":[2039283,2039196],"length":1,"stats":{"Line":2}},{"line":305,"address":[2039293],"length":1,"stats":{"Line":1}},{"line":306,"address":[2039374],"length":1,"stats":{"Line":1}},{"line":307,"address":[2039496],"length":1,"stats":{"Line":1}},{"line":310,"address":[2039392,2039299],"length":1,"stats":{"Line":2}},{"line":312,"address":[2039419],"length":1,"stats":{"Line":1}},{"line":314,"address":[2039203],"length":1,"stats":{"Line":1}},{"line":316,"address":[2039232,2039571],"length":1,"stats":{"Line":2}},{"line":317,"address":[2039581],"length":1,"stats":{"Line":1}},{"line":318,"address":[2039616],"length":1,"stats":{"Line":1}},{"line":319,"address":[2039699],"length":1,"stats":{"Line":1}},{"line":323,"address":[2039740],"length":1,"stats":{"Line":1}},{"line":324,"address":[2039787,2039754],"length":1,"stats":{"Line":2}},{"line":326,"address":[2039780,2039804],"length":1,"stats":{"Line":2}},{"line":330,"address":[2039714,2039809],"length":1,"stats":{"Line":2}},{"line":333,"address":[2039797,2039811],"length":1,"stats":{"Line":2}},{"line":336,"address":[2039624,2039816],"length":1,"stats":{"Line":2}},{"line":338,"address":[2039843],"length":1,"stats":{"Line":1}},{"line":340,"address":[2038122,2039121],"length":1,"stats":{"Line":3}},{"line":341,"address":[2038175],"length":1,"stats":{"Line":1}},{"line":343,"address":[2038204,2038785],"length":1,"stats":{"Line":2}},{"line":344,"address":[2038795],"length":1,"stats":{"Line":1}},{"line":345,"address":[2038830],"length":1,"stats":{"Line":1}},{"line":346,"address":[2038913],"length":1,"stats":{"Line":1}},{"line":350,"address":[2038954],"length":1,"stats":{"Line":1}},{"line":351,"address":[2039001,2038968],"length":1,"stats":{"Line":2}},{"line":353,"address":[2039018,2038994],"length":1,"stats":{"Line":2}},{"line":357,"address":[2039023,2038928],"length":1,"stats":{"Line":2}},{"line":360,"address":[2039011,2039025],"length":1,"stats":{"Line":2}},{"line":363,"address":[2039030,2038838],"length":1,"stats":{"Line":2}},{"line":365,"address":[2039057],"length":1,"stats":{"Line":1}},{"line":368,"address":[2038164,2038241],"length":1,"stats":{"Line":2}},{"line":369,"address":[2038233],"length":1,"stats":{"Line":1}},{"line":372,"address":[2038273,2038222],"length":1,"stats":{"Line":2}},{"line":373,"address":[2038265],"length":1,"stats":{"Line":1}},{"line":376,"address":[2038254,2038553],"length":1,"stats":{"Line":3}},{"line":377,"address":[2038309,2038726,2038739],"length":1,"stats":{"Line":5}},{"line":378,"address":[2038718],"length":1,"stats":{"Line":2}},{"line":380,"address":[2038731],"length":1,"stats":{"Line":2}},{"line":384,"address":[2038286],"length":1,"stats":{"Line":1}},{"line":385,"address":[2038545],"length":1,"stats":{"Line":2}},{"line":387,"address":[2038332,2038414],"length":1,"stats":{"Line":2}},{"line":393,"address":[2038587],"length":1,"stats":{"Line":1}},{"line":395,"address":[2038594],"length":1,"stats":{"Line":1}},{"line":399,"address":[2047722,2047232],"length":1,"stats":{"Line":1}},{"line":400,"address":[2047254],"length":1,"stats":{"Line":1}},{"line":402,"address":[2047264,2047308],"length":1,"stats":{"Line":2}},{"line":404,"address":[2047315,2047364],"length":1,"stats":{"Line":2}},{"line":405,"address":[2047383,2047505],"length":1,"stats":{"Line":4}},{"line":408,"address":[2047395],"length":1,"stats":{"Line":1}}],"covered":220,"coverable":220},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","tokens.rs"],"content":"use super::predule::OperatorToken;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::errors::predule::IntoError;\nuse crate::errors::RRDBError;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Token {\n    // DCL\n    // Grant,\n    // Revoke,\n\n    // DML\n    Select,\n    From,\n    Where,\n    As,\n    Order,\n    By,\n    Asc,\n    Desc,\n    Group,\n    Having,\n    Limit,\n    Offset,\n    Insert,\n    Into,\n    Values,\n    Update,\n    Set,\n    Delete,\n    Join,\n    Inner,\n    Left,\n    Right,\n    Full,\n    Outer,\n    On,\n    Nulls,\n    First,\n    Last,\n\n    // DDL\n    Create,\n    Alter,\n    Drop,\n    Database,\n    Table,\n    Column,\n    Comment,\n    Primary,\n    Foreign,\n    Key,\n    Add,\n    If,\n    Rename,\n    To,\n    Show,\n    Databases,\n    Tables,\n    Use,\n    Type,\n    Default,\n    Data,\n\n    // TCL\n    Begin,\n    Transaction,\n    Commit,\n    Rollback,\n\n    // ETC\n    // Analyze,\n    CodeComment(String),\n\n    // EXPRESSION\n    And,\n    Or,\n    Not,\n    Between,\n    Like,\n    In,\n    Is,\n\n    // primary expression\n    Identifier(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    String(String),\n    Null,\n\n    Operator(OperatorToken),\n\n    //functions\n    Exists,\n\n    // general syntax\n    Comma,\n    Period,\n    SemiColon,\n    LeftParentheses,\n    RightParentheses,\n    Backslash,\n\n    // exception handling\n    EOF,\n    Error(String),\n    UnknownCharacter(char),\n}\n\nimpl Token {\n    pub fn is_eof(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self {\n            Token::EOF =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_unary_operator(\u0026self) -\u003e bool {\n        match self {\n            Token::Operator(operator) =\u003e operator.is_unary_operator(),\n            _ =\u003e false,\n        }\n    }\n\n    // 복합 토큰으로 구성된 연산자일 수 있는 경우\n    // IS NOT, NOT IN 등\n    pub fn can_be_multi_token_operator(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self {\n            Token::Not | Token::Is =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn try_into_multi_token_operator(\n        self,\n        second_token: Self,\n    ) -\u003e Result\u003cBinaryOperator, RRDBError\u003e {\n        match self {\n            Token::Not =\u003e match second_token {\n                Token::Like =\u003e Ok(BinaryOperator::NotLike),\n                Token::In =\u003e Ok(BinaryOperator::NotIn),\n                _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n            },\n            Token::Is =\u003e match second_token {\n                Token::Not =\u003e Ok(BinaryOperator::IsNot),\n                _ =\u003e Ok(BinaryOperator::Is),\n            },\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n\n    pub fn is_expression(\u0026self) -\u003e bool {\n        match self {\n            Token::Identifier(_)\n            | Token::Integer(_)\n            | Token::Float(_)\n            | Token::Boolean(_)\n            | Token::String(_)\n            | Token::Null\n            | Token::LeftParentheses\n            | Token::Not =\u003e true,\n            Token::Operator(operator) =\u003e operator.is_unary_operator(),\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl TryInto\u003cBinaryOperator\u003e for Token {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cBinaryOperator, RRDBError\u003e {\n        match self {\n            Token::Operator(operator) =\u003e operator.try_into(),\n            Token::And =\u003e Ok(BinaryOperator::And),\n            Token::Or =\u003e Ok(BinaryOperator::Or),\n            Token::Like =\u003e Ok(BinaryOperator::Like),\n            Token::In =\u003e Ok(BinaryOperator::In),\n            Token::Is =\u003e Ok(BinaryOperator::Is),\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::dml::expressions::operators::BinaryOperator,\n        lexer::{predule::OperatorToken, tokens::Token},\n    };\n\n    #[test]\n    fn test_token_is_unary_operator() {\n        let test_cases = vec![\n            (Token::Operator(OperatorToken::Plus), true),\n            (Token::Operator(OperatorToken::Minus), true),\n            (Token::Operator(OperatorToken::Not), true),\n            (Token::And, false),\n            (Token::Or, false),\n            (Token::Like, false),\n            (Token::In, false),\n            (Token::Is, false),\n            (Token::Identifier(\"test\".to_owned()), false),\n            (Token::Integer(1), false),\n            (Token::Float(1.0), false),\n            (Token::Boolean(true), false),\n            (Token::String(\"test\".to_owned()), false),\n            (Token::Null, false),\n            (Token::LeftParentheses, false),\n        ];\n\n        for (token, want) in test_cases {\n            assert_eq!(token.is_unary_operator(), want);\n        }\n    }\n\n    #[test]\n    fn test_token_try_into_multi_token_operator() {\n        struct TestCase {\n            name: String,\n            first: Token,\n            second: Token,\n            expected: BinaryOperator,\n            want_error: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"NOT LIKE\".into(),\n                first: Token::Not,\n                second: Token::Like,\n                expected: BinaryOperator::NotLike,\n                want_error: false,\n            },\n            TestCase {\n                name: \"NOT IN\".into(),\n                first: Token::Not,\n                second: Token::In,\n                expected: BinaryOperator::NotIn,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS NOT\".into(),\n                first: Token::Is,\n                second: Token::Not,\n                expected: BinaryOperator::IsNot,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS\".into(),\n                first: Token::Is,\n                second: Token::Is,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"NOT AND\".into(),\n                first: Token::Not,\n                second: Token::And,\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n            TestCase {\n                name: \"IS LIKE\".into(),\n                first: Token::Is,\n                second: Token::Like,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"Error\".into(),\n                first: Token::Select,\n                second: Token::Like,\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n        ];\n\n        for t in test_cases {\n            let got = t.first.try_into_multi_token_operator(t.second);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n\n    #[test]\n    fn test_token_is_expression() {\n        struct TestCase {\n            name: String,\n            input: Token,\n            expected: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"Identifier\".into(),\n                input: Token::Identifier(\"test\".into()),\n                expected: true,\n            },\n            TestCase {\n                name: \"Integer\".into(),\n                input: Token::Integer(1),\n                expected: true,\n            },\n            TestCase {\n                name: \"Float\".into(),\n                input: Token::Float(1.0),\n                expected: true,\n            },\n            TestCase {\n                name: \"Boolean\".into(),\n                input: Token::Boolean(true),\n                expected: true,\n            },\n            TestCase {\n                name: \"String\".into(),\n                input: Token::String(\"test\".into()),\n                expected: true,\n            },\n            TestCase {\n                name: \"Null\".into(),\n                input: Token::Null,\n                expected: true,\n            },\n            TestCase {\n                name: \"LeftParentheses\".into(),\n                input: Token::LeftParentheses,\n                expected: true,\n            },\n            TestCase {\n                name: \"Not\".into(),\n                input: Token::Not,\n                expected: true,\n            },\n            TestCase {\n                name: \"Operator\".into(),\n                input: Token::Operator(OperatorToken::Plus),\n                expected: true,\n            },\n            TestCase {\n                name: \"And\".into(),\n                input: Token::And,\n                expected: false,\n            },\n            TestCase {\n                name: \"Or\".into(),\n                input: Token::Or,\n                expected: false,\n            },\n            TestCase {\n                name: \"Like\".into(),\n                input: Token::Like,\n                expected: false,\n            },\n            TestCase {\n                name: \"In\".into(),\n                input: Token::In,\n                expected: false,\n            },\n            TestCase {\n                name: \"Is\".into(),\n                input: Token::Is,\n                expected: false,\n            },\n            TestCase {\n                name: \"Comma\".into(),\n                input: Token::Comma,\n                expected: false,\n            },\n            TestCase {\n                name: \"Period\".into(),\n                input: Token::Period,\n                expected: false,\n            },\n            TestCase {\n                name: \"SemiColon\".into(),\n                input: Token::SemiColon,\n                expected: false,\n            },\n            TestCase {\n                name: \"RightParentheses\".into(),\n                input: Token::RightParentheses,\n                expected: false,\n            },\n            TestCase {\n                name: \"EOF\".into(),\n                input: Token::EOF,\n                expected: false,\n            },\n        ];\n\n        for t in test_cases {\n            let got = t.input.is_expression();\n            assert_eq!(got, t.expected, \"TC: {}\", t.name);\n        }\n    }\n\n    #[test]\n    fn test_token_try_into_binary_operator() {\n        struct TestCase {\n            name: String,\n            input: Token,\n            expected: BinaryOperator,\n            want_error: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"AND\".into(),\n                input: Token::And,\n                expected: BinaryOperator::And,\n                want_error: false,\n            },\n            TestCase {\n                name: \"OR\".into(),\n                input: Token::Or,\n                expected: BinaryOperator::Or,\n                want_error: false,\n            },\n            TestCase {\n                name: \"LIKE\".into(),\n                input: Token::Like,\n                expected: BinaryOperator::Like,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IN\".into(),\n                input: Token::In,\n                expected: BinaryOperator::In,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS\".into(),\n                input: Token::Is,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"Identifier\".into(),\n                input: Token::Identifier(\"test\".into()),\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cBinaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n}\n","traces":[{"line":112,"address":[5740400],"length":1,"stats":{"Line":4}},{"line":114,"address":[5740405],"length":1,"stats":{"Line":4}},{"line":120,"address":[5740432],"length":1,"stats":{"Line":1}},{"line":121,"address":[5740446],"length":1,"stats":{"Line":1}},{"line":122,"address":[5740460],"length":1,"stats":{"Line":1}},{"line":123,"address":[5740482],"length":1,"stats":{"Line":1}},{"line":129,"address":[5740512],"length":1,"stats":{"Line":2}},{"line":131,"address":[5740517],"length":1,"stats":{"Line":2}},{"line":132,"address":[5740537],"length":1,"stats":{"Line":1}},{"line":133,"address":[5740530],"length":1,"stats":{"Line":2}},{"line":137,"address":[5740560,5741003],"length":1,"stats":{"Line":1}},{"line":141,"address":[5740587],"length":1,"stats":{"Line":1}},{"line":142,"address":[5740651],"length":1,"stats":{"Line":1}},{"line":143,"address":[5740732],"length":1,"stats":{"Line":1}},{"line":144,"address":[5740758],"length":1,"stats":{"Line":1}},{"line":145,"address":[5740703,5740834],"length":1,"stats":{"Line":2}},{"line":147,"address":[5740685],"length":1,"stats":{"Line":1}},{"line":148,"address":[5740856],"length":1,"stats":{"Line":1}},{"line":149,"address":[5740888],"length":1,"stats":{"Line":1}},{"line":151,"address":[5740923,5740616],"length":1,"stats":{"Line":2}},{"line":155,"address":[5741040],"length":1,"stats":{"Line":1}},{"line":156,"address":[5741053],"length":1,"stats":{"Line":1}},{"line":157,"address":[5741119],"length":1,"stats":{"Line":1}},{"line":165,"address":[5741130],"length":1,"stats":{"Line":1}},{"line":166,"address":[5741112],"length":1,"stats":{"Line":1}},{"line":174,"address":[5741519,5741168],"length":1,"stats":{"Line":1}},{"line":175,"address":[5741190],"length":1,"stats":{"Line":1}},{"line":176,"address":[5741399,5741470],"length":1,"stats":{"Line":4}},{"line":177,"address":[5741261],"length":1,"stats":{"Line":1}},{"line":178,"address":[5741290],"length":1,"stats":{"Line":1}},{"line":179,"address":[5741316],"length":1,"stats":{"Line":1}},{"line":180,"address":[5741342],"length":1,"stats":{"Line":1}},{"line":181,"address":[5741368],"length":1,"stats":{"Line":1}},{"line":182,"address":[5741229,5741477],"length":1,"stats":{"Line":2}}],"covered":34,"coverable":34},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","logger.rs"],"content":"use colored::Colorize;\n\npub struct Logger {}\n\nimpl Logger {\n    pub fn error(text: impl Into\u003cString\u003e) {\n        println!(\"{}\", format!(\"!![ERROR] {}\", text.into()).red());\n    }\n\n    pub fn info(text: impl Into\u003cString\u003e) {\n        println!(\"{}\", format!(\"@@[INFO] {}\", text.into()).green());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_error() {\n        Logger::error(\"This is an error message\");\n    }\n\n    #[test]\n    fn test_info() {\n        Logger::info(\"This is an info message\");\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":2}},{"line":11,"address":[],"length":0,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","mod.rs"],"content":"#[allow(clippy::module_inception)]\npub mod logger;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","predule.rs"],"content":"pub use super::logger::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","main.rs"],"content":"pub mod ast;\npub mod command;\npub mod constants;\npub mod errors;\npub mod executor;\npub mod lexer;\npub mod logger;\npub mod optimizer;\npub mod parser;\npub mod pgwire;\npub mod server;\npub mod utils;\n\nuse std::sync::Arc;\n\nuse command::{Command, SubCommand};\nuse errors::RRDBError;\nuse executor::{config::global::GlobalConfig, predule::Executor};\nuse server::predule::Server;\n\nuse clap::Parser;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), RRDBError\u003e {\n    let args = Command::parse();\n\n    match args.action {\n        SubCommand::Init(init) =\u003e {\n            let config = GlobalConfig::load_from_path(None).unwrap_or_default();\n\n            let _init_option = init.init;\n\n            let executor = Executor::new(Arc::new(config));\n\n            executor.init_config().await?;\n            executor.init_database().await?;\n        }\n        SubCommand::Run(run) =\u003e {\n            let config = GlobalConfig::load_from_path(run.value.config).expect(\"config load error\");\n\n            let server = Server::new(config);\n\n            server.run().await?;\n        }\n        SubCommand::Client =\u003e {\n            println!(\"Client\");\n            unimplemented!();\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":24,"address":[3988224,3988629],"length":1,"stats":{"Line":0}},{"line":25,"address":[5749621],"length":1,"stats":{"Line":0}},{"line":27,"address":[3988325,3988504,3988265,3988395],"length":1,"stats":{"Line":0}},{"line":28,"address":[5749800],"length":1,"stats":{"Line":0}},{"line":29,"address":[5749840,5750045],"length":1,"stats":{"Line":0}},{"line":31,"address":[5750052],"length":1,"stats":{"Line":0}},{"line":33,"address":[5750142,5750087],"length":1,"stats":{"Line":0}},{"line":35,"address":[4801421],"length":1,"stats":{"Line":0}},{"line":36,"address":[4801437],"length":1,"stats":{"Line":0}},{"line":38,"address":[5749874],"length":1,"stats":{"Line":0}},{"line":39,"address":[5749903,5750302],"length":1,"stats":{"Line":0}},{"line":41,"address":[5750344],"length":1,"stats":{"Line":0}},{"line":43,"address":[4801453],"length":1,"stats":{"Line":0}},{"line":46,"address":[5750538,5749961],"length":1,"stats":{"Line":0}},{"line":51,"address":[3988526,3988349],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","mod.rs"],"content":"#[allow(clippy::module_inception)]\npub mod optimizer;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","optimizer.rs"],"content":"use crate::{\n    ast::dml::{\n        delete::DeleteQuery,\n        parts::from::FromTarget,\n        plan::{\n            delete::{delete_plan::DeletePlan, from::DeleteFromPlan},\n            select::{\n                filter::FilterPlan,\n                from::SelectFromPlan,\n                limit_offset::LimitOffsetPlan,\n                scan::ScanType,\n                select_plan::{SelectPlan, SelectPlanItem},\n            },\n            update::{from::UpdateFromPlan, update_plan::UpdatePlan},\n        },\n        select::SelectQuery,\n        update::UpdateQuery,\n    },\n    errors::RRDBError,\n};\n\npub struct Optimizer {}\n\nimpl Optimizer {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n\n    pub async fn optimize_select(\u0026self, query: SelectQuery) -\u003e Result\u003cSelectPlan, RRDBError\u003e {\n        let mut has_from = false;\n        let mut plan = SelectPlan { list: vec![] };\n\n        // FROM 절 분석\n        if let Some(from_clause) = query.from_table {\n            has_from = true;\n            let alias = from_clause.alias;\n\n            match from_clause.from {\n                FromTarget::Table(table_name) =\u003e plan.list.push(\n                    SelectFromPlan {\n                        table_name,\n                        alias,\n                        scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n                    }\n                    .into(),\n                ),\n                FromTarget::Subquery(_subquery) =\u003e {}\n            }\n        }\n\n        if has_from {\n            // JOIN 절 구성\n            if !query.join_clause.is_empty() {\n                // TODO\n            }\n\n            // WHERE 절 필터링 구성\n            if let Some(where_clause) = query.where_clause {\n                let expression = where_clause.expression;\n\n                plan.list.push(FilterPlan { expression }.into());\n            }\n\n            // GROUP BY 절 구성\n            if let Some(group_by_clause) = query.group_by_clause {\n                plan.list.push(group_by_clause.into());\n\n                // HAVING 절 구성\n                if let Some(having_clause) = query.having_clause {\n                    plan.list.push(\n                        FilterPlan {\n                            expression: *having_clause.expression,\n                        }\n                        .into(),\n                    );\n                }\n            } else if query.has_aggregate {\n                plan.list.push(SelectPlanItem::GroupAll);\n            }\n\n            // ORDER BY 절 구성\n            if let Some(order_by_clause) = query.order_by_clause {\n                plan.list.push(order_by_clause.into());\n            }\n\n            // LIMIT OFFSET 절 구성\n            if query.limit.is_some() || query.offset.is_some() {\n                plan.list.push(\n                    LimitOffsetPlan {\n                        limit: query.limit,\n                        offset: query.offset,\n                    }\n                    .into(),\n                );\n            }\n        }\n\n        Ok(plan)\n    }\n\n    pub async fn optimize_update(\u0026self, query: UpdateQuery) -\u003e Result\u003cUpdatePlan, RRDBError\u003e {\n        let mut plan = UpdatePlan { list: vec![] };\n\n        let target_table = query.target_table.clone().unwrap();\n\n        plan.list.push(\n            UpdateFromPlan {\n                table_name: target_table.table.clone(),\n                alias: target_table.alias,\n                scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n            }\n            .into(),\n        );\n\n        // WHERE 절 분석\n        if let Some(where_clause) = query.where_clause {\n            // WHERE 절 필터링 구성\n\n            let expression = where_clause.expression;\n\n            plan.list.push(FilterPlan { expression }.into());\n        }\n\n        Ok(plan)\n    }\n\n    pub async fn optimize_delete(\u0026self, query: DeleteQuery) -\u003e Result\u003cDeletePlan, RRDBError\u003e {\n        let mut plan = DeletePlan { list: vec![] };\n\n        let target_table = query.from_table.clone().unwrap();\n\n        plan.list.push(\n            DeleteFromPlan {\n                table_name: target_table.table.clone(),\n                alias: target_table.alias,\n                scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n            }\n            .into(),\n        );\n\n        // WHERE 절 분석\n        if let Some(where_clause) = query.where_clause {\n            // WHERE 절 필터링 구성\n\n            let expression = where_clause.expression;\n\n            plan.list.push(FilterPlan { expression }.into());\n        }\n\n        Ok(plan)\n    }\n}\n\nimpl Default for Optimizer {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":29,"address":[3544915,3544880],"length":1,"stats":{"Line":0}},{"line":30,"address":[4423038],"length":1,"stats":{"Line":0}},{"line":31,"address":[4423054,4423120],"length":1,"stats":{"Line":0}},{"line":34,"address":[4423168,4423759,4423346],"length":1,"stats":{"Line":0}},{"line":35,"address":[4423242],"length":1,"stats":{"Line":0}},{"line":36,"address":[4423250],"length":1,"stats":{"Line":0}},{"line":38,"address":[4422904,4423306],"length":1,"stats":{"Line":0}},{"line":39,"address":[4423351,4423732],"length":1,"stats":{"Line":0}},{"line":40,"address":[4423457],"length":1,"stats":{"Line":0}},{"line":42,"address":[4423399],"length":1,"stats":{"Line":0}},{"line":43,"address":[4423449],"length":1,"stats":{"Line":0}},{"line":47,"address":[4423647],"length":1,"stats":{"Line":0}},{"line":51,"address":[4423812],"length":1,"stats":{"Line":0}},{"line":53,"address":[4423965],"length":1,"stats":{"Line":0}},{"line":58,"address":[4424002],"length":1,"stats":{"Line":0}},{"line":59,"address":[4424129],"length":1,"stats":{"Line":0}},{"line":61,"address":[4424209,4424372],"length":1,"stats":{"Line":0}},{"line":65,"address":[4424319,4424381],"length":1,"stats":{"Line":0}},{"line":66,"address":[4424421,4424483],"length":1,"stats":{"Line":0}},{"line":69,"address":[4424490],"length":1,"stats":{"Line":0}},{"line":70,"address":[4424865],"length":1,"stats":{"Line":0}},{"line":71,"address":[4424676],"length":1,"stats":{"Line":0}},{"line":72,"address":[4424617,4424543,4424791],"length":1,"stats":{"Line":0}},{"line":77,"address":[4424451],"length":1,"stats":{"Line":0}},{"line":78,"address":[4424907],"length":1,"stats":{"Line":0}},{"line":82,"address":[4424571,4424943],"length":1,"stats":{"Line":0}},{"line":83,"address":[4424977,4425046],"length":1,"stats":{"Line":0}},{"line":87,"address":[4425007,4425059,4425178],"length":1,"stats":{"Line":0}},{"line":88,"address":[4425203],"length":1,"stats":{"Line":0}},{"line":89,"address":[4425116],"length":1,"stats":{"Line":0}},{"line":90,"address":[4425088],"length":1,"stats":{"Line":0}},{"line":91,"address":[4425102],"length":1,"stats":{"Line":0}},{"line":98,"address":[4423874],"length":1,"stats":{"Line":0}},{"line":101,"address":[3544995,3544960],"length":1,"stats":{"Line":0}},{"line":102,"address":[4426695,4426769],"length":1,"stats":{"Line":0}},{"line":104,"address":[4426809,4426951],"length":1,"stats":{"Line":0}},{"line":106,"address":[4427286],"length":1,"stats":{"Line":0}},{"line":107,"address":[4427080],"length":1,"stats":{"Line":0}},{"line":108,"address":[4426975],"length":1,"stats":{"Line":0}},{"line":109,"address":[4427022],"length":1,"stats":{"Line":0}},{"line":110,"address":[4427072],"length":1,"stats":{"Line":0}},{"line":116,"address":[4427293],"length":1,"stats":{"Line":0}},{"line":119,"address":[4427420],"length":1,"stats":{"Line":0}},{"line":121,"address":[4427500,4427725],"length":1,"stats":{"Line":0}},{"line":124,"address":[4427610],"length":1,"stats":{"Line":0}},{"line":127,"address":[3545075,3545040],"length":1,"stats":{"Line":0}},{"line":128,"address":[4428480,4428406],"length":1,"stats":{"Line":0}},{"line":130,"address":[4428533,4428662],"length":1,"stats":{"Line":0}},{"line":132,"address":[4428997],"length":1,"stats":{"Line":0}},{"line":133,"address":[4428791],"length":1,"stats":{"Line":0}},{"line":134,"address":[4428686],"length":1,"stats":{"Line":0}},{"line":135,"address":[4428733],"length":1,"stats":{"Line":0}},{"line":136,"address":[4428783],"length":1,"stats":{"Line":0}},{"line":142,"address":[4429004],"length":1,"stats":{"Line":0}},{"line":145,"address":[4429122],"length":1,"stats":{"Line":0}},{"line":147,"address":[4429427,4429202],"length":1,"stats":{"Line":0}},{"line":150,"address":[4429312],"length":1,"stats":{"Line":0}},{"line":155,"address":[3545120],"length":1,"stats":{"Line":0}},{"line":156,"address":[3545121],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","predule.rs"],"content":"pub use super::optimizer::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","context.rs"],"content":"#[derive(Debug, Default, Clone)]\npub struct ParserContext {\n    pub in_between_clause: bool,\n    pub in_parentheses: bool,\n    pub default_database: Option\u003cString\u003e,\n}\n\nimpl ParserContext {\n    pub fn set_in_between_clause(mut self, in_between_clause: bool) -\u003e Self {\n        self.in_between_clause = in_between_clause;\n        self\n    }\n\n    pub fn set_in_parentheses(mut self, in_parentheses: bool) -\u003e Self {\n        self.in_parentheses = in_parentheses;\n        self\n    }\n\n    pub fn set_default_database(mut self, default_database: String) -\u003e Self {\n        self.default_database = Some(default_database);\n        self\n    }\n}\n","traces":[{"line":9,"address":[7935136],"length":1,"stats":{"Line":1}},{"line":10,"address":[7935150],"length":1,"stats":{"Line":1}},{"line":11,"address":[7935156],"length":1,"stats":{"Line":1}},{"line":14,"address":[7935200],"length":1,"stats":{"Line":1}},{"line":15,"address":[7935214],"length":1,"stats":{"Line":1}},{"line":16,"address":[7935220],"length":1,"stats":{"Line":1}},{"line":19,"address":[7935264,7935440],"length":1,"stats":{"Line":1}},{"line":20,"address":[7935291,7935379],"length":1,"stats":{"Line":2}},{"line":21,"address":[7935405],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","common.rs"],"content":"use crate::ast::dml::expressions::subquery::SubqueryExpression;\nuse crate::ast::dml::parts::join::JoinType;\nuse crate::ast::types::{Column, DataType, SelectColumn, TableName};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    // 테이블 컬럼 정의 분석\n    pub(crate) fn parse_table_column(\u0026mut self) -\u003e Result\u003cColumn, RRDBError\u003e {\n        let mut builder = Column::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0001 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(name) = current_token {\n            builder = builder.set_name(name);\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0028 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let data_type = self.parse_data_type()?;\n        builder = builder.set_data_type(data_type);\n\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Comma =\u003e {\n                    // , 만나면 종료\n                    break;\n                }\n                Token::RightParentheses =\u003e {\n                    // ) 만나면 종료\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::Primary =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0003 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Key =\u003e {\n                            builder = builder.set_primary_key(true).set_not_null(true);\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected 'PRIMARY KEY'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0004 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Null =\u003e {\n                            builder = builder.set_not_null(true);\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected 'NOT NULL'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n                Token::Null =\u003e {\n                    builder = builder.set_not_null(false);\n                }\n                Token::Comment =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0005 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if let Token::String(comment) = current_token {\n                        builder = builder.set_comment(comment);\n                    } else {\n                        return Err(ParsingError::wrap(format!(\n                            \"expected comment string. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n                }\n                Token::Default =\u003e {\n                    return Err(ParsingError::wrap(\"not supported yet\"));\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(builder.build())\n    }\n\n    // 데이터 타입 분석\n    pub(crate) fn parse_data_type(\u0026mut self) -\u003e Result\u003cDataType, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0006 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(type_name) = current_token {\n            match type_name.to_uppercase().as_str() {\n                \"INTEGER\" | \"INT\" =\u003e Ok(DataType::Int),\n                \"FLOAT\" =\u003e Ok(DataType::Float),\n                \"BOOLEAN\" | \"BOOL\" =\u003e Ok(DataType::Boolean),\n                \"VARCHAR\" =\u003e {\n                    // 여는 괄호 체크\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0007 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if Token::LeftParentheses != current_token {\n                        return Err(ParsingError::wrap(format!(\n                            \"expected '('. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n\n                    // 문자열 길이 체크\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0008 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if let Token::Integer(integer) = current_token {\n                        // 닫는 괄호 체크\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E0009 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if Token::RightParentheses != current_token {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected ')'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n\n                        Ok(DataType::Varchar(integer))\n                    } else {\n                        Err(ParsingError::wrap(format!(\n                            \"expected integer number. but your input word is '{:?}'\",\n                            current_token\n                        )))\n                    }\n                }\n                _ =\u003e Err(ParsingError::wrap(format!(\n                    \"unknown data type '{}'\",\n                    type_name\n                ))),\n            }\n        } else {\n            Err(ParsingError::wrap(format!(\n                \"E0029 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )))\n        }\n    }\n\n    // 테이블명 분석\n    pub(crate) fn parse_table_name(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cTableName, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0010 need more tokens\"));\n        }\n\n        // 첫번째로 오는 이름은 테이블명으로 추정\n        let current_token = self.get_next_token();\n        let mut database_name = None;\n\n        let mut table_name = if let Token::Identifier(name) = current_token {\n            name\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0030 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        };\n\n        if !self.has_next_token() {\n            return Ok(TableName::new(\n                database_name.or(context.default_database),\n                table_name,\n            ));\n        }\n\n        let current_token = self.get_next_token();\n\n        // .가 있을 경우 \"데이터베이스명\".\"테이블명\"의 형태로 추정\n        if current_token == Token::Period {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0012 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if let Token::Identifier(name) = current_token {\n                database_name = Some(table_name);\n                table_name = name;\n            } else {\n                return Err(ParsingError::wrap(format!(\n                    \"E0031 expected identifier. but your input word is '{:?}'\",\n                    current_token\n                )));\n            }\n        } else {\n            self.unget_next_token(current_token);\n        }\n\n        Ok(TableName::new(\n            database_name.or(context.default_database),\n            table_name,\n        ))\n    }\n\n    // IF NOT EXISTS 체크 로직\n    pub(crate) fn has_if_not_exists(\u0026mut self) -\u003e Result\u003cbool, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0013 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::If == current_token {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0014 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if Token::Not == current_token {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0015 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if Token::Exists == current_token {\n                    Ok(true)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"expected keyword is 'exists'. but your input word is '{:?}'\",\n                        current_token\n                    )))\n                }\n            } else {\n                Err(ParsingError::wrap(format!(\n                    \"expected keyword is 'not'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        } else {\n            self.unget_next_token(current_token);\n            Ok(false)\n        }\n    }\n\n    // IF EXISTS 체크 로직\n    pub(crate) fn has_if_exists(\u0026mut self) -\u003e Result\u003cbool, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0016 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::If == current_token {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0017 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if Token::Exists == current_token {\n                Ok(true)\n            } else {\n                Err(ParsingError::wrap(format!(\n                    \"expected keyword is 'exists'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        } else {\n            self.unget_next_token(current_token);\n            Ok(false)\n        }\n    }\n\n    // SELECT 컬럼 정의 분석\n    pub(crate) fn parse_select_column(\u0026mut self) -\u003e Result\u003cSelectColumn, RRDBError\u003e {\n        let mut select_column = SelectColumn::new(None, \"\".to_string());\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0018 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(name) = current_token {\n            select_column.column_name = name;\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0032 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            Ok(select_column)\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::Period {\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(name) = current_token {\n                    select_column.table_name = Some(select_column.column_name);\n                    select_column.column_name = name;\n                    Ok(select_column)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"E0033 expected identifier. but your input word is '{:?}'\",\n                        current_token\n                    )))\n                }\n            } else {\n                self.unget_next_token(current_token);\n                Ok(select_column)\n            }\n        }\n    }\n\n    // 다음 토큰이 2항 연산자/키워드인지\n    pub(crate) fn next_token_is_binary_operator(\u0026mut self, context: ParserContext) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            // 2항 키워드, 연산자일 경우에만 true 반환\n            match current_token {\n                Token::And =\u003e {\n                    self.unget_next_token(current_token);\n\n                    // BETWEEN 파싱중이면서 괄호가 없는 상태라면 연산자가 아닌 것으로 간주.\n                    #[allow(clippy::needless_bool)]\n                    if context.in_between_clause \u0026\u0026 !context.in_parentheses {\n                        false\n                    } else {\n                        true\n                    }\n                }\n                Token::Or | Token::Like | Token::In =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Operator(ref operator) =\u003e {\n                    let result = [\n                        OperatorToken::Plus,\n                        OperatorToken::Minus,\n                        OperatorToken::Asterisk,\n                        OperatorToken::Slash,\n                        OperatorToken::Lt,\n                        OperatorToken::Lte,\n                        OperatorToken::Gt,\n                        OperatorToken::Gte,\n                        OperatorToken::Eq,\n                        OperatorToken::Neq,\n                    ]\n                    .contains(operator);\n\n                    self.unget_next_token(current_token);\n\n                    result\n                }\n                Token::Is =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::In | Token::Like =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn next_token_is_left_parentheses(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::LeftParentheses\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn _next_token_is_subquery(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::LeftParentheses {\n                if !self.has_next_token() {\n                    self.unget_next_token(current_token);\n                    false\n                } else {\n                    let second_token = self.get_next_token();\n\n                    if second_token == Token::Select {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        true\n                    } else {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        false\n                    }\n                }\n            } else {\n                self.unget_next_token(current_token);\n                false\n            }\n        }\n    }\n\n    // 다음 토큰이 닫는 괄호인지\n    pub(crate) fn next_token_is_right_parentheses(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::RightParentheses\n        }\n    }\n\n    // 다음 토큰이 쉼표인지\n    pub(crate) fn next_token_is_comma(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::Comma\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn next_token_is_between(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Between =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n                        match second_token.clone() {\n                            Token::Between =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 AS인지\n    pub(crate) fn next_token_is_table_alias(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token.clone() {\n                Token::As =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Identifier(_) =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 AS인지\n    pub(crate) fn next_token_is_where(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token.clone() {\n                Token::Where =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 ORDER BY인지\n    pub(crate) fn next_token_is_order_by(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Order =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        return false;\n                    }\n\n                    let second_token = self.get_next_token();\n\n                    match second_token {\n                        Token::By =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            true\n                        }\n                        _ =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            false\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 GROUP BY인지\n    pub(crate) fn next_token_is_group_by(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Group =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        return false;\n                    }\n\n                    let second_token = self.get_next_token();\n\n                    match second_token {\n                        Token::By =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            true\n                        }\n                        _ =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            false\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 HAVING인지\n    pub(crate) fn next_token_is_having(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Having =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 OFFSET인지\n    pub(crate) fn next_token_is_offset(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Offset =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 OFFSET인지\n    pub(crate) fn next_token_is_limit(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Limit =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_column(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Column =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_not_null(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(first_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Null =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_data_type(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Data =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(first_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Type =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_default(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Default =\u003e {\n                    self.unget_next_token(first_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 JOIN 토큰이라면 JOIN 타입을 추출해서 반환\n    pub(crate) fn get_next_join_type(\u0026mut self) -\u003e Option\u003cJoinType\u003e {\n        if !self.has_next_token() {\n            None\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Inner =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e Some(JoinType::InnerJoin),\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Left | Token::Right =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e match current_token {\n                                Token::Left =\u003e Some(JoinType::LeftOuterJoin),\n                                Token::Right =\u003e Some(JoinType::RightOuterJoin),\n                                _ =\u003e unreachable!(),\n                            },\n                            Token::Outer =\u003e {\n                                if !self.has_next_token() {\n                                    self.unget_next_token(second_token);\n                                    self.unget_next_token(current_token);\n                                    None\n                                } else {\n                                    let third_token = self.get_next_token();\n\n                                    match third_token {\n                                        Token::Join =\u003e match current_token {\n                                            Token::Left =\u003e Some(JoinType::LeftOuterJoin),\n                                            Token::Right =\u003e Some(JoinType::RightOuterJoin),\n                                            _ =\u003e unreachable!(),\n                                        },\n                                        _ =\u003e {\n                                            self.unget_next_token(third_token);\n                                            self.unget_next_token(second_token);\n                                            self.unget_next_token(current_token);\n                                            None\n                                        }\n                                    }\n                                }\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Full =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e Some(JoinType::FullOuterJoin),\n                            Token::Outer =\u003e {\n                                if !self.has_next_token() {\n                                    self.unget_next_token(current_token);\n                                    None\n                                } else {\n                                    let third_token = self.get_next_token();\n\n                                    match third_token {\n                                        Token::Join =\u003e Some(JoinType::FullOuterJoin),\n                                        _ =\u003e {\n                                            self.unget_next_token(third_token);\n                                            self.unget_next_token(second_token);\n                                            self.unget_next_token(current_token);\n                                            None\n                                        }\n                                    }\n                                }\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Join =\u003e Some(JoinType::InnerJoin),\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    None\n                }\n            }\n        }\n    }\n\n    // Table Alias 획득\n    pub(crate) fn parse_table_alias(\u0026mut self) -\u003e Result\u003cString, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0024 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::As =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0026 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(id) =\u003e Ok(id),\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"E0027 expected identifier. but your input is {:?}\",\n                        current_token\n                    ))),\n                }\n            }\n            Token::Identifier(id) =\u003e Ok(id),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0025 expected AS. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    // 서브쿼리 분석\n    pub(crate) fn parse_subquery(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSubqueryExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0019 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0020 expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0021 need more tokens\"));\n        }\n\n        // 서브쿼리 파싱\n        let select = self.handle_select_query(context)?;\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0022 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0023 expected right parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        Ok(select.into())\n    }\n}\n","traces":[{"line":11,"address":[5099768,5095984,5098085],"length":1,"stats":{"Line":1}},{"line":12,"address":[5096029],"length":1,"stats":{"Line":2}},{"line":14,"address":[5096143,5096087],"length":1,"stats":{"Line":4}},{"line":15,"address":[5096201,5096149],"length":1,"stats":{"Line":0}},{"line":18,"address":[5096261,5096189],"length":1,"stats":{"Line":4}},{"line":20,"address":[5096269],"length":1,"stats":{"Line":2}},{"line":21,"address":[5096541,5096323],"length":1,"stats":{"Line":4}},{"line":23,"address":[5099514],"length":1,"stats":{"Line":0}},{"line":29,"address":[5096768,5099509,5096592],"length":1,"stats":{"Line":2}},{"line":30,"address":[5096873,5096690],"length":1,"stats":{"Line":4}},{"line":32,"address":[5099504],"length":1,"stats":{"Line":2}},{"line":33,"address":[5096912],"length":1,"stats":{"Line":2}},{"line":37,"address":[5097012],"length":1,"stats":{"Line":2}},{"line":39,"address":[5097027],"length":1,"stats":{"Line":2}},{"line":46,"address":[5099362,5097268],"length":1,"stats":{"Line":2}},{"line":50,"address":[5098098,5097113],"length":1,"stats":{"Line":2}},{"line":51,"address":[5098156,5098104],"length":1,"stats":{"Line":0}},{"line":54,"address":[5098144],"length":1,"stats":{"Line":1}},{"line":56,"address":[5098195],"length":1,"stats":{"Line":1}},{"line":58,"address":[5098437,5098209],"length":1,"stats":{"Line":2}},{"line":61,"address":[5098500],"length":1,"stats":{"Line":0}},{"line":69,"address":[5098734,5097162],"length":1,"stats":{"Line":0}},{"line":70,"address":[5098740,5098792],"length":1,"stats":{"Line":0}},{"line":73,"address":[5098780],"length":1,"stats":{"Line":0}},{"line":75,"address":[5098831],"length":1,"stats":{"Line":0}},{"line":77,"address":[5099050,5098845],"length":1,"stats":{"Line":0}},{"line":80,"address":[5099106],"length":1,"stats":{"Line":0}},{"line":87,"address":[5099357],"length":1,"stats":{"Line":0}},{"line":88,"address":[5097176,5099323],"length":1,"stats":{"Line":0}},{"line":91,"address":[5097094,5097371],"length":1,"stats":{"Line":0}},{"line":92,"address":[5097377,5097429],"length":1,"stats":{"Line":0}},{"line":95,"address":[5097417,5097481],"length":1,"stats":{"Line":0}},{"line":97,"address":[5097489],"length":1,"stats":{"Line":0}},{"line":98,"address":[5097543,5097758],"length":1,"stats":{"Line":0}},{"line":100,"address":[5097834],"length":1,"stats":{"Line":0}},{"line":107,"address":[5098691,5097127],"length":1,"stats":{"Line":0}},{"line":113,"address":[5099400,5096933],"length":1,"stats":{"Line":4}},{"line":117,"address":[5102083,5102715,5099808],"length":1,"stats":{"Line":2}},{"line":118,"address":[5099846],"length":1,"stats":{"Line":2}},{"line":119,"address":[5099863],"length":1,"stats":{"Line":0}},{"line":122,"address":[5099912],"length":1,"stats":{"Line":2}},{"line":124,"address":[5099962,5099933],"length":1,"stats":{"Line":4}},{"line":125,"address":[5100278,5100183,5100010],"length":1,"stats":{"Line":6}},{"line":126,"address":[5100294],"length":1,"stats":{"Line":2}},{"line":127,"address":[5100433,5100504],"length":1,"stats":{"Line":2}},{"line":128,"address":[5100476,5100556],"length":1,"stats":{"Line":4}},{"line":129,"address":[5100668],"length":1,"stats":{"Line":2}},{"line":131,"address":[5100961,5100802],"length":1,"stats":{"Line":4}},{"line":132,"address":[5100967,5101019],"length":1,"stats":{"Line":0}},{"line":135,"address":[5101007],"length":1,"stats":{"Line":2}},{"line":137,"address":[5101059,5101129],"length":1,"stats":{"Line":4}},{"line":138,"address":[5102234],"length":1,"stats":{"Line":0}},{"line":145,"address":[5101254,5101140],"length":1,"stats":{"Line":4}},{"line":146,"address":[5101260,5101312],"length":1,"stats":{"Line":0}},{"line":149,"address":[5101300],"length":1,"stats":{"Line":2}},{"line":151,"address":[5101348,5102211],"length":1,"stats":{"Line":2}},{"line":153,"address":[5101545,5101388],"length":1,"stats":{"Line":4}},{"line":154,"address":[5101551,5101603],"length":1,"stats":{"Line":0}},{"line":157,"address":[5101591],"length":1,"stats":{"Line":2}},{"line":159,"address":[5101709,5101639],"length":1,"stats":{"Line":4}},{"line":160,"address":[5101905],"length":1,"stats":{"Line":0}},{"line":166,"address":[5101725],"length":1,"stats":{"Line":2}},{"line":168,"address":[5102092],"length":1,"stats":{"Line":0}},{"line":174,"address":[5100816],"length":1,"stats":{"Line":0}},{"line":180,"address":[5102506],"length":1,"stats":{"Line":0}},{"line":188,"address":[5104681,5105478,5102752],"length":1,"stats":{"Line":2}},{"line":193,"address":[5102907,5102795],"length":1,"stats":{"Line":4}},{"line":194,"address":[5102962,5102913],"length":1,"stats":{"Line":0}},{"line":198,"address":[5102950,5102996],"length":1,"stats":{"Line":4}},{"line":199,"address":[5103004],"length":1,"stats":{"Line":2}},{"line":201,"address":[5103030],"length":1,"stats":{"Line":2}},{"line":202,"address":[5103089],"length":1,"stats":{"Line":2}},{"line":204,"address":[5105118],"length":1,"stats":{"Line":0}},{"line":210,"address":[5103287,5103129],"length":1,"stats":{"Line":4}},{"line":211,"address":[5103487],"length":1,"stats":{"Line":0}},{"line":212,"address":[5103298],"length":1,"stats":{"Line":0}},{"line":213,"address":[5103423],"length":1,"stats":{"Line":0}},{"line":217,"address":[5103413,5103552],"length":1,"stats":{"Line":4}},{"line":220,"address":[5104448,5103560,5103631],"length":1,"stats":{"Line":5}},{"line":221,"address":[5103702,5103829],"length":1,"stats":{"Line":2}},{"line":222,"address":[5103835,5103887],"length":1,"stats":{"Line":0}},{"line":225,"address":[5103875,5103923],"length":1,"stats":{"Line":2}},{"line":227,"address":[5103931],"length":1,"stats":{"Line":1}},{"line":228,"address":[5103989,5104182,5104266],"length":1,"stats":{"Line":2}},{"line":229,"address":[5104322],"length":1,"stats":{"Line":1}},{"line":231,"address":[5104735],"length":1,"stats":{"Line":0}},{"line":237,"address":[5103713,5103642],"length":1,"stats":{"Line":4}},{"line":240,"address":[5104532],"length":1,"stats":{"Line":2}},{"line":241,"address":[5103720],"length":1,"stats":{"Line":2}},{"line":242,"address":[5104468],"length":1,"stats":{"Line":2}},{"line":247,"address":[5105520,5106776],"length":1,"stats":{"Line":2}},{"line":249,"address":[5105558],"length":1,"stats":{"Line":3}},{"line":250,"address":[5105575],"length":1,"stats":{"Line":0}},{"line":253,"address":[5105624],"length":1,"stats":{"Line":3}},{"line":255,"address":[5105731,5105655],"length":1,"stats":{"Line":6}},{"line":256,"address":[5105852,5105802],"length":1,"stats":{"Line":2}},{"line":257,"address":[5105858,5105910],"length":1,"stats":{"Line":0}},{"line":260,"address":[5105898],"length":1,"stats":{"Line":1}},{"line":262,"address":[5106024,5105954],"length":1,"stats":{"Line":2}},{"line":263,"address":[5106286,5106131],"length":1,"stats":{"Line":2}},{"line":264,"address":[5106292,5106344],"length":1,"stats":{"Line":0}},{"line":267,"address":[5106332],"length":1,"stats":{"Line":1}},{"line":269,"address":[5106491,5106609,5106421],"length":1,"stats":{"Line":3}},{"line":270,"address":[5106598],"length":1,"stats":{"Line":1}},{"line":272,"address":[5106611],"length":1,"stats":{"Line":0}},{"line":278,"address":[5106145],"length":1,"stats":{"Line":0}},{"line":284,"address":[5105742],"length":1,"stats":{"Line":2}},{"line":285,"address":[5105818],"length":1,"stats":{"Line":2}},{"line":290,"address":[5106816,5107605],"length":1,"stats":{"Line":2}},{"line":292,"address":[5106854],"length":1,"stats":{"Line":2}},{"line":293,"address":[5106871],"length":1,"stats":{"Line":0}},{"line":296,"address":[5106920],"length":1,"stats":{"Line":2}},{"line":298,"address":[5106951,5107027],"length":1,"stats":{"Line":4}},{"line":299,"address":[5107098,5107148],"length":1,"stats":{"Line":4}},{"line":300,"address":[5107206,5107154],"length":1,"stats":{"Line":0}},{"line":303,"address":[5107194],"length":1,"stats":{"Line":2}},{"line":305,"address":[5107250,5107320,5107438],"length":1,"stats":{"Line":6}},{"line":306,"address":[5107427],"length":1,"stats":{"Line":2}},{"line":308,"address":[5107440],"length":1,"stats":{"Line":0}},{"line":314,"address":[5107038],"length":1,"stats":{"Line":0}},{"line":315,"address":[5107114],"length":1,"stats":{"Line":0}},{"line":320,"address":[5109341,5109747,5107648],"length":1,"stats":{"Line":1}},{"line":321,"address":[5107678,5110142],"length":1,"stats":{"Line":1}},{"line":323,"address":[5107870,5107926],"length":1,"stats":{"Line":2}},{"line":324,"address":[5107932,5107984],"length":1,"stats":{"Line":0}},{"line":327,"address":[5107972,5108033],"length":1,"stats":{"Line":2}},{"line":329,"address":[5108041],"length":1,"stats":{"Line":1}},{"line":330,"address":[5108095,5108213],"length":1,"stats":{"Line":1}},{"line":332,"address":[5109849],"length":1,"stats":{"Line":0}},{"line":338,"address":[5108467,5108323,5109586,5108383],"length":1,"stats":{"Line":3}},{"line":339,"address":[5108389],"length":1,"stats":{"Line":0}},{"line":341,"address":[5108512,5108482],"length":1,"stats":{"Line":2}},{"line":343,"address":[5109554,5108591,5108520],"length":1,"stats":{"Line":3}},{"line":344,"address":[5108670,5108774],"length":1,"stats":{"Line":2}},{"line":346,"address":[5108782,5109514],"length":1,"stats":{"Line":1}},{"line":347,"address":[5108836,5109020,5109098],"length":1,"stats":{"Line":2}},{"line":348,"address":[5109145],"length":1,"stats":{"Line":1}},{"line":349,"address":[5109240],"length":1,"stats":{"Line":1}},{"line":351,"address":[5109395],"length":1,"stats":{"Line":0}},{"line":357,"address":[5108602],"length":1,"stats":{"Line":1}},{"line":358,"address":[5108677],"length":1,"stats":{"Line":1}},{"line":364,"address":[5111130,5110176],"length":1,"stats":{"Line":1}},{"line":365,"address":[5110272,5110719,5110201,5110261],"length":1,"stats":{"Line":4}},{"line":366,"address":[5110267],"length":1,"stats":{"Line":1}},{"line":368,"address":[5110318,5110284],"length":1,"stats":{"Line":2}},{"line":371,"address":[5110326],"length":1,"stats":{"Line":1}},{"line":373,"address":[5110429],"length":1,"stats":{"Line":2}},{"line":377,"address":[5110684,5110695],"length":1,"stats":{"Line":2}},{"line":380,"address":[5110690],"length":1,"stats":{"Line":0}},{"line":384,"address":[5110477],"length":1,"stats":{"Line":1}},{"line":385,"address":[5111003],"length":1,"stats":{"Line":1}},{"line":387,"address":[5110599],"length":1,"stats":{"Line":1}},{"line":388,"address":[5110612,5111032],"length":1,"stats":{"Line":2}},{"line":402,"address":[5111041],"length":1,"stats":{"Line":1}},{"line":404,"address":[5111094],"length":1,"stats":{"Line":1}},{"line":407,"address":[5110547],"length":1,"stats":{"Line":0}},{"line":408,"address":[5111013],"length":1,"stats":{"Line":0}},{"line":411,"address":[5110728,5110528,5110813],"length":1,"stats":{"Line":2}},{"line":412,"address":[5110739],"length":1,"stats":{"Line":0}},{"line":413,"address":[5110808],"length":1,"stats":{"Line":0}},{"line":415,"address":[5110801],"length":1,"stats":{"Line":1}},{"line":417,"address":[5110815],"length":1,"stats":{"Line":1}},{"line":419,"address":[5110868],"length":1,"stats":{"Line":1}},{"line":420,"address":[5110880],"length":1,"stats":{"Line":1}},{"line":421,"address":[5110929],"length":1,"stats":{"Line":1}},{"line":424,"address":[5110848],"length":1,"stats":{"Line":1}},{"line":425,"address":[5110944],"length":1,"stats":{"Line":1}},{"line":426,"address":[5110993],"length":1,"stats":{"Line":1}},{"line":432,"address":[5110372],"length":1,"stats":{"Line":1}},{"line":433,"address":[5111105],"length":1,"stats":{"Line":1}},{"line":440,"address":[5111354,5111152],"length":1,"stats":{"Line":2}},{"line":441,"address":[5111166,5111180],"length":1,"stats":{"Line":4}},{"line":442,"address":[5111175],"length":1,"stats":{"Line":2}},{"line":444,"address":[5111197],"length":1,"stats":{"Line":2}},{"line":446,"address":[5111212,5111271],"length":1,"stats":{"Line":4}},{"line":448,"address":[5111278,5111333],"length":1,"stats":{"Line":4}},{"line":453,"address":[5111376,5112058],"length":1,"stats":{"Line":0}},{"line":454,"address":[5111426,5111396,5111630],"length":1,"stats":{"Line":0}},{"line":455,"address":[5111421],"length":1,"stats":{"Line":0}},{"line":457,"address":[5111433],"length":1,"stats":{"Line":0}},{"line":459,"address":[5111541,5111461],"length":1,"stats":{"Line":0}},{"line":460,"address":[5111977,5111712,5111606,5111639],"length":1,"stats":{"Line":0}},{"line":461,"address":[5111650],"length":1,"stats":{"Line":0}},{"line":462,"address":[5111707],"length":1,"stats":{"Line":0}},{"line":464,"address":[5111700,5111714],"length":1,"stats":{"Line":0}},{"line":466,"address":[5111722,5111790,5112041],"length":1,"stats":{"Line":0}},{"line":467,"address":[5111858],"length":1,"stats":{"Line":0}},{"line":468,"address":[5111987],"length":1,"stats":{"Line":0}},{"line":469,"address":[5112036],"length":1,"stats":{"Line":0}},{"line":471,"address":[5111801],"length":1,"stats":{"Line":0}},{"line":472,"address":[5111915],"length":1,"stats":{"Line":0}},{"line":473,"address":[5111964],"length":1,"stats":{"Line":0}},{"line":477,"address":[5111552],"length":1,"stats":{"Line":0}},{"line":478,"address":[5111617],"length":1,"stats":{"Line":0}},{"line":484,"address":[5112096,5112298],"length":1,"stats":{"Line":2}},{"line":485,"address":[5112110,5112124],"length":1,"stats":{"Line":2}},{"line":486,"address":[5112119],"length":1,"stats":{"Line":0}},{"line":488,"address":[5112141],"length":1,"stats":{"Line":2}},{"line":490,"address":[5112215,5112156],"length":1,"stats":{"Line":4}},{"line":492,"address":[5112277,5112222],"length":1,"stats":{"Line":4}},{"line":497,"address":[5112522,5112320],"length":1,"stats":{"Line":2}},{"line":498,"address":[5112334,5112348],"length":1,"stats":{"Line":2}},{"line":499,"address":[5112343],"length":1,"stats":{"Line":0}},{"line":501,"address":[5112365],"length":1,"stats":{"Line":2}},{"line":503,"address":[5112439,5112380],"length":1,"stats":{"Line":4}},{"line":505,"address":[5112501,5112446],"length":1,"stats":{"Line":4}},{"line":510,"address":[5113273,5113302,5112544],"length":1,"stats":{"Line":1}},{"line":511,"address":[5112909,5112564,5112586],"length":1,"stats":{"Line":3}},{"line":512,"address":[5112581],"length":1,"stats":{"Line":1}},{"line":514,"address":[5112593],"length":1,"stats":{"Line":1}},{"line":516,"address":[5112611],"length":1,"stats":{"Line":1}},{"line":518,"address":[5112737],"length":1,"stats":{"Line":1}},{"line":519,"address":[5113282],"length":1,"stats":{"Line":1}},{"line":522,"address":[5112825,5112721],"length":1,"stats":{"Line":2}},{"line":523,"address":[5112836],"length":1,"stats":{"Line":0}},{"line":524,"address":[5112896],"length":1,"stats":{"Line":0}},{"line":526,"address":[5112889],"length":1,"stats":{"Line":1}},{"line":527,"address":[5112977,5112930],"length":1,"stats":{"Line":2}},{"line":529,"address":[5112996],"length":1,"stats":{"Line":1}},{"line":530,"address":[5113140],"length":1,"stats":{"Line":1}},{"line":531,"address":[5113189],"length":1,"stats":{"Line":1}},{"line":534,"address":[5113048],"length":1,"stats":{"Line":0}},{"line":535,"address":[5113217],"length":1,"stats":{"Line":0}},{"line":536,"address":[5113266],"length":1,"stats":{"Line":0}},{"line":542,"address":[5112664],"length":1,"stats":{"Line":1}},{"line":543,"address":[5113292],"length":1,"stats":{"Line":1}},{"line":550,"address":[5113328,5113684],"length":1,"stats":{"Line":1}},{"line":551,"address":[5113348,5113362],"length":1,"stats":{"Line":2}},{"line":552,"address":[5113357],"length":1,"stats":{"Line":1}},{"line":554,"address":[5113379],"length":1,"stats":{"Line":1}},{"line":556,"address":[5113455,5113394],"length":1,"stats":{"Line":2}},{"line":558,"address":[5113538],"length":1,"stats":{"Line":1}},{"line":559,"address":[5113650],"length":1,"stats":{"Line":1}},{"line":562,"address":[5113575],"length":1,"stats":{"Line":0}},{"line":563,"address":[5113670],"length":1,"stats":{"Line":0}},{"line":566,"address":[5113489],"length":1,"stats":{"Line":1}},{"line":567,"address":[5113677],"length":1,"stats":{"Line":1}},{"line":574,"address":[5113712,5113994],"length":1,"stats":{"Line":1}},{"line":575,"address":[5113746,5113732],"length":1,"stats":{"Line":2}},{"line":576,"address":[5113741],"length":1,"stats":{"Line":1}},{"line":578,"address":[5113763],"length":1,"stats":{"Line":1}},{"line":580,"address":[5113778,5113839],"length":1,"stats":{"Line":2}},{"line":582,"address":[5113855],"length":1,"stats":{"Line":1}},{"line":583,"address":[5113967],"length":1,"stats":{"Line":1}},{"line":586,"address":[5113892],"length":1,"stats":{"Line":1}},{"line":587,"address":[5113987],"length":1,"stats":{"Line":1}},{"line":594,"address":[5114016,5114502,5114527],"length":1,"stats":{"Line":1}},{"line":595,"address":[5114058,5114429,5114036],"length":1,"stats":{"Line":3}},{"line":596,"address":[5114053],"length":1,"stats":{"Line":1}},{"line":598,"address":[5114065],"length":1,"stats":{"Line":1}},{"line":600,"address":[5114083],"length":1,"stats":{"Line":1}},{"line":602,"address":[5114118,5114231],"length":1,"stats":{"Line":2}},{"line":603,"address":[5114242],"length":1,"stats":{"Line":0}},{"line":604,"address":[5114299],"length":1,"stats":{"Line":0}},{"line":607,"address":[5114292],"length":1,"stats":{"Line":1}},{"line":609,"address":[5114317],"length":1,"stats":{"Line":1}},{"line":611,"address":[5114338],"length":1,"stats":{"Line":1}},{"line":612,"address":[5114367],"length":1,"stats":{"Line":1}},{"line":613,"address":[5114416],"length":1,"stats":{"Line":1}},{"line":616,"address":[5114355],"length":1,"stats":{"Line":0}},{"line":617,"address":[5114439],"length":1,"stats":{"Line":0}},{"line":618,"address":[5114488],"length":1,"stats":{"Line":0}},{"line":623,"address":[5114134],"length":1,"stats":{"Line":1}},{"line":624,"address":[5114495],"length":1,"stats":{"Line":1}},{"line":631,"address":[5115030,5114544,5115055],"length":1,"stats":{"Line":1}},{"line":632,"address":[5114586,5114957,5114564],"length":1,"stats":{"Line":3}},{"line":633,"address":[5114581],"length":1,"stats":{"Line":1}},{"line":635,"address":[5114593],"length":1,"stats":{"Line":1}},{"line":637,"address":[5114611],"length":1,"stats":{"Line":1}},{"line":639,"address":[5114759,5114646],"length":1,"stats":{"Line":2}},{"line":640,"address":[5114770],"length":1,"stats":{"Line":0}},{"line":641,"address":[5114827],"length":1,"stats":{"Line":0}},{"line":644,"address":[5114820],"length":1,"stats":{"Line":1}},{"line":646,"address":[5114845],"length":1,"stats":{"Line":1}},{"line":648,"address":[5114866],"length":1,"stats":{"Line":1}},{"line":649,"address":[5114895],"length":1,"stats":{"Line":1}},{"line":650,"address":[5114944],"length":1,"stats":{"Line":1}},{"line":653,"address":[5114883],"length":1,"stats":{"Line":0}},{"line":654,"address":[5114967],"length":1,"stats":{"Line":0}},{"line":655,"address":[5115016],"length":1,"stats":{"Line":0}},{"line":660,"address":[5114662],"length":1,"stats":{"Line":1}},{"line":661,"address":[5115023],"length":1,"stats":{"Line":1}},{"line":668,"address":[5115072],"length":1,"stats":{"Line":1}},{"line":669,"address":[5115099,5115085],"length":1,"stats":{"Line":2}},{"line":670,"address":[5115094],"length":1,"stats":{"Line":1}},{"line":672,"address":[5115105],"length":1,"stats":{"Line":1}},{"line":674,"address":[5115115],"length":1,"stats":{"Line":1}},{"line":676,"address":[5115146],"length":1,"stats":{"Line":1}},{"line":677,"address":[5115156],"length":1,"stats":{"Line":1}},{"line":680,"address":[5115167],"length":1,"stats":{"Line":1}},{"line":681,"address":[5115177],"length":1,"stats":{"Line":1}},{"line":688,"address":[5115184],"length":1,"stats":{"Line":1}},{"line":689,"address":[5115197,5115211],"length":1,"stats":{"Line":2}},{"line":690,"address":[5115206],"length":1,"stats":{"Line":1}},{"line":692,"address":[5115217],"length":1,"stats":{"Line":1}},{"line":694,"address":[5115227],"length":1,"stats":{"Line":1}},{"line":696,"address":[5115258],"length":1,"stats":{"Line":3}},{"line":697,"address":[5115268],"length":1,"stats":{"Line":3}},{"line":700,"address":[5115279],"length":1,"stats":{"Line":1}},{"line":701,"address":[5115289],"length":1,"stats":{"Line":1}},{"line":708,"address":[5115296],"length":1,"stats":{"Line":1}},{"line":709,"address":[5115309,5115323],"length":1,"stats":{"Line":2}},{"line":710,"address":[5115318],"length":1,"stats":{"Line":1}},{"line":712,"address":[5115329],"length":1,"stats":{"Line":1}},{"line":714,"address":[5115339],"length":1,"stats":{"Line":1}},{"line":716,"address":[5115370],"length":1,"stats":{"Line":1}},{"line":717,"address":[5115380],"length":1,"stats":{"Line":1}},{"line":720,"address":[5115391],"length":1,"stats":{"Line":1}},{"line":721,"address":[5115401],"length":1,"stats":{"Line":1}},{"line":728,"address":[5115408],"length":1,"stats":{"Line":1}},{"line":729,"address":[5115435,5115421],"length":1,"stats":{"Line":1}},{"line":730,"address":[5115430],"length":1,"stats":{"Line":0}},{"line":732,"address":[5115441],"length":1,"stats":{"Line":1}},{"line":734,"address":[5115451],"length":1,"stats":{"Line":2}},{"line":736,"address":[5115482],"length":1,"stats":{"Line":2}},{"line":737,"address":[5115492],"length":1,"stats":{"Line":2}},{"line":740,"address":[5115503],"length":1,"stats":{"Line":1}},{"line":741,"address":[5115513],"length":1,"stats":{"Line":1}},{"line":748,"address":[5116001,5115520,5116026],"length":1,"stats":{"Line":2}},{"line":749,"address":[5115816,5115540,5115562],"length":1,"stats":{"Line":3}},{"line":750,"address":[5115557],"length":1,"stats":{"Line":0}},{"line":752,"address":[5115569],"length":1,"stats":{"Line":2}},{"line":754,"address":[5115587],"length":1,"stats":{"Line":2}},{"line":756,"address":[5115622,5115735],"length":1,"stats":{"Line":2}},{"line":757,"address":[5115746],"length":1,"stats":{"Line":0}},{"line":758,"address":[5115803],"length":1,"stats":{"Line":0}},{"line":760,"address":[5115796],"length":1,"stats":{"Line":1}},{"line":762,"address":[5115821],"length":1,"stats":{"Line":1}},{"line":764,"address":[5115842],"length":1,"stats":{"Line":1}},{"line":765,"address":[5115871],"length":1,"stats":{"Line":1}},{"line":766,"address":[5115920],"length":1,"stats":{"Line":1}},{"line":769,"address":[5115859],"length":1,"stats":{"Line":0}},{"line":770,"address":[5115932],"length":1,"stats":{"Line":0}},{"line":771,"address":[5115981],"length":1,"stats":{"Line":0}},{"line":777,"address":[5115638],"length":1,"stats":{"Line":1}},{"line":778,"address":[5115991],"length":1,"stats":{"Line":1}},{"line":785,"address":[5116529,5116554,5116048],"length":1,"stats":{"Line":2}},{"line":786,"address":[5116090,5116068,5116344],"length":1,"stats":{"Line":3}},{"line":787,"address":[5116085],"length":1,"stats":{"Line":0}},{"line":789,"address":[5116097],"length":1,"stats":{"Line":2}},{"line":791,"address":[5116115],"length":1,"stats":{"Line":2}},{"line":793,"address":[5116263,5116150],"length":1,"stats":{"Line":2}},{"line":794,"address":[5116274],"length":1,"stats":{"Line":0}},{"line":795,"address":[5116331],"length":1,"stats":{"Line":0}},{"line":797,"address":[5116324],"length":1,"stats":{"Line":1}},{"line":799,"address":[5116349],"length":1,"stats":{"Line":1}},{"line":801,"address":[5116370],"length":1,"stats":{"Line":1}},{"line":802,"address":[5116399],"length":1,"stats":{"Line":1}},{"line":803,"address":[5116448],"length":1,"stats":{"Line":1}},{"line":806,"address":[5116387],"length":1,"stats":{"Line":0}},{"line":807,"address":[5116460],"length":1,"stats":{"Line":0}},{"line":808,"address":[5116509],"length":1,"stats":{"Line":0}},{"line":814,"address":[5116166],"length":1,"stats":{"Line":1}},{"line":815,"address":[5116519],"length":1,"stats":{"Line":1}},{"line":822,"address":[5116576],"length":1,"stats":{"Line":1}},{"line":823,"address":[5116589,5116603],"length":1,"stats":{"Line":1}},{"line":824,"address":[5116598],"length":1,"stats":{"Line":0}},{"line":826,"address":[5116609],"length":1,"stats":{"Line":1}},{"line":828,"address":[5116619],"length":1,"stats":{"Line":1}},{"line":830,"address":[5116650],"length":1,"stats":{"Line":1}},{"line":831,"address":[5116660],"length":1,"stats":{"Line":1}},{"line":834,"address":[5116671],"length":1,"stats":{"Line":0}},{"line":835,"address":[5116681],"length":1,"stats":{"Line":0}},{"line":842,"address":[5116688,5118286,5119211],"length":1,"stats":{"Line":1}},{"line":843,"address":[5119194,5116708,5116770],"length":1,"stats":{"Line":3}},{"line":844,"address":[5116765],"length":1,"stats":{"Line":1}},{"line":846,"address":[5116777],"length":1,"stats":{"Line":1}},{"line":848,"address":[5116795],"length":1,"stats":{"Line":1}},{"line":850,"address":[5117044,5116931,5117123,5117312],"length":1,"stats":{"Line":3}},{"line":851,"address":[5117055],"length":1,"stats":{"Line":0}},{"line":852,"address":[5117118],"length":1,"stats":{"Line":0}},{"line":854,"address":[5117128,5117111],"length":1,"stats":{"Line":2}},{"line":856,"address":[5117136],"length":1,"stats":{"Line":1}},{"line":857,"address":[5117150],"length":1,"stats":{"Line":1}},{"line":859,"address":[5117176],"length":1,"stats":{"Line":0}},{"line":860,"address":[5117248],"length":1,"stats":{"Line":0}},{"line":861,"address":[5117297],"length":1,"stats":{"Line":0}},{"line":867,"address":[5117336,5117421,5116947,5118367],"length":1,"stats":{"Line":5}},{"line":868,"address":[5117347],"length":1,"stats":{"Line":0}},{"line":869,"address":[5117416],"length":1,"stats":{"Line":0}},{"line":871,"address":[5117409,5117426],"length":1,"stats":{"Line":4}},{"line":873,"address":[5117434],"length":1,"stats":{"Line":2}},{"line":874,"address":[5117531],"length":1,"stats":{"Line":1}},{"line":875,"address":[5117611],"length":1,"stats":{"Line":1}},{"line":876,"address":[5117632],"length":1,"stats":{"Line":1}},{"line":880,"address":[5117862,5118248,5117567,5117717],"length":1,"stats":{"Line":3}},{"line":881,"address":[5117728],"length":1,"stats":{"Line":0}},{"line":882,"address":[5117808],"length":1,"stats":{"Line":0}},{"line":883,"address":[5117857],"length":1,"stats":{"Line":0}},{"line":885,"address":[5117796,5117867],"length":1,"stats":{"Line":2}},{"line":887,"address":[5117875],"length":1,"stats":{"Line":1}},{"line":888,"address":[5117889],"length":1,"stats":{"Line":1}},{"line":889,"address":[5118016],"length":1,"stats":{"Line":1}},{"line":890,"address":[5118037],"length":1,"stats":{"Line":1}},{"line":894,"address":[5117925],"length":1,"stats":{"Line":0}},{"line":895,"address":[5118121],"length":1,"stats":{"Line":0}},{"line":896,"address":[5118181],"length":1,"stats":{"Line":0}},{"line":897,"address":[5118230],"length":1,"stats":{"Line":0}},{"line":903,"address":[5117473],"length":1,"stats":{"Line":0}},{"line":904,"address":[5118300],"length":1,"stats":{"Line":0}},{"line":905,"address":[5118349],"length":1,"stats":{"Line":0}},{"line":911,"address":[5118409,5116966,5118494,5119138],"length":1,"stats":{"Line":5}},{"line":912,"address":[5118420],"length":1,"stats":{"Line":0}},{"line":913,"address":[5118489],"length":1,"stats":{"Line":0}},{"line":915,"address":[5118482,5118499],"length":1,"stats":{"Line":4}},{"line":917,"address":[5118507],"length":1,"stats":{"Line":2}},{"line":918,"address":[5118604],"length":1,"stats":{"Line":1}},{"line":920,"address":[5118630,5118790,5119046,5118705],"length":1,"stats":{"Line":3}},{"line":921,"address":[5118716],"length":1,"stats":{"Line":0}},{"line":922,"address":[5118785],"length":1,"stats":{"Line":0}},{"line":924,"address":[5118778,5118795],"length":1,"stats":{"Line":2}},{"line":926,"address":[5118803],"length":1,"stats":{"Line":1}},{"line":927,"address":[5118817],"length":1,"stats":{"Line":1}},{"line":929,"address":[5118843],"length":1,"stats":{"Line":0}},{"line":930,"address":[5118919],"length":1,"stats":{"Line":0}},{"line":931,"address":[5118979],"length":1,"stats":{"Line":0}},{"line":932,"address":[5119028],"length":1,"stats":{"Line":0}},{"line":938,"address":[5118546],"length":1,"stats":{"Line":0}},{"line":939,"address":[5119071],"length":1,"stats":{"Line":0}},{"line":940,"address":[5119120],"length":1,"stats":{"Line":0}},{"line":945,"address":[5116905],"length":1,"stats":{"Line":1}},{"line":947,"address":[5116853],"length":1,"stats":{"Line":1}},{"line":948,"address":[5119176],"length":1,"stats":{"Line":1}},{"line":955,"address":[5119248,5120320,5120538],"length":1,"stats":{"Line":1}},{"line":957,"address":[5119286],"length":1,"stats":{"Line":1}},{"line":958,"address":[5119311],"length":1,"stats":{"Line":0}},{"line":961,"address":[5119360],"length":1,"stats":{"Line":1}},{"line":963,"address":[5119381],"length":1,"stats":{"Line":1}},{"line":965,"address":[5119540,5119712],"length":1,"stats":{"Line":2}},{"line":966,"address":[5119718,5119770],"length":1,"stats":{"Line":0}},{"line":969,"address":[5119758,5119830],"length":1,"stats":{"Line":2}},{"line":971,"address":[5119838],"length":1,"stats":{"Line":1}},{"line":972,"address":[5119857],"length":1,"stats":{"Line":1}},{"line":973,"address":[5120117],"length":1,"stats":{"Line":0}},{"line":979,"address":[5119559],"length":1,"stats":{"Line":0}},{"line":980,"address":[5120329],"length":1,"stats":{"Line":0}},{"line":988,"address":[5120576,5122195,5122027],"length":1,"stats":{"Line":1}},{"line":992,"address":[5120619,5120699],"length":1,"stats":{"Line":2}},{"line":993,"address":[5120705,5120754],"length":1,"stats":{"Line":0}},{"line":997,"address":[5120742],"length":1,"stats":{"Line":1}},{"line":999,"address":[5120788,5120858],"length":1,"stats":{"Line":2}},{"line":1000,"address":[5122056],"length":1,"stats":{"Line":0}},{"line":1006,"address":[5120869,5120983],"length":1,"stats":{"Line":2}},{"line":1007,"address":[5121085,5120989],"length":1,"stats":{"Line":0}},{"line":1011,"address":[5122054,5121026,5121137,5121281],"length":1,"stats":{"Line":2}},{"line":1013,"address":[5121262,5121431],"length":1,"stats":{"Line":2}},{"line":1014,"address":[5121489,5121437],"length":1,"stats":{"Line":0}},{"line":1018,"address":[5121477],"length":1,"stats":{"Line":1}},{"line":1020,"address":[5121525,5121595],"length":1,"stats":{"Line":2}},{"line":1021,"address":[5121836],"length":1,"stats":{"Line":0}},{"line":1027,"address":[5121601,5121774],"length":1,"stats":{"Line":2}}],"covered":306,"coverable":451},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","database.rs"],"content":"use crate::ast::ddl::alter_database::{\n    AlterDatabaseAction, AlterDatabaseQuery, AlterDatabaseRenameTo,\n};\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::ast::ddl::drop_database::{DropDatabaseQuery, SQLStatement};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE DATABASE 쿼리 분석\n    pub(crate) fn handle_create_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0101 need more tokens\"));\n        }\n\n        let mut query_builder = CreateDatabaseQuery::builder();\n\n        // IF NOT EXISTS 파싱\n        let if_not_exists = self.has_if_not_exists()?;\n        query_builder = query_builder.set_if_not_exists(if_not_exists);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0102 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (create database)\",\n                ));\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // DROP DATABASE 쿼리 분석\n    pub(crate) fn handle_drop_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        let mut query_builder = DropDatabaseQuery::builder();\n\n        // IF EXISTS 파싱\n        let if_exists = self.has_if_exists()?;\n        query_builder = query_builder.set_if_exists(if_exists);\n\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0104 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (create database)\",\n                ));\n            }\n        }\n\n        // 세미콜론 체크\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // ALTER DATABASE 쿼리 분석\n    pub(crate) fn handle_alter_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0105 need more tokens\"));\n        }\n\n        let mut query_builder = AlterDatabaseQuery::builder();\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (alter database)\",\n                ));\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Rename =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E106: expected 'TO'. but no more token\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if current_token != Token::To {\n                    return Err(ParsingError::wrap(format!(\n                        \"E107: expected 'TO'. but your input word is '{:?}'\",\n                        current_token\n                    )));\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\n                        \"E108: expected identifier. but no more token\",\n                    ));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(identifier) =\u003e {\n                        query_builder = query_builder.set_action(AlterDatabaseAction::RenameTo(\n                            AlterDatabaseRenameTo { name: identifier },\n                        ));\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(\n                            \"E109: not supported command. possible commands: (alter database)\",\n                        ));\n                    }\n                }\n            }\n            Token::SemiColon =\u003e {}\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E107: not supported syntax'{:?}'\",\n                    current_token\n                )));\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":13,"address":[5123770,5123973,5122224],"length":1,"stats":{"Line":2}},{"line":14,"address":[5122262],"length":1,"stats":{"Line":2}},{"line":15,"address":[5122287],"length":1,"stats":{"Line":0}},{"line":18,"address":[5122353],"length":1,"stats":{"Line":2}},{"line":21,"address":[5122502,5123943,5122384,5122461,5122581],"length":1,"stats":{"Line":4}},{"line":22,"address":[5122691,5122513,5122494],"length":1,"stats":{"Line":3}},{"line":24,"address":[5122728],"length":1,"stats":{"Line":1}},{"line":25,"address":[5122801,5122749],"length":1,"stats":{"Line":0}},{"line":28,"address":[5122789,5122860],"length":1,"stats":{"Line":2}},{"line":30,"address":[5122868],"length":1,"stats":{"Line":1}},{"line":31,"address":[5122882],"length":1,"stats":{"Line":1}},{"line":32,"address":[5123070,5122922],"length":1,"stats":{"Line":4}},{"line":35,"address":[5122990,5123784],"length":1,"stats":{"Line":0}},{"line":41,"address":[5123107],"length":1,"stats":{"Line":2}},{"line":42,"address":[5123213,5123128],"length":1,"stats":{"Line":0}},{"line":45,"address":[5123201],"length":1,"stats":{"Line":2}},{"line":47,"address":[5123324,5123254],"length":1,"stats":{"Line":4}},{"line":48,"address":[5123578],"length":1,"stats":{"Line":0}},{"line":54,"address":[5123511,5123330],"length":1,"stats":{"Line":4}},{"line":58,"address":[5124000,5125421,5125624],"length":1,"stats":{"Line":1}},{"line":59,"address":[5124030],"length":1,"stats":{"Line":1}},{"line":62,"address":[5125594,5124138,5124173,5124077,5124249],"length":1,"stats":{"Line":3}},{"line":63,"address":[5124168,5124347,5124184],"length":1,"stats":{"Line":3}},{"line":66,"address":[5124381],"length":1,"stats":{"Line":1}},{"line":67,"address":[5124402,5124454],"length":1,"stats":{"Line":0}},{"line":70,"address":[5124513,5124442],"length":1,"stats":{"Line":2}},{"line":72,"address":[5124521],"length":1,"stats":{"Line":1}},{"line":73,"address":[5124535],"length":1,"stats":{"Line":1}},{"line":74,"address":[5124575,5124720],"length":1,"stats":{"Line":2}},{"line":77,"address":[5125435,5124640],"length":1,"stats":{"Line":0}},{"line":84,"address":[5124754],"length":1,"stats":{"Line":1}},{"line":85,"address":[5124857,5124775],"length":1,"stats":{"Line":0}},{"line":88,"address":[5124845],"length":1,"stats":{"Line":1}},{"line":90,"address":[5124968,5124898],"length":1,"stats":{"Line":2}},{"line":91,"address":[5125229],"length":1,"stats":{"Line":0}},{"line":97,"address":[5125152,5124974],"length":1,"stats":{"Line":2}},{"line":101,"address":[5128183,5125664,5127591],"length":1,"stats":{"Line":2}},{"line":102,"address":[5125702],"length":1,"stats":{"Line":2}},{"line":103,"address":[5125735],"length":1,"stats":{"Line":0}},{"line":106,"address":[5125801],"length":1,"stats":{"Line":2}},{"line":108,"address":[5125835,5125896],"length":1,"stats":{"Line":4}},{"line":110,"address":[5125904],"length":1,"stats":{"Line":2}},{"line":111,"address":[5125918],"length":1,"stats":{"Line":2}},{"line":112,"address":[5125958,5126125],"length":1,"stats":{"Line":4}},{"line":115,"address":[5127989,5126045],"length":1,"stats":{"Line":0}},{"line":121,"address":[5126181],"length":1,"stats":{"Line":2}},{"line":122,"address":[5126306,5126202],"length":1,"stats":{"Line":0}},{"line":125,"address":[5126294],"length":1,"stats":{"Line":2}},{"line":127,"address":[5126347],"length":1,"stats":{"Line":2}},{"line":129,"address":[5126622,5126485],"length":1,"stats":{"Line":2}},{"line":130,"address":[5126680,5126628],"length":1,"stats":{"Line":0}},{"line":133,"address":[5126668],"length":1,"stats":{"Line":1}},{"line":135,"address":[5126738,5126808],"length":1,"stats":{"Line":2}},{"line":136,"address":[5127600],"length":1,"stats":{"Line":0}},{"line":142,"address":[5126819,5126933],"length":1,"stats":{"Line":2}},{"line":143,"address":[5126939,5126991],"length":1,"stats":{"Line":0}},{"line":148,"address":[5126979,5127049],"length":1,"stats":{"Line":2}},{"line":150,"address":[5127057],"length":1,"stats":{"Line":1}},{"line":151,"address":[5127075],"length":1,"stats":{"Line":1}},{"line":152,"address":[5127341,5127115,5127203],"length":1,"stats":{"Line":3}},{"line":153,"address":[5127171],"length":1,"stats":{"Line":1}},{"line":157,"address":[5127266,5127435],"length":1,"stats":{"Line":0}},{"line":165,"address":[5127838],"length":1,"stats":{"Line":0}},{"line":172,"address":[5127771,5126496],"length":1,"stats":{"Line":2}}],"covered":47,"coverable":64},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","mod.rs"],"content":"pub mod database;\npub mod table;\npub mod top_level;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","table.rs"],"content":"use crate::ast::ddl::alter_table::{\n    AlterColumnDropDefault, AlterColumnDropNotNull, AlterColumnSetDefault, AlterColumnSetNotNull,\n    AlterColumnSetType, AlterTableAddColumn, AlterTableAlterColumn, AlterTableDropColumn,\n    AlterTableQuery, AlterTableRenameColumn, AlterTableRenameTo,\n};\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::ast::ddl::drop_database::SQLStatement;\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE TABLE 쿼리 분석\n    pub(crate) fn handle_create_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1205 need more tokens\"));\n        }\n\n        let mut query_builder = CreateTableQuery::builder();\n\n        // IF NOT EXISTS 파싱\n        let if_not_exists = self.has_if_not_exists()?;\n        query_builder = query_builder.set_if_not_exists(if_not_exists);\n\n        // 테이블명 설정\n        let table = self.parse_table_name(context)?;\n        query_builder = query_builder.set_table(table);\n\n        // 여는 괄호 체크\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1206 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::LeftParentheses != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1207 expected '('. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // 닫는 괄호 나올때까지 행 파싱 반복\n        loop {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E1208 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::RightParentheses =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    let column = self.parse_table_column()?;\n                    query_builder = query_builder.add_column(column);\n                }\n            }\n        }\n\n        // 닫는 괄호 체크\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1209 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::RightParentheses != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1210 expected ')'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1211 expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // ALTER TABLE 쿼리 분석\n    pub(crate) fn handle_alter_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1201 need more tokens\"));\n        }\n\n        let mut query_builder = AlterTableQuery::builder();\n\n        let table_name = self.parse_table_name(context.clone())?;\n\n        query_builder = query_builder.set_table(table_name);\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::SemiColon =\u003e return Ok(query_builder.build()),\n            Token::Rename =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1212 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    // table name rename\n                    Token::To =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1213 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        match current_token {\n                            Token::Identifier(identifier) =\u003e {\n                                query_builder = query_builder\n                                    .set_action(AlterTableRenameTo { name: identifier }.into());\n                            }\n                            _ =\u003e {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1214 unexpected token {:?}\",\n                                    current_token\n                                )))\n                            }\n                        }\n                    }\n                    // table column name rename\n                    Token::Column =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1217 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if let Token::Identifier(from_name) = current_token {\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1219 need more tokens\"));\n                            }\n\n                            let current_token = self.get_next_token();\n\n                            if Token::To != current_token {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1220 expected token is 'TO', but you input is {:?}\",\n                                    current_token\n                                )));\n                            }\n\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1221 need more tokens\"));\n                            }\n\n                            let current_token = self.get_next_token();\n\n                            if let Token::Identifier(to_name) = current_token {\n                                query_builder = query_builder.set_action(\n                                    AlterTableRenameColumn { from_name, to_name }.into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1222 expected token is 'identifer', but you input is {:?}\",\n                                    current_token\n                                )));\n                            }\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1218 expected token {:?}\",\n                                current_token\n                            )));\n                        }\n                    }\n                    // table column name rename\n                    Token::Identifier(from_name) =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1218 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if Token::To != current_token {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1223 expected token is 'TO', but you input is {:?}\",\n                                current_token\n                            )));\n                        }\n\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1224 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if let Token::Identifier(to_name) = current_token {\n                            query_builder = query_builder\n                                .set_action(AlterTableRenameColumn { from_name, to_name }.into());\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1225 expected token is 'identifer', but you input is {:?}\",\n                                current_token\n                            )));\n                        }\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E1213 expected token is 'TO' or 'COLUMN', but you input is {:?}\",\n                            current_token\n                        )))\n                    }\n                }\n            }\n            Token::Add =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1215 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Column =\u003e {\n                        let column = self.parse_table_column()?;\n\n                        query_builder =\n                            query_builder.set_action(AlterTableAddColumn { column }.into());\n                    }\n                    Token::Identifier(_) =\u003e {\n                        self.unget_next_token(current_token);\n\n                        let column = self.parse_table_column()?;\n\n                        query_builder =\n                            query_builder.set_action(AlterTableAddColumn { column }.into());\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E1216 unexpected keyword '{:?}'\",\n                            current_token\n                        )))\n                    }\n                }\n            }\n            Token::Drop =\u003e {\n                if self.next_token_is_column() {\n                    self.get_next_token();\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1226 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(column_name) = current_token {\n                    query_builder =\n                        query_builder.set_action(AlterTableDropColumn { column_name }.into());\n                } else {\n                    return Err(ParsingError::wrap(format!(\n                        \"E1227 unexpected token {:?}\",\n                        current_token\n                    )));\n                }\n            }\n            Token::Alter =\u003e {\n                if self.next_token_is_column() {\n                    self.get_next_token();\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1228 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(column_name) = current_token {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E1230 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Set =\u003e {\n                            if self.next_token_is_not_null() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetNotNull {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_data_type() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                if !self.has_next_token() {\n                                    return Err(ParsingError::wrap(\"E1233 need more tokens\"));\n                                }\n\n                                let data_type = self.parse_data_type()?;\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetType { data_type }.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_default() {\n                                self.get_next_token();\n\n                                if !self.has_next_token() {\n                                    return Err(ParsingError::wrap(\"E1234 need more tokens\"));\n                                }\n\n                                let expression = self.parse_expression(context)?;\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetDefault { expression }.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(\"E1231 unexpected tokens\"));\n                            }\n                        }\n                        Token::Drop =\u003e {\n                            if self.next_token_is_not_null() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnDropNotNull {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_default() {\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnDropDefault {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(\"E1231 unexpected tokens\"));\n                            }\n                        }\n                        Token::Type =\u003e {\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1232 need more tokens\"));\n                            }\n\n                            let data_type = self.parse_data_type()?;\n\n                            query_builder = query_builder.set_action(\n                                AlterTableAlterColumn {\n                                    action: AlterColumnSetType { data_type }.into(),\n                                    column_name,\n                                }\n                                .into(),\n                            );\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1229 unexpected token {:?}\",\n                                current_token\n                            )))\n                        }\n                    }\n                } else {\n                    return Err(ParsingError::wrap(format!(\n                        \"E1229 unexpected token {:?}\",\n                        current_token\n                    )));\n                }\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E1202 unexpected keyword '{:?}'\",\n                    current_token\n                )))\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // DROP TABLE 쿼리 분석\n    pub(crate) fn handle_drop_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        let mut query_builder = DropTableQuery::builder();\n\n        // IF EXISTS 파싱\n        let if_exists = self.has_if_exists()?;\n        query_builder = query_builder.set_if_exists(if_exists);\n\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1203 need more tokens\"));\n        }\n\n        let table = self.parse_table_name(context)?;\n\n        // 테이블명 설정\n        query_builder = query_builder.set_table(table);\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1204 expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":17,"address":[5130916,5131815,5128224],"length":1,"stats":{"Line":1}},{"line":21,"address":[5128390,5128288],"length":1,"stats":{"Line":2}},{"line":22,"address":[5128396,5128446],"length":1,"stats":{"Line":0}},{"line":25,"address":[5128431],"length":1,"stats":{"Line":1}},{"line":28,"address":[5131752,5128513,5128593,5128725,5128638],"length":1,"stats":{"Line":3}},{"line":29,"address":[5128647,5128626,5128830],"length":1,"stats":{"Line":3}},{"line":32,"address":[5129227,5128878,5131735],"length":1,"stats":{"Line":1}},{"line":33,"address":[5129089,5129373],"length":1,"stats":{"Line":2}},{"line":36,"address":[5129416],"length":1,"stats":{"Line":1}},{"line":37,"address":[5129437,5129492],"length":1,"stats":{"Line":0}},{"line":40,"address":[5129477],"length":1,"stats":{"Line":1}},{"line":42,"address":[5129548,5129618],"length":1,"stats":{"Line":2}},{"line":43,"address":[5131565],"length":1,"stats":{"Line":0}},{"line":50,"address":[5131529],"length":1,"stats":{"Line":1}},{"line":51,"address":[5129629,5129743],"length":1,"stats":{"Line":2}},{"line":52,"address":[5129749,5129804],"length":1,"stats":{"Line":0}},{"line":55,"address":[5129789],"length":1,"stats":{"Line":1}},{"line":57,"address":[5129865],"length":1,"stats":{"Line":1}},{"line":59,"address":[5129892],"length":1,"stats":{"Line":1}},{"line":63,"address":[5129912],"length":1,"stats":{"Line":1}},{"line":64,"address":[5131090,5131348],"length":1,"stats":{"Line":1}},{"line":65,"address":[5131487,5131238],"length":1,"stats":{"Line":2}},{"line":71,"address":[5129927],"length":1,"stats":{"Line":1}},{"line":72,"address":[5129948,5130003],"length":1,"stats":{"Line":0}},{"line":75,"address":[5129988],"length":1,"stats":{"Line":1}},{"line":77,"address":[5130051,5130121],"length":1,"stats":{"Line":2}},{"line":78,"address":[5130925],"length":1,"stats":{"Line":0}},{"line":84,"address":[5130132,5130246],"length":1,"stats":{"Line":2}},{"line":85,"address":[5130343,5130252],"length":1,"stats":{"Line":0}},{"line":88,"address":[5130328],"length":1,"stats":{"Line":1}},{"line":90,"address":[5130379,5130449],"length":1,"stats":{"Line":2}},{"line":91,"address":[5130721],"length":1,"stats":{"Line":0}},{"line":97,"address":[5130455,5130642],"length":1,"stats":{"Line":2}},{"line":101,"address":[5131840,5135760,5148054],"length":1,"stats":{"Line":2}},{"line":105,"address":[5132260,5131958],"length":1,"stats":{"Line":4}},{"line":106,"address":[5132316,5132266],"length":1,"stats":{"Line":0}},{"line":109,"address":[5132301],"length":1,"stats":{"Line":2}},{"line":111,"address":[5132782,5147985,5132474,5132386],"length":1,"stats":{"Line":4}},{"line":113,"address":[5132928,5132638],"length":1,"stats":{"Line":4}},{"line":115,"address":[5132974],"length":1,"stats":{"Line":2}},{"line":116,"address":[5133101,5133001],"length":1,"stats":{"Line":0}},{"line":119,"address":[5133086],"length":1,"stats":{"Line":2}},{"line":121,"address":[5133146],"length":1,"stats":{"Line":2}},{"line":122,"address":[5133395,5147792],"length":1,"stats":{"Line":0}},{"line":124,"address":[5133378,5142291],"length":1,"stats":{"Line":2}},{"line":125,"address":[5142297,5142355],"length":1,"stats":{"Line":0}},{"line":128,"address":[5142340,5142403],"length":1,"stats":{"Line":2}},{"line":130,"address":[5142411],"length":1,"stats":{"Line":1}},{"line":133,"address":[5144979,5142599],"length":1,"stats":{"Line":2}},{"line":134,"address":[5144985,5145043],"length":1,"stats":{"Line":0}},{"line":137,"address":[5145028,5145091],"length":1,"stats":{"Line":2}},{"line":139,"address":[5145099],"length":1,"stats":{"Line":1}},{"line":140,"address":[5145117],"length":1,"stats":{"Line":1}},{"line":141,"address":[5145455,5145157,5145408],"length":1,"stats":{"Line":3}},{"line":142,"address":[5145367,5145447,5145562,5145203],"length":1,"stats":{"Line":2}},{"line":145,"address":[5145591],"length":1,"stats":{"Line":0}},{"line":154,"address":[5142577,5142732],"length":1,"stats":{"Line":2}},{"line":155,"address":[5142796,5142738],"length":1,"stats":{"Line":0}},{"line":158,"address":[5142862,5142781],"length":1,"stats":{"Line":2}},{"line":160,"address":[5142870],"length":1,"stats":{"Line":1}},{"line":161,"address":[5143098,5142940],"length":1,"stats":{"Line":2}},{"line":162,"address":[5143162,5143104],"length":1,"stats":{"Line":0}},{"line":165,"address":[5143147],"length":1,"stats":{"Line":1}},{"line":167,"address":[5143227,5143297],"length":1,"stats":{"Line":2}},{"line":168,"address":[5144462],"length":1,"stats":{"Line":0}},{"line":174,"address":[5143425,5143311],"length":1,"stats":{"Line":2}},{"line":175,"address":[5143431,5143489],"length":1,"stats":{"Line":0}},{"line":178,"address":[5143550,5143474],"length":1,"stats":{"Line":2}},{"line":180,"address":[5143558],"length":1,"stats":{"Line":1}},{"line":181,"address":[5143616,5143986,5143939],"length":1,"stats":{"Line":3}},{"line":182,"address":[5143662],"length":1,"stats":{"Line":1}},{"line":185,"address":[5144202],"length":1,"stats":{"Line":0}},{"line":191,"address":[5144709],"length":1,"stats":{"Line":0}},{"line":198,"address":[5142621],"length":1,"stats":{"Line":1}},{"line":199,"address":[5142669,5145896],"length":1,"stats":{"Line":2}},{"line":200,"address":[5145960,5145902],"length":1,"stats":{"Line":0}},{"line":203,"address":[5145945],"length":1,"stats":{"Line":1}},{"line":205,"address":[5146025,5146095],"length":1,"stats":{"Line":2}},{"line":206,"address":[5147331],"length":1,"stats":{"Line":0}},{"line":212,"address":[5146109,5146221],"length":1,"stats":{"Line":2}},{"line":213,"address":[5146227,5146285],"length":1,"stats":{"Line":0}},{"line":216,"address":[5146346,5146270],"length":1,"stats":{"Line":2}},{"line":218,"address":[5146354],"length":1,"stats":{"Line":1}},{"line":219,"address":[5146412,5146782,5146735],"length":1,"stats":{"Line":3}},{"line":220,"address":[5146774,5146694,5146458,5147042],"length":1,"stats":{"Line":2}},{"line":222,"address":[5147071],"length":1,"stats":{"Line":0}},{"line":229,"address":[5147518],"length":1,"stats":{"Line":0}},{"line":237,"address":[5140450,5133353],"length":1,"stats":{"Line":4}},{"line":238,"address":[5140514,5140456],"length":1,"stats":{"Line":0}},{"line":241,"address":[5140499,5140562],"length":1,"stats":{"Line":4}},{"line":243,"address":[5140570],"length":1,"stats":{"Line":2}},{"line":245,"address":[5140849,5140719,5141119],"length":1,"stats":{"Line":2}},{"line":247,"address":[5141312],"length":1,"stats":{"Line":1}},{"line":248,"address":[5141224,5140974,5141396],"length":1,"stats":{"Line":1}},{"line":251,"address":[5140734],"length":1,"stats":{"Line":1}},{"line":253,"address":[5141464,5141757],"length":1,"stats":{"Line":1}},{"line":255,"address":[5141950],"length":1,"stats":{"Line":1}},{"line":256,"address":[5141862,5142048,5141612],"length":1,"stats":{"Line":1}},{"line":259,"address":[5142086],"length":1,"stats":{"Line":0}},{"line":267,"address":[5139504,5133328],"length":1,"stats":{"Line":3}},{"line":268,"address":[5139545],"length":1,"stats":{"Line":1}},{"line":271,"address":[5139571,5139518],"length":1,"stats":{"Line":3}},{"line":272,"address":[5139635,5139577],"length":1,"stats":{"Line":0}},{"line":275,"address":[5139620,5139683],"length":1,"stats":{"Line":4}},{"line":277,"address":[5139691],"length":1,"stats":{"Line":2}},{"line":278,"address":[5140047],"length":1,"stats":{"Line":2}},{"line":279,"address":[5140154,5139959,5139749],"length":1,"stats":{"Line":2}},{"line":281,"address":[5140183],"length":1,"stats":{"Line":0}},{"line":288,"address":[5133303,5133514],"length":1,"stats":{"Line":3}},{"line":289,"address":[5133558],"length":1,"stats":{"Line":2}},{"line":292,"address":[5133587,5133528],"length":1,"stats":{"Line":4}},{"line":293,"address":[5133651,5133593],"length":1,"stats":{"Line":0}},{"line":296,"address":[5133712,5133636],"length":1,"stats":{"Line":4}},{"line":298,"address":[5133720],"length":1,"stats":{"Line":2}},{"line":299,"address":[5133790,5133954],"length":1,"stats":{"Line":4}},{"line":300,"address":[5133960,5134018],"length":1,"stats":{"Line":0}},{"line":303,"address":[5134003],"length":1,"stats":{"Line":2}},{"line":305,"address":[5134083],"length":1,"stats":{"Line":2}},{"line":307,"address":[5137052,5134369,5134258],"length":1,"stats":{"Line":7}},{"line":308,"address":[5134413,5136635],"length":1,"stats":{"Line":2}},{"line":309,"address":[5136658],"length":1,"stats":{"Line":1}},{"line":311,"address":[5137018,5136971,5136680],"length":1,"stats":{"Line":3}},{"line":312,"address":[5136829],"length":1,"stats":{"Line":1}},{"line":313,"address":[5136726],"length":1,"stats":{"Line":1}},{"line":314,"address":[5136789],"length":1,"stats":{"Line":1}},{"line":318,"address":[5134383,5134430,5136599],"length":1,"stats":{"Line":4}},{"line":319,"address":[5135808,5134474],"length":1,"stats":{"Line":2}},{"line":320,"address":[5135831],"length":1,"stats":{"Line":1}},{"line":322,"address":[5135861],"length":1,"stats":{"Line":1}},{"line":323,"address":[5135946,5135888],"length":1,"stats":{"Line":0}},{"line":326,"address":[5136010,5135931,5136190,5136622],"length":1,"stats":{"Line":2}},{"line":328,"address":[5136565,5136095,5136518],"length":1,"stats":{"Line":3}},{"line":329,"address":[5136376],"length":1,"stats":{"Line":1}},{"line":330,"address":[5136157],"length":1,"stats":{"Line":1}},{"line":331,"address":[5136336],"length":1,"stats":{"Line":1}},{"line":335,"address":[5134491,5134444],"length":1,"stats":{"Line":2}},{"line":336,"address":[5134540,5134624],"length":1,"stats":{"Line":2}},{"line":338,"address":[5134639],"length":1,"stats":{"Line":1}},{"line":339,"address":[5134666,5134771],"length":1,"stats":{"Line":0}},{"line":342,"address":[5134835,5134709,5135295],"length":1,"stats":{"Line":2}},{"line":344,"address":[5135670,5135623,5135040],"length":1,"stats":{"Line":3}},{"line":345,"address":[5135481],"length":1,"stats":{"Line":1}},{"line":346,"address":[5135086],"length":1,"stats":{"Line":1}},{"line":347,"address":[5135441],"length":1,"stats":{"Line":1}},{"line":352,"address":[5134555,5134497],"length":1,"stats":{"Line":0}},{"line":356,"address":[5137082,5134280,5137642,5138090],"length":1,"stats":{"Line":5}},{"line":357,"address":[5137673,5137126],"length":1,"stats":{"Line":2}},{"line":358,"address":[5137696],"length":1,"stats":{"Line":1}},{"line":360,"address":[5138009,5138056,5137718],"length":1,"stats":{"Line":3}},{"line":361,"address":[5137867],"length":1,"stats":{"Line":1}},{"line":362,"address":[5137764],"length":1,"stats":{"Line":1}},{"line":363,"address":[5137827],"length":1,"stats":{"Line":1}},{"line":367,"address":[5137096,5137143],"length":1,"stats":{"Line":2}},{"line":368,"address":[5137263,5137192],"length":1,"stats":{"Line":2}},{"line":370,"address":[5137270,5137608,5137561],"length":1,"stats":{"Line":3}},{"line":371,"address":[5137419],"length":1,"stats":{"Line":1}},{"line":372,"address":[5137316],"length":1,"stats":{"Line":1}},{"line":373,"address":[5137379],"length":1,"stats":{"Line":1}},{"line":378,"address":[5137207,5137149],"length":1,"stats":{"Line":0}},{"line":382,"address":[5138120,5134305],"length":1,"stats":{"Line":2}},{"line":383,"address":[5138126,5138184],"length":1,"stats":{"Line":0}},{"line":386,"address":[5138979,5138248,5138428,5138169],"length":1,"stats":{"Line":2}},{"line":388,"address":[5138333,5138756,5138803],"length":1,"stats":{"Line":3}},{"line":389,"address":[5138614],"length":1,"stats":{"Line":1}},{"line":390,"address":[5138395],"length":1,"stats":{"Line":1}},{"line":391,"address":[5138574],"length":1,"stats":{"Line":1}},{"line":397,"address":[5138984],"length":1,"stats":{"Line":0}},{"line":404,"address":[5139231],"length":1,"stats":{"Line":0}},{"line":411,"address":[5147815],"length":1,"stats":{"Line":0}},{"line":418,"address":[5138889,5146937],"length":1,"stats":{"Line":3}},{"line":422,"address":[5150078,5148096,5149976],"length":1,"stats":{"Line":1}},{"line":426,"address":[5148131],"length":1,"stats":{"Line":1}},{"line":429,"address":[5148330,5148221,5148295,5148432,5150008],"length":1,"stats":{"Line":3}},{"line":430,"address":[5148325,5148539,5148341],"length":1,"stats":{"Line":3}},{"line":433,"address":[5148599],"length":1,"stats":{"Line":1}},{"line":434,"address":[5148620,5148716],"length":1,"stats":{"Line":0}},{"line":437,"address":[5149087,5150003,5148657,5148791],"length":1,"stats":{"Line":2}},{"line":440,"address":[5149238,5148932],"length":1,"stats":{"Line":2}},{"line":442,"address":[5149298],"length":1,"stats":{"Line":1}},{"line":443,"address":[5149319,5149427],"length":1,"stats":{"Line":0}},{"line":446,"address":[5149415],"length":1,"stats":{"Line":1}},{"line":448,"address":[5149528,5149458],"length":1,"stats":{"Line":2}},{"line":449,"address":[5149784],"length":1,"stats":{"Line":0}},{"line":455,"address":[5149534,5149738],"length":1,"stats":{"Line":2}}],"covered":142,"coverable":184},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","top_level.rs"],"content":"use crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE...로 시작되는 쿼리 분석\n    pub(crate) fn handle_create_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1101 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_create_table_query(context),\n            Token::Database =\u003e self.handle_create_database_query(),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E1102 not supported command. possible commands: (create table). but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    // ALTER TABLE...\n    pub(crate) fn handle_alter_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1103 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_alter_table_query(context),\n            Token::Database =\u003e self.handle_alter_database_query(),\n            _ =\u003e Err(ParsingError::wrap(\n                \"E1104 not supported command. possible commands: (alter table)\",\n            )),\n        }\n    }\n\n    pub(crate) fn handle_drop_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1105 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_drop_table_query(context),\n            Token::Database =\u003e self.handle_drop_database_query(),\n            _ =\u003e Err(ParsingError::wrap(\n                \"E1106 not supported command. possible commands: (create table)\",\n            )),\n        }\n    }\n}\n","traces":[{"line":10,"address":[5150788,5150112],"length":1,"stats":{"Line":1}},{"line":14,"address":[5150227,5150155],"length":1,"stats":{"Line":2}},{"line":15,"address":[5150282,5150233],"length":1,"stats":{"Line":0}},{"line":18,"address":[5150270],"length":1,"stats":{"Line":3}},{"line":20,"address":[5150342],"length":1,"stats":{"Line":3}},{"line":21,"address":[5150611,5150505],"length":1,"stats":{"Line":2}},{"line":22,"address":[5150483,5150591],"length":1,"stats":{"Line":4}},{"line":23,"address":[5150613],"length":1,"stats":{"Line":0}},{"line":31,"address":[5150832,5151337],"length":1,"stats":{"Line":4}},{"line":35,"address":[5150947,5150875],"length":1,"stats":{"Line":8}},{"line":36,"address":[5151002,5150953],"length":1,"stats":{"Line":0}},{"line":39,"address":[5150990],"length":1,"stats":{"Line":4}},{"line":41,"address":[5151062],"length":1,"stats":{"Line":4}},{"line":42,"address":[5151156,5151259],"length":1,"stats":{"Line":4}},{"line":43,"address":[5151134,5151242],"length":1,"stats":{"Line":3}},{"line":44,"address":[5151266,5151094],"length":1,"stats":{"Line":0}},{"line":50,"address":[5151376,5151881],"length":1,"stats":{"Line":1}},{"line":54,"address":[5151419,5151491],"length":1,"stats":{"Line":2}},{"line":55,"address":[5151497,5151546],"length":1,"stats":{"Line":0}},{"line":58,"address":[5151534],"length":1,"stats":{"Line":2}},{"line":60,"address":[5151606],"length":1,"stats":{"Line":2}},{"line":61,"address":[5151803,5151700],"length":1,"stats":{"Line":2}},{"line":62,"address":[5151786,5151678],"length":1,"stats":{"Line":2}},{"line":63,"address":[5151810,5151638],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":24},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","debug.rs"],"content":"use crate::parser::predule::Parser;\n\nimpl Parser {\n    #[allow(dead_code)]\n    pub(crate) fn show_tokens(\u0026self) {\n        println!(\"{:?}\", self);\n    }\n}\n","traces":[{"line":5,"address":[5151920],"length":1,"stats":{"Line":0}},{"line":6,"address":[5151988],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","delete.rs"],"content":"use crate::ast::dml::delete::DeleteQuery;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nuse crate::errors::predule::ParsingError;\nuse crate::lexer::predule::Token;\n\nimpl Parser {\n    pub(crate) fn handle_delete_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cDeleteQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0501 need more tokens\"));\n        }\n\n        // DELETE 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Delete {\n            return Err(ParsingError::wrap(format!(\n                \"E0502: expected 'DELETE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0503 need more tokens\"));\n        }\n\n        // FROM 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::From {\n            return Err(ParsingError::wrap(format!(\n                \"E0504: expected 'FROM'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let mut query_builder = DeleteQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0505 need more tokens\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_from_table(table_name);\n\n        // 테이블 alias 파싱\n        if self.next_token_is_table_alias() {\n            let alias = self.parse_table_alias()?;\n            query_builder = query_builder.set_from_alias(alias);\n        }\n\n        // WHERE 절 파싱\n        if self.next_token_is_where() {\n            let where_clause = self.parse_where(context)?;\n            query_builder = query_builder.set_where(where_clause);\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":9,"address":[5152048,5155276,5154843],"length":1,"stats":{"Line":1}},{"line":13,"address":[5152091,5152195],"length":1,"stats":{"Line":2}},{"line":14,"address":[5152250,5152201],"length":1,"stats":{"Line":2}},{"line":18,"address":[5152238],"length":1,"stats":{"Line":1}},{"line":20,"address":[5152306,5152376],"length":1,"stats":{"Line":2}},{"line":21,"address":[5155115],"length":1,"stats":{"Line":1}},{"line":27,"address":[5152501,5152387],"length":1,"stats":{"Line":2}},{"line":28,"address":[5152559,5152507],"length":1,"stats":{"Line":2}},{"line":32,"address":[5152547],"length":1,"stats":{"Line":1}},{"line":34,"address":[5152687,5152617],"length":1,"stats":{"Line":2}},{"line":35,"address":[5154969],"length":1,"stats":{"Line":1}},{"line":41,"address":[5152701],"length":1,"stats":{"Line":1}},{"line":43,"address":[5152876,5152812],"length":1,"stats":{"Line":2}},{"line":44,"address":[5152882,5152934],"length":1,"stats":{"Line":2}},{"line":48,"address":[5152922,5153312,5154923,5153013],"length":1,"stats":{"Line":2}},{"line":49,"address":[5153177,5153458],"length":1,"stats":{"Line":2}},{"line":52,"address":[5153993,5153501],"length":1,"stats":{"Line":2}},{"line":53,"address":[5153554,5153805],"length":1,"stats":{"Line":1}},{"line":54,"address":[5153686,5153951],"length":1,"stats":{"Line":2}},{"line":58,"address":[5153527,5154712,5154002],"length":1,"stats":{"Line":3}},{"line":59,"address":[5154084,5154524],"length":1,"stats":{"Line":1}},{"line":60,"address":[5154670,5154359],"length":1,"stats":{"Line":2}},{"line":63,"address":[5154008,5154742],"length":1,"stats":{"Line":2}}],"covered":23,"coverable":23},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","expression.rs"],"content":"use crate::ast::dml::expressions::between::BetweenExpression;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::call::CallExpression;\nuse crate::ast::dml::expressions::list::ListExpression;\nuse crate::ast::dml::expressions::not_between::NotBetweenExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::dml::expressions::parentheses::ParenthesesExpression;\nuse crate::ast::dml::expressions::unary::UnaryOperatorExpression;\nuse crate::ast::types::{BuiltInFunction, SQLExpression, SelectColumn, UserDefinedFunction};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::Parser;\nuse crate::parser::predule::ParserContext;\n\nimpl Parser {\n    pub(crate) fn parse_expression(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0201 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Operator(operator) =\u003e {\n                if operator.is_unary_operator() {\n                    let operator: UnaryOperator = operator.try_into()?;\n                    let expression = self.parse_unary_expression(operator, context)?;\n\n                    Ok(expression)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"E0212 unexpected operator: {:?}\",\n                        operator\n                    )))\n                }\n            }\n            Token::Not =\u003e {\n                let operator = UnaryOperator::Not;\n\n                let expression = self.parse_unary_expression(operator, context)?;\n\n                Ok(expression)\n            }\n            Token::Integer(integer) =\u003e {\n                let lhs = SQLExpression::Integer(integer);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Float(float) =\u003e {\n                let lhs = SQLExpression::Float(float);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::String(string) =\u003e {\n                let lhs = SQLExpression::String(string);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Boolean(boolean) =\u003e {\n                let lhs = SQLExpression::Boolean(boolean);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Null =\u003e {\n                let lhs = SQLExpression::Null;\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::LeftParentheses =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0214 need more tokens\"));\n                }\n\n                let second_token = self.get_next_token();\n\n                match second_token {\n                    Token::Select =\u003e {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        let lhs = self.parse_subquery(context.clone())?.into();\n\n                        if self.next_token_is_binary_operator(context.clone()) {\n                            let expression = self.parse_binary_expression(lhs, context)?;\n                            Ok(expression)\n                        } else if self.next_token_is_between() {\n                            let expression = self.parse_between_expression(lhs, context)?;\n                            Ok(expression)\n                        } else {\n                            Ok(lhs)\n                        }\n                    }\n                    _ =\u003e {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        let lhs = self.parse_parentheses_expression(context.clone())?;\n\n                        if self.next_token_is_binary_operator(context.clone()) {\n                            let expression = self.parse_binary_expression(lhs, context)?;\n                            Ok(expression)\n                        } else if self.next_token_is_between() {\n                            let expression = self.parse_between_expression(lhs, context)?;\n                            Ok(expression)\n                        } else {\n                            Ok(lhs)\n                        }\n                    }\n                }\n            }\n            Token::RightParentheses =\u003e Err(ParsingError::wrap(format!(\n                \"E0213 unexpected token: {:?}\",\n                current_token\n            ))),\n            Token::Identifier(identifier) =\u003e {\n                self.unget_next_token(Token::Identifier(identifier));\n                let select_column = self.parse_select_column()?;\n\n                let lhs = SQLExpression::SelectColumn(select_column.clone());\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_left_parentheses() {\n                    let SelectColumn {\n                        table_name,\n                        column_name,\n                    } = select_column;\n\n                    let lhs = self.parse_function_call_expression(\n                        table_name,\n                        column_name,\n                        context.clone(),\n                    )?;\n\n                    if self.next_token_is_binary_operator(context.clone()) {\n                        let expression = self.parse_binary_expression(lhs, context)?;\n                        Ok(expression)\n                    } else if self.next_token_is_between() {\n                        let expression = self.parse_between_expression(lhs, context)?;\n                        Ok(expression)\n                    } else {\n                        Ok(lhs)\n                    }\n                } else {\n                    Ok(lhs)\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0202 unexpected token: {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_unary_expression(\n        \u0026mut self,\n        operator: UnaryOperator,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0201 need more tokens\"));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        // expression이 2항 표현식일 경우 단항 표현식이 최우선으로 처리되게 구성\n        match expression {\n            SQLExpression::Binary(mut binary) =\u003e {\n                binary.lhs = UnaryOperatorExpression {\n                    operand: binary.lhs,\n                    operator,\n                }\n                .into();\n\n                Ok(binary.into())\n            }\n            SQLExpression::Between(mut between) =\u003e {\n                between.a = UnaryOperatorExpression {\n                    operand: between.a,\n                    operator,\n                }\n                .into();\n\n                Ok(between.into())\n            }\n            _ =\u003e Ok(UnaryOperatorExpression {\n                operand: expression,\n                operator,\n            }\n            .into()),\n        }\n    }\n\n    /**\n     * 소괄호연산자, 혹은 리스트 파싱\n    parenexpr ::= '(' expression ')'\n    parenexpr ::= '(' 1, 2, 3 ')'\n    */\n    pub(crate) fn parse_parentheses_expression(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let context = context.set_in_parentheses(true);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0203 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0204 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let expression = self.parse_expression(context.clone())?;\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0205 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        match current_token {\n            // 우선순위 연산자\n            Token::RightParentheses =\u003e {\n                let expression = ParenthesesExpression { expression };\n\n                Ok(expression.into())\n            }\n            // 리스트 표현식\n            Token::Comma =\u003e {\n                let mut list = ListExpression {\n                    value: vec![expression],\n                };\n\n                loop {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0215 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::RightParentheses =\u003e break,\n                        Token::Comma =\u003e continue,\n                        _ =\u003e {\n                            self.unget_next_token(current_token);\n                            let expression = self.parse_expression(context.clone())?;\n                            list.value.push(expression);\n                            continue;\n                        }\n                    }\n                }\n\n                Ok(list.into())\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"expected right parentheses. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    /**\n     * 2항 연산식 파싱\n     */\n    pub(crate) fn parse_binary_expression(\n        \u0026mut self,\n        lhs: SQLExpression,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0206 need more tokens\"));\n        }\n\n        // 연산자 획득\n        let current_token = self.get_next_token();\n\n        let operator: Result\u003cBinaryOperator, _\u003e =\n            if current_token.can_be_multi_token_operator() \u0026\u0026 self.has_next_token() {\n                let second_token = self.get_next_token();\n                current_token.try_into_multi_token_operator(second_token)\n            } else {\n                current_token.try_into()\n            };\n\n        match operator {\n            Ok(operator) =\u003e {\n                let rhs = self.parse_expression(context)?;\n\n                let current_precedence = operator.get_precedence();\n\n                let mut rhs_has_parentheses = false;\n\n                // 소괄호가 있다면 벗기고 플래그값 설정\n                let rhs = if let SQLExpression::Parentheses(paren) = rhs {\n                    rhs_has_parentheses = true;\n                    paren.expression\n                } else {\n                    rhs\n                };\n\n                if let SQLExpression::Binary(rhs_binary) = rhs.clone() {\n                    let next_precedence = rhs_binary.operator.get_precedence();\n\n                    // 단항연산식일 경우\n                    if lhs.is_unary() {\n                        let new_lhs = BinaryOperatorExpression {\n                            lhs,\n                            rhs: rhs_binary.lhs,\n                            operator,\n                        };\n                        Ok(BinaryOperatorExpression {\n                            lhs: new_lhs.into(),\n                            rhs: rhs_binary.rhs,\n                            operator: rhs_binary.operator,\n                        }\n                        .into())\n                    }\n                    // 2항연산식일 경우\n                    else {\n                        // 오른쪽 연산자의 우선순위가 더 크거나, 소괄호가 있을 경우 오른쪽을 먼저 묶어서 바인딩\n                        if next_precedence \u003e current_precedence || rhs_has_parentheses {\n                            Ok(BinaryOperatorExpression { lhs, rhs, operator }.into())\n                        }\n                        // 아니라면 왼쪽으로 묶어서 바인딩\n                        else {\n                            let new_lhs = BinaryOperatorExpression {\n                                lhs,\n                                rhs: rhs_binary.lhs,\n                                operator,\n                            };\n                            Ok(BinaryOperatorExpression {\n                                lhs: new_lhs.into(),\n                                rhs: rhs_binary.rhs,\n                                operator: rhs_binary.operator,\n                            }\n                            .into())\n                        }\n                    }\n                } else {\n                    Ok(BinaryOperatorExpression { lhs, rhs, operator }.into())\n                }\n            }\n            Err(error) =\u003e Err(error),\n        }\n    }\n\n    /**\n     * 함수호출 파싱\n     */\n    pub(crate) fn parse_function_call_expression(\n        \u0026mut self,\n        database_name: Option\u003cString\u003e,\n        function_name: String,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let function = if database_name.is_some() {\n            UserDefinedFunction {\n                database_name,\n                function_name,\n            }\n            .into()\n        } else {\n            match BuiltInFunction::try_from(function_name.clone()) {\n                Ok(builtin) =\u003e builtin.into(),\n                Err(_) =\u003e UserDefinedFunction {\n                    database_name,\n                    function_name,\n                }\n                .into(),\n            }\n        };\n\n        let mut call_expression = CallExpression {\n            function,\n            arguments: vec![],\n        };\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0207 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0208 need more tokens\"));\n        }\n\n        // 닫는 괄호가 나올때까지 인자 파싱\n        loop {\n            if self.next_token_is_right_parentheses() {\n                break;\n            }\n\n            // 표현식 파싱\n            let expression = self.parse_expression(context.clone())?;\n\n            call_expression.arguments.push(expression);\n\n            // 쉼표 삼키기.\n            if self.next_token_is_comma() {\n                self.get_next_token();\n            }\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0209 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected right parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        Ok(call_expression.into())\n    }\n\n    /**\n     * between 및 not between 절 파싱\n     */\n    pub(crate) fn parse_between_expression(\n        \u0026mut self,\n        a: SQLExpression,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let context = context.set_in_between_clause(true);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0210 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Between =\u003e {\n                let x = self.parse_expression(context.clone())?;\n\n                // AND 삼킴\n                self.get_next_token();\n\n                let y = self.parse_expression(context)?;\n\n                let expression = BetweenExpression { a, x, y };\n\n                Ok(expression.into())\n            }\n            Token::Not =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0211 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Between =\u003e {\n                        let x = self.parse_expression(context.clone())?;\n\n                        // AND 삼킴\n                        self.get_next_token();\n\n                        let y = self.parse_expression(context)?;\n\n                        let expression = NotBetweenExpression { a, x, y };\n\n                        Ok(expression.into())\n                    }\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"expected between. but your input is {:?}\",\n                        current_token\n                    ))),\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"expected between. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":17,"address":[5170082,5155312,5159574],"length":1,"stats":{"Line":1}},{"line":21,"address":[5155400,5155600],"length":1,"stats":{"Line":2}},{"line":22,"address":[5155606,5155655],"length":1,"stats":{"Line":0}},{"line":25,"address":[5155689,5155643],"length":1,"stats":{"Line":2}},{"line":27,"address":[5155713],"length":1,"stats":{"Line":1}},{"line":28,"address":[5156433],"length":1,"stats":{"Line":1}},{"line":29,"address":[5166235,5165873,5156455,5165629],"length":1,"stats":{"Line":3}},{"line":30,"address":[5165944,5166012,5166352,5165731,5165894],"length":1,"stats":{"Line":3}},{"line":31,"address":[5166245,5165953,5165937,5166133],"length":1,"stats":{"Line":3}},{"line":33,"address":[5166201],"length":1,"stats":{"Line":1}},{"line":35,"address":[5165754],"length":1,"stats":{"Line":0}},{"line":42,"address":[5155866],"length":1,"stats":{"Line":1}},{"line":44,"address":[5156644,5155874,5156874,5156753],"length":1,"stats":{"Line":2}},{"line":46,"address":[5156712],"length":1,"stats":{"Line":1}},{"line":48,"address":[5156047],"length":1,"stats":{"Line":1}},{"line":49,"address":[5156063],"length":1,"stats":{"Line":1}},{"line":51,"address":[5156105,5160599,5161426],"length":1,"stats":{"Line":5}},{"line":52,"address":[5161436,5160649,5161324],"length":1,"stats":{"Line":4}},{"line":53,"address":[5161392],"length":1,"stats":{"Line":3}},{"line":54,"address":[5160806,5160625,5161181,5160885],"length":1,"stats":{"Line":5}},{"line":55,"address":[5160900,5161079,5161191],"length":1,"stats":{"Line":3}},{"line":56,"address":[5161147],"length":1,"stats":{"Line":2}},{"line":58,"address":[5160812],"length":1,"stats":{"Line":1}},{"line":61,"address":[5156120],"length":1,"stats":{"Line":0}},{"line":62,"address":[5156138],"length":1,"stats":{"Line":0}},{"line":64,"address":[5162442,5161615,5156181],"length":1,"stats":{"Line":0}},{"line":65,"address":[5162340,5161665,5162452],"length":1,"stats":{"Line":0}},{"line":66,"address":[5162408],"length":1,"stats":{"Line":0}},{"line":67,"address":[5161822,5162197,5161901,5161641],"length":1,"stats":{"Line":0}},{"line":68,"address":[5161916,5162095,5162207],"length":1,"stats":{"Line":0}},{"line":69,"address":[5162163],"length":1,"stats":{"Line":0}},{"line":71,"address":[5161828],"length":1,"stats":{"Line":0}},{"line":74,"address":[5156268],"length":1,"stats":{"Line":1}},{"line":75,"address":[5156308],"length":1,"stats":{"Line":1}},{"line":77,"address":[5163647,5164474,5156374],"length":1,"stats":{"Line":2}},{"line":78,"address":[5163697,5164484,5164372],"length":1,"stats":{"Line":0}},{"line":79,"address":[5164440],"length":1,"stats":{"Line":0}},{"line":80,"address":[5164229,5163854,5163673,5163933],"length":1,"stats":{"Line":3}},{"line":81,"address":[5163948,5164127,5164239],"length":1,"stats":{"Line":0}},{"line":82,"address":[5164195],"length":1,"stats":{"Line":0}},{"line":84,"address":[5163860],"length":1,"stats":{"Line":1}},{"line":87,"address":[5156196],"length":1,"stats":{"Line":1}},{"line":88,"address":[5156212],"length":1,"stats":{"Line":1}},{"line":90,"address":[5162631,5163458,5156253],"length":1,"stats":{"Line":2}},{"line":91,"address":[5163468,5162681,5163356],"length":1,"stats":{"Line":0}},{"line":92,"address":[5163424],"length":1,"stats":{"Line":0}},{"line":93,"address":[5162838,5162917,5163213,5162657],"length":1,"stats":{"Line":3}},{"line":94,"address":[5162932,5163111,5163223],"length":1,"stats":{"Line":0}},{"line":95,"address":[5163179],"length":1,"stats":{"Line":0}},{"line":97,"address":[5162844],"length":1,"stats":{"Line":1}},{"line":101,"address":[5156389],"length":1,"stats":{"Line":2}},{"line":103,"address":[5165490,5156423,5164663],"length":1,"stats":{"Line":4}},{"line":104,"address":[5164713,5165388,5165500],"length":1,"stats":{"Line":0}},{"line":105,"address":[5165456],"length":1,"stats":{"Line":0}},{"line":106,"address":[5164949,5164870,5164689,5165245],"length":1,"stats":{"Line":6}},{"line":107,"address":[5164964,5165143,5165255],"length":1,"stats":{"Line":0}},{"line":108,"address":[5165211],"length":1,"stats":{"Line":0}},{"line":110,"address":[5164876],"length":1,"stats":{"Line":2}},{"line":114,"address":[5156474,5166361],"length":1,"stats":{"Line":2}},{"line":115,"address":[5166367,5166419],"length":1,"stats":{"Line":0}},{"line":118,"address":[5166407],"length":1,"stats":{"Line":1}},{"line":120,"address":[5166442],"length":1,"stats":{"Line":1}},{"line":122,"address":[5166469],"length":1,"stats":{"Line":1}},{"line":123,"address":[5166504],"length":1,"stats":{"Line":1}},{"line":124,"address":[5166588,5167864],"length":1,"stats":{"Line":1}},{"line":126,"address":[5166902,5166841,5167729],"length":1,"stats":{"Line":2}},{"line":127,"address":[5167627,5167739,5166952],"length":1,"stats":{"Line":0}},{"line":128,"address":[5167695],"length":1,"stats":{"Line":0}},{"line":129,"address":[5166928,5167109,5167484,5167188],"length":1,"stats":{"Line":3}},{"line":130,"address":[5167494,5167203,5167382],"length":1,"stats":{"Line":0}},{"line":131,"address":[5167450],"length":1,"stats":{"Line":0}},{"line":133,"address":[5167115],"length":1,"stats":{"Line":1}},{"line":137,"address":[5166489],"length":1,"stats":{"Line":1}},{"line":138,"address":[5167874],"length":1,"stats":{"Line":1}},{"line":139,"address":[5168242,5169363,5167958],"length":1,"stats":{"Line":1}},{"line":141,"address":[5168227,5168401,5169228],"length":1,"stats":{"Line":3}},{"line":142,"address":[5169126,5169238,5168451],"length":1,"stats":{"Line":2}},{"line":143,"address":[5169194],"length":1,"stats":{"Line":1}},{"line":144,"address":[5168983,5168608,5168427,5168687],"length":1,"stats":{"Line":3}},{"line":145,"address":[5168881,5168993,5168702],"length":1,"stats":{"Line":0}},{"line":146,"address":[5168949],"length":1,"stats":{"Line":0}},{"line":148,"address":[5168614],"length":1,"stats":{"Line":1}},{"line":153,"address":[5169492],"length":1,"stats":{"Line":0}},{"line":157,"address":[5155944],"length":1,"stats":{"Line":1}},{"line":158,"address":[5155984],"length":1,"stats":{"Line":1}},{"line":159,"address":[5160540,5156908,5157111],"length":1,"stats":{"Line":1}},{"line":161,"address":[5157262,5157096],"length":1,"stats":{"Line":2}},{"line":163,"address":[5157344,5157405,5160016],"length":1,"stats":{"Line":3}},{"line":164,"address":[5159914,5160026,5157455,5160296],"length":1,"stats":{"Line":2}},{"line":165,"address":[5159982],"length":1,"stats":{"Line":1}},{"line":166,"address":[5159781,5157431,5157612],"length":1,"stats":{"Line":4}},{"line":167,"address":[5159791,5157647,5159679],"length":1,"stats":{"Line":0}},{"line":168,"address":[5159747],"length":1,"stats":{"Line":0}},{"line":169,"address":[5159071,5157623,5157804,5157883],"length":1,"stats":{"Line":7}},{"line":171,"address":[5157893],"length":1,"stats":{"Line":2}},{"line":172,"address":[5157933],"length":1,"stats":{"Line":2}},{"line":175,"address":[5159583,5158220,5158533,5158133],"length":1,"stats":{"Line":4}},{"line":176,"address":[5157973],"length":1,"stats":{"Line":2}},{"line":177,"address":[5158013],"length":1,"stats":{"Line":2}},{"line":178,"address":[5158061],"length":1,"stats":{"Line":2}},{"line":181,"address":[5158612,5158438,5159439],"length":1,"stats":{"Line":4}},{"line":182,"address":[5159337,5158662,5159449],"length":1,"stats":{"Line":0}},{"line":183,"address":[5159405],"length":1,"stats":{"Line":0}},{"line":184,"address":[5158819,5158638,5159194,5158898],"length":1,"stats":{"Line":6}},{"line":185,"address":[5159204,5159092,5158913],"length":1,"stats":{"Line":0}},{"line":186,"address":[5159160],"length":1,"stats":{"Line":0}},{"line":188,"address":[5158825],"length":1,"stats":{"Line":2}},{"line":191,"address":[5157810],"length":1,"stats":{"Line":1}},{"line":194,"address":[5169616],"length":1,"stats":{"Line":0}},{"line":201,"address":[5172719,5171731,5170112],"length":1,"stats":{"Line":1}},{"line":206,"address":[5170296,5170168],"length":1,"stats":{"Line":2}},{"line":207,"address":[5170395,5170302],"length":1,"stats":{"Line":0}},{"line":210,"address":[5170336,5170445,5170742],"length":1,"stats":{"Line":2}},{"line":213,"address":[5170666],"length":1,"stats":{"Line":1}},{"line":214,"address":[5171075],"length":1,"stats":{"Line":1}},{"line":215,"address":[5171605,5171283,5171467],"length":1,"stats":{"Line":2}},{"line":216,"address":[5171405,5171115,5171224],"length":1,"stats":{"Line":2}},{"line":221,"address":[5171631,5171554],"length":1,"stats":{"Line":2}},{"line":223,"address":[5171143],"length":1,"stats":{"Line":0}},{"line":224,"address":[5172174,5171852,5172036],"length":1,"stats":{"Line":0}},{"line":225,"address":[5171974,5171183,5171793],"length":1,"stats":{"Line":0}},{"line":230,"address":[5172123,5172200],"length":1,"stats":{"Line":0}},{"line":232,"address":[5170955,5172381],"length":1,"stats":{"Line":2}},{"line":233,"address":[5170851],"length":1,"stats":{"Line":1}},{"line":236,"address":[5172415],"length":1,"stats":{"Line":1}},{"line":245,"address":[5175916,5172752,5175428],"length":1,"stats":{"Line":1}},{"line":249,"address":[5172795],"length":1,"stats":{"Line":1}},{"line":251,"address":[5172847,5172899],"length":1,"stats":{"Line":2}},{"line":252,"address":[5172954,5172905],"length":1,"stats":{"Line":0}},{"line":256,"address":[5172942],"length":1,"stats":{"Line":1}},{"line":258,"address":[5172984,5173054],"length":1,"stats":{"Line":2}},{"line":259,"address":[5175792],"length":1,"stats":{"Line":0}},{"line":265,"address":[5173065,5173179],"length":1,"stats":{"Line":2}},{"line":266,"address":[5173237,5173185],"length":1,"stats":{"Line":0}},{"line":270,"address":[5173546,5173294,5175787,5173225],"length":1,"stats":{"Line":2}},{"line":272,"address":[5173527,5173696],"length":1,"stats":{"Line":2}},{"line":273,"address":[5173754,5173702],"length":1,"stats":{"Line":0}},{"line":277,"address":[5173742],"length":1,"stats":{"Line":1}},{"line":279,"address":[5173791],"length":1,"stats":{"Line":1}},{"line":282,"address":[5173949],"length":1,"stats":{"Line":1}},{"line":284,"address":[5175535,5174117],"length":1,"stats":{"Line":2}},{"line":289,"address":[5173934,5174190],"length":1,"stats":{"Line":2}},{"line":293,"address":[5174466,5174410],"length":1,"stats":{"Line":4}},{"line":294,"address":[5174472,5174524],"length":1,"stats":{"Line":0}},{"line":297,"address":[5174512,5174560],"length":1,"stats":{"Line":4}},{"line":299,"address":[5174568],"length":1,"stats":{"Line":2}},{"line":303,"address":[5174607],"length":1,"stats":{"Line":2}},{"line":304,"address":[5175230,5174855],"length":1,"stats":{"Line":2}},{"line":305,"address":[5175111],"length":1,"stats":{"Line":2}},{"line":311,"address":[5174707],"length":1,"stats":{"Line":2}},{"line":313,"address":[5175574],"length":1,"stats":{"Line":0}},{"line":323,"address":[5180153,5181020,5175936],"length":1,"stats":{"Line":1}},{"line":328,"address":[5176128,5175984],"length":1,"stats":{"Line":2}},{"line":329,"address":[5176134,5176186],"length":1,"stats":{"Line":0}},{"line":333,"address":[5176223,5176174],"length":1,"stats":{"Line":4}},{"line":335,"address":[5176295,5176369,5176239],"length":1,"stats":{"Line":5}},{"line":337,"address":[5176403],"length":1,"stats":{"Line":1}},{"line":338,"address":[5176443],"length":1,"stats":{"Line":1}},{"line":340,"address":[5176410,5176301],"length":1,"stats":{"Line":4}},{"line":343,"address":[5176412],"length":1,"stats":{"Line":2}},{"line":344,"address":[5176526],"length":1,"stats":{"Line":2}},{"line":345,"address":[5176664,5176904,5176540],"length":1,"stats":{"Line":3}},{"line":347,"address":[5177054,5176885],"length":1,"stats":{"Line":2}},{"line":349,"address":[5177061],"length":1,"stats":{"Line":1}},{"line":352,"address":[5177227,5177069],"length":1,"stats":{"Line":2}},{"line":353,"address":[5177133],"length":1,"stats":{"Line":1}},{"line":354,"address":[5177234,5177141,5177313],"length":1,"stats":{"Line":2}},{"line":356,"address":[5177177],"length":1,"stats":{"Line":1}},{"line":359,"address":[5177352,5177399],"length":1,"stats":{"Line":3}},{"line":360,"address":[5177487,5177933],"length":1,"stats":{"Line":4}},{"line":363,"address":[5179911,5177940],"length":1,"stats":{"Line":2}},{"line":366,"address":[5179505,5178006,5179237],"length":1,"stats":{"Line":0}},{"line":369,"address":[5179877,5179649],"length":1,"stats":{"Line":0}},{"line":370,"address":[5179470],"length":1,"stats":{"Line":0}},{"line":371,"address":[5179617,5179526],"length":1,"stats":{"Line":0}},{"line":372,"address":[5179643,5179584,5179851],"length":1,"stats":{"Line":0}},{"line":379,"address":[5177969,5178046,5179230],"length":1,"stats":{"Line":4}},{"line":380,"address":[5178065,5179196],"length":1,"stats":{"Line":2}},{"line":386,"address":[5178766,5178458],"length":1,"stats":{"Line":1}},{"line":389,"address":[5178910,5179138],"length":1,"stats":{"Line":2}},{"line":390,"address":[5178731],"length":1,"stats":{"Line":1}},{"line":391,"address":[5178878,5178787],"length":1,"stats":{"Line":1}},{"line":392,"address":[5178904,5179112,5178845],"length":1,"stats":{"Line":2}},{"line":398,"address":[5180235,5177521],"length":1,"stats":{"Line":5}},{"line":401,"address":[5176594],"length":1,"stats":{"Line":0}},{"line":408,"address":[5181056,5184068,5182987],"length":1,"stats":{"Line":2}},{"line":414,"address":[5181109,5181213],"length":1,"stats":{"Line":4}},{"line":421,"address":[5181224,5181420],"length":1,"stats":{"Line":4}},{"line":422,"address":[5181708,5181482],"length":1,"stats":{"Line":2}},{"line":433,"address":[5181757],"length":1,"stats":{"Line":1}},{"line":436,"address":[5181957,5181901],"length":1,"stats":{"Line":4}},{"line":437,"address":[5182015,5181963],"length":1,"stats":{"Line":0}},{"line":441,"address":[5182003],"length":1,"stats":{"Line":2}},{"line":443,"address":[5182121,5182051],"length":1,"stats":{"Line":4}},{"line":444,"address":[5183830],"length":1,"stats":{"Line":0}},{"line":450,"address":[5182132,5182246],"length":1,"stats":{"Line":4}},{"line":451,"address":[5182252,5182300],"length":1,"stats":{"Line":0}},{"line":455,"address":[5182929],"length":1,"stats":{"Line":2}},{"line":456,"address":[5182340,5182284],"length":1,"stats":{"Line":4}},{"line":461,"address":[5182753,5182359,5182406],"length":1,"stats":{"Line":4}},{"line":463,"address":[5182634],"length":1,"stats":{"Line":2}},{"line":466,"address":[5182900],"length":1,"stats":{"Line":2}},{"line":467,"address":[5182947],"length":1,"stats":{"Line":2}},{"line":471,"address":[5182371,5183013],"length":1,"stats":{"Line":4}},{"line":472,"address":[5183071,5183019],"length":1,"stats":{"Line":0}},{"line":476,"address":[5183059],"length":1,"stats":{"Line":2}},{"line":478,"address":[5183094,5183164],"length":1,"stats":{"Line":4}},{"line":479,"address":[5183652],"length":1,"stats":{"Line":0}},{"line":485,"address":[5183170,5183392],"length":1,"stats":{"Line":4}},{"line":491,"address":[5184112,5188379,5186395],"length":1,"stats":{"Line":1}},{"line":496,"address":[5184160,5184279],"length":1,"stats":{"Line":2}},{"line":498,"address":[5184287,5184340],"length":1,"stats":{"Line":2}},{"line":499,"address":[5184395,5184346],"length":1,"stats":{"Line":0}},{"line":502,"address":[5184383],"length":1,"stats":{"Line":1}},{"line":504,"address":[5184429],"length":1,"stats":{"Line":1}},{"line":506,"address":[5186892,5184591,5188133,5186636],"length":1,"stats":{"Line":3}},{"line":509,"address":[5187046,5186877],"length":1,"stats":{"Line":4}},{"line":511,"address":[5187862,5187058],"length":1,"stats":{"Line":2}},{"line":513,"address":[5187341],"length":1,"stats":{"Line":2}},{"line":515,"address":[5188006,5187824],"length":1,"stats":{"Line":4}},{"line":518,"address":[5184645,5184567],"length":1,"stats":{"Line":2}},{"line":519,"address":[5184703,5184651],"length":1,"stats":{"Line":0}},{"line":522,"address":[5184691],"length":1,"stats":{"Line":1}},{"line":524,"address":[5184739],"length":1,"stats":{"Line":1}},{"line":526,"address":[5185192,5184936,5184766,5186471],"length":1,"stats":{"Line":2}},{"line":529,"address":[5185177,5185346],"length":1,"stats":{"Line":2}},{"line":531,"address":[5186162,5185358],"length":1,"stats":{"Line":1}},{"line":533,"address":[5185641],"length":1,"stats":{"Line":1}},{"line":535,"address":[5186309,5186124],"length":1,"stats":{"Line":2}},{"line":537,"address":[5186473],"length":1,"stats":{"Line":0}},{"line":543,"address":[5188180],"length":1,"stats":{"Line":0}}],"covered":166,"coverable":231},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","insert.rs"],"content":"use crate::ast::dml::insert::InsertQuery;\nuse crate::ast::dml::parts::insert_values::InsertValue;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_insert_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cInsertQuery, RRDBError\u003e {\n        let mut query_builder = InsertQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0401 need more tokens\"));\n        }\n\n        // INSERT 토큰 삼키기\n        let current_token = self.get_next_token();\n        if current_token != Token::Insert {\n            return Err(ParsingError::wrap(\"E0402 expected INSERT\"));\n        }\n\n        // INTO 토큰 삼키기\n        let current_token = self.get_next_token();\n        if current_token != Token::Into {\n            return Err(ParsingError::wrap(\"E0403 expected INTO\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_into_table(table_name);\n\n        // 컬럼명 지정 파싱\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0404 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected '('. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0405 need more tokens\"));\n        }\n\n        // 컬럼명 지정 파싱\n        let columns = self.parse_insert_columns(context.clone())?;\n        query_builder = query_builder.set_columns(columns.clone());\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0413 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Values =\u003e {\n                self.unget_next_token(current_token);\n                let values = self.parse_insert_values(context)?;\n\n                if values.iter().any(|e| e.list.len() != columns.len()) {\n                    return Err(ParsingError::wrap(\n                        \"E0415 The number of values in insert and the number of columns do not match.\",\n                    ));\n                }\n\n                query_builder = query_builder.set_values(values);\n            }\n            Token::Select =\u003e {\n                self.unget_next_token(current_token);\n                let select = self.handle_select_query(context)?;\n\n                if select.select_items.len() != columns.len() {\n                    return Err(ParsingError::wrap(\n                        \"E0416 The number of values in insert and the number of columns do not match.\",\n                    ));\n                }\n\n                query_builder = query_builder.set_select(select);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E0414 expected 'Values'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        }\n\n        // TODO: On Conflict 절 파싱\n\n        // TODO: Returning 절 파싱\n\n        Ok(query_builder.build())\n    }\n\n    // INSERT의 컬럼명 지정 부분 파싱\n    // INSERT INTO (A, B, C) Values (1, 2, 3);\n    //              ^^^^^^^\n    pub(crate) fn parse_insert_columns(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cVec\u003cString\u003e, RRDBError\u003e {\n        let mut names = vec![];\n        loop {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0406 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Identifier(identifier) =\u003e {\n                    names.push(identifier);\n                    continue;\n                }\n                Token::Comma =\u003e {\n                    continue;\n                }\n                Token::RightParentheses =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                _ =\u003e {\n                    return Err(ParsingError::wrap(format!(\n                        \"E0407 unexpected input word '{:?}'\",\n                        current_token\n                    )));\n                }\n            }\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0408 expected ')'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(names)\n    }\n\n    // Values 절 파싱\n    // INSERT INTO (A, B, C) Values(1, 2, 3);\n    //                       ^^^^^^^^^^^^^^^\n    pub(crate) fn parse_insert_values(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cVec\u003cInsertValue\u003e, RRDBError\u003e {\n        // Values 파싱\n        let mut values: Vec\u003cInsertValue\u003e = vec![];\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0409 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Values {\n            return Err(ParsingError::wrap(format!(\n                \"E0408 expected 'Values'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        loop {\n            let mut list = vec![];\n\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            if current_token != Token::LeftParentheses {\n                self.unget_next_token(current_token);\n                break;\n            }\n\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0411 need more tokens\"));\n            }\n\n            // 각 Value 절 파싱. (A, B, C, D...)\n            loop {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0412 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Comma =\u003e {\n                        continue;\n                    }\n                    Token::RightParentheses =\u003e {\n                        break;\n                    }\n                    Token::Default =\u003e {\n                        list.push(None);\n                        continue;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let expression = self.parse_expression(context.clone())?;\n                            list.push(Some(expression));\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            // 쉼표가 있으면 삼키기\n            if self.pick_next_token() == Token::Comma {\n                self.get_next_token();\n            }\n\n            let value = InsertValue { list };\n\n            values.push(value);\n        }\n\n        Ok(values)\n    }\n}\n","traces":[{"line":9,"address":[5192136,5188416,5193781],"length":1,"stats":{"Line":3}},{"line":13,"address":[5188472],"length":1,"stats":{"Line":3}},{"line":15,"address":[5188597,5188658],"length":1,"stats":{"Line":6}},{"line":16,"address":[5188664,5188719],"length":1,"stats":{"Line":0}},{"line":20,"address":[5188704],"length":1,"stats":{"Line":3}},{"line":21,"address":[5188780,5188850],"length":1,"stats":{"Line":8}},{"line":22,"address":[5193681,5188876],"length":1,"stats":{"Line":0}},{"line":26,"address":[5188869],"length":1,"stats":{"Line":4}},{"line":27,"address":[5188976,5188906],"length":1,"stats":{"Line":8}},{"line":28,"address":[5189002,5193610],"length":1,"stats":{"Line":0}},{"line":32,"address":[5189053,5188995,5189419,5193582],"length":1,"stats":{"Line":8}},{"line":33,"address":[5189570,5189217],"length":1,"stats":{"Line":8}},{"line":36,"address":[5189674],"length":1,"stats":{"Line":4}},{"line":37,"address":[5189695,5189750],"length":1,"stats":{"Line":0}},{"line":40,"address":[5189735],"length":1,"stats":{"Line":4}},{"line":42,"address":[5189806,5189876],"length":1,"stats":{"Line":8}},{"line":43,"address":[5193412],"length":1,"stats":{"Line":0}},{"line":49,"address":[5190001,5189887],"length":1,"stats":{"Line":8}},{"line":50,"address":[5190007,5190062],"length":1,"stats":{"Line":0}},{"line":54,"address":[5193407,5190047,5190418,5190144],"length":1,"stats":{"Line":8}},{"line":55,"address":[5190268,5190523,5193397],"length":1,"stats":{"Line":4}},{"line":57,"address":[5190720,5190779],"length":1,"stats":{"Line":8}},{"line":58,"address":[5190840,5190785],"length":1,"stats":{"Line":0}},{"line":61,"address":[5190825,5190905],"length":1,"stats":{"Line":8}},{"line":63,"address":[5190913],"length":1,"stats":{"Line":4}},{"line":65,"address":[5191114],"length":1,"stats":{"Line":3}},{"line":66,"address":[5193189,5192387,5192176],"length":1,"stats":{"Line":3}},{"line":68,"address":[5192359,5192543],"length":1,"stats":{"Line":11}},{"line":69,"address":[5193070,5192802],"length":1,"stats":{"Line":0}},{"line":74,"address":[5192627,5192832],"length":1,"stats":{"Line":6}},{"line":77,"address":[5191054],"length":1,"stats":{"Line":1}},{"line":78,"address":[5191223,5191446,5192145],"length":1,"stats":{"Line":1}},{"line":80,"address":[5191423,5191592],"length":1,"stats":{"Line":2}},{"line":81,"address":[5192020,5191810],"length":1,"stats":{"Line":0}},{"line":86,"address":[5191635,5191840],"length":1,"stats":{"Line":2}},{"line":89,"address":[5193191],"length":1,"stats":{"Line":0}},{"line":100,"address":[5192887,5191882],"length":1,"stats":{"Line":6}},{"line":106,"address":[5193808,5194995,5195311],"length":1,"stats":{"Line":4}},{"line":110,"address":[5193843],"length":1,"stats":{"Line":4}},{"line":111,"address":[5193920],"length":1,"stats":{"Line":4}},{"line":112,"address":[5193933,5193986],"length":1,"stats":{"Line":8}},{"line":113,"address":[5193992,5194041],"length":1,"stats":{"Line":0}},{"line":116,"address":[5194029,5194075],"length":1,"stats":{"Line":8}},{"line":118,"address":[5194091],"length":1,"stats":{"Line":4}},{"line":119,"address":[5194249],"length":1,"stats":{"Line":4}},{"line":120,"address":[5194289,5194444],"length":1,"stats":{"Line":8}},{"line":127,"address":[5194340],"length":1,"stats":{"Line":4}},{"line":131,"address":[5195004],"length":1,"stats":{"Line":0}},{"line":139,"address":[5194522],"length":1,"stats":{"Line":4}},{"line":141,"address":[5194599,5194529],"length":1,"stats":{"Line":8}},{"line":142,"address":[5194817],"length":1,"stats":{"Line":0}},{"line":148,"address":[5194610],"length":1,"stats":{"Line":4}},{"line":154,"address":[5196738,5197934,5195328],"length":1,"stats":{"Line":3}},{"line":159,"address":[5195363],"length":1,"stats":{"Line":3}},{"line":161,"address":[5195457,5195518],"length":1,"stats":{"Line":6}},{"line":162,"address":[5195573,5195524],"length":1,"stats":{"Line":0}},{"line":165,"address":[5195561],"length":1,"stats":{"Line":3}},{"line":167,"address":[5195673,5195603],"length":1,"stats":{"Line":6}},{"line":168,"address":[5197772],"length":1,"stats":{"Line":0}},{"line":174,"address":[5196733],"length":1,"stats":{"Line":3}},{"line":175,"address":[5195687],"length":1,"stats":{"Line":3}},{"line":177,"address":[5195862,5195798],"length":1,"stats":{"Line":6}},{"line":181,"address":[5195899],"length":1,"stats":{"Line":3}},{"line":183,"address":[5195985,5195914],"length":1,"stats":{"Line":6}},{"line":184,"address":[5196012],"length":1,"stats":{"Line":0}},{"line":188,"address":[5195996,5196074],"length":1,"stats":{"Line":6}},{"line":189,"address":[5196128,5196080],"length":1,"stats":{"Line":0}},{"line":193,"address":[5196840],"length":1,"stats":{"Line":0}},{"line":194,"address":[5196168,5196112],"length":1,"stats":{"Line":6}},{"line":195,"address":[5196174,5196226],"length":1,"stats":{"Line":0}},{"line":198,"address":[5196246,5196214],"length":1,"stats":{"Line":6}},{"line":200,"address":[5196254],"length":1,"stats":{"Line":3}},{"line":208,"address":[5196439,5196333],"length":1,"stats":{"Line":2}},{"line":212,"address":[5196309,5196751],"length":1,"stats":{"Line":6}},{"line":213,"address":[5196777],"length":1,"stats":{"Line":3}},{"line":214,"address":[5197313,5196858],"length":1,"stats":{"Line":3}},{"line":215,"address":[5197114],"length":1,"stats":{"Line":3}},{"line":223,"address":[5196462],"length":1,"stats":{"Line":3}},{"line":224,"address":[5196680],"length":1,"stats":{"Line":2}},{"line":227,"address":[5196575],"length":1,"stats":{"Line":1}},{"line":229,"address":[5196660],"length":1,"stats":{"Line":3}},{"line":232,"address":[5197625],"length":1,"stats":{"Line":2}}],"covered":63,"coverable":82},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","mod.rs"],"content":"pub mod delete;\npub mod expression;\npub mod insert;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","select.rs"],"content":"use std::collections::HashSet;\n\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::group_by::GroupByItem;\nuse crate::ast::dml::parts::having::HavingClause;\nuse crate::ast::dml::parts::join::{JoinClause, JoinType};\nuse crate::ast::dml::parts::order_by::{OrderByItem, OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectWildCard};\nuse crate::ast::dml::select::SelectQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_select_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSelectQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0301: need more tokens\"));\n        }\n\n        // SELECT 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Select {\n            return Err(ParsingError::wrap(format!(\n                \"E0302: expected 'SELECT'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0303: need more tokens\"));\n        }\n\n        let mut query_builder = SelectQuery::builder();\n\n        // FROM 절이나 세미콜론이 나오기 전까지 select 절 파싱\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::From =\u003e {\n                    // from 다시 집어넣고 종료\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::SemiColon =\u003e {\n                    // from 없는 select절로 간주. 종료.\n                    return Ok(query_builder.build());\n                }\n                Token::Comma =\u003e continue,\n                Token::Operator(OperatorToken::Asterisk) =\u003e {\n                    query_builder =\n                        query_builder.add_select_wildcard(SelectWildCard { alias: None });\n                    continue;\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    let select_item = self.parse_select_item(context.clone())?;\n                    query_builder = query_builder.add_select_item(select_item);\n                }\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        // FROM 절 파싱\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::From =\u003e {\n                if self.next_token_is_left_parentheses() {\n                    let subquery = self.parse_subquery(context.clone())?;\n                    query_builder = query_builder.set_from_subquery(subquery);\n                } else {\n                    let table_name = self.parse_table_name(context.clone())?;\n                    query_builder = query_builder.set_from_table(table_name);\n                }\n\n                if self.next_token_is_table_alias() {\n                    let alias = self.parse_table_alias()?;\n                    query_builder = query_builder.set_from_alias(alias);\n                }\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E0304 expected 'FROM' clause. but your input word is '{:?}'\",\n                    current_token\n                )));\n            }\n        }\n\n        // JOIN 절 파싱\n        while let Some(join_type) = self.get_next_join_type() {\n            let join = self.parse_join(join_type, context.clone())?;\n            query_builder = query_builder.add_join(join);\n        }\n\n        // WHERE 절 파싱\n        if self.next_token_is_where() {\n            let where_clause = self.parse_where(context.clone())?;\n            query_builder = query_builder.set_where(where_clause);\n        }\n\n        // Group By 절 파싱\n        if self.next_token_is_group_by() {\n            // GROUP BY 삼킴\n            self.get_next_token();\n            self.get_next_token();\n\n            loop {\n                if !self.has_next_token() {\n                    break;\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::SemiColon =\u003e {\n                        return Ok(query_builder.build());\n                    }\n                    Token::Comma =\u003e continue,\n                    Token::Having | Token::Limit | Token::Offset | Token::Order =\u003e {\n                        self.unget_next_token(current_token);\n                        break;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let group_by_item = self.parse_group_by_item(context.clone())?;\n                            query_builder = query_builder.add_group_by(group_by_item);\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E0319 unexpected token '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n            }\n        }\n\n        if !query_builder.select_items.is_empty() {\n            // 집계 함수 \u003c\u003e GROUP BY 불일치 검증\n            if query_builder.has_aggregate() {\n                query_builder = query_builder.set_has_aggregate(true);\n\n                let group_by_columns = match query_builder.group_by_clause {\n                    Some(ref clause) =\u003e HashSet::from_iter(\n                        clause.group_by_items.clone().into_iter().map(|e| e.item),\n                    ),\n                    None =\u003e HashSet::new(),\n                };\n\n                // 집계함수가 사용되지 않은 select column 목록\n                let non_aggregate_columns = query_builder.get_non_aggregate_column();\n\n                // 집계함수가 사용되지 않은 컬럼이 group by에 없다면 오류\n                for non_aggregate_column in non_aggregate_columns {\n                    if !group_by_columns.contains(\u0026non_aggregate_column) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0331: column '{:?}' must be in a GROUP BY clause or used within an aggregate function\",\n                            non_aggregate_column\n                        )));\n                    }\n                }\n\n                // 집계함수가 사용된 select column 목록\n                let aggregate_columns = query_builder.get_aggregate_column();\n\n                // 집계함수가 사용된 컬럼이 group by에 있다면 오류\n                for aggregate_column in aggregate_columns {\n                    if group_by_columns.contains(\u0026aggregate_column) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0332: column '{:?}' cannot be in a GROUP BY clause\",\n                            group_by_columns\n                        )));\n                    }\n                }\n            }\n        }\n\n        // Having 절 파싱\n        if self.next_token_is_having() {\n            if query_builder.has_group_by() {\n                let having_clause = self.parse_having(context.clone())?;\n                query_builder = query_builder.set_having(having_clause);\n            } else {\n                return Err(ParsingError::wrap(\n                    \"E0315 Having without group by is invalid.\",\n                ));\n            }\n        }\n\n        // Order By 절 파싱\n        if self.next_token_is_order_by() {\n            // ORDER BY 삼킴\n            self.get_next_token();\n            self.get_next_token();\n\n            loop {\n                if !self.has_next_token() {\n                    break;\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::SemiColon =\u003e {\n                        return Ok(query_builder.build());\n                    }\n                    Token::Comma =\u003e continue,\n                    Token::Group | Token::Limit | Token::Offset =\u003e {\n                        self.unget_next_token(current_token);\n                        break;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let order_by_item = self.parse_order_by_item(context.clone())?;\n                            query_builder = query_builder.add_order_by(order_by_item);\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E0318 unexpected token '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Limit \u0026 Offset 절 파싱\n        // Offset이 먼저인 경우와, Limit이 먼저인 경우 둘다 대응\n        if self.next_token_is_offset() {\n            let offset = self.parse_offset(context.clone())?;\n            query_builder = query_builder.set_offset(offset);\n\n            if self.next_token_is_limit() {\n                let limit = self.parse_limit(context)?;\n                query_builder = query_builder.set_limit(limit);\n            }\n        } else if self.next_token_is_limit() {\n            let limit = self.parse_limit(context.clone())?;\n            query_builder = query_builder.set_limit(limit);\n\n            if self.next_token_is_offset() {\n                let offset = self.parse_offset(context)?;\n                query_builder = query_builder.set_offset(offset);\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n\n    pub(crate) fn parse_select_item(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSelectItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0305 need more tokens\"));\n        }\n\n        let select_item = SelectItem::builder();\n\n        // 표현식 파싱\n        let select_item = select_item.set_item(self.parse_expression(context)?);\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(select_item.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::As =\u003e {\n                // 더 없을 경우 바로 반환\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0306 expected alias. need more\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(identifier) =\u003e {\n                        let select_item = select_item.set_alias(identifier);\n                        Ok(select_item.build())\n                    }\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"E0307 expected alias, but your input word is '{:?}'\",\n                        current_token\n                    ))),\n                }\n            }\n            Token::Comma =\u003e {\n                self.unget_next_token(current_token);\n                // 현재 select_item은 종료된 것으로 판단.\n                Ok(select_item.build())\n            }\n            Token::From =\u003e {\n                self.unget_next_token(current_token);\n                // 현재 select_item은 종료된 것으로 판단.\n                Ok(select_item.build())\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0308 expected expression. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_order_by_item(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cOrderByItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0313 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let item = self.parse_expression(context)?;\n\n        let mut order_by_item = OrderByItem {\n            item,\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        };\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(order_by_item);\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Asc =\u003e {\n                order_by_item.order_type = OrderByType::Asc;\n            }\n            Token::Desc =\u003e {\n                order_by_item.order_type = OrderByType::Desc;\n            }\n            _ =\u003e {\n                self.unget_next_token(current_token);\n            }\n        }\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(order_by_item);\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Nulls =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0329 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::First =\u003e {}\n                    Token::Last =\u003e order_by_item.nulls = OrderByNulls::Last,\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0330 expected keyword is FIRST or LAST, but your input is {:?}\",\n                            current_token\n                        )))\n                    }\n                }\n\n                Ok(order_by_item)\n            }\n            _ =\u003e {\n                self.unget_next_token(current_token);\n                Ok(order_by_item)\n            }\n        }\n    }\n\n    pub(crate) fn parse_group_by_item(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cGroupByItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0314 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let item = self.parse_select_column()?;\n\n        let order_by_item = GroupByItem { item };\n\n        Ok(order_by_item)\n    }\n\n    pub(crate) fn parse_join(\n        \u0026mut self,\n        join_type: JoinType,\n        context: ParserContext,\n    ) -\u003e Result\u003cJoinClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0310 need more tokens\"));\n        }\n\n        let right = self.parse_table_name(context.clone())?;\n\n        let right_alias = if self.next_token_is_table_alias() {\n            self.parse_table_alias().ok()\n        } else {\n            None\n        };\n\n        let on = if !self.has_next_token() {\n            None\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::On {\n                let expression = self.parse_expression(context)?;\n                Some(expression)\n            } else {\n                self.unget_next_token(current_token);\n                None\n            }\n        };\n\n        let join = JoinClause {\n            join_type,\n            on,\n            right,\n            right_alias,\n        };\n\n        Ok(join)\n    }\n\n    pub(crate) fn parse_where(\u0026mut self, context: ParserContext) -\u003e Result\u003cWhereClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0311 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Where {\n            return Err(ParsingError::wrap(format!(\n                \"E0312 expected 'WHERE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        Ok(expression.into())\n    }\n\n    pub(crate) fn parse_having(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cHavingClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0316 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Having {\n            return Err(ParsingError::wrap(format!(\n                \"E0317 expected 'Having'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        Ok(HavingClause {\n            expression: expression.into(),\n        })\n    }\n\n    pub(crate) fn parse_offset(\u0026mut self, _context: ParserContext) -\u003e Result\u003cu32, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0320 need more tokens\"));\n        }\n\n        // OFFSET 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Offset {\n            return Err(ParsingError::wrap(format!(\n                \"E0321 expected 'Offset'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // OFFSET 숫자값 획득\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0322 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Integer(integer) =\u003e {\n                if integer \u003e= 0 {\n                    Ok(integer as u32)\n                } else {\n                    Err(ParsingError::wrap(\n                        \"E0323 Offset can only contain positive numbers.\",\n                    ))\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0324 expected positive numbers. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_limit(\u0026mut self, _context: ParserContext) -\u003e Result\u003cu32, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0325 need more tokens\"));\n        }\n\n        // OFFSET 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Limit {\n            return Err(ParsingError::wrap(format!(\n                \"E0326 expected 'Limit'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // OFFSET 숫자값 획득\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0327 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Integer(integer) =\u003e {\n                if integer \u003e= 0 {\n                    Ok(integer as u32)\n                } else {\n                    Err(ParsingError::wrap(\n                        \"E0327 Limit can only contain positive numbers.\",\n                    ))\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0328 expected positive numbers. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":16,"address":[5211070,5200181,5197952],"length":1,"stats":{"Line":1}},{"line":20,"address":[5198252,5198070],"length":1,"stats":{"Line":2}},{"line":21,"address":[5198258,5198316],"length":1,"stats":{"Line":0}},{"line":25,"address":[5198301],"length":1,"stats":{"Line":1}},{"line":27,"address":[5198378,5198454],"length":1,"stats":{"Line":2}},{"line":28,"address":[5210900],"length":1,"stats":{"Line":0}},{"line":34,"address":[5198468,5198588],"length":1,"stats":{"Line":2}},{"line":35,"address":[5198594,5198644],"length":1,"stats":{"Line":0}},{"line":38,"address":[5198629],"length":1,"stats":{"Line":1}},{"line":41,"address":[5210772,5198705],"length":1,"stats":{"Line":4}},{"line":42,"address":[5198721,5198783],"length":1,"stats":{"Line":2}},{"line":46,"address":[5198830],"length":1,"stats":{"Line":1}},{"line":48,"address":[5199065,5198845],"length":1,"stats":{"Line":2}},{"line":51,"address":[5199007],"length":1,"stats":{"Line":1}},{"line":56,"address":[5210044,5199106],"length":1,"stats":{"Line":0}},{"line":60,"address":[5209984],"length":1,"stats":{"Line":1}},{"line":61,"address":[5209863],"length":1,"stats":{"Line":1}},{"line":62,"address":[5210018],"length":1,"stats":{"Line":1}},{"line":65,"address":[5198941],"length":1,"stats":{"Line":1}},{"line":66,"address":[5210097,5210583],"length":1,"stats":{"Line":1}},{"line":67,"address":[5210397,5210722],"length":1,"stats":{"Line":5}},{"line":72,"address":[5199239,5198797],"length":1,"stats":{"Line":6}},{"line":73,"address":[5199245,5199345],"length":1,"stats":{"Line":6}},{"line":77,"address":[5199330],"length":1,"stats":{"Line":1}},{"line":79,"address":[5199382],"length":1,"stats":{"Line":1}},{"line":81,"address":[5199567,5200612,5199404],"length":1,"stats":{"Line":3}},{"line":82,"address":[5199612,5200240,5200424],"length":1,"stats":{"Line":2}},{"line":83,"address":[5200570,5200328],"length":1,"stats":{"Line":2}},{"line":85,"address":[5199589,5199646,5199954],"length":1,"stats":{"Line":2}},{"line":86,"address":[5199810,5200096],"length":1,"stats":{"Line":2}},{"line":89,"address":[5200146,5200624,5201119],"length":1,"stats":{"Line":3}},{"line":90,"address":[5200671,5200931],"length":1,"stats":{"Line":1}},{"line":91,"address":[5201077,5200803],"length":1,"stats":{"Line":2}},{"line":95,"address":[5209711],"length":1,"stats":{"Line":0}},{"line":103,"address":[5201131,5201759,5200638],"length":1,"stats":{"Line":4}},{"line":104,"address":[5201578,5201247,5201200],"length":1,"stats":{"Line":2}},{"line":105,"address":[5201447,5201717],"length":1,"stats":{"Line":4}},{"line":109,"address":[5202472,5201215,5201802],"length":1,"stats":{"Line":3}},{"line":110,"address":[5202284,5201849],"length":1,"stats":{"Line":1}},{"line":111,"address":[5202108,5202430],"length":1,"stats":{"Line":2}},{"line":115,"address":[5202484,5201816],"length":1,"stats":{"Line":2}},{"line":117,"address":[5202531],"length":1,"stats":{"Line":1}},{"line":118,"address":[5202569],"length":1,"stats":{"Line":1}},{"line":120,"address":[5209532],"length":1,"stats":{"Line":1}},{"line":121,"address":[5202599],"length":1,"stats":{"Line":1}},{"line":125,"address":[5202645],"length":1,"stats":{"Line":1}},{"line":127,"address":[5202660],"length":1,"stats":{"Line":1}},{"line":129,"address":[5202845,5208630],"length":1,"stats":{"Line":0}},{"line":133,"address":[5202769],"length":1,"stats":{"Line":1}},{"line":137,"address":[5202744,5208674],"length":1,"stats":{"Line":2}},{"line":138,"address":[5208784],"length":1,"stats":{"Line":1}},{"line":139,"address":[5209010,5209343],"length":1,"stats":{"Line":1}},{"line":140,"address":[5209205,5209482],"length":1,"stats":{"Line":2}},{"line":142,"address":[5208842],"length":1,"stats":{"Line":0}},{"line":152,"address":[5202978,5202498],"length":1,"stats":{"Line":2}},{"line":154,"address":[5203038,5202992],"length":1,"stats":{"Line":2}},{"line":155,"address":[5203044],"length":1,"stats":{"Line":1}},{"line":157,"address":[5203152],"length":1,"stats":{"Line":1}},{"line":159,"address":[3977484,3977456],"length":1,"stats":{"Line":4}},{"line":161,"address":[5203195,5203233],"length":1,"stats":{"Line":0}},{"line":165,"address":[5203251],"length":1,"stats":{"Line":1}},{"line":168,"address":[5203569,5203385,5203519],"length":1,"stats":{"Line":3}},{"line":169,"address":[5203633,5204406],"length":1,"stats":{"Line":2}},{"line":170,"address":[5204526],"length":1,"stats":{"Line":1}},{"line":178,"address":[5203666],"length":1,"stats":{"Line":0}},{"line":181,"address":[5203873,5203689,5203823],"length":1,"stats":{"Line":0}},{"line":182,"address":[5203937,5204016],"length":1,"stats":{"Line":0}},{"line":183,"address":[5204134],"length":1,"stats":{"Line":0}},{"line":193,"address":[5205311,5203014,5204743],"length":1,"stats":{"Line":3}},{"line":194,"address":[5204782],"length":1,"stats":{"Line":1}},{"line":195,"address":[5204939,5204852,5205123],"length":1,"stats":{"Line":2}},{"line":196,"address":[5205269,5205027],"length":1,"stats":{"Line":2}},{"line":198,"address":[5204867,5204809],"length":1,"stats":{"Line":0}},{"line":205,"address":[5204757,5205323],"length":1,"stats":{"Line":2}},{"line":207,"address":[5205370],"length":1,"stats":{"Line":1}},{"line":208,"address":[5205408],"length":1,"stats":{"Line":1}},{"line":210,"address":[5208496],"length":1,"stats":{"Line":1}},{"line":211,"address":[5205438],"length":1,"stats":{"Line":1}},{"line":215,"address":[5205484],"length":1,"stats":{"Line":1}},{"line":217,"address":[5205499],"length":1,"stats":{"Line":1}},{"line":219,"address":[5205681,5207513],"length":1,"stats":{"Line":0}},{"line":223,"address":[5205608],"length":1,"stats":{"Line":0}},{"line":227,"address":[5207557,5205583],"length":1,"stats":{"Line":2}},{"line":228,"address":[5207667],"length":1,"stats":{"Line":1}},{"line":229,"address":[5207893,5208307],"length":1,"stats":{"Line":1}},{"line":230,"address":[5208446,5208137],"length":1,"stats":{"Line":2}},{"line":232,"address":[5207725],"length":1,"stats":{"Line":0}},{"line":244,"address":[5205337,5205808],"length":1,"stats":{"Line":2}},{"line":245,"address":[5205849,5207487,5206842,5206693],"length":1,"stats":{"Line":4}},{"line":246,"address":[5206767,5206947],"length":1,"stats":{"Line":4}},{"line":248,"address":[5206993,5207368],"length":1,"stats":{"Line":3}},{"line":249,"address":[5207482,5207229,5207033],"length":1,"stats":{"Line":1}},{"line":250,"address":[5207334,5207154],"length":1,"stats":{"Line":2}},{"line":252,"address":[5205863,5205822],"length":1,"stats":{"Line":2}},{"line":253,"address":[5205951,5206131,5206664],"length":1,"stats":{"Line":1}},{"line":254,"address":[5206056,5206236],"length":1,"stats":{"Line":2}},{"line":256,"address":[5206282,5206654],"length":1,"stats":{"Line":2}},{"line":257,"address":[5206322,5206518,5206659],"length":1,"stats":{"Line":1}},{"line":258,"address":[5206620,5206443],"length":1,"stats":{"Line":2}},{"line":262,"address":[5207401,5205869],"length":1,"stats":{"Line":2}},{"line":265,"address":[5214026,5211104,5213549],"length":1,"stats":{"Line":1}},{"line":269,"address":[5211251,5211147],"length":1,"stats":{"Line":2}},{"line":270,"address":[5211301,5211257],"length":1,"stats":{"Line":0}},{"line":273,"address":[5211289],"length":1,"stats":{"Line":1}},{"line":276,"address":[5213976,5214016,5211367],"length":1,"stats":{"Line":1}},{"line":279,"address":[5211908,5211964],"length":1,"stats":{"Line":2}},{"line":280,"address":[5212126,5211974],"length":1,"stats":{"Line":0}},{"line":283,"address":[5212163,5212114],"length":1,"stats":{"Line":2}},{"line":285,"address":[5212171],"length":1,"stats":{"Line":1}},{"line":288,"address":[5212685,5212394],"length":1,"stats":{"Line":2}},{"line":289,"address":[5212746,5212691],"length":1,"stats":{"Line":0}},{"line":292,"address":[5212731,5212875],"length":1,"stats":{"Line":2}},{"line":294,"address":[5212883],"length":1,"stats":{"Line":2}},{"line":295,"address":[5212901],"length":1,"stats":{"Line":2}},{"line":296,"address":[5212941],"length":1,"stats":{"Line":2}},{"line":297,"address":[5213236],"length":1,"stats":{"Line":2}},{"line":299,"address":[5213289],"length":1,"stats":{"Line":0}},{"line":306,"address":[5212413],"length":1,"stats":{"Line":1}},{"line":308,"address":[5213558],"length":1,"stats":{"Line":1}},{"line":311,"address":[5212334],"length":1,"stats":{"Line":1}},{"line":313,"address":[5212512],"length":1,"stats":{"Line":1}},{"line":315,"address":[5213713],"length":1,"stats":{"Line":0}},{"line":322,"address":[5216396,5216661,5214064],"length":1,"stats":{"Line":1}},{"line":326,"address":[5214107,5214211],"length":1,"stats":{"Line":2}},{"line":327,"address":[5214217,5214310],"length":1,"stats":{"Line":0}},{"line":331,"address":[5214251,5214376,5216644,5214829],"length":1,"stats":{"Line":2}},{"line":340,"address":[5214979,5214810],"length":1,"stats":{"Line":2}},{"line":341,"address":[5214985],"length":1,"stats":{"Line":0}},{"line":344,"address":[5215073,5215099],"length":1,"stats":{"Line":2}},{"line":346,"address":[5215107],"length":1,"stats":{"Line":1}},{"line":347,"address":[5215225],"length":1,"stats":{"Line":1}},{"line":348,"address":[5215201],"length":1,"stats":{"Line":1}},{"line":351,"address":[5215227],"length":1,"stats":{"Line":1}},{"line":354,"address":[5215146,5215308],"length":1,"stats":{"Line":4}},{"line":359,"address":[5215314,5215256],"length":1,"stats":{"Line":2}},{"line":360,"address":[5215320],"length":1,"stats":{"Line":1}},{"line":363,"address":[5215408,5215434],"length":1,"stats":{"Line":3}},{"line":365,"address":[5215442],"length":1,"stats":{"Line":1}},{"line":367,"address":[5215461,5215580],"length":1,"stats":{"Line":4}},{"line":368,"address":[5215586,5215638],"length":1,"stats":{"Line":0}},{"line":371,"address":[5215626],"length":1,"stats":{"Line":2}},{"line":373,"address":[5215690],"length":1,"stats":{"Line":2}},{"line":375,"address":[5216002],"length":1,"stats":{"Line":1}},{"line":377,"address":[5216090],"length":1,"stats":{"Line":0}},{"line":384,"address":[5215832],"length":1,"stats":{"Line":1}},{"line":387,"address":[5215477],"length":1,"stats":{"Line":1}},{"line":388,"address":[5216405],"length":1,"stats":{"Line":1}},{"line":393,"address":[5216688,5217149],"length":1,"stats":{"Line":1}},{"line":397,"address":[5216783,5216731],"length":1,"stats":{"Line":2}},{"line":398,"address":[5216838,5216789],"length":1,"stats":{"Line":0}},{"line":402,"address":[5217144,5216884,5216826,5217029],"length":1,"stats":{"Line":2}},{"line":404,"address":[5216947],"length":1,"stats":{"Line":1}},{"line":406,"address":[5216978],"length":1,"stats":{"Line":1}},{"line":409,"address":[5217184,5218809,5218838],"length":1,"stats":{"Line":1}},{"line":414,"address":[5217240,5217320],"length":1,"stats":{"Line":2}},{"line":415,"address":[5217326,5217375],"length":1,"stats":{"Line":0}},{"line":418,"address":[5218818,5217363,5217628,5217452],"length":1,"stats":{"Line":4}},{"line":420,"address":[5217609,5217777,5217801],"length":1,"stats":{"Line":4}},{"line":421,"address":[5217816,5217855],"length":1,"stats":{"Line":4}},{"line":423,"address":[5217783],"length":1,"stats":{"Line":0}},{"line":426,"address":[5218686,5217912,5217936,5217828],"length":1,"stats":{"Line":6}},{"line":427,"address":[5217918],"length":1,"stats":{"Line":0}},{"line":429,"address":[5217951,5218218],"length":1,"stats":{"Line":4}},{"line":431,"address":[5218226,5218297,5218569],"length":1,"stats":{"Line":6}},{"line":432,"address":[5218576,5218480,5218373],"length":1,"stats":{"Line":4}},{"line":433,"address":[5218543],"length":1,"stats":{"Line":2}},{"line":435,"address":[5218308],"length":1,"stats":{"Line":0}},{"line":436,"address":[5218427],"length":1,"stats":{"Line":0}},{"line":447,"address":[5218181],"length":1,"stats":{"Line":2}},{"line":450,"address":[5218864,5219934,5220108],"length":1,"stats":{"Line":1}},{"line":451,"address":[5218987,5218907],"length":1,"stats":{"Line":2}},{"line":452,"address":[5218993,5219042],"length":1,"stats":{"Line":0}},{"line":455,"address":[5219030],"length":1,"stats":{"Line":1}},{"line":457,"address":[5219146,5219076],"length":1,"stats":{"Line":2}},{"line":458,"address":[5219969],"length":1,"stats":{"Line":0}},{"line":464,"address":[5219662,5219331,5219162],"length":1,"stats":{"Line":2}},{"line":466,"address":[5219813,5219536],"length":1,"stats":{"Line":2}},{"line":469,"address":[5220144,5221151,5221325],"length":1,"stats":{"Line":1}},{"line":473,"address":[5220267,5220187],"length":1,"stats":{"Line":2}},{"line":474,"address":[5220322,5220273],"length":1,"stats":{"Line":0}},{"line":477,"address":[5220310],"length":1,"stats":{"Line":1}},{"line":479,"address":[5220356,5220426],"length":1,"stats":{"Line":2}},{"line":480,"address":[5221186],"length":1,"stats":{"Line":0}},{"line":486,"address":[5220938,5220442,5220611],"length":1,"stats":{"Line":2}},{"line":488,"address":[5221086],"length":1,"stats":{"Line":1}},{"line":489,"address":[5220816],"length":1,"stats":{"Line":1}},{"line":493,"address":[5221360,5222255,5222388],"length":1,"stats":{"Line":1}},{"line":494,"address":[5221403,5221455],"length":1,"stats":{"Line":6}},{"line":495,"address":[5221461,5221510],"length":1,"stats":{"Line":0}},{"line":499,"address":[5221498],"length":1,"stats":{"Line":3}},{"line":501,"address":[5221540,5221610],"length":1,"stats":{"Line":6}},{"line":502,"address":[5222264],"length":1,"stats":{"Line":0}},{"line":509,"address":[5221621,5221735],"length":1,"stats":{"Line":6}},{"line":510,"address":[5221793,5221741],"length":1,"stats":{"Line":0}},{"line":513,"address":[5221781],"length":1,"stats":{"Line":3}},{"line":515,"address":[5221829],"length":1,"stats":{"Line":3}},{"line":516,"address":[5221843],"length":1,"stats":{"Line":3}},{"line":517,"address":[5222013,5221863],"length":1,"stats":{"Line":6}},{"line":518,"address":[5222003],"length":1,"stats":{"Line":3}},{"line":520,"address":[5221967,5222060],"length":1,"stats":{"Line":0}},{"line":525,"address":[5222093],"length":1,"stats":{"Line":0}},{"line":532,"address":[5222416,5223444,5223311],"length":1,"stats":{"Line":1}},{"line":533,"address":[5222511,5222459],"length":1,"stats":{"Line":2}},{"line":534,"address":[5222517,5222566],"length":1,"stats":{"Line":0}},{"line":538,"address":[5222554],"length":1,"stats":{"Line":1}},{"line":540,"address":[5222596,5222666],"length":1,"stats":{"Line":2}},{"line":541,"address":[5223320],"length":1,"stats":{"Line":0}},{"line":548,"address":[5222791,5222677],"length":1,"stats":{"Line":2}},{"line":549,"address":[5222797,5222849],"length":1,"stats":{"Line":0}},{"line":552,"address":[5222837],"length":1,"stats":{"Line":1}},{"line":554,"address":[5222885],"length":1,"stats":{"Line":1}},{"line":555,"address":[5222899],"length":1,"stats":{"Line":1}},{"line":556,"address":[5223069,5222919],"length":1,"stats":{"Line":2}},{"line":557,"address":[5223059],"length":1,"stats":{"Line":1}},{"line":559,"address":[5223116,5223023],"length":1,"stats":{"Line":0}},{"line":564,"address":[5223149],"length":1,"stats":{"Line":0}}],"covered":171,"coverable":216},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","update.rs"],"content":"use crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::update_item::UpdateItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_update_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cUpdateQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0601: need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Update {\n            return Err(ParsingError::wrap(format!(\n                \"E0602: expected 'UPDATE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let mut query_builder = UpdateQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0603: need more tokens\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_target_table(table_name);\n\n        if self.next_token_is_table_alias() {\n            let alias = self.parse_table_alias()?;\n            query_builder = query_builder.set_target_alias(alias);\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0604: need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Set {\n            return Err(ParsingError::wrap(format!(\n                \"E0605: expected 'SET'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Comma =\u003e continue,\n                Token::Where =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::SemiColon =\u003e {\n                    return Ok(query_builder.build());\n                }\n                Token::Identifier(identifier) =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0606: need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if current_token != Token::Operator(OperatorToken::Eq) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0607: expected '='. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0608: need more tokens\"));\n                    }\n\n                    let expression = self.parse_expression(context.clone())?;\n\n                    let update_item = UpdateItem {\n                        column: identifier,\n                        value: expression,\n                    };\n\n                    query_builder = query_builder.add_update_item(update_item)\n                }\n                _ =\u003e {\n                    return Err(ParsingError::wrap(format!(\n                        \"E0609: unexpected input word: '{:?}'\",\n                        current_token\n                    )));\n                }\n            }\n        }\n\n        // Where 절 파싱\n        if self.next_token_is_where() {\n            self.get_next_token(); // where 토큰 삼키기\n\n            let expression = self.parse_expression(context)?;\n            query_builder = query_builder.set_where(WhereClause { expression });\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":10,"address":[5226968,5223472,5229333],"length":1,"stats":{"Line":2}},{"line":14,"address":[5223672,5223530],"length":1,"stats":{"Line":4}},{"line":15,"address":[5223730,5223678],"length":1,"stats":{"Line":0}},{"line":18,"address":[5223718],"length":1,"stats":{"Line":2}},{"line":20,"address":[5223789,5223859],"length":1,"stats":{"Line":4}},{"line":21,"address":[5229172],"length":1,"stats":{"Line":0}},{"line":27,"address":[5223873],"length":1,"stats":{"Line":2}},{"line":29,"address":[5224048,5223984],"length":1,"stats":{"Line":4}},{"line":30,"address":[5224106,5224054],"length":1,"stats":{"Line":0}},{"line":34,"address":[5224485,5229106,5224094,5224186],"length":1,"stats":{"Line":4}},{"line":35,"address":[5224631,5224350],"length":1,"stats":{"Line":4}},{"line":37,"address":[5224674,5225166],"length":1,"stats":{"Line":2}},{"line":38,"address":[5224978,5224727],"length":1,"stats":{"Line":0}},{"line":39,"address":[5225124,5224859],"length":1,"stats":{"Line":0}},{"line":42,"address":[5225175,5224700],"length":1,"stats":{"Line":4}},{"line":43,"address":[5225233,5225181],"length":1,"stats":{"Line":0}},{"line":46,"address":[5225221],"length":1,"stats":{"Line":2}},{"line":48,"address":[5225356,5225286],"length":1,"stats":{"Line":4}},{"line":49,"address":[5228907],"length":1,"stats":{"Line":0}},{"line":55,"address":[5228298],"length":1,"stats":{"Line":2}},{"line":56,"address":[5225367,5225481],"length":1,"stats":{"Line":4}},{"line":60,"address":[5225519],"length":1,"stats":{"Line":2}},{"line":62,"address":[5225542],"length":1,"stats":{"Line":2}},{"line":65,"address":[5225722],"length":1,"stats":{"Line":1}},{"line":69,"address":[5228597,5225878],"length":1,"stats":{"Line":0}},{"line":71,"address":[5225793],"length":1,"stats":{"Line":2}},{"line":72,"address":[5227048,5225841],"length":1,"stats":{"Line":4}},{"line":73,"address":[5227054,5227106],"length":1,"stats":{"Line":0}},{"line":76,"address":[5227094],"length":1,"stats":{"Line":2}},{"line":78,"address":[5227168,5227238],"length":1,"stats":{"Line":4}},{"line":79,"address":[5228349],"length":1,"stats":{"Line":0}},{"line":85,"address":[5227249,5227363],"length":1,"stats":{"Line":4}},{"line":86,"address":[5227369,5227421],"length":1,"stats":{"Line":0}},{"line":89,"address":[5227500,5228045,5227409],"length":1,"stats":{"Line":4}},{"line":96,"address":[5228191,5227968],"length":1,"stats":{"Line":4}},{"line":99,"address":[5228617],"length":1,"stats":{"Line":0}},{"line":108,"address":[5226010,5226837,5225492],"length":1,"stats":{"Line":5}},{"line":109,"address":[5226095],"length":1,"stats":{"Line":1}},{"line":111,"address":[5226649,5226127],"length":1,"stats":{"Line":1}},{"line":112,"address":[5226795,5226402],"length":1,"stats":{"Line":2}},{"line":115,"address":[5226016,5226867],"length":1,"stats":{"Line":4}}],"covered":29,"coverable":41},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","mod.rs"],"content":"pub mod common;\npub mod ddl;\npub mod debug;\npub mod dml;\npub mod other;\npub mod tcl;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","backslash_command.rs"],"content":"use crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_backslash_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0801 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e match identifier.as_str() {\n                \"l\" =\u003e Ok(ShowDatabasesQuery {}.into()),\n                _ =\u003e Err(ParsingError::wrap(format!(\n                    \"E0803: unexpected identifier '{:?}'\",\n                    identifier\n                ))),\n            },\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0802: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":9,"address":[5230507,5230228,5229360],"length":1,"stats":{"Line":1}},{"line":13,"address":[5229463,5229403],"length":1,"stats":{"Line":2}},{"line":14,"address":[5229469,5229518],"length":1,"stats":{"Line":0}},{"line":17,"address":[5229506,5229578],"length":1,"stats":{"Line":2}},{"line":19,"address":[5229586],"length":1,"stats":{"Line":1}},{"line":20,"address":[5229600],"length":1,"stats":{"Line":1}},{"line":21,"address":[5229821,5229950,5230140],"length":1,"stats":{"Line":3}},{"line":22,"address":[5229975],"length":1,"stats":{"Line":0}},{"line":27,"address":[5230237],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","desc.rs"],"content":"use crate::ast::other::desc_table::DescTableQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_desc_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1001 need more tokens\"));\n        }\n\n        let table_name = self.parse_table_name(context)?;\n\n        Ok(DescTableQuery { table_name }.into())\n    }\n}\n","traces":[{"line":8,"address":[5231306,5231340,5230528],"length":1,"stats":{"Line":1}},{"line":12,"address":[5230651,5230571],"length":1,"stats":{"Line":2}},{"line":13,"address":[5230750,5230657],"length":1,"stats":{"Line":0}},{"line":16,"address":[5230691,5231105,5230822],"length":1,"stats":{"Line":2}},{"line":18,"address":[5231249,5230963],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":5},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","mod.rs"],"content":"pub mod backslash_command;\npub mod desc;\npub mod show;\n#[path = \"./use.rs\"]\npub mod use_;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","show.rs"],"content":"use crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_show_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0701 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Databases =\u003e Ok(ShowDatabasesQuery {}.into()),\n            Token::Tables =\u003e Ok(ShowTablesQuery {\n                database: context.default_database.unwrap_or_else(|| \"None\".into()),\n            }\n            .into()),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0702: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":10,"address":[5231376,5232169],"length":1,"stats":{"Line":1}},{"line":14,"address":[5231419,5231491],"length":1,"stats":{"Line":3}},{"line":15,"address":[5231546,5231497],"length":1,"stats":{"Line":0}},{"line":18,"address":[5231534],"length":1,"stats":{"Line":2}},{"line":20,"address":[5231606],"length":1,"stats":{"Line":2}},{"line":21,"address":[5231737,5231870],"length":1,"stats":{"Line":2}},{"line":22,"address":[5231906],"length":1,"stats":{"Line":1}},{"line":23,"address":[3192140,3192128],"length":1,"stats":{"Line":1}},{"line":25,"address":[5231991],"length":1,"stats":{"Line":1}},{"line":26,"address":[5231993],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","use.rs"],"content":"use crate::ast::other::use_database::UseDatabaseQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_use_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0901 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e Ok(UseDatabaseQuery {\n                database_name: identifier,\n            }\n            .into()),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0902: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":9,"address":[5232208,5233010],"length":1,"stats":{"Line":1}},{"line":13,"address":[5232311,5232251],"length":1,"stats":{"Line":2}},{"line":14,"address":[5232366,5232317],"length":1,"stats":{"Line":0}},{"line":17,"address":[5232354,5232426],"length":1,"stats":{"Line":2}},{"line":19,"address":[5232434],"length":1,"stats":{"Line":1}},{"line":20,"address":[5232448,5232699],"length":1,"stats":{"Line":2}},{"line":24,"address":[5232740],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","begin.rs"],"content":"use crate::ast::tcl::BeginTransactionQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::tokens::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_begin_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E2001 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Transaction {\n            return Err(ParsingError::wrap(\"E2002 Expected BEGIN\"));\n        }\n\n        Ok(BeginTransactionQuery {}.into())\n    }\n}\n","traces":[{"line":9,"address":[5233528,5233040],"length":1,"stats":{"Line":1}},{"line":13,"address":[5233083,5233135],"length":1,"stats":{"Line":2}},{"line":14,"address":[5233141,5233190],"length":1,"stats":{"Line":2}},{"line":17,"address":[5233178],"length":1,"stats":{"Line":1}},{"line":19,"address":[5233312,5233242],"length":1,"stats":{"Line":2}},{"line":20,"address":[5233437,5233340],"length":1,"stats":{"Line":2}},{"line":23,"address":[5233392,5233318],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","commit.rs"],"content":"use crate::ast::tcl::CommitQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_commit_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        Ok(CommitQuery {}.into())\n    }\n}\n","traces":[{"line":7,"address":[5233678,5233552],"length":1,"stats":{"Line":1}},{"line":11,"address":[5233640,5233582],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","mod.rs"],"content":"pub mod begin;\npub mod commit;\npub mod rollback;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","rollback.rs"],"content":"use crate::ast::tcl::RollbackQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_rollback_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        Ok(RollbackQuery {}.into())\n    }\n}\n","traces":[{"line":7,"address":[5233712,5233838],"length":1,"stats":{"Line":1}},{"line":11,"address":[5233742,5233800],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","utils.rs"],"content":"use crate::parser::predule::Parser;\n\nuse crate::lexer::predule::Token;\n\nimpl Parser {\n    // 다음 토큰 획득\n    pub(crate) fn get_next_token(\u0026mut self) -\u003e Token {\n        self.tokens.pop_front().unwrap()\n    }\n\n    // 다음 토큰 미리보기\n    pub(crate) fn pick_next_token(\u0026mut self) -\u003e Token {\n        self.tokens.front().unwrap().to_owned()\n    }\n\n    // 토큰 획득 롤백\n    pub(crate) fn unget_next_token(\u0026mut self, token: Token) {\n        self.tokens.push_front(token)\n    }\n\n    // 다음 토큰 유무 확인\n    pub(crate) fn has_next_token(\u0026self) -\u003e bool {\n        !self.tokens.is_empty() \u0026\u0026 !self.tokens.front().unwrap().is_eof()\n    }\n}\n","traces":[{"line":7,"address":[5233872],"length":1,"stats":{"Line":4}},{"line":8,"address":[5233890],"length":1,"stats":{"Line":4}},{"line":12,"address":[5233984],"length":1,"stats":{"Line":3}},{"line":13,"address":[5234075,5234016],"length":1,"stats":{"Line":6}},{"line":17,"address":[5234096],"length":1,"stats":{"Line":2}},{"line":18,"address":[5234101],"length":1,"stats":{"Line":2}},{"line":22,"address":[5234112],"length":1,"stats":{"Line":2}},{"line":23,"address":[5234125,5234192],"length":1,"stats":{"Line":6}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","mod.rs"],"content":"pub mod context;\npub mod implements;\n#[allow(clippy::module_inception)]\npub mod parser;\npub mod predule;\n\npub(crate) mod test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","parser.rs"],"content":"use std::collections::VecDeque;\n\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{Token, Tokenizer};\nuse crate::parser::predule::ParserContext;\n\n#[derive(Debug)]\npub struct Parser {\n    pub current_token: Token,\n    pub tokens: VecDeque\u003cToken\u003e,\n}\n\nimpl Parser {\n    // 파서 객체 생성\n    pub fn new(tokens: Vec\u003cToken\u003e) -\u003e Self {\n        Self {\n            current_token: Token::EOF,\n            tokens: VecDeque::from(tokens),\n        }\n    }\n\n    // deorecated\n    pub fn with_string(text: String) -\u003e Result\u003cSelf, RRDBError\u003e {\n        Ok(Self {\n            current_token: Token::EOF,\n            tokens: VecDeque::from(Tokenizer::string_to_tokens(text)?),\n        })\n    }\n\n    // 파서 객체 생성\n    pub fn with_tokens(tokens: VecDeque\u003cToken\u003e) -\u003e Self {\n        Self {\n            current_token: Token::EOF,\n            tokens,\n        }\n    }\n\n    pub fn parse(\u0026mut self, context: ParserContext) -\u003e Result\u003cVec\u003cSQLStatement\u003e, RRDBError\u003e {\n        let mut statements: Vec\u003cSQLStatement\u003e = vec![];\n\n        // Top-Level Parser Loop\n        loop {\n            if self.has_next_token() {\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::EOF =\u003e {\n                        // 루프 종료\n                        break;\n                    }\n                    Token::SemiColon =\u003e {\n                        // top-level 세미콜론 무시\n                        continue;\n                    }\n                    Token::Create =\u003e statements.push(self.handle_create_query(context.clone())?),\n                    Token::Alter =\u003e statements.push(self.handle_alter_query(context.clone())?),\n                    Token::Drop =\u003e statements.push(self.handle_drop_query(context.clone())?),\n                    Token::Select =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_select_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Update =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_update_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Insert =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_insert_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Delete =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_delete_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Backslash =\u003e {\n                        let query = self.parse_backslash_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Show =\u003e {\n                        let query = self.parse_show_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Use =\u003e {\n                        let query = self.parse_use_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Desc =\u003e {\n                        let query = self.parse_desc_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Begin =\u003e {\n                        let query = self.parse_begin_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Commit =\u003e {\n                        let query = self.parse_commit_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Rollback =\u003e {\n                        let query = self.parse_rollback_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    _ =\u003e {\n                        break;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        Ok(statements)\n    }\n}\n","traces":[{"line":16,"address":[5234240,5234385],"length":1,"stats":{"Line":1}},{"line":19,"address":[5234264],"length":1,"stats":{"Line":1}},{"line":24,"address":[5234884,5234416],"length":1,"stats":{"Line":4}},{"line":25,"address":[5234743],"length":1,"stats":{"Line":2}},{"line":26,"address":[5234432],"length":1,"stats":{"Line":4}},{"line":27,"address":[5234445,5234505],"length":1,"stats":{"Line":6}},{"line":32,"address":[5234912],"length":1,"stats":{"Line":0}},{"line":39,"address":[5234992,5236637,5242455],"length":1,"stats":{"Line":1}},{"line":40,"address":[17219112],"length":1,"stats":{"Line":3}},{"line":43,"address":[5242306],"length":1,"stats":{"Line":1}},{"line":44,"address":[17219182],"length":1,"stats":{"Line":6}},{"line":45,"address":[5235457],"length":1,"stats":{"Line":4}},{"line":47,"address":[5235472],"length":1,"stats":{"Line":4}},{"line":56,"address":[5238862,5235842],"length":1,"stats":{"Line":2}},{"line":57,"address":[5239132,5235868],"length":1,"stats":{"Line":8}},{"line":58,"address":[5239402,5235894],"length":1,"stats":{"Line":2}},{"line":60,"address":[3514142],"length":1,"stats":{"Line":1}},{"line":61,"address":[3514440],"length":1,"stats":{"Line":2}},{"line":62,"address":[3514448],"length":1,"stats":{"Line":6}},{"line":65,"address":[5235702],"length":1,"stats":{"Line":2}},{"line":66,"address":[17219632],"length":1,"stats":{"Line":2}},{"line":67,"address":[5238270,5238048],"length":1,"stats":{"Line":4}},{"line":70,"address":[5235636],"length":1,"stats":{"Line":3}},{"line":71,"address":[3514564,3514496],"length":1,"stats":{"Line":3}},{"line":72,"address":[5237453,5237753],"length":1,"stats":{"Line":6}},{"line":75,"address":[3532382,3532368],"length":1,"stats":{"Line":0}},{"line":76,"address":[5238632,5238337],"length":1,"stats":{"Line":0}},{"line":77,"address":[5238787,5238565],"length":1,"stats":{"Line":0}},{"line":80,"address":[3514798,3528084],"length":1,"stats":{"Line":2}},{"line":81,"address":[5242092],"length":1,"stats":{"Line":1}},{"line":84,"address":[5239929,5235920,5239672],"length":1,"stats":{"Line":2}},{"line":85,"address":[3515098,3532466,3532448],"length":1,"stats":{"Line":1}},{"line":88,"address":[5240393,5235946,5240136],"length":1,"stats":{"Line":2}},{"line":89,"address":[5240333],"length":1,"stats":{"Line":1}},{"line":91,"address":[3515261,3515230],"length":1,"stats":{"Line":0}},{"line":92,"address":[5235618,5236697,5236954],"length":1,"stats":{"Line":2}},{"line":93,"address":[5236894],"length":1,"stats":{"Line":1}},{"line":96,"address":[5240600,5235972,5240851],"length":1,"stats":{"Line":3}},{"line":97,"address":[5240791],"length":1,"stats":{"Line":1}},{"line":100,"address":[5235998,5241279,5241058],"length":1,"stats":{"Line":2}},{"line":101,"address":[5241225],"length":1,"stats":{"Line":1}},{"line":103,"address":[3515356,3515293],"length":1,"stats":{"Line":0}},{"line":104,"address":[3515362,3515408],"length":1,"stats":{"Line":2}},{"line":105,"address":[5241653],"length":1,"stats":{"Line":1}},{"line":107,"address":[3515379,3515473],"length":1,"stats":{"Line":0}},{"line":112,"address":[3515700],"length":1,"stats":{"Line":0}},{"line":116,"address":[5235340],"length":1,"stats":{"Line":1}}],"covered":39,"coverable":47},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","predule.rs"],"content":"pub use super::context::*;\npub use super::implements::*;\npub use super::parser::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","alter_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::alter_database::{\n    AlterDatabaseAction, AlterDatabaseQuery, AlterDatabaseRenameTo,\n};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn alter_database_1() {\n    let text = r#\"\n        ALTER DATABASE foo RENAME TO bar;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterDatabaseQuery::builder()\n        .set_name(\"foo\".to_owned())\n        .set_action(AlterDatabaseAction::RenameTo(AlterDatabaseRenameTo {\n            name: \"bar\".into(),\n        }))\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_database_2() {\n    let text = r#\"\n        ALTER DATABASE foo;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterDatabaseQuery::builder()\n        .set_name(\"foo\".to_owned())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","alter_table.rs"],"content":"#![cfg(test)]\n\nuse crate::{\n    ast::{\n        ddl::alter_table::{\n            AlterColumnDropDefault, AlterColumnDropNotNull, AlterColumnSetDefault,\n            AlterColumnSetNotNull, AlterColumnSetType, AlterTableAddColumn, AlterTableAlterColumn,\n            AlterTableDropColumn, AlterTableQuery, AlterTableRenameColumn, AlterTableRenameTo,\n        },\n        types::{Column, DataType, SQLExpression, TableName},\n    },\n    parser::predule::{Parser, ParserContext},\n};\n\n#[test]\npub fn alter_table_rename_1() {\n    let text = r#\"\n        ALTER TABLE foo RENAME TO bar;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(AlterTableRenameTo { name: \"bar\".into() }.into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_add_column_1() {\n    let text = r#\"\n        ALTER TABLE foo ADD COLUMN name varchar(100);\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAddColumn {\n                column: Column::builder()\n                    .set_name(\"name\".to_owned())\n                    .set_data_type(DataType::Varchar(100))\n                    .build(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_add_column_2() {\n    let text = r#\"\n        ALTER TABLE foo ADD name varchar(100);\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAddColumn {\n                column: Column::builder()\n                    .set_name(\"name\".to_owned())\n                    .set_data_type(DataType::Varchar(100))\n                    .build(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_rename_column_1() {\n    let text = r#\"\n        ALTER TABLE foo RENAME COLUMN name TO name_1;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableRenameColumn {\n                from_name: \"name\".into(),\n                to_name: \"name_1\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_rename_column_2() {\n    let text = r#\"\n        ALTER TABLE foo RENAME name TO name_1;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableRenameColumn {\n                from_name: \"name\".into(),\n                to_name: \"name_1\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_drop_not_null_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name DROP NOT NULL;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnDropNotNull {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_not_null_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name SET NOT NULL;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetNotNull {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_type_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name TYPE int;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetType {\n                    data_type: DataType::Int,\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_type_2() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name SET DATA TYPE int;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetType {\n                    data_type: DataType::Int,\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_default_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN id SET DEFAULT 0;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"id\".into(),\n                action: AlterColumnSetDefault {\n                    expression: SQLExpression::Integer(0),\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_drop_default_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN id DROP DEFAULT;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"id\".into(),\n                action: AlterColumnDropDefault {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_drop_column_1() {\n    let text = r#\"\n        ALTER TABLE foo DROP COLUMN name;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableDropColumn {\n                column_name: \"name\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_drop_column_2() {\n    let text = r#\"\n        ALTER TABLE foo DROP name;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableDropColumn {\n                column_name: \"name\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","create_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn create_database_1() {\n    let text = r#\"\n        CREATE DATABASE IF Not exists test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_not_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn create_database_2() {\n    let text = r#\"\n        CREATE DATABASE test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_not_exists(false)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","create_table.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::ast::types::{Column, DataType, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn create_table() {\n    let text = r#\"\n        CREATE TABLE \"test_db\".person\n        (\n            id INTEGER PRIMARY KEY,\n            name varchar(100),\n            age INTEGER\n        );\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateTableQuery::builder()\n        .set_table(TableName::new(\n            Some(\"test_db\".to_owned()),\n            \"person\".to_owned(),\n        ))\n        .add_column(\n            Column::builder()\n                .set_name(\"id\".to_owned())\n                .set_data_type(DataType::Int)\n                .set_primary_key(true)\n                .build(),\n        )\n        .add_column(\n            Column::builder()\n                .set_name(\"name\".to_owned())\n                .set_data_type(DataType::Varchar(100))\n                .build(),\n        )\n        .add_column(\n            Column::builder()\n                .set_name(\"age\".to_owned())\n                .set_data_type(DataType::Int)\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","delete.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::delete::DeleteQuery;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::lexer::predule::OperatorToken;\nuse crate::lexer::tokens::Token;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn test_delete_query() {\n    struct TestCase {\n        name: String,\n        input: Vec\u003cToken\u003e,\n        expected: DeleteQuery,\n        want_error: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"성공: delete from foo.bar\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"성공: DELETE FROM foo.bar WHERE name = 'asdf'\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n                Token::Where,\n                Token::Identifier(\"name\".into()),\n                Token::Operator(OperatorToken::Eq),\n                Token::String(\"asdf\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_where(WhereClause {\n                    expression: BinaryOperatorExpression {\n                        operator: BinaryOperator::Eq,\n                        lhs: SelectColumn::new(None, \"name\".into()).into(),\n                        rhs: SQLExpression::String(\"asdf\".into()),\n                    }\n                    .into(),\n                })\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"성공: DELETE FROM foo.bar as f\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n                Token::As,\n                Token::Identifier(\"f\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_from_alias(\"f\".into())\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"실패: 토큰이 하나도 없음\".into(),\n            input: vec![],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE가 아님\".into(),\n            input: vec![Token::Select],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE밖에 없음\".into(),\n            input: vec![Token::Delete],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE INTO\".into(),\n            input: vec![Token::Delete, Token::Into],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE FROM\".into(),\n            input: vec![Token::Delete, Token::From],\n            expected: Default::default(),\n            want_error: true,\n        },\n    ];\n\n    for t in test_cases {\n        let mut parser = Parser::new(t.input);\n\n        let got = parser.handle_delete_query(Default::default());\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(statements) = got {\n            assert_eq!(statements, t.expected.into(), \"TC: {}\", t.name);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","drop_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::drop_database::DropDatabaseQuery;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn drop_database() {\n    let text = r#\"\n        DROP DATABASE IF exists test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DropDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","drop_table.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::ast::types::TableName;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn drop_table() {\n    let text = r#\"\n        drop table if exists \"foo_db\".foo;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DropTableQuery::builder()\n        .set_table(TableName::new(Some(\"foo_db\".to_owned()), \"foo\".to_owned()))\n        .set_if_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","expressions.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::between::BetweenExpression;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::call::CallExpression;\nuse crate::ast::dml::expressions::list::ListExpression;\nuse crate::ast::dml::expressions::not_between::NotBetweenExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::dml::expressions::parentheses::ParenthesesExpression;\nuse crate::ast::dml::expressions::unary::UnaryOperatorExpression;\nuse crate::ast::dml::parts::select_item::SelectItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{ConditionalFunction, SQLExpression, UserDefinedFunction};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn unary_expression_1() {\n    let text = r#\"\n        SELECT Not TRUE AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    UnaryOperatorExpression {\n                        operator: UnaryOperator::Not,\n                        operand: SQLExpression::Boolean(true),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn unary_expression_2() {\n    let text = r#\"\n        SELECT !TRUE AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    UnaryOperatorExpression {\n                        operator: UnaryOperator::Not,\n                        operand: SQLExpression::Boolean(true),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_1() {\n    let text = r#\"\n        SELECT 3 + 5 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: SQLExpression::Integer(3),\n                        rhs: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_2() {\n    let text = r#\"\n        SELECT 1 + 2 + 3 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: SQLExpression::Integer(2),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(3),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_3() {\n    let text = r#\"\n        SELECT 1 + 2 * 3 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Mul,\n                            lhs: SQLExpression::Integer(2),\n                            rhs: SQLExpression::Integer(3),\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_4() {\n    let text = r#\"\n        SELECT 1 + 2 * 3 + 4 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: BinaryOperatorExpression {\n                                operator: BinaryOperator::Mul,\n                                lhs: SQLExpression::Integer(2),\n                                rhs: SQLExpression::Integer(3),\n                            }\n                            .into(),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(4),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_5() {\n    let text = r#\"\n        SELECT 2 * (3 + 5) AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Mul,\n                        lhs: SQLExpression::Integer(2),\n                        rhs: SQLExpression::Binary(\n                            BinaryOperatorExpression {\n                                operator: BinaryOperator::Add,\n                                lhs: SQLExpression::Integer(3),\n                                rhs: SQLExpression::Integer(5),\n                            }\n                            .into(),\n                        ),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_6() {\n    let text = r#\"\n        SELECT -2 * 5 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Mul,\n                        lhs: UnaryOperatorExpression {\n                            operator: UnaryOperator::Neg,\n                            operand: SQLExpression::Integer(2),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn function_call_expression_1() {\n    let text = r#\"\n        SELECT foobar(null, 1) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    CallExpression {\n                        function: UserDefinedFunction {\n                            database_name: None,\n                            function_name: \"foobar\".into(),\n                        }\n                        .into(),\n                        arguments: vec![SQLExpression::Null, SQLExpression::Integer(1)],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn function_call_expression_2() {\n    let text = r#\"\n        SELECT coalesce(null, 1) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    CallExpression {\n                        function: ConditionalFunction::Coalesce.into(),\n                        arguments: vec![SQLExpression::Null, SQLExpression::Integer(1)],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_1() {\n    let text = r#\"\n        SELECT 3 between 1 and 5 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_2() {\n    let text = r#\"\n        SELECT 3 between 1 and 5 + 1 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(5),\n                            rhs: SQLExpression::Integer(1),\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_3() {\n    let text = r#\"\n        SELECT 3 between 1 + 1 and 99 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: SQLExpression::Integer(1),\n                        }\n                        .into(),\n                        y: SQLExpression::Integer(99),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn not_between_expression_1() {\n    let text = r#\"\n        SELECT 3 not between 1 and 5 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    NotBetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn list_expression_1() {\n    let text = r#\"\n        SELECT (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    ListExpression {\n                        value: vec![\n                            SQLExpression::Integer(1),\n                            SQLExpression::Integer(2),\n                            SQLExpression::Integer(3),\n                        ],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn in_expression_1() {\n    let text = r#\"\n        SELECT 1 in (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::In,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: ListExpression {\n                            value: vec![\n                                SQLExpression::Integer(1),\n                                SQLExpression::Integer(2),\n                                SQLExpression::Integer(3),\n                            ],\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn not_in_expression_1() {\n    let text = r#\"\n        SELECT 1 not in (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::NotIn,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: ListExpression {\n                            value: vec![\n                                SQLExpression::Integer(1),\n                                SQLExpression::Integer(2),\n                                SQLExpression::Integer(3),\n                            ],\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn complex_expression_1() {\n    let text = r#\"\n        SELECT 3+(10*2+44)-11 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Sub,\n                        lhs: SQLExpression::Binary(\n                            BinaryOperatorExpression {\n                                operator: BinaryOperator::Add,\n                                lhs: SQLExpression::Integer(3),\n                                rhs: ParenthesesExpression {\n                                    expression: BinaryOperatorExpression {\n                                        operator: BinaryOperator::Add,\n                                        lhs: BinaryOperatorExpression {\n                                            operator: BinaryOperator::Mul,\n                                            lhs: SQLExpression::Integer(10),\n                                            rhs: SQLExpression::Integer(2),\n                                        }\n                                        .into(),\n                                        rhs: SQLExpression::Integer(44),\n                                    }\n                                    .into(),\n                                }\n                                .into(),\n                            }\n                            .into(),\n                        ),\n                        rhs: SQLExpression::Integer(11),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","insert.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::insert::InsertQuery;\nuse crate::ast::dml::parts::insert_values::InsertValue;\nuse crate::ast::dml::parts::select_item::SelectItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn insert_into_values_1() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![InsertValue {\n            list: vec![\n                Some(SQLExpression::Integer(1)),\n                Some(SQLExpression::Integer(2)),\n                Some(SQLExpression::Integer(3)),\n            ],\n        }])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_values_2() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3), (4, 5, 6)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(1)),\n                    Some(SQLExpression::Integer(2)),\n                    Some(SQLExpression::Integer(3)),\n                ],\n            },\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(4)),\n                    Some(SQLExpression::Integer(5)),\n                    Some(SQLExpression::Integer(6)),\n                ],\n            },\n        ])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_values_3() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3), (4, 5, DEFAULT)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(1)),\n                    Some(SQLExpression::Integer(2)),\n                    Some(SQLExpression::Integer(3)),\n                ],\n            },\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(4)),\n                    Some(SQLExpression::Integer(5)),\n                    None,\n                ],\n            },\n        ])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_select_1() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Select s.a, s.b, s.c from boom.some as s\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_select(\n            SelectQuery::builder()\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"a\".into()).into())\n                        .build(),\n                )\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"b\".into()).into())\n                        .build(),\n                )\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"c\".into()).into())\n                        .build(),\n                )\n                .set_from_table(TableName {\n                    database_name: Some(\"boom\".into()),\n                    table_name: \"some\".into(),\n                })\n                .set_from_alias(\"s\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","mod.rs"],"content":"pub(crate) mod alter_database;\npub(crate) mod create_database;\npub(crate) mod drop_database;\n\npub(crate) mod alter_table;\npub(crate) mod create_table;\npub(crate) mod drop_table;\npub(crate) mod expressions;\n\npub(crate) mod delete;\npub(crate) mod insert;\npub(crate) mod select;\npub(crate) mod update;\n\npub(crate) mod other;\n\npub(crate) mod tcl;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","other.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::other::desc_table::DescTableQuery;\nuse crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::ast::other::use_database::UseDatabaseQuery;\nuse crate::ast::types::TableName;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn show_databases_1() {\n    let text = r#\"\n        Show Databases\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowDatabasesQuery {};\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn show_databases_2() {\n    let text = r#\"\n        \\l\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowDatabasesQuery {};\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn use_databases_1() {\n    let text = r#\"\n        Use asdf;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UseDatabaseQuery {\n        database_name: \"asdf\".into(),\n    };\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn desc_table_1() {\n    let text = r#\"\n        desc asdf;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DescTableQuery {\n        table_name: TableName {\n            database_name: None,\n            table_name: \"asdf\".into(),\n        },\n    };\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn show_tables_1() {\n    let text = r#\"\n        show tables;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowTablesQuery {\n        database: \"rrdb\".into(),\n    };\n\n    assert_eq!(\n        parser\n            .parse(ParserContext::default().set_default_database(\"rrdb\".into()))\n            .unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","select.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::group_by::GroupByItem;\nuse crate::ast::dml::parts::having::HavingClause;\nuse crate::ast::dml::parts::join::{JoinClause, JoinType};\nuse crate::ast::dml::parts::order_by::{OrderByItem, OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectWildCard};\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn select_from_1() {\n    let text = r#\"\n        SELECT 1 as asdf\n        FROM foo.bar\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SQLExpression::Integer(1))\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_2() {\n    let text = r#\"\n        SELECT 1 as asdf\n        FROM foo.bar as boom\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SQLExpression::Integer(1))\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_from_alias(\"boom\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_3() {\n    let text = r#\"\n        SELECT boom.number as number\n        FROM (\n            select 1 as number\n            from foo.bar as temp\n        ) as boom\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"boom\".into()), \"number\".into()).into())\n                .set_alias(\"number\".into())\n                .build(),\n        )\n        .set_from_subquery(\n            SelectQuery::builder()\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SQLExpression::Integer(1))\n                        .set_alias(\"number\".into())\n                        .build(),\n                )\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_from_alias(\"temp\".into())\n                .build()\n                .into(),\n        )\n        .set_from_alias(\"boom\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_4() {\n    let text = r#\"\n        SELECT *\n        FROM foo.bar\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_wildcard(SelectWildCard { alias: None })\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_inner_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        INNER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::InnerJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_inner_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::InnerJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_left_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        LEFT JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::LeftOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_left_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        LEFT OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::LeftOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_right_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        RIGHT JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::RightOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_right_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        RIGHT OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::RightOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_full_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        FULL JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::FullOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_full_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        FULL OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::FullOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_where_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        where p.user_id = 1\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_where(WhereClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n                rhs: SQLExpression::Integer(1),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id ASC\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id ASC, p.id DESC\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n            order_type: OrderByType::Desc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_3() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id NULLS FIRST\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_4() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id NULLS LAST\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::Last,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_group_by_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_group_by_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content, p.user_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn error_select_group_by_1() {\n    let text = r#\"\n        SELECT \n            COUNT(p.a),\n            p.b,\n            p.c\n        FROM post as p\n        GROUP BY p.b\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    assert!(parser.parse(ParserContext::default()).is_err());\n}\n\n#[test]\npub fn select_group_by_having_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content\n        HAVING p.content = 'FOO'\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .set_having(HavingClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"content\".into()).into(),\n                rhs: SQLExpression::String(\"FOO\".into()),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_offset_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        OFFSET 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_limit_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        LIMIT 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_limit(5)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_offset_limit_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        OFFSET 5\n        LIMIT 10\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .set_limit(10)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_limit_offset_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        LIMIT 10\n        OFFSET 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .set_limit(10)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_subquery_1() {\n    let text = r#\"\n        SELECT \n            ff.number as number,\n            (\n                select 1 as number\n                from foo.bar as temp\n                limit 1\n            ) as asdf\n        FROM foo.foo as ff\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"ff\".into()), \"number\".into()).into())\n                .set_alias(\"number\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    SelectQuery::builder()\n                        .add_select_item(\n                            SelectItem::builder()\n                                .set_item(SQLExpression::Integer(1))\n                                .set_alias(\"number\".into())\n                                .build(),\n                        )\n                        .set_from_table(TableName {\n                            database_name: Some(\"foo\".into()),\n                            table_name: \"bar\".into(),\n                        })\n                        .set_from_alias(\"temp\".into())\n                        .set_limit(1)\n                        .build()\n                        .into(),\n                )\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"foo\".into(),\n        })\n        .set_from_alias(\"ff\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","tcl.rs"],"content":"#![cfg(test)]\n\nuse crate::{\n    ast::{\n        tcl::{BeginTransactionQuery, CommitQuery, RollbackQuery},\n        SQLStatement,\n    },\n    parser::predule::{Parser, ParserContext},\n};\n\n#[test]\npub fn begin_transaction() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"정상적인 트랜잭션 시작\".to_owned(),\n            input: \"BEGIN TRANSACTION;\".to_owned(),\n            expected: BeginTransactionQuery {}.into(),\n            want_err: false,\n        },\n        TestCase {\n            name: \"begin만 있는 경우\".to_owned(),\n            input: \"BEGIN;\".to_owned(),\n            expected: Default::default(),\n            want_err: true,\n        },\n        TestCase {\n            name: \"begin 이후에 기대하지 않은 입력이 있는 경우\".to_owned(),\n            input: \"BEGIN TRANSITION;\".to_owned(),\n            expected: Default::default(),\n            want_err: true,\n        },\n    ];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n\n#[test]\npub fn commit() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"정상적인 Commit 명령\".to_owned(),\n        input: \"COMMIT;\".to_owned(),\n        expected: CommitQuery {}.into(),\n        want_err: false,\n    }];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n\n#[test]\npub fn rollback() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"정상적인 ROLLBACK 명령\".to_owned(),\n        input: \"ROLLBACK;\".to_owned(),\n        expected: RollbackQuery {}.into(),\n        want_err: false,\n    }];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","update.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::update_item::UpdateItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn update_set_1() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn update_set_2() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1,\n            b = 2\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .add_update_item(UpdateItem {\n            column: \"b\".into(),\n            value: SQLExpression::Integer(2),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn update_set_where_1() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1\n        where a = 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .set_where(WhereClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(None, \"a\".into()).into(),\n                rhs: SQLExpression::Integer(5),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","bound_portal.rs"],"content":"use crate::pgwire::{engine::Engine, protocol::backend::RowDescription};\n\npub struct BoundPortal\u003cE: Engine\u003e {\n    pub portal: E::PortalType,\n    pub row_desc: RowDescription,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","connection.rs"],"content":"//! Contains the [Connection] struct, which represents an individual Postgres session, and related types.\n\nuse futures::{SinkExt, StreamExt};\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::io::{AsyncRead, AsyncWrite};\nuse tokio_util::codec::Framed;\n\nuse crate::{\n    ast::{OtherStatement, SQLStatement},\n    executor::{config::global::GlobalConfig, executor::Executor},\n    lexer::predule::Tokenizer,\n    logger::predule::Logger,\n    parser::{context::ParserContext, predule::Parser},\n    pgwire::{\n        connection::{BoundPortal, ConnectionError, ConnectionState, PreparedStatement},\n        engine::{Engine, Portal, RRDBEngine},\n        protocol::{\n            backend::{\n                AuthenticationOk, BindComplete, CommandComplete, EmptyQueryResponse, ErrorResponse,\n                NoData, ParameterDescription, ParameterStatus, ParseComplete, ReadyForQuery,\n                RowDescription,\n            },\n            client::{BindFormat, ClientMessage, Describe},\n            ConnectionCodec, DataRowBatch, FormatCode, Severity, SqlState,\n        },\n    },\n    server::predule::SharedState,\n};\n\n/// Describes a connection using a specific engine.\n/// Contains connection state including prepared statements and portals.\npub struct Connection {\n    engine: RRDBEngine,\n    state: ConnectionState,\n    statements: HashMap\u003cString, PreparedStatement\u003e,\n    portals: HashMap\u003cString, Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e\u003e,\n    config: Arc\u003cGlobalConfig\u003e,\n}\n\nimpl Connection {\n    /// Create a new connection from an engine instance.\n    pub fn new(shared_state: SharedState, config: Arc\u003cGlobalConfig\u003e) -\u003e Self {\n        Self {\n            state: ConnectionState::Startup,\n            statements: HashMap::new(),\n            portals: HashMap::new(),\n            engine: RRDBEngine {\n                shared_state,\n                portal: None,\n            },\n            config,\n        }\n    }\n\n    fn prepared_statement(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026PreparedStatement, ConnectionError\u003e {\n        Ok(self.statements.get(name).ok_or_else(|| {\n            ErrorResponse::error(SqlState::INVALID_SQL_STATEMENT_NAME, \"missing statement\")\n        })?)\n    }\n\n    fn portal(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e, ConnectionError\u003e {\n        Ok(self\n            .portals\n            .get(name)\n            .ok_or_else(|| ErrorResponse::error(SqlState::INVALID_CURSOR_NAME, \"missing portal\"))?)\n    }\n\n    fn portal_mut(\n        \u0026mut self,\n        name: \u0026str,\n    ) -\u003e Result\u003c\u0026mut Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e, ConnectionError\u003e {\n        Ok(self\n            .portals\n            .get_mut(name)\n            .ok_or_else(|| ErrorResponse::error(SqlState::INVALID_CURSOR_NAME, \"missing portal\"))?)\n    }\n\n    fn parse_statement(\u0026mut self, text: \u0026str) -\u003e Result\u003cOption\u003cSQLStatement\u003e, ErrorResponse\u003e {\n        let tokens = match Tokenizer::string_to_tokens(text.into()) {\n            Ok(tokens) =\u003e tokens,\n            Err(e) =\u003e {\n                return Err(ErrorResponse::error(SqlState::SYNTAX_ERROR, e.to_string()));\n            }\n        };\n\n        let mut parser = Parser::new(tokens);\n\n        let statements = parser\n            .parse(\n                ParserContext::default()\n                    .set_default_database(self.engine.shared_state.client_info.database.clone()),\n            )\n            .map_err(|e| ErrorResponse::error(SqlState::SYNTAX_ERROR, e.to_string()))?;\n\n        match statements.len() {\n            0 =\u003e Ok(None),\n            1 =\u003e Ok(Some(statements[0].clone())),\n            _ =\u003e Err(ErrorResponse::error(\n                SqlState::SYNTAX_ERROR,\n                \"expected zero or one statements\",\n            )),\n        }\n    }\n\n    async fn step(\n        \u0026mut self,\n        framed: \u0026mut Framed\u003cimpl AsyncRead + AsyncWrite + Unpin, ConnectionCodec\u003e,\n    ) -\u003e Result\u003cOption\u003cConnectionState\u003e, ConnectionError\u003e {\n        match self.state {\n            ConnectionState::Startup =\u003e {\n                match framed\n                    .next()\n                    .await\n                    .ok_or(ConnectionError::ConnectionClosed)??\n                {\n                    ClientMessage::Startup(startup) =\u003e {\n                        if let Some(database_name) = startup.parameters.get(\"database\") {\n                            // 해당 데이터베이스가 존재하는지 검사\n                            let executor = Executor::new(self.config.clone());\n                            let result = executor.find_database(database_name.clone()).await;\n\n                            match result {\n                                Ok(has_match) =\u003e {\n                                    if has_match {\n                                        self.engine.shared_state.client_info.database =\n                                            database_name.to_owned();\n\n                                        Logger::info(format!(\n                                            \"New Connection=\u003e UUID:{} IP:{} DATABASE:{}\",\n                                            self.engine.shared_state.client_info.connection_id,\n                                            self.engine.shared_state.client_info.ip,\n                                            self.engine.shared_state.client_info.database\n                                        ));\n                                    } else {\n                                        return Err(ErrorResponse::fatal(\n                                            SqlState::CONNECTION_EXCEPTION,\n                                            format!(\"No database named '{}'\", database_name),\n                                        )\n                                        .into());\n                                    }\n                                }\n                                Err(error) =\u003e {\n                                    return Err(ErrorResponse::fatal(\n                                        SqlState::CONNECTION_EXCEPTION,\n                                        format!(\"{:?}\", error),\n                                    )\n                                    .into());\n                                }\n                            }\n                        }\n                    }\n                    ClientMessage::SSLRequest =\u003e {\n                        // we don't support SSL for now\n                        // client will retry with startup packet\n                        framed.send('N').await?;\n                        return Ok(Some(ConnectionState::Startup));\n                    }\n                    _ =\u003e {\n                        return Err(ErrorResponse::fatal(\n                            SqlState::PROTOCOL_VIOLATION,\n                            \"expected startup message\",\n                        )\n                        .into());\n                    }\n                }\n\n                framed.send(AuthenticationOk).await?;\n\n                let param_statuses = \u0026[\n                    (\"server_version\", \"13\"),\n                    (\"server_encoding\", \"UTF8\"),\n                    (\"client_encoding\", \"UTF8\"),\n                    (\"DateStyle\", \"ISO\"),\n                    (\"TimeZone\", \"UTC\"),\n                    (\"integer_datetimes\", \"on\"),\n                ];\n\n                for \u0026(param, status) in param_statuses {\n                    framed.send(ParameterStatus::new(param, status)).await?;\n                }\n\n                framed.send(ReadyForQuery).await?;\n                Ok(Some(ConnectionState::Idle))\n            }\n            ConnectionState::Idle =\u003e {\n                match framed\n                    .next()\n                    .await\n                    .ok_or(ConnectionError::ConnectionClosed)??\n                {\n                    ClientMessage::Parse(parse) =\u003e {\n                        let parsed_statement = self.parse_statement(\u0026parse.query)?;\n\n                        self.statements.insert(\n                            parse.prepared_statement_name,\n                            PreparedStatement {\n                                fields: match \u0026parsed_statement {\n                                    Some(statement) =\u003e self.engine.prepare(statement).await?,\n                                    None =\u003e vec![],\n                                },\n                                statement: parsed_statement,\n                            },\n                        );\n                        framed.send(ParseComplete).await?;\n                    }\n                    ClientMessage::Bind(bind) =\u003e {\n                        let format_code = match bind.result_format {\n                            BindFormat::All(format) =\u003e format,\n                            BindFormat::PerColumn(_) =\u003e {\n                                return Err(ErrorResponse::error(\n                                    SqlState::FEATURE_NOT_SUPPORTED,\n                                    \"per-column format codes not supported\",\n                                )\n                                .into());\n                            }\n                        };\n\n                        let prepared = self\n                            .prepared_statement(\u0026bind.prepared_statement_name)?\n                            .clone();\n\n                        let portal = match prepared.statement {\n                            Some(statement) =\u003e {\n                                let portal = self.engine.create_portal(\u0026statement).await?;\n                                let row_desc = RowDescription {\n                                    fields: prepared.fields.clone(),\n                                    format_code,\n                                };\n\n                                Some(BoundPortal { portal, row_desc })\n                            }\n                            None =\u003e None,\n                        };\n\n                        self.portals.insert(bind.portal, portal);\n\n                        framed.send(BindComplete).await?;\n                    }\n                    ClientMessage::Describe(Describe::PreparedStatement(ref statement_name)) =\u003e {\n                        let fields = self.prepared_statement(statement_name)?.fields.clone();\n                        framed.send(ParameterDescription {}).await?;\n                        framed\n                            .send(RowDescription {\n                                fields,\n                                format_code: FormatCode::Text,\n                            })\n                            .await?;\n                    }\n                    ClientMessage::Describe(Describe::Portal(ref portal_name)) =\u003e {\n                        match self.portal(portal_name)? {\n                            Some(portal) =\u003e framed.send(portal.row_desc.clone()).await?,\n                            None =\u003e framed.send(NoData).await?,\n                        }\n                    }\n                    ClientMessage::Sync =\u003e {\n                        framed.send(ReadyForQuery).await?;\n                    }\n                    ClientMessage::Execute(exec) =\u003e match self.portal_mut(\u0026exec.portal)? {\n                        Some(bound) =\u003e {\n                            let mut batch_writer = DataRowBatch::from_row_desc(\u0026bound.row_desc);\n                            bound.portal.fetch(\u0026mut batch_writer).await?;\n                            let num_rows = batch_writer.num_rows();\n\n                            framed.send(batch_writer).await?;\n\n                            framed\n                                .send(CommandComplete {\n                                    command_tag: format!(\"SELECT {}\", num_rows),\n                                })\n                                .await?;\n                        }\n                        None =\u003e {\n                            framed.send(EmptyQueryResponse).await?;\n                        }\n                    },\n                    ClientMessage::Query(query) =\u003e {\n                        if let Some(parsed) = self.parse_statement(\u0026query)? {\n                            let fields = self.engine.prepare(\u0026parsed).await?;\n                            let row_desc = RowDescription {\n                                fields,\n                                format_code: FormatCode::Text,\n                            };\n                            let mut portal = self.engine.create_portal(\u0026parsed).await?;\n\n                            let mut batch_writer = DataRowBatch::from_row_desc(\u0026row_desc);\n                            portal.fetch(\u0026mut batch_writer).await?;\n                            let num_rows = batch_writer.num_rows();\n\n                            if let SQLStatement::Other(OtherStatement::UseDatabase(query)) = parsed\n                            {\n                                self.engine.shared_state.client_info.database = query.database_name;\n                            }\n\n                            framed.send(row_desc).await?;\n                            framed.send(batch_writer).await?;\n\n                            framed\n                                .send(CommandComplete {\n                                    command_tag: format!(\"SELECT {}\", num_rows),\n                                })\n                                .await?;\n                        } else {\n                            framed.send(EmptyQueryResponse).await?;\n                        }\n                        framed.send(ReadyForQuery).await?;\n                    }\n                    ClientMessage::Terminate =\u003e {\n                        return Ok(None);\n                    }\n                    _ =\u003e {\n                        return Err(ErrorResponse::error(\n                            SqlState::PROTOCOL_VIOLATION,\n                            \"unexpected message\",\n                        )\n                        .into())\n                    }\n                };\n\n                Ok(Some(ConnectionState::Idle))\n            }\n        }\n    }\n\n    /// Given a stream (typically TCP), extract Postgres protocol messages and respond accordingly.\n    /// This function only returns when the connection is closed (either gracefully or due to an error).\n    pub async fn run(\n        \u0026mut self,\n        stream: impl AsyncRead + AsyncWrite + Unpin,\n    ) -\u003e Result\u003c(), ConnectionError\u003e {\n        let mut framed = Framed::new(stream, ConnectionCodec::new());\n\n        loop {\n            let new_state = match self.step(\u0026mut framed).await {\n                Ok(Some(state)) =\u003e state,\n                Ok(None) =\u003e {\n                    return Ok(());\n                }\n                Err(ConnectionError::ErrorResponse(err_info)) =\u003e {\n                    framed.send(err_info.clone()).await?;\n\n                    if err_info.severity == Severity::FATAL {\n                        return Err(err_info.into());\n                    }\n\n                    framed.send(ReadyForQuery).await?;\n                    ConnectionState::Idle\n                }\n                Err(err) =\u003e {\n                    framed\n                        .send(ErrorResponse::fatal(\n                            SqlState::CONNECTION_EXCEPTION,\n                            \"connection error\",\n                        ))\n                        .await?;\n                    return Err(err);\n                }\n            };\n\n            self.state = new_state;\n        }\n    }\n}\n","traces":[{"line":42,"address":[2856416,2856790,2856769],"length":1,"stats":{"Line":0}},{"line":45,"address":[2856453],"length":1,"stats":{"Line":0}},{"line":46,"address":[2856502],"length":1,"stats":{"Line":0}},{"line":47,"address":[2856584],"length":1,"stats":{"Line":0}},{"line":55,"address":[2856816],"length":1,"stats":{"Line":0}},{"line":56,"address":[2857033,2856896],"length":1,"stats":{"Line":0}},{"line":57,"address":[1560540],"length":1,"stats":{"Line":0}},{"line":61,"address":[2857072],"length":1,"stats":{"Line":0}},{"line":62,"address":[2857289,2857152],"length":1,"stats":{"Line":0}},{"line":65,"address":[2857261],"length":1,"stats":{"Line":0}},{"line":68,"address":[2857328],"length":1,"stats":{"Line":0}},{"line":72,"address":[2857408,2857545],"length":1,"stats":{"Line":0}},{"line":75,"address":[2857517],"length":1,"stats":{"Line":0}},{"line":78,"address":[2858812,2857584,2858864],"length":1,"stats":{"Line":0}},{"line":79,"address":[2857656],"length":1,"stats":{"Line":0}},{"line":80,"address":[2857734],"length":1,"stats":{"Line":0}},{"line":81,"address":[2857854],"length":1,"stats":{"Line":0}},{"line":82,"address":[2857941,2858926],"length":1,"stats":{"Line":0}},{"line":86,"address":[2857794],"length":1,"stats":{"Line":0}},{"line":88,"address":[2858433,2858189],"length":1,"stats":{"Line":0}},{"line":90,"address":[2858000,2858118],"length":1,"stats":{"Line":0}},{"line":91,"address":[2858049,2858854,2858157],"length":1,"stats":{"Line":0}},{"line":93,"address":[2858369],"length":1,"stats":{"Line":0}},{"line":95,"address":[2858349,2858503],"length":1,"stats":{"Line":0}},{"line":96,"address":[2858571],"length":1,"stats":{"Line":0}},{"line":97,"address":[2858609,2858668],"length":1,"stats":{"Line":0}},{"line":98,"address":[2858731,2858523],"length":1,"stats":{"Line":0}},{"line":105,"address":[1560848],"length":1,"stats":{"Line":0}},{"line":109,"address":[1561035,1561368],"length":1,"stats":{"Line":0}},{"line":111,"address":[1564192,1562019,1562891,1564170,1562647,1562466,1562588,1563249,1562155],"length":1,"stats":{"Line":0}},{"line":113,"address":[1562413,1562132,1562611,1562170,1561439],"length":1,"stats":{"Line":0}},{"line":114,"address":[1562823,1563196,1562556],"length":1,"stats":{"Line":0}},{"line":116,"address":[1563370],"length":1,"stats":{"Line":0}},{"line":117,"address":[1563457,1563714],"length":1,"stats":{"Line":0}},{"line":119,"address":[1563844,1563774],"length":1,"stats":{"Line":0}},{"line":120,"address":[1561460,1563866,1564194,1563989],"length":1,"stats":{"Line":0}},{"line":122,"address":[1564452],"length":1,"stats":{"Line":0}},{"line":123,"address":[1564478],"length":1,"stats":{"Line":0}},{"line":124,"address":[1564497],"length":1,"stats":{"Line":0}},{"line":125,"address":[1565060,1564952],"length":1,"stats":{"Line":0}},{"line":126,"address":[1564726,1565033],"length":1,"stats":{"Line":0}},{"line":128,"address":[1565398,1565204,1565301,1565111],"length":1,"stats":{"Line":0}},{"line":135,"address":[1564836],"length":1,"stats":{"Line":0}},{"line":137,"address":[1564763,1564632],"length":1,"stats":{"Line":0}},{"line":142,"address":[1564507],"length":1,"stats":{"Line":0}},{"line":143,"address":[1565915],"length":1,"stats":{"Line":0}},{"line":145,"address":[1565842],"length":1,"stats":{"Line":0}},{"line":155,"address":[1563566,1561481,1563325,1566381,1566104],"length":1,"stats":{"Line":0}},{"line":156,"address":[1566320],"length":1,"stats":{"Line":0}},{"line":159,"address":[1563282,1564087],"length":1,"stats":{"Line":0}},{"line":167,"address":[1565576,1566927,1561502,1566673,1567076,1565700],"length":1,"stats":{"Line":0}},{"line":169,"address":[1566889],"length":1,"stats":{"Line":0}},{"line":178,"address":[1567500,1567574,1567021,1567406,1566904],"length":1,"stats":{"Line":0}},{"line":179,"address":[1561523,1567081,1567637,1567113,1567813,1567411],"length":1,"stats":{"Line":0}},{"line":182,"address":[1567690,1567537,1561544,1567894,1568171],"length":1,"stats":{"Line":0}},{"line":183,"address":[1568110],"length":1,"stats":{"Line":0}},{"line":186,"address":[1575320,1569146,1568496,1568740,1568437,1569394,1575253,1562049,1562323,1568315],"length":1,"stats":{"Line":0}},{"line":188,"address":[1561565,1562300,1562338,1568262,1568460],"length":1,"stats":{"Line":0}},{"line":189,"address":[1569093,1568405,1568672],"length":1,"stats":{"Line":0}},{"line":191,"address":[1569222],"length":1,"stats":{"Line":0}},{"line":192,"address":[1570802,1569937,1570266,1569338],"length":1,"stats":{"Line":0}},{"line":194,"address":[1570080,1570627],"length":1,"stats":{"Line":0}},{"line":195,"address":[1570117],"length":1,"stats":{"Line":0}},{"line":196,"address":[1570585],"length":1,"stats":{"Line":0}},{"line":197,"address":[1570205],"length":1,"stats":{"Line":0}},{"line":198,"address":[1570706,1561586,1575322,1570386],"length":1,"stats":{"Line":0}},{"line":199,"address":[1570371,1570483],"length":1,"stats":{"Line":0}},{"line":201,"address":[1570485],"length":1,"stats":{"Line":0}},{"line":204,"address":[1561607,1575907,1576747,1576204,1576461],"length":1,"stats":{"Line":0}},{"line":206,"address":[1569421],"length":1,"stats":{"Line":0}},{"line":207,"address":[1569495],"length":1,"stats":{"Line":0}},{"line":208,"address":[1572260],"length":1,"stats":{"Line":0}},{"line":210,"address":[1573228,1572351],"length":1,"stats":{"Line":0}},{"line":218,"address":[1573161,1572468,1572298,1572635],"length":1,"stats":{"Line":0}},{"line":219,"address":[1572321,1572571],"length":1,"stats":{"Line":0}},{"line":222,"address":[1572683],"length":1,"stats":{"Line":0}},{"line":223,"address":[1572745],"length":1,"stats":{"Line":0}},{"line":224,"address":[1577738,1572799,1561628,1573065,1577068],"length":1,"stats":{"Line":0}},{"line":226,"address":[1577705],"length":1,"stats":{"Line":0}},{"line":230,"address":[1577930],"length":1,"stats":{"Line":0}},{"line":232,"address":[1572725],"length":1,"stats":{"Line":0}},{"line":235,"address":[1572847,1578354],"length":1,"stats":{"Line":0}},{"line":237,"address":[1578361,1578805,1561649,1578567,1579055],"length":1,"stats":{"Line":0}},{"line":239,"address":[1570917],"length":1,"stats":{"Line":0}},{"line":240,"address":[1570940,1571821,1572238],"length":1,"stats":{"Line":0}},{"line":241,"address":[1561670,1579398,1579757,1572036,1572136,1579923],"length":1,"stats":{"Line":0}},{"line":242,"address":[1579750,1579858,1580064,1580202,1580312,1579618],"length":1,"stats":{"Line":0}},{"line":243,"address":[1579686],"length":1,"stats":{"Line":0}},{"line":244,"address":[1579633],"length":1,"stats":{"Line":0}},{"line":245,"address":[1579678],"length":1,"stats":{"Line":0}},{"line":247,"address":[1561691,1579891,1579851,1580112,1580264,1579951],"length":1,"stats":{"Line":0}},{"line":249,"address":[1570845],"length":1,"stats":{"Line":0}},{"line":250,"address":[1570868,1571104,1571684],"length":1,"stats":{"Line":0}},{"line":251,"address":[1561712,1571395,1571586,1580397,1580695],"length":1,"stats":{"Line":0}},{"line":252,"address":[1571350,1571460,1580786,1561733],"length":1,"stats":{"Line":0}},{"line":255,"address":[1581314],"length":1,"stats":{"Line":0}},{"line":256,"address":[1569546,1561754,1573325,1581319,1581098],"length":1,"stats":{"Line":0}},{"line":258,"address":[1569586,1574208,1573503],"length":1,"stats":{"Line":0}},{"line":259,"address":[1573794],"length":1,"stats":{"Line":0}},{"line":260,"address":[1573998,1573802],"length":1,"stats":{"Line":0}},{"line":261,"address":[1574013,1574112,1561775,1581402,1581758,1582105],"length":1,"stats":{"Line":0}},{"line":262,"address":[1581871,1581711],"length":1,"stats":{"Line":0}},{"line":264,"address":[1561796,1581874,1582133,1582883,1582543],"length":1,"stats":{"Line":0}},{"line":266,"address":[1582753,1582783,1583246,1583001,1582426,1583298,1583139],"length":1,"stats":{"Line":0}},{"line":267,"address":[1582705],"length":1,"stats":{"Line":0}},{"line":268,"address":[1582624,1582449],"length":1,"stats":{"Line":0}},{"line":270,"address":[1561817,1582851,1583049,1583198,1582888,1582776],"length":1,"stats":{"Line":0}},{"line":272,"address":[1583594],"length":1,"stats":{"Line":0}},{"line":273,"address":[1583599,1583378,1573846,1573749,1561838],"length":1,"stats":{"Line":0}},{"line":276,"address":[1569690],"length":1,"stats":{"Line":0}},{"line":277,"address":[1588552,1574306,1569741,1575170,1589474],"length":1,"stats":{"Line":0}},{"line":278,"address":[1574687,1574884,1584246,1584500,1583682,1561859],"length":1,"stats":{"Line":0}},{"line":283,"address":[1585228,1585572,1584573,1561880,1584407,1584198],"length":1,"stats":{"Line":0}},{"line":285,"address":[1585380,1585193],"length":1,"stats":{"Line":0}},{"line":286,"address":[1561901,1585600,1586571,1585395,1585947,1585494],"length":1,"stats":{"Line":0}},{"line":287,"address":[1585906,1586054],"length":1,"stats":{"Line":0}},{"line":289,"address":[1586057,1586237,1586481],"length":1,"stats":{"Line":0}},{"line":291,"address":[1586290,1586430],"length":1,"stats":{"Line":0}},{"line":294,"address":[1587199,1587036,1586151,1586502,1561922,1586599],"length":1,"stats":{"Line":0}},{"line":295,"address":[1561943,1587608,1587204,1587942,1586893,1587130],"length":1,"stats":{"Line":0}},{"line":297,"address":[1588669,1587494,1588057,1587815,1588195,1588315,1587845],"length":1,"stats":{"Line":0}},{"line":298,"address":[1587767],"length":1,"stats":{"Line":0}},{"line":299,"address":[1587689,1587514],"length":1,"stats":{"Line":0}},{"line":301,"address":[1561964,1587913,1588267,1587838,1587947,1588105],"length":1,"stats":{"Line":0}},{"line":303,"address":[1561985,1574735,1589789,1589258,1575068,1589479],"length":1,"stats":{"Line":0}},{"line":305,"address":[1590165,1589705,1590389,1562006,1589592,1589920],"length":1,"stats":{"Line":0}},{"line":308,"address":[1569797],"length":1,"stats":{"Line":0}},{"line":311,"address":[1569179,1575192],"length":1,"stats":{"Line":0}},{"line":319,"address":[1590328],"length":1,"stats":{"Line":0}},{"line":326,"address":[1590832],"length":1,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":150},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","engine_func.rs"],"content":"use std::{pin::Pin, sync::Arc};\n\npub type EngineFunc\u003cE\u003e =\n    Arc\u003cdyn Fn() -\u003e Pin\u003cBox\u003cdyn futures::Future\u003cOutput = E\u003e + Send\u003e\u003e + Send + Sync\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","error","connection_error.rs"],"content":"use crate::pgwire::protocol::{backend::ErrorResponse, ProtocolError};\n\n/// Describes an error that may or may not result in the termination of a connection.\n#[derive(thiserror::Error, Debug)]\npub enum ConnectionError {\n    /// A protocol error was encountered, e.g. an invalid message for a connection's current state.\n    #[error(\"protocol error: {0}\")]\n    Protocol(#[from] ProtocolError),\n    /// A Postgres error containing a SqlState code and message occurred.\n    /// May result in connection termination depending on the severity.\n    #[error(\"error response: {0}\")]\n    ErrorResponse(#[from] ErrorResponse),\n    /// The connection was closed.\n    /// This always implies connection termination.\n    #[error(\"connection closed\")]\n    ConnectionClosed,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","error","mod.rs"],"content":"pub mod connection_error;\npub use connection_error::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","mod.rs"],"content":"pub mod error;\npub use error::*;\n\n#[path = \"./connection.rs\"]\npub mod connection_impl;\npub use connection_impl::*;\n\npub mod state;\npub use state::*;\n\npub mod prepared_statement;\npub use prepared_statement::*;\n\npub mod bound_portal;\npub use bound_portal::*;\n\npub mod engine_func;\npub use engine_func::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","prepared_statement.rs"],"content":"use crate::{ast::SQLStatement, pgwire::protocol::backend::FieldDescription};\n\n#[derive(Debug, Clone)]\npub struct PreparedStatement {\n    pub statement: Option\u003cSQLStatement\u003e,\n    pub fields: Vec\u003cFieldDescription\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","state.rs"],"content":"#[derive(Debug)]\npub enum ConnectionState {\n    Startup,\n    Idle,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","engine.rs"],"content":"use async_trait::async_trait;\n\nuse crate::{\n    ast::SQLStatement,\n    pgwire::protocol::backend::{ErrorResponse, FieldDescription},\n};\n\nuse super::Portal;\n\n/// The engine trait is the core of the `convergence` crate, and is responsible for dispatching most SQL operations.\n///\n/// Each connection is allocated an [Engine] instance, which it uses to prepare statements, create portals, etc.\n#[async_trait]\npub trait Engine: Send + Sync + 'static {\n    /// The [Portal] implementation used by [Engine::create_portal].\n    type PortalType: Portal;\n\n    /// Prepares a statement, returning a vector of field descriptions for the final statement result.\n    async fn prepare(\n        \u0026mut self,\n        statement: \u0026SQLStatement,\n    ) -\u003e Result\u003cVec\u003cFieldDescription\u003e, ErrorResponse\u003e;\n\n    /// Creates a new portal for the given statement.\n    async fn create_portal(\n        \u0026mut self,\n        stmt: \u0026SQLStatement,\n    ) -\u003e Result\u003cSelf::PortalType, ErrorResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","mod.rs"],"content":"#[path = \"./engine.rs\"]\npub mod engine_impl;\npub use engine_impl::*;\n\npub mod portal;\npub use portal::*;\n\npub mod rrdb;\npub use rrdb::*;","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","portal.rs"],"content":"use async_trait::async_trait;\n\nuse crate::pgwire::protocol::{backend::ErrorResponse, DataRowBatch};\n\n/// A Postgres portal. Portals represent a prepared statement with all parameters specified.\n///\n/// See Postgres' protocol docs regarding the [extended query overview](https://www.postgresql.org/docs/current/protocol-overview.html#PROTOCOL-QUERY-CONCEPTS)\n/// for more details.\n#[async_trait]\npub trait Portal: Send + Sync {\n    /// Fetches the contents of the portal into a [DataRowBatch].\n    async fn fetch(\u0026mut self, batch: \u0026mut DataRowBatch) -\u003e Result\u003c(), ErrorResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","rrdb.rs"],"content":"use async_trait::async_trait;\nuse tokio::sync::oneshot;\n\nuse crate::ast::SQLStatement;\nuse crate::executor::predule::ExecuteResult;\nuse crate::executor::result::ExecuteField;\nuse crate::pgwire::engine::{Engine, Portal};\nuse crate::pgwire::protocol::backend::{ErrorResponse, FieldDescription};\nuse crate::pgwire::protocol::{DataRowBatch, SqlState};\nuse crate::server::predule::{ChannelRequest, ChannelResponse, SharedState};\n\n#[derive(Debug, Clone)]\npub struct RRDBPortal {\n    pub shared_state: SharedState,\n    pub execute_result: ExecuteResult,\n}\n\n#[async_trait]\nimpl Portal for RRDBPortal {\n    // 실제 결과 데이터 리스트 전송\n    async fn fetch(\u0026mut self, batch: \u0026mut DataRowBatch) -\u003e Result\u003c(), ErrorResponse\u003e {\n        for row in self.execute_result.rows.iter().cloned() {\n            let mut writer = batch.create_row();\n\n            for field in row.fields {\n                match field {\n                    ExecuteField::Bool(data) =\u003e {\n                        writer.write_bool(data);\n                    }\n                    ExecuteField::Integer(data) =\u003e {\n                        writer.write_int8(data);\n                    }\n                    ExecuteField::Float(data) =\u003e {\n                        writer.write_float8(data);\n                    }\n                    ExecuteField::String(data) =\u003e {\n                        writer.write_string(\u0026data);\n                    }\n                    ExecuteField::Null =\u003e {\n                        writer.write_null();\n                    }\n                }\n            }\n        }\n\n        return Ok(());\n    }\n}\n\npub struct RRDBEngine {\n    pub shared_state: SharedState,\n    pub portal: Option\u003cRRDBPortal\u003e,\n}\n\n#[async_trait]\nimpl Engine for RRDBEngine {\n    type PortalType = RRDBPortal;\n\n    // 결과 데이터 리스트의 컬럼 정보 전송\n    async fn prepare(\n        \u0026mut self,\n        statement: \u0026SQLStatement,\n    ) -\u003e Result\u003cVec\u003cFieldDescription\u003e, ErrorResponse\u003e {\n        // Server Background Loop와의 통신용 채널\n        let (response_sender, response_receiver) = oneshot::channel::\u003cChannelResponse\u003e();\n\n        if let Err(error) = self\n            .shared_state\n            .sender\n            .send(ChannelRequest {\n                statement: statement.to_owned(),\n                response_sender,\n                connection_id: self.shared_state.client_info.connection_id.clone(),\n            })\n            .await\n        {\n            return Err(ErrorResponse::fatal(\n                SqlState::CONNECTION_EXCEPTION,\n                error.to_string(),\n            ));\n        }\n\n        match response_receiver.await {\n            Ok(response) =\u003e match response.result {\n                Ok(result) =\u003e {\n                    let return_value = Ok(result\n                        .columns\n                        .iter()\n                        .map(|e| FieldDescription {\n                            name: e.name.to_owned(),\n                            data_type: e.data_type.to_owned().into(),\n                        })\n                        .collect());\n\n                    self.portal = Some(RRDBPortal {\n                        execute_result: result,\n                        shared_state: self.shared_state.clone(),\n                    });\n\n                    return return_value;\n                }\n                Err(error) =\u003e {\n                    return Err(ErrorResponse::error(\n                        SqlState::SYNTAX_ERROR,\n                        error.to_string(),\n                    ));\n                }\n            },\n            Err(error) =\u003e {\n                return Err(ErrorResponse::fatal(\n                    SqlState::CONNECTION_EXCEPTION,\n                    error.to_string(),\n                ));\n            }\n        }\n    }\n\n    async fn create_portal(\u0026mut self, _: \u0026SQLStatement) -\u003e Result\u003cSelf::PortalType, ErrorResponse\u003e {\n        match \u0026self.portal {\n            Some(portal) =\u003e Ok(portal.to_owned()),\n            None =\u003e {\n                return Err(ErrorResponse::fatal(\n                    SqlState::CONNECTION_EXCEPTION,\n                    \"not prepared yet\".to_string(),\n                ));\n            }\n        }\n    }\n}\n","traces":[{"line":21,"address":[5270094],"length":1,"stats":{"Line":0}},{"line":22,"address":[5646377,5645898,5646911,5646168],"length":1,"stats":{"Line":0}},{"line":23,"address":[5646417,5646497],"length":1,"stats":{"Line":0}},{"line":25,"address":[5646743,5646513,5646616,5646793],"length":1,"stats":{"Line":0}},{"line":26,"address":[5646825],"length":1,"stats":{"Line":0}},{"line":27,"address":[5646924],"length":1,"stats":{"Line":0}},{"line":28,"address":[5646936,5646916,5647093],"length":1,"stats":{"Line":0}},{"line":30,"address":[5646957],"length":1,"stats":{"Line":0}},{"line":31,"address":[5647098,5646981],"length":1,"stats":{"Line":0}},{"line":33,"address":[5646988],"length":1,"stats":{"Line":0}},{"line":34,"address":[5647103,5647014],"length":1,"stats":{"Line":0}},{"line":36,"address":[5647021],"length":1,"stats":{"Line":0}},{"line":37,"address":[5647061,5647170],"length":1,"stats":{"Line":0}},{"line":40,"address":[5647086,5647208],"length":1,"stats":{"Line":0}},{"line":46,"address":[5646354],"length":1,"stats":{"Line":0}},{"line":65,"address":[5647728],"length":1,"stats":{"Line":0}},{"line":67,"address":[5647815,5648080,5648110,5648471,5647800,5648376],"length":1,"stats":{"Line":0}},{"line":70,"address":[5647981],"length":1,"stats":{"Line":0}},{"line":71,"address":[5647832,5647811],"length":1,"stats":{"Line":0}},{"line":72,"address":[5647883],"length":1,"stats":{"Line":0}},{"line":73,"address":[5647911],"length":1,"stats":{"Line":0}},{"line":75,"address":[4718172],"length":1,"stats":{"Line":0}},{"line":77,"address":[5648619],"length":1,"stats":{"Line":0}},{"line":79,"address":[5648554],"length":1,"stats":{"Line":0}},{"line":83,"address":[4718188],"length":1,"stats":{"Line":0}},{"line":84,"address":[5649264],"length":1,"stats":{"Line":0}},{"line":85,"address":[5649344],"length":1,"stats":{"Line":0}},{"line":86,"address":[5649400,5649585],"length":1,"stats":{"Line":0}},{"line":89,"address":[5650747,5650710,5650560],"length":1,"stats":{"Line":0}},{"line":90,"address":[5650597],"length":1,"stats":{"Line":0}},{"line":91,"address":[5650667,5650616],"length":1,"stats":{"Line":0}},{"line":95,"address":[5649826],"length":1,"stats":{"Line":0}},{"line":96,"address":[5649704],"length":1,"stats":{"Line":0}},{"line":97,"address":[5649760],"length":1,"stats":{"Line":0}},{"line":100,"address":[5650194],"length":1,"stats":{"Line":0}},{"line":102,"address":[5649428],"length":1,"stats":{"Line":0}},{"line":103,"address":[5650342],"length":1,"stats":{"Line":0}},{"line":105,"address":[5649524],"length":1,"stats":{"Line":0}},{"line":110,"address":[5650484],"length":1,"stats":{"Line":0}},{"line":112,"address":[5649334],"length":1,"stats":{"Line":0}},{"line":118,"address":[5270414],"length":1,"stats":{"Line":0}},{"line":119,"address":[5651071,5650830],"length":1,"stats":{"Line":0}},{"line":120,"address":[5651257,5651146],"length":1,"stats":{"Line":0}},{"line":122,"address":[5651169],"length":1,"stats":{"Line":0}},{"line":124,"address":[5651114],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","mod.rs"],"content":"pub mod connection;\npub mod engine;\npub mod predule;\npub mod protocol;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","predule.rs"],"content":"pub use super::connection::*;\npub use super::engine::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","connection_codec.rs"],"content":"use bytes::{Buf, BufMut, BytesMut};\nuse std::collections::HashMap;\nuse tokio_util::codec::{Decoder, Encoder};\n\nuse crate::pgwire::protocol::ProtocolError;\n\nuse super::{\n    backend::BackendMessage,\n    client::{Bind, BindFormat, ClientMessage, Describe, Execute, Parse, Startup},\n    FormatCode, MESSAGE_HEADER_SIZE, STARTUP_HEADER_SIZE,\n};\n\n#[derive(Default, Debug)]\npub struct ConnectionCodec {\n    // most state tracking is handled at a higher level\n    // however, the actual wire format uses a different header for startup vs normal messages\n    // so we need to be able to differentiate inside the decoder\n    startup_received: bool,\n}\n\nimpl ConnectionCodec {\n    pub fn new() -\u003e Self {\n        Self {\n            startup_received: false,\n        }\n    }\n}\n\nimpl Decoder for ConnectionCodec {\n    type Item = ClientMessage;\n    type Error = ProtocolError;\n\n    fn decode(\u0026mut self, src: \u0026mut BytesMut) -\u003e Result\u003cOption\u003cSelf::Item\u003e, Self::Error\u003e {\n        if !self.startup_received {\n            if src.len() \u003c STARTUP_HEADER_SIZE {\n                return Ok(None);\n            }\n\n            let mut header_buf = src.clone();\n            let message_len = header_buf.get_i32() as usize;\n            let protocol_version_major = header_buf.get_i16();\n            let protocol_version_minor = header_buf.get_i16();\n\n            if protocol_version_major == 1234i16 \u0026\u0026 protocol_version_minor == 5679i16 {\n                src.advance(STARTUP_HEADER_SIZE);\n                return Ok(Some(ClientMessage::SSLRequest));\n            }\n\n            if src.len() \u003c message_len {\n                src.reserve(message_len - src.len());\n                return Ok(None);\n            }\n\n            src.advance(STARTUP_HEADER_SIZE);\n\n            let mut parameters = HashMap::new();\n\n            let mut param_str_start_pos = 0;\n            let mut current_key = None;\n\n            for (i, \u0026blah) in src.iter().enumerate() {\n                if blah == 0 {\n                    let string_value = String::from_utf8(src[param_str_start_pos..i].to_owned())?;\n\n                    param_str_start_pos = i + 1;\n\n                    current_key = match current_key {\n                        Some(key) =\u003e {\n                            parameters.insert(key, string_value);\n                            None\n                        }\n                        None =\u003e Some(string_value),\n                    }\n                }\n            }\n\n            src.advance(message_len - STARTUP_HEADER_SIZE);\n\n            self.startup_received = true;\n            return Ok(Some(ClientMessage::Startup(Startup {\n                requested_protocol_version: (protocol_version_major, protocol_version_minor),\n                parameters,\n            })));\n        }\n\n        if src.len() \u003c MESSAGE_HEADER_SIZE {\n            src.reserve(MESSAGE_HEADER_SIZE);\n            return Ok(None);\n        }\n\n        let mut header_buf = src.clone();\n        let message_tag = header_buf.get_u8();\n        let message_len = header_buf.get_i32() as usize;\n\n        if src.len() \u003c message_len {\n            src.reserve(message_len - src.len());\n            return Ok(None);\n        }\n\n        src.advance(MESSAGE_HEADER_SIZE);\n\n        let read_cstr = |src: \u0026mut BytesMut| -\u003e Result\u003cString, ProtocolError\u003e {\n            let next_null = src\n                .iter()\n                .position(|\u0026b| b == 0)\n                .ok_or(ProtocolError::ParserError)?;\n            let bytes = src[..next_null].to_owned();\n            src.advance(bytes.len() + 1);\n            Ok(String::from_utf8(bytes)?)\n        };\n\n        let message = match message_tag {\n            b'P' =\u003e {\n                let prepared_statement_name = read_cstr(src)?;\n                let query = read_cstr(src)?;\n                let num_params = src.get_i16();\n                let _params: Vec\u003c_\u003e = (0..num_params).map(|_| src.get_u32()).collect();\n\n                ClientMessage::Parse(Parse {\n                    prepared_statement_name,\n                    query,\n                    parameter_types: Vec::new(),\n                })\n            }\n            b'D' =\u003e {\n                let target_type = src.get_u8();\n                let name = read_cstr(src)?;\n\n                ClientMessage::Describe(match target_type {\n                    b'P' =\u003e Describe::Portal(name),\n                    b'S' =\u003e Describe::PreparedStatement(name),\n                    _ =\u003e return Err(ProtocolError::ParserError),\n                })\n            }\n            b'S' =\u003e ClientMessage::Sync,\n            b'B' =\u003e {\n                let portal = read_cstr(src)?;\n                let prepared_statement_name = read_cstr(src)?;\n\n                let num_param_format_codes = src.get_i16();\n                for _ in 0..num_param_format_codes {\n                    let _format_code = src.get_i16();\n                }\n\n                let num_params = src.get_i16();\n                for _ in 0..num_params {\n                    let param_len = src.get_i32() as usize;\n                    let _bytes = \u0026src[0..param_len];\n                    src.advance(param_len);\n                }\n\n                let result_format = match src.get_i16() {\n                    0 =\u003e BindFormat::All(FormatCode::Text),\n                    1 =\u003e BindFormat::All(src.get_i16().try_into()?),\n                    n =\u003e {\n                        let mut result_format_codes = Vec::new();\n                        for _ in 0..n {\n                            result_format_codes.push(src.get_i16().try_into()?);\n                        }\n                        BindFormat::PerColumn(result_format_codes)\n                    }\n                };\n\n                ClientMessage::Bind(Bind {\n                    portal,\n                    prepared_statement_name,\n                    result_format,\n                })\n            }\n            b'E' =\u003e {\n                let portal = read_cstr(src)?;\n                let max_rows = match src.get_i32() {\n                    0 =\u003e None,\n                    other =\u003e Some(other),\n                };\n\n                ClientMessage::Execute(Execute { portal, max_rows })\n            }\n            b'Q' =\u003e {\n                let query = read_cstr(src)?;\n                ClientMessage::Query(query)\n            }\n            b'X' =\u003e ClientMessage::Terminate,\n            other =\u003e {\n                return Err(ProtocolError::InvalidMessageType(other));\n            }\n        };\n\n        Ok(Some(message))\n    }\n}\n\nimpl\u003cT: BackendMessage\u003e Encoder\u003cT\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: T, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut body = BytesMut::new();\n        item.encode(\u0026mut body);\n\n        dst.put_u8(T::TAG);\n        dst.put_i32((body.len() + 4) as i32);\n        dst.put_slice(\u0026body);\n        Ok(())\n    }\n}\n\nimpl Encoder\u003cchar\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: char, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        dst.put_u8(item as u8);\n        Ok(())\n    }\n}\n","traces":[{"line":33,"address":[5045237,5044947,5042448],"length":1,"stats":{"Line":0}},{"line":34,"address":[5042518],"length":1,"stats":{"Line":0}},{"line":35,"address":[5042571],"length":1,"stats":{"Line":0}},{"line":36,"address":[5042679],"length":1,"stats":{"Line":0}},{"line":39,"address":[5042620],"length":1,"stats":{"Line":0}},{"line":40,"address":[5042653,5042765],"length":1,"stats":{"Line":0}},{"line":41,"address":[5042783],"length":1,"stats":{"Line":0}},{"line":42,"address":[5042826],"length":1,"stats":{"Line":0}},{"line":44,"address":[5042877],"length":1,"stats":{"Line":0}},{"line":45,"address":[5042933],"length":1,"stats":{"Line":0}},{"line":46,"address":[5042940],"length":1,"stats":{"Line":0}},{"line":49,"address":[5043039,5042905],"length":1,"stats":{"Line":0}},{"line":50,"address":[5043072,5045115],"length":1,"stats":{"Line":0}},{"line":51,"address":[5045186],"length":1,"stats":{"Line":0}},{"line":54,"address":[5043057],"length":1,"stats":{"Line":0}},{"line":56,"address":[5043098],"length":1,"stats":{"Line":0}},{"line":58,"address":[5043113],"length":1,"stats":{"Line":0}},{"line":59,"address":[5043133],"length":1,"stats":{"Line":0}},{"line":61,"address":[5043159,5043528,5043264],"length":1,"stats":{"Line":0}},{"line":62,"address":[5044881,5043569],"length":1,"stats":{"Line":0}},{"line":63,"address":[5044154,5043852,5044401],"length":1,"stats":{"Line":0}},{"line":65,"address":[5044370,5044482,5044530],"length":1,"stats":{"Line":0}},{"line":67,"address":[5044817,5044490],"length":1,"stats":{"Line":0}},{"line":68,"address":[5044698],"length":1,"stats":{"Line":0}},{"line":69,"address":[5044738,5044886],"length":1,"stats":{"Line":0}},{"line":70,"address":[5044905],"length":1,"stats":{"Line":0}},{"line":72,"address":[5044592],"length":1,"stats":{"Line":0}},{"line":77,"address":[5043505,5043598],"length":1,"stats":{"Line":0}},{"line":79,"address":[5043633],"length":1,"stats":{"Line":0}},{"line":80,"address":[5043686],"length":1,"stats":{"Line":0}},{"line":82,"address":[5043636],"length":1,"stats":{"Line":0}},{"line":86,"address":[5042592],"length":1,"stats":{"Line":0}},{"line":87,"address":[5045317],"length":1,"stats":{"Line":0}},{"line":88,"address":[5045335],"length":1,"stats":{"Line":0}},{"line":91,"address":[5045258],"length":1,"stats":{"Line":0}},{"line":92,"address":[5045291,5045421],"length":1,"stats":{"Line":0}},{"line":93,"address":[5045428],"length":1,"stats":{"Line":0}},{"line":95,"address":[5045484],"length":1,"stats":{"Line":0}},{"line":96,"address":[5050969,5045545],"length":1,"stats":{"Line":0}},{"line":97,"address":[5051032],"length":1,"stats":{"Line":0}},{"line":100,"address":[5045530],"length":1,"stats":{"Line":0}},{"line":102,"address":[1239748,1238832,1239716],"length":1,"stats":{"Line":0}},{"line":103,"address":[1239291,1238878,1238953],"length":1,"stats":{"Line":0}},{"line":105,"address":[1239770,1239760],"length":1,"stats":{"Line":0}},{"line":106,"address":[1238935,1239263],"length":1,"stats":{"Line":0}},{"line":107,"address":[1239212,1239045],"length":1,"stats":{"Line":0}},{"line":108,"address":[1239247,1239362],"length":1,"stats":{"Line":0}},{"line":109,"address":[1239411,1239644],"length":1,"stats":{"Line":0}},{"line":112,"address":[5045567],"length":1,"stats":{"Line":0}},{"line":114,"address":[5045896,5045708,5047084,5046049],"length":1,"stats":{"Line":0}},{"line":115,"address":[5046034,5046179,5046325],"length":1,"stats":{"Line":0}},{"line":116,"address":[5046301,5046452],"length":1,"stats":{"Line":0}},{"line":117,"address":[1239809,1239792],"length":1,"stats":{"Line":0}},{"line":119,"address":[5046642],"length":1,"stats":{"Line":0}},{"line":120,"address":[5046503],"length":1,"stats":{"Line":0}},{"line":121,"address":[5046543],"length":1,"stats":{"Line":0}},{"line":122,"address":[5046591],"length":1,"stats":{"Line":0}},{"line":126,"address":[5045726,5047117],"length":1,"stats":{"Line":0}},{"line":127,"address":[5047305,5047768,5047140],"length":1,"stats":{"Line":0}},{"line":129,"address":[5047273,5047687],"length":1,"stats":{"Line":0}},{"line":130,"address":[5047469],"length":1,"stats":{"Line":0}},{"line":131,"address":[5047579],"length":1,"stats":{"Line":0}},{"line":132,"address":[5047396],"length":1,"stats":{"Line":0}},{"line":135,"address":[5045744],"length":1,"stats":{"Line":0}},{"line":137,"address":[5050169,5045785,5047789,5047934],"length":1,"stats":{"Line":0}},{"line":138,"address":[5048205,5047919,5048067,5050164],"length":1,"stats":{"Line":0}},{"line":140,"address":[5048327,5048181],"length":1,"stats":{"Line":0}},{"line":141,"address":[5048335],"length":1,"stats":{"Line":0}},{"line":142,"address":[5048480,5050151],"length":1,"stats":{"Line":0}},{"line":145,"address":[5048504,5048456],"length":1,"stats":{"Line":0}},{"line":146,"address":[5048512],"length":1,"stats":{"Line":0}},{"line":147,"address":[5048657,5049903],"length":1,"stats":{"Line":0}},{"line":148,"address":[5049918,5050118],"length":1,"stats":{"Line":0}},{"line":149,"address":[5050134],"length":1,"stats":{"Line":0}},{"line":152,"address":[5048680,5048633],"length":1,"stats":{"Line":0}},{"line":153,"address":[5048726],"length":1,"stats":{"Line":0}},{"line":154,"address":[5048778,5049137],"length":1,"stats":{"Line":0}},{"line":156,"address":[5048716],"length":1,"stats":{"Line":0}},{"line":157,"address":[5049371,5049443],"length":1,"stats":{"Line":0}},{"line":158,"address":[5049633],"length":1,"stats":{"Line":0}},{"line":160,"address":[5049524],"length":1,"stats":{"Line":0}},{"line":164,"address":[5048941],"length":1,"stats":{"Line":0}},{"line":165,"address":[5048797],"length":1,"stats":{"Line":0}},{"line":166,"address":[5048845],"length":1,"stats":{"Line":0}},{"line":167,"address":[5048893],"length":1,"stats":{"Line":0}},{"line":171,"address":[5050327,5050190,5045819,5050700],"length":1,"stats":{"Line":0}},{"line":172,"address":[5050304,5050448],"length":1,"stats":{"Line":0}},{"line":173,"address":[5050460],"length":1,"stats":{"Line":0}},{"line":174,"address":[5050477],"length":1,"stats":{"Line":0}},{"line":177,"address":[5050495],"length":1,"stats":{"Line":0}},{"line":180,"address":[5045853,5050884,5050721],"length":1,"stats":{"Line":0}},{"line":181,"address":[5050811],"length":1,"stats":{"Line":0}},{"line":183,"address":[5045863],"length":1,"stats":{"Line":0}},{"line":185,"address":[5045617],"length":1,"stats":{"Line":0}},{"line":189,"address":[5046865],"length":1,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[5051072],"length":1,"stats":{"Line":0}},{"line":211,"address":[5051113],"length":1,"stats":{"Line":0}},{"line":212,"address":[5051134],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":105},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","constants.rs"],"content":"use std::mem::size_of;\n\n// length prefix, two version components\npub const STARTUP_HEADER_SIZE: usize = size_of::\u003ci32\u003e() + (size_of::\u003ci16\u003e() * 2);\n// message tag, length prefix\npub const MESSAGE_HEADER_SIZE: usize = size_of::\u003cu8\u003e() + size_of::\u003ci32\u003e();\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","data_types.rs"],"content":"macro_rules! data_types {\n\t($($name:ident = $oid:expr, $size: expr)*) =\u003e {\n\t\t#[derive(Debug, Copy, Clone)]\n\t\t/// Describes a Postgres data type.\n\t\tpub enum DataTypeOid {\n\t\t\t$(\n\t\t\t\t#[allow(missing_docs)]\n\t\t\t\t$name,\n\t\t\t)*\n\t\t\t/// A type which is not known to this crate.\n\t\t\tUnknown(u32),\n\t\t}\n\n\t\timpl DataTypeOid {\n\t\t\t/// Fetch the size in bytes for this data type.\n\t\t\t/// Variably-sized types return -1.\n\t\t\tpub fn size_bytes(\u0026self) -\u003e i16 {\n\t\t\t\tmatch self {\n\t\t\t\t\t$(\n\t\t\t\t\t\tSelf::$name =\u003e $size,\n\t\t\t\t\t)*\n\t\t\t\t\tSelf::Unknown(_) =\u003e unimplemented!(),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timpl From\u003cu32\u003e for DataTypeOid {\n\t\t\tfn from(value: u32) -\u003e Self {\n\t\t\t\tmatch value {\n\t\t\t\t\t$(\n\t\t\t\t\t\t$oid =\u003e Self::$name,\n\t\t\t\t\t)*\n\t\t\t\t\tother =\u003e Self::Unknown(other),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timpl From\u003cDataTypeOid\u003e for u32 {\n\t\t\tfn from(value: DataTypeOid) -\u003e Self {\n\t\t\t\tmatch value {\n\t\t\t\t\t$(\n\t\t\t\t\t\tDataTypeOid::$name =\u003e $oid,\n\t\t\t\t\t)*\n\t\t\t\t\tDataTypeOid::Unknown(other) =\u003e other,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// For oid see:\n// https://github.com/sfackler/rust-postgres/blob/master/postgres-types/src/type_gen.rs\ndata_types! {\n    Unspecified = 0, 0\n\n    Bool = 16, 1\n\n    Int2 = 21, 2\n    Int4 = 23, 4\n    Int8 = 20, 8\n\n    Float4 = 700, 4\n    Float8 = 701, 8\n\n    Date = 1082, 4\n    Timestamp = 1114, 8\n\n    Text = 25, -1\n}\n","traces":[{"line":3,"address":[7768080,7768544,7768549,7768103,7768482],"length":1,"stats":{"Line":0}},{"line":11,"address":[7768473],"length":1,"stats":{"Line":0}},{"line":17,"address":[7767472],"length":1,"stats":{"Line":0}},{"line":18,"address":[7767481],"length":1,"stats":{"Line":0}},{"line":22,"address":[7767599],"length":1,"stats":{"Line":0}},{"line":28,"address":[7767648],"length":1,"stats":{"Line":0}},{"line":29,"address":[7767656],"length":1,"stats":{"Line":0}},{"line":31,"address":[7767803],"length":1,"stats":{"Line":0}},{"line":33,"address":[7767789],"length":1,"stats":{"Line":0}},{"line":39,"address":[7767920],"length":1,"stats":{"Line":0}},{"line":40,"address":[7767928],"length":1,"stats":{"Line":0}},{"line":44,"address":[7768060],"length":1,"stats":{"Line":0}},{"line":54,"address":[7767509,7767960],"length":1,"stats":{"Line":0}},{"line":56,"address":[7767518,7767970],"length":1,"stats":{"Line":0}},{"line":58,"address":[7767980,7767527],"length":1,"stats":{"Line":0}},{"line":59,"address":[7767990,7767536],"length":1,"stats":{"Line":0}},{"line":60,"address":[7767545,7768000],"length":1,"stats":{"Line":0}},{"line":62,"address":[7768010,7767554],"length":1,"stats":{"Line":0}},{"line":63,"address":[7767563,7768020],"length":1,"stats":{"Line":0}},{"line":65,"address":[7767572,7768030],"length":1,"stats":{"Line":0}},{"line":66,"address":[7767581,7768040],"length":1,"stats":{"Line":0}},{"line":68,"address":[7768050,7767590],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","data_row_batch.rs"],"content":"use bytes::BytesMut;\nuse tokio_util::codec::Encoder;\n\nuse crate::pgwire::protocol::{\n    backend::RowDescription, ConnectionCodec, FormatCode, ProtocolError,\n};\n\nuse super::data_row_writer::DataRowWriter;\n\n/// Supports batched rows for e.g. returning portal result sets.\n///\n/// NB: this struct only performs limited validation of column consistency across rows.\npub struct DataRowBatch {\n    pub(crate) format_code: FormatCode,\n    pub(crate) num_cols: usize,\n    pub(crate) num_rows: usize,\n    pub(crate) data: BytesMut,\n    pub(crate) row: BytesMut,\n}\n\nimpl DataRowBatch {\n    /// Creates a new row batch using the given format code, requiring a certain number of columns per row.\n    pub fn new(format_code: FormatCode, num_cols: usize) -\u003e Self {\n        Self {\n            format_code,\n            num_cols,\n            num_rows: 0,\n            data: BytesMut::new(),\n            row: BytesMut::new(),\n        }\n    }\n\n    /// Creates a [DataRowBatch] from the given [RowDescription].\n    pub fn from_row_desc(desc: \u0026RowDescription) -\u003e Self {\n        Self::new(desc.format_code, desc.fields.len())\n    }\n\n    /// Starts writing a new row.\n    ///\n    /// Returns a [DataRowWriter] that is responsible for the actual value encoding.\n    pub fn create_row(\u0026mut self) -\u003e DataRowWriter {\n        self.num_rows += 1;\n        DataRowWriter::new(self)\n    }\n\n    /// Returns the number of rows currently written to this batch.\n    pub fn num_rows(\u0026self) -\u003e usize {\n        self.num_rows\n    }\n}\n\nimpl Encoder\u003cDataRowBatch\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: DataRowBatch, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        dst.extend(item.data);\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[2155616,2155835],"length":1,"stats":{"Line":0}},{"line":28,"address":[2155661],"length":1,"stats":{"Line":0}},{"line":29,"address":[2155671],"length":1,"stats":{"Line":0}},{"line":34,"address":[2155856],"length":1,"stats":{"Line":0}},{"line":35,"address":[2155886],"length":1,"stats":{"Line":0}},{"line":41,"address":[2155936],"length":1,"stats":{"Line":0}},{"line":42,"address":[2155990,2155949],"length":1,"stats":{"Line":0}},{"line":43,"address":[2155980],"length":1,"stats":{"Line":0}},{"line":47,"address":[2156016],"length":1,"stats":{"Line":0}},{"line":48,"address":[2156021],"length":1,"stats":{"Line":0}},{"line":55,"address":[5051152,5051299],"length":1,"stats":{"Line":0}},{"line":56,"address":[5051193],"length":1,"stats":{"Line":0}},{"line":57,"address":[5051266],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","data_row_writer.rs"],"content":"use bytes::BufMut;\nuse chrono::{NaiveDate, NaiveDateTime};\n\nuse crate::pgwire::protocol::FormatCode;\n\nuse super::DataRowBatch;\n\nmacro_rules! primitive_write {\n    ($name: ident, $type: ident) =\u003e {\n        #[allow(missing_docs)]\n        pub fn $name(\u0026mut self, val: $type) {\n            match self.parent.format_code {\n                FormatCode::Text =\u003e self.write_value(\u0026val.to_string().into_bytes()),\n                FormatCode::Binary =\u003e self.write_value(\u0026val.to_be_bytes()),\n            };\n        }\n    };\n}\n\n/// Temporarily leased from a [DataRowBatch] to encode a single row.\npub struct DataRowWriter\u003c'a\u003e {\n    current_col: usize,\n    parent: \u0026'a mut DataRowBatch,\n}\n\nimpl\u003c'a\u003e DataRowWriter\u003c'a\u003e {\n    pub fn new(parent: \u0026'a mut DataRowBatch) -\u003e Self {\n        parent.row.put_i16(parent.num_cols as i16);\n        Self {\n            current_col: 0,\n            parent,\n        }\n    }\n\n    fn write_value(\u0026mut self, data: \u0026[u8]) {\n        self.current_col += 1;\n        self.parent.row.put_i32(data.len() as i32);\n        self.parent.row.put_slice(data);\n    }\n\n    /// Writes a null value for the next column.\n    pub fn write_null(\u0026mut self) {\n        self.current_col += 1;\n        self.parent.row.put_i32(-1);\n    }\n\n    /// Writes a string value for the next column.\n    pub fn write_string(\u0026mut self, val: \u0026str) {\n        self.write_value(val.as_bytes());\n    }\n\n    /// Writes a bool value for the next column.\n    pub fn write_bool(\u0026mut self, val: bool) {\n        match self.parent.format_code {\n            FormatCode::Text =\u003e self.write_value(if val { \"t\" } else { \"f\" }.as_bytes()),\n            FormatCode::Binary =\u003e {\n                self.current_col += 1;\n                self.parent.row.put_u8(val as u8);\n            }\n        };\n    }\n\n    fn pg_date_epoch() -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(2000, 1, 1).unwrap()\n    }\n\n    /// Writes a date value for the next column.\n    pub fn write_date(\u0026mut self, val: NaiveDate) {\n        match self.parent.format_code {\n            FormatCode::Binary =\u003e {\n                self.write_int4(val.signed_duration_since(Self::pg_date_epoch()).num_days() as i32)\n            }\n            FormatCode::Text =\u003e self.write_string(\u0026val.to_string()),\n        }\n    }\n\n    /// Writes a timestamp value for the next column.\n    pub fn write_timestamp(\u0026mut self, val: NaiveDateTime) {\n        match self.parent.format_code {\n            FormatCode::Binary =\u003e {\n                self.write_int8(\n                    val.signed_duration_since(Self::pg_date_epoch().and_hms_opt(0, 0, 0).unwrap())\n                        .num_microseconds()\n                        .unwrap(),\n                );\n            }\n            FormatCode::Text =\u003e self.write_string(\u0026val.to_string()),\n        }\n    }\n\n    primitive_write!(write_int2, i16);\n    primitive_write!(write_int4, i32);\n    primitive_write!(write_int8, i64);\n    primitive_write!(write_float4, f32);\n    primitive_write!(write_float8, f64);\n}\n\nimpl\u003c'a\u003e Drop for DataRowWriter\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        assert_eq!(\n            self.parent.num_cols, self.current_col,\n            \"dropped a row writer with an invalid number of columns\"\n        );\n\n        self.parent.data.put_u8(b'D');\n        self.parent.data.put_i32((self.parent.row.len() + 4) as i32);\n        self.parent.data.extend(self.parent.row.split());\n    }\n}\n","traces":[{"line":11,"address":[4202160,4202644,4202672,4202907,4202416,4201648,4202132,4201884,4201904,4202393],"length":1,"stats":{"Line":0}},{"line":12,"address":[4202439,4202695,4201673,4201925,4202182],"length":1,"stats":{"Line":0}},{"line":13,"address":[4201690,4201811,4202571,4202712,4202470,4201942,4202199,4202320,4202059,4202834],"length":1,"stats":{"Line":0}},{"line":14,"address":[4202010,4202520,4202780,4201758,4202267],"length":1,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","mod.rs"],"content":"pub mod data_row_batch;\npub use data_row_batch::*;\n\npub mod data_row_writer;\npub use data_row_writer::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","format_code.rs"],"content":"use crate::pgwire::protocol::ProtocolError;\n\n/// Describes how to format a given value or set of values.\n#[derive(Debug, Copy, Clone)]\npub enum FormatCode {\n    /// Use the stable text representation.\n    Text = 0,\n    /// Use the less-stable binary representation.\n    Binary = 1,\n}\n\nimpl TryFrom\u003ci16\u003e for FormatCode {\n    type Error = ProtocolError;\n\n    fn try_from(value: i16) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            0 =\u003e Ok(FormatCode::Text),\n            1 =\u003e Ok(FormatCode::Binary),\n            other =\u003e Err(ProtocolError::InvalidFormatCode(other)),\n        }\n    }\n}\n","traces":[{"line":15,"address":[7515856],"length":1,"stats":{"Line":0}},{"line":16,"address":[7515883],"length":1,"stats":{"Line":0}},{"line":17,"address":[7515955],"length":1,"stats":{"Line":0}},{"line":18,"address":[7515990],"length":1,"stats":{"Line":0}},{"line":19,"address":[7515913],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","backend_message.rs"],"content":"use bytes::BytesMut;\n\npub trait BackendMessage: std::fmt::Debug {\n    const TAG: u8;\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","mod.rs"],"content":"pub mod backend_message;\npub use backend_message::*;\n\npub mod types;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","bind_complete.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct BindComplete;\n\nimpl BackendMessage for BindComplete {\n    const TAG: u8 = b'2';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[5731770,5731760],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","command_complete.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct CommandComplete {\n    pub command_tag: String,\n}\n\nimpl BackendMessage for CommandComplete {\n    const TAG: u8 = b'C';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_slice(self.command_tag.as_bytes());\n        dst.put_u8(0);\n    }\n}\n","traces":[{"line":13,"address":[4105344],"length":1,"stats":{"Line":0}},{"line":14,"address":[4105362],"length":1,"stats":{"Line":0}},{"line":15,"address":[4105384],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","empty_query_response.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct EmptyQueryResponse;\n\nimpl BackendMessage for EmptyQueryResponse {\n    const TAG: u8 = b'I';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[3511248,3511258],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","error_response.rs"],"content":"use std::fmt::Display;\n\nuse bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::{backend::BackendMessage, Severity, SqlState};\n\n#[derive(thiserror::Error, Debug, Clone)]\npub struct ErrorResponse {\n    pub sql_state: SqlState,\n    pub severity: Severity,\n    pub message: String,\n}\n\nimpl ErrorResponse {\n    pub fn new(sql_state: SqlState, severity: Severity, message: impl Into\u003cString\u003e) -\u003e Self {\n        ErrorResponse {\n            sql_state,\n            severity,\n            message: message.into(),\n        }\n    }\n\n    pub fn error(sql_state: SqlState, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(sql_state, Severity::ERROR, message)\n    }\n\n    pub fn fatal(sql_state: SqlState, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(sql_state, Severity::FATAL, message)\n    }\n}\n\nimpl Display for ErrorResponse {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"error\")\n    }\n}\n\nimpl From\u003cBox\u003cdyn std::error::Error\u003e\u003e for ErrorResponse {\n    fn from(value: Box\u003cdyn std::error::Error\u003e) -\u003e ErrorResponse {\n        ErrorResponse {\n            sql_state: SqlState::SYNTAX_ERROR,\n            severity: Severity::ERROR,\n            message: value.to_string(),\n        }\n    }\n}\n\nimpl BackendMessage for ErrorResponse {\n    const TAG: u8 = b'E';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_u8(b'C');\n        dst.put_slice(self.sql_state.0.as_bytes());\n        dst.put_u8(0);\n        dst.put_u8(b'S');\n        dst.put_slice(self.severity.0.as_bytes());\n        dst.put_u8(0);\n        dst.put_u8(b'M');\n        dst.put_slice(self.message.as_bytes());\n        dst.put_u8(0);\n\n        dst.put_u8(0); // tag\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[4198752],"length":1,"stats":{"Line":0}},{"line":34,"address":[4198770],"length":1,"stats":{"Line":0}},{"line":39,"address":[4198816,4198972],"length":1,"stats":{"Line":0}},{"line":43,"address":[4198849],"length":1,"stats":{"Line":0}},{"line":51,"address":[4198992],"length":1,"stats":{"Line":0}},{"line":52,"address":[4199029],"length":1,"stats":{"Line":0}},{"line":53,"address":[4199058],"length":1,"stats":{"Line":0}},{"line":54,"address":[4199097],"length":1,"stats":{"Line":0}},{"line":55,"address":[4199114],"length":1,"stats":{"Line":0}},{"line":56,"address":[4199126],"length":1,"stats":{"Line":0}},{"line":57,"address":[4199155],"length":1,"stats":{"Line":0}},{"line":58,"address":[4199168],"length":1,"stats":{"Line":0}},{"line":59,"address":[4199184],"length":1,"stats":{"Line":0}},{"line":60,"address":[4199208],"length":1,"stats":{"Line":0}},{"line":62,"address":[4199221],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","field_description.rs"],"content":"use crate::pgwire::protocol::DataTypeOid;\n\n#[derive(Debug, Clone)]\npub struct FieldDescription {\n    pub name: String,\n    pub data_type: DataTypeOid,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","mod.rs"],"content":"pub mod parameter_description;\npub use parameter_description::*;\n\npub mod field_description;\npub use field_description::*;\n\npub mod row_description;\npub use row_description::*;\n\npub mod ok;\npub use ok::*;\n\npub mod ready_for_query;\npub use ready_for_query::*;\n\npub mod parse_complete;\npub use parse_complete::*;\n\npub mod bind_complete;\npub use bind_complete::*;\n\npub mod no_data;\npub use no_data::*;\n\npub mod empty_query_response;\npub use empty_query_response::*;\n\npub mod command_complete;\npub use command_complete::*;\n\npub mod parameter_status;\npub use parameter_status::*;\n\npub mod error_response;\npub use error_response::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","no_data.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct NoData;\n\nimpl BackendMessage for NoData {\n    const TAG: u8 = b'n';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[5682240,5682250],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","ok.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct AuthenticationOk;\n\nimpl BackendMessage for AuthenticationOk {\n    const TAG: u8 = b'R';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i32(0);\n    }\n}\n","traces":[{"line":11,"address":[5645296],"length":1,"stats":{"Line":0}},{"line":12,"address":[5645321],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parameter_description.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParameterDescription {}\n\nimpl BackendMessage for ParameterDescription {\n    const TAG: u8 = b't';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i16(0);\n    }\n}\n","traces":[{"line":11,"address":[4431056],"length":1,"stats":{"Line":0}},{"line":12,"address":[4431081],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parameter_status.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParameterStatus {\n    name: String,\n    value: String,\n}\n\nimpl BackendMessage for ParameterStatus {\n    const TAG: u8 = b'S';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_slice(self.name.as_bytes());\n        dst.put_u8(0);\n        dst.put_slice(self.value.as_bytes());\n        dst.put_u8(0);\n    }\n}\n\nimpl ParameterStatus {\n    pub fn new(name: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            value: value.into(),\n        }\n    }\n}\n","traces":[{"line":14,"address":[2886112],"length":1,"stats":{"Line":0}},{"line":15,"address":[2886136],"length":1,"stats":{"Line":0}},{"line":16,"address":[2886160],"length":1,"stats":{"Line":0}},{"line":17,"address":[2886173],"length":1,"stats":{"Line":0}},{"line":18,"address":[2886201],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parse_complete.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParseComplete;\n\nimpl BackendMessage for ParseComplete {\n    const TAG: u8 = b'1';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[5558096,5558106],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","ready_for_query.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ReadyForQuery;\n\nimpl BackendMessage for ReadyForQuery {\n    const TAG: u8 = b'Z';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_u8(b'I');\n    }\n}\n","traces":[{"line":11,"address":[5719472],"length":1,"stats":{"Line":0}},{"line":12,"address":[5719497],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","row_description.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::{backend::BackendMessage, FormatCode};\n\nuse super::field_description::FieldDescription;\n\n#[derive(Debug, Clone)]\npub struct RowDescription {\n    pub fields: Vec\u003cFieldDescription\u003e,\n    pub format_code: FormatCode,\n}\n\nimpl BackendMessage for RowDescription {\n    const TAG: u8 = b'T';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i16(self.fields.len() as i16);\n        for field in \u0026self.fields {\n            dst.put_slice(field.name.as_bytes());\n            dst.put_u8(0);\n            dst.put_i32(0); // table oid\n            dst.put_i16(0); // column attr number\n            dst.put_u32(field.data_type.into());\n            dst.put_i16(field.data_type.size_bytes());\n            dst.put_i32(-1); // data type modifier\n            dst.put_i16(self.format_code as i16);\n        }\n    }\n}\n","traces":[{"line":16,"address":[1216304],"length":1,"stats":{"Line":0}},{"line":17,"address":[1216328],"length":1,"stats":{"Line":0}},{"line":18,"address":[1216352,1216413],"length":1,"stats":{"Line":0}},{"line":19,"address":[1216428],"length":1,"stats":{"Line":0}},{"line":20,"address":[1216452],"length":1,"stats":{"Line":0}},{"line":21,"address":[1216465],"length":1,"stats":{"Line":0}},{"line":22,"address":[1216478],"length":1,"stats":{"Line":0}},{"line":23,"address":[1216491],"length":1,"stats":{"Line":0}},{"line":24,"address":[1216527],"length":1,"stats":{"Line":0}},{"line":25,"address":[1216555],"length":1,"stats":{"Line":0}},{"line":26,"address":[1216576],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","client_message.rs"],"content":"use super::{Bind, Describe, Execute, Parse, Startup};\n\n#[derive(Debug)]\npub enum ClientMessage {\n    SSLRequest, // for SSL negotiation\n    Startup(Startup),\n    Parse(Parse),\n    Describe(Describe),\n    Bind(Bind),\n    Sync,\n    Execute(Execute),\n    Query(String),\n    Terminate,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","mod.rs"],"content":"pub mod client_message;\npub use client_message::*;\n\npub mod types;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","bind.rs"],"content":"use super::BindFormat;\n\n#[derive(Debug)]\npub struct Bind {\n    pub portal: String,\n    pub prepared_statement_name: String,\n    pub result_format: BindFormat,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","bind_format.rs"],"content":"use crate::pgwire::protocol::FormatCode;\n\n#[derive(Debug)]\npub enum BindFormat {\n    All(FormatCode),\n    PerColumn(Vec\u003cFormatCode\u003e),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","describe.rs"],"content":"#[derive(Debug)]\npub enum Describe {\n    Portal(String),\n    PreparedStatement(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","execute.rs"],"content":"#[derive(Debug)]\npub struct Execute {\n    pub portal: String,\n    pub max_rows: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","mod.rs"],"content":"pub mod startup;\npub use startup::*;\n\npub mod describe;\npub use describe::*;\n\npub mod parse;\npub use parse::*;\n\npub mod bind_format;\npub use bind_format::*;\n\npub mod bind;\npub use bind::*;\n\npub mod execute;\npub use execute::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","parse.rs"],"content":"use crate::pgwire::protocol::DataTypeOid;\n\n#[derive(Debug)]\npub struct Parse {\n    pub prepared_statement_name: String,\n    pub query: String,\n    pub parameter_types: Vec\u003cDataTypeOid\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","startup.rs"],"content":"use std::collections::HashMap;\n\n#[derive(Debug)]\npub struct Startup {\n    pub requested_protocol_version: (i16, i16),\n    pub parameters: HashMap\u003cString, String\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","mod.rs"],"content":"pub mod backend;\npub mod client;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","mod.rs"],"content":"pub mod data_types;\npub use data_types::*;\n\npub mod format_code;\npub use format_code::*;\n\npub mod sql_state;\npub use sql_state::*;\n\npub mod severity;\npub use severity::*;\n\npub mod message;\npub use message::*;\n\npub mod connection_codec;\npub use connection_codec::*;\n\npub mod protocol_error;\npub use protocol_error::*;\n\npub mod constants;\npub use constants::*;\n\npub mod extension;\npub use extension::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","protocol_error.rs"],"content":"#[derive(thiserror::Error, Debug)]\npub enum ProtocolError {\n    #[error(\"io error: {0}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"utf8 error: {0}\")]\n    Utf8(#[from] std::string::FromUtf8Error),\n    #[error(\"parsing error\")]\n    ParserError,\n    #[error(\"invalid message type: {0}\")]\n    InvalidMessageType(u8),\n    #[error(\"invalid format code: {0}\")]\n    InvalidFormatCode(i16),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","severity.rs"],"content":"#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Severity(pub \u0026'static str);\n\nimpl Severity {\n    pub const ERROR: Severity = Severity(\"ERROR\");\n    pub const FATAL: Severity = Severity(\"FATAL\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","sql_state.rs"],"content":"#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SqlState(pub \u0026'static str);\n\nimpl SqlState {\n    pub const SUCCESSFUL_COMPLETION: SqlState = SqlState(\"00000\");\n    pub const FEATURE_NOT_SUPPORTED: SqlState = SqlState(\"0A000\");\n    pub const INVALID_CURSOR_NAME: SqlState = SqlState(\"34000\");\n    pub const CONNECTION_EXCEPTION: SqlState = SqlState(\"08000\");\n    pub const INVALID_SQL_STATEMENT_NAME: SqlState = SqlState(\"26000\");\n    pub const DATA_EXCEPTION: SqlState = SqlState(\"22000\");\n    pub const PROTOCOL_VIOLATION: SqlState = SqlState(\"08P01\");\n    pub const SYNTAX_ERROR: SqlState = SqlState(\"42601\");\n    pub const INVALID_DATETIME_FORMAT: SqlState = SqlState(\"22007\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","channel.rs"],"content":"use tokio::sync::oneshot::Sender;\n\nuse crate::{ast::SQLStatement, errors::RRDBError, executor::result::ExecuteResult};\n\n#[derive(Debug)]\npub struct ChannelRequest {\n    pub statement: SQLStatement,\n    pub connection_id: String,\n    pub response_sender: Sender\u003cChannelResponse\u003e,\n}\n\n#[derive(Debug)]\npub struct ChannelResponse {\n    pub result: Result\u003cExecuteResult, RRDBError\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","client.rs"],"content":"use std::net::IpAddr;\n\n#[derive(Clone, Debug)]\npub struct ClientInfo {\n    pub ip: IpAddr,\n    pub connection_id: String,\n    pub database: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","mod.rs"],"content":"pub mod channel;\npub mod client;\npub mod predule;\n#[allow(clippy::module_inception)]\npub mod server;\npub mod shared_state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","predule.rs"],"content":"pub use super::channel::*;\npub use super::client::*;\npub use super::server::*;\npub use super::shared_state::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","server.rs"],"content":"use std::sync::Arc;\n\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::global::GlobalConfig;\nuse crate::executor::predule::Executor;\nuse crate::logger::predule::Logger;\nuse crate::pgwire::predule::Connection;\nuse crate::server::channel::ChannelResponse;\nuse crate::server::predule::{ChannelRequest, SharedState};\n\nuse futures::future::join_all;\nuse tokio::net::TcpListener;\nuse tokio::sync::mpsc;\n\nuse super::client::ClientInfo;\n\npub struct Server {\n    pub config: Arc\u003cGlobalConfig\u003e,\n}\n\nimpl Server {\n    pub fn new(config: GlobalConfig) -\u003e Self {\n        Self {\n            config: Arc::new(config),\n        }\n    }\n\n    /// 메인 서버 루프.\n    /// 여러개의 태스크 제어\n    pub async fn run(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // TODO: 인덱스 로딩 등 기본 로직 실행.\n\n        let (request_sender, mut request_receiver) = mpsc::channel::\u003cChannelRequest\u003e(1000);\n\n        // background task\n        // 쿼리 실행 요청을 전달받음\n        let config = self.config.clone();\n\n        let background_task = tokio::spawn(async move {\n            while let Some(request) = request_receiver.recv().await {\n                let config = config.clone();\n\n                // 쿼리 실행 태스크\n                tokio::spawn(async move {\n                    let executor = Executor::new(config);\n                    let result = executor\n                        .process_query(request.statement, request.connection_id)\n                        .await;\n\n                    match result {\n                        Ok(result) =\u003e {\n                            if let Err(_response) = request\n                                .response_sender\n                                .send(ChannelResponse { result: Ok(result) })\n                            {\n                                Logger::error(\"channel send failed\");\n                            }\n                        }\n                        Err(error) =\u003e {\n                            let error = error.to_string();\n                            if let Err(_response) = request.response_sender.send(ChannelResponse {\n                                result: Err(ExecuteError::wrap(error)),\n                            }) {\n                                Logger::error(\"channel send failed\");\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        // connection task\n        // client와의 커넥션 처리 루프\n        let listener = TcpListener::bind((self.config.host.to_owned(), self.config.port as u16))\n            .await\n            .map_err(|error| ExecuteError::wrap(error.to_string()))?;\n\n        let config = self.config.clone();\n        let connection_task = tokio::spawn(async move {\n            loop {\n                let accepted = listener.accept().await;\n\n                let (stream, address) = match accepted {\n                    Ok((stream, address)) =\u003e (stream, address),\n                    Err(error) =\u003e {\n                        Logger::error(format!(\"socket error {:?}\", error));\n                        continue;\n                    }\n                };\n\n                let client_info = ClientInfo {\n                    ip: address.ip(),\n                    connection_id: uuid::Uuid::new_v4().to_string(),\n                    database: \"None\".into(),\n                };\n\n                let shared_state = SharedState {\n                    sender: request_sender.clone(),\n                    client_info,\n                };\n\n                let config = config.clone();\n                tokio::spawn(async move {\n                    let mut conn = Connection::new(shared_state, config);\n                    if let Err(error) = conn.run(stream).await {\n                        Logger::error(format!(\"connection error {:?}\", error));\n                    }\n                });\n            }\n        });\n\n        Logger::info(format!(\n            \"Server is running on {}:{}\",\n            self.config.host, self.config.port\n        ));\n\n        join_all(vec![connection_task, background_task]).await;\n\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[4535184],"length":1,"stats":{"Line":0}},{"line":25,"address":[4535185],"length":1,"stats":{"Line":0}},{"line":31,"address":[4535208,4535200],"length":1,"stats":{"Line":0}},{"line":34,"address":[5242840,5242990],"length":1,"stats":{"Line":0}},{"line":38,"address":[5243034,5243107],"length":1,"stats":{"Line":0}},{"line":40,"address":[5246802,5245812,5245866,5245736,5245696,5246652,5243115,5243252,5245778],"length":1,"stats":{"Line":0}},{"line":41,"address":[4674293],"length":1,"stats":{"Line":0}},{"line":42,"address":[5246342,5246260],"length":1,"stats":{"Line":0}},{"line":45,"address":[5246350,5247111,5247449,5246981,5249197,5246896,5248347,5246936],"length":1,"stats":{"Line":0}},{"line":46,"address":[5246989],"length":1,"stats":{"Line":0}},{"line":47,"address":[5247196,5247396,5247579,5247325],"length":1,"stats":{"Line":0}},{"line":48,"address":[5247216],"length":1,"stats":{"Line":0}},{"line":49,"address":[4692011],"length":1,"stats":{"Line":0}},{"line":51,"address":[5247712],"length":1,"stats":{"Line":0}},{"line":52,"address":[5247742],"length":1,"stats":{"Line":0}},{"line":53,"address":[5248262,5247790,5248129,5247970],"length":1,"stats":{"Line":0}},{"line":55,"address":[5247814,5248121],"length":1,"stats":{"Line":0}},{"line":57,"address":[5248243],"length":1,"stats":{"Line":0}},{"line":60,"address":[5247980],"length":1,"stats":{"Line":0}},{"line":61,"address":[5248076],"length":1,"stats":{"Line":0}},{"line":62,"address":[5248453,5248637,5248772,5248905],"length":1,"stats":{"Line":0}},{"line":63,"address":[5248557,5248509],"length":1,"stats":{"Line":0}},{"line":65,"address":[5248886],"length":1,"stats":{"Line":0}},{"line":75,"address":[5243723,5244123,5243349,5243527,5243267,5243849],"length":1,"stats":{"Line":0}},{"line":76,"address":[4818717],"length":1,"stats":{"Line":0}},{"line":77,"address":[5249266,5244043,5249248],"length":1,"stats":{"Line":0}},{"line":79,"address":[5244017,5244206],"length":1,"stats":{"Line":0}},{"line":80,"address":[5244214,5249542,5249458,5249492,5244393,5249416,5249376,5251176,5251470],"length":1,"stats":{"Line":0}},{"line":81,"address":[5249466],"length":1,"stats":{"Line":0}},{"line":82,"address":[5251402,5249582,5249558,5249451,5249505],"length":1,"stats":{"Line":0}},{"line":84,"address":[5250038,5249848],"length":1,"stats":{"Line":0}},{"line":85,"address":[5249878],"length":1,"stats":{"Line":0}},{"line":86,"address":[5250152],"length":1,"stats":{"Line":0}},{"line":87,"address":[5251279],"length":1,"stats":{"Line":0}},{"line":92,"address":[5250444],"length":1,"stats":{"Line":0}},{"line":93,"address":[5250142],"length":1,"stats":{"Line":0}},{"line":94,"address":[5250316],"length":1,"stats":{"Line":0}},{"line":95,"address":[5250362],"length":1,"stats":{"Line":0}},{"line":98,"address":[5250709],"length":1,"stats":{"Line":0}},{"line":99,"address":[5250546],"length":1,"stats":{"Line":0}},{"line":100,"address":[5250621],"length":1,"stats":{"Line":0}},{"line":103,"address":[5250805,5250872],"length":1,"stats":{"Line":0}},{"line":104,"address":[5251988,5252010,5250880,5252976,5251504,5251589,5251544,5251704],"length":1,"stats":{"Line":0}},{"line":105,"address":[5251597],"length":1,"stats":{"Line":0}},{"line":106,"address":[4692520],"length":1,"stats":{"Line":0}},{"line":107,"address":[5252594],"length":1,"stats":{"Line":0}},{"line":113,"address":[5244589,5244671],"length":1,"stats":{"Line":0}},{"line":115,"address":[5244413,5244561],"length":1,"stats":{"Line":0}},{"line":118,"address":[4818733],"length":1,"stats":{"Line":0}},{"line":120,"address":[5245469],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["/","home","runner","work","rrdb","rrdb","src","server","shared_state.rs"],"content":"use tokio::sync::mpsc::Sender;\n\nuse super::{channel::ChannelRequest, client::ClientInfo};\n\n#[derive(Clone, Debug)]\npub struct SharedState {\n    pub sender: Sender\u003cChannelRequest\u003e,\n    pub client_info: ClientInfo,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","test.rs"],"content":"#![allow(unused_imports)]\n#![allow(dead_code)]\n\npub mod command;\n// pub mod lib;\n\n// use parser::context::ParserContext;\n\n// use crate::ast::predule::{\n//     BinaryOperator, BinaryOperatorExpression, SQLExpression, SelectItem, SelectQuery,\n// };\n// use crate::parser::predule::Parser;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // let text = r#\"\n    // create database asdf;\n    // \"#\n    // .to_owned();\n\n    // let mut parser = Parser::new(text).unwrap();\n\n    // parser.parse(ParserContext::default()).unwrap();\n\n    Ok(())\n}\n","traces":[{"line":15,"address":[483664,484072],"length":1,"stats":{"Line":0}},{"line":25,"address":[483752,483692,483899],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","collection.rs"],"content":"macro_rules! join_vec {\n    ($x:expr) =\u003e {\n        $x\n    };\n    ($x:expr, $($y:expr),+) =\u003e {\n        {\n            let join_fn = |mut lhs: Vec\u003c_\u003e, mut rhs: Vec\u003c_\u003e| -\u003e Vec\u003c_\u003e {\n                lhs.append(\u0026mut rhs);\n                lhs\n            };\n\n            join_fn($x, join_vec!($($y),+))\n        }\n\n    };\n}\n\npub(crate) use join_vec;\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_join_vec() {\n        let v1 = vec![1, 2, 3];\n        let v2 = vec![4, 5, 6];\n\n        assert_eq!(join_vec!(v1), vec![1, 2, 3]);\n        assert_eq!(join_vec!(v1, v2), vec![1, 2, 3, 4, 5, 6]);\n    }\n}\n","traces":[{"line":7,"address":[3136272,3136064,3138102,3138560,3136688,3137686,3137936,3137312,3135814,3136022,3135648,3136230,3136896,3137104,3137728,3138144,3138310,3137270,3136854,3137478,3137894,3135856,3138518,3138352,3136646,3138726,3136480,3137062,3137520,3136438],"length":1,"stats":{"Line":19}},{"line":8,"address":[3136733,3137981,3138397,3136109,3136941,3138189,3135901,3136525,3135693,3136317,3137357,3137565,3137773,3138605,3137149],"length":1,"stats":{"Line":16}},{"line":9,"address":[3137417,3136169,3136585,3137833,3138665,3135961,3136377,3138457,3137209,3135753,3136793,3137625,3137001,3138249,3138041],"length":1,"stats":{"Line":16}},{"line":12,"address":[5564813],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","float.rs"],"content":"use std::{\n    cmp::Ordering,\n    hash::{Hash, Hasher},\n    ops::{Add, Div, Mul, Neg, Sub},\n};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Copy, Debug)]\npub struct Float64 {\n    pub value: f64,\n}\n\nimpl Eq for Float64 {}\n\nimpl Hash for Float64 {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.value.to_ne_bytes().hash(state)\n    }\n}\n\nimpl ToString for Float64 {\n    fn to_string(\u0026self) -\u003e String {\n        self.value.to_string()\n    }\n}\n\nimpl From\u003cf64\u003e for Float64 {\n    fn from(value: f64) -\u003e Self {\n        Float64 { value }\n    }\n}\n\nimpl From\u003cFloat64\u003e for f64 {\n    fn from(value: Float64) -\u003e Self {\n        value.value\n    }\n}\n\nimpl Neg for Float64 {\n    type Output = Self;\n\n    fn neg(self) -\u003e Self::Output {\n        (-self.value).into()\n    }\n}\n\nimpl Add for Float64 {\n    type Output = Self;\n\n    fn add(self, other: Self) -\u003e Self {\n        let result = self.value + other.value;\n        result.into()\n    }\n}\n\nimpl Sub for Float64 {\n    type Output = Self;\n\n    fn sub(self, other: Self) -\u003e Self {\n        let result = self.value - other.value;\n        result.into()\n    }\n}\n\nimpl Mul for Float64 {\n    type Output = Self;\n\n    fn mul(self, other: Self) -\u003e Self {\n        let result = self.value * other.value;\n        result.into()\n    }\n}\n\nimpl Div for Float64 {\n    type Output = Self;\n\n    fn div(self, other: Self) -\u003e Self {\n        let result = self.value / other.value;\n        result.into()\n    }\n}\n\nimpl PartialEq for Float64 {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.value == other.value\n    }\n}\n\nimpl PartialOrd for Float64 {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Float64 {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        if self == other {\n            Ordering::Equal\n        } else {\n            let lhs = self.value;\n            let rhs = other.value;\n\n            match lhs.partial_cmp(\u0026rhs) {\n                Some(order) =\u003e order,\n                None =\u003e Ordering::Less,\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_float64_hash() {\n        use super::Float64;\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        Float64 { value: 1.0 }.hash(\u0026mut hasher);\n        let hash1 = hasher.finish();\n\n        let mut hasher = DefaultHasher::new();\n        Float64 { value: 1.0 }.hash(\u0026mut hasher);\n        let hash2 = hasher.finish();\n\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_float64_to_string() {\n        use super::Float64;\n\n        let f = Float64 { value: 1.0 };\n        assert_eq!(f.to_string(), \"1\");\n    }\n\n    #[test]\n    fn test_float64_from_f64() {\n        use super::Float64;\n\n        let f: Float64 = 1.0.into();\n        assert_eq!(f, Float64 { value: 1.0 });\n    }\n\n    #[test]\n    fn test_float64_from_float64() {\n        use super::Float64;\n\n        let f: f64 = Float64 { value: 1.0 }.into();\n        assert_eq!(f, 1.0);\n    }\n\n    #[test]\n    fn test_float64_neg() {\n        use super::Float64;\n\n        let f = Float64 { value: 1.0 };\n        assert_eq!(-f, Float64 { value: -1.0 });\n    }\n\n    #[test]\n    fn test_float64_add() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 + f2, Float64 { value: 3.0 });\n    }\n\n    #[test]\n    fn test_float64_sub() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 - f2, Float64 { value: -1.0 });\n    }\n\n    #[test]\n    fn test_float64_mul() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 * f2, Float64 { value: 2.0 });\n    }\n\n    #[test]\n    fn test_float64_div() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 / f2, Float64 { value: 0.5 });\n    }\n\n    #[test]\n    fn test_float64_eq() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(PartialEq::eq(\u0026f1, \u0026f2), true);\n    }\n\n    #[test]\n    fn test_float64_partial_cmp() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Less)\n        );\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Equal)\n        );\n\n        let f1 = Float64 { value: 2.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Greater)\n        );\n    }\n\n    #[test]\n    fn test_float64_cmp() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Less);\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Equal);\n\n        let f1 = Float64 { value: 2.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Greater);\n\n        let f1 = Float64 { value: f64::NAN };\n        let f2 = Float64 { value: f64::NAN };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Less);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[5039360],"length":1,"stats":{"Line":1}},{"line":24,"address":[5039377],"length":1,"stats":{"Line":1}},{"line":29,"address":[5039408],"length":1,"stats":{"Line":1}},{"line":35,"address":[5039424],"length":1,"stats":{"Line":1}},{"line":43,"address":[5039440],"length":1,"stats":{"Line":1}},{"line":44,"address":[5039446],"length":1,"stats":{"Line":1}},{"line":51,"address":[5039488],"length":1,"stats":{"Line":1}},{"line":52,"address":[5039503],"length":1,"stats":{"Line":1}},{"line":53,"address":[5039513],"length":1,"stats":{"Line":1}},{"line":60,"address":[5039536],"length":1,"stats":{"Line":1}},{"line":61,"address":[5039551],"length":1,"stats":{"Line":1}},{"line":62,"address":[5039561],"length":1,"stats":{"Line":1}},{"line":69,"address":[5039584],"length":1,"stats":{"Line":1}},{"line":70,"address":[5039599],"length":1,"stats":{"Line":1}},{"line":71,"address":[5039609],"length":1,"stats":{"Line":1}},{"line":78,"address":[5039632],"length":1,"stats":{"Line":1}},{"line":79,"address":[5039647],"length":1,"stats":{"Line":1}},{"line":80,"address":[5039657],"length":1,"stats":{"Line":1}},{"line":85,"address":[5039680],"length":1,"stats":{"Line":1}},{"line":86,"address":[5039690],"length":1,"stats":{"Line":1}},{"line":91,"address":[5039712],"length":1,"stats":{"Line":1}},{"line":92,"address":[5039726],"length":1,"stats":{"Line":1}},{"line":97,"address":[5039744],"length":1,"stats":{"Line":1}},{"line":98,"address":[5039855,5039758],"length":1,"stats":{"Line":2}},{"line":99,"address":[5039850],"length":1,"stats":{"Line":1}},{"line":101,"address":[5039777],"length":1,"stats":{"Line":1}},{"line":102,"address":[5039792],"length":1,"stats":{"Line":1}},{"line":104,"address":[5039807],"length":1,"stats":{"Line":1}},{"line":105,"address":[5039864],"length":1,"stats":{"Line":1}},{"line":106,"address":[5039857],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","macos.rs"],"content":"// MacOS에서 고정 환경변수를 가져옵니다.\npub fn get_profile_path() -\u003e String {\n    let username = whoami::username();\n    let user_path = format!(\"/Users/{}\", username);\n    let profile_path = format!(\"{}/.zshenv\", user_path);\n\n    profile_path\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_profile_path() {\n        let username = whoami::username();\n        let user_path = format!(\"/Users/{}\", username);\n        let profile_path = format!(\"{}/.zshenv\", user_path);\n\n        assert_eq!(get_profile_path(), profile_path);\n    }\n}\n","traces":[{"line":2,"address":[4004209,4003664],"length":1,"stats":{"Line":1}},{"line":4,"address":[4003874],"length":1,"stats":{"Line":1}},{"line":5,"address":[4004099],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","mod.rs"],"content":"pub mod collection;\npub mod float;\npub mod macos;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","predule.rs"],"content":"pub use super::float::*;\npub use super::macos::*;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","runner","work","rrdb","rrdb","src","ast","commands","connect.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ConnectCommand {\n    pub database_name: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","commands","mod.rs"],"content":"pub mod connect;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dcl","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","alter_database.rs"],"content":"use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nALTER DATABASE database_name\n{\n    RENAME TO new_database_name\n};\n*/\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AlterDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub action: Option\u003cAlterDatabaseAction\u003e,\n}\n\nimpl AlterDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        AlterDatabaseQuery {\n            database_name: None,\n            action: None,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_action(mut self, action: AlterDatabaseAction) -\u003e Self {\n        self.action = Some(action);\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::AlterDatabase(self))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum AlterDatabaseAction {\n    RenameTo(AlterDatabaseRenameTo),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AlterDatabaseRenameTo {\n    pub name: String,\n}\n","traces":[{"line":16,"address":[1868144],"length":1,"stats":{"Line":2}},{"line":23,"address":[1868396,1868240],"length":1,"stats":{"Line":2}},{"line":24,"address":[1868350,1868267],"length":1,"stats":{"Line":4}},{"line":25,"address":[1868376],"length":1,"stats":{"Line":2}},{"line":28,"address":[1868416,1868574],"length":1,"stats":{"Line":1}},{"line":29,"address":[1868527,1868443],"length":1,"stats":{"Line":2}},{"line":30,"address":[1868554],"length":1,"stats":{"Line":1}},{"line":33,"address":[1868608],"length":1,"stats":{"Line":1}},{"line":34,"address":[1868625],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","alter_table.rs"],"content":"//use crate::ast::enums::SQLStatement;\nuse crate::ast::{\n    types::{Column, DataType, SQLExpression, TableName},\n    SQLStatement,\n};\n\nuse super::drop_database::DDLStatement;\n\n/*\nALTER TABLE [database_name.]table_name\n{\n    [RENAME TO new_table_name] |\n    [RENAME COLUMN from_name TO new_name] |\n    [ALTER COLUMN column_name ...] |\n    [DROP COLUMN column_name] |\n    [ADD COLUMN column_name column_type ... ] ...\n};\n*/\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub action: AlterTableAction,\n}\n\nimpl AlterTableQuery {\n    pub fn builder() -\u003e Self {\n        AlterTableQuery {\n            table: None,\n            action: AlterTableAction::None,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_action(mut self, action: AlterTableAction) -\u003e Self {\n        self.action = action;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::AlterTableQuery(self))\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum AlterTableAction {\n    AlterTableRenameTo(AlterTableRenameTo),\n    AddColumn(AlterTableAddColumn),\n    AlterColumn(AlterTableAlterColumn),\n    DropColumn(AlterTableDropColumn),\n    RenameColumn(AlterTableRenameColumn),\n    None,\n}\n\n// 테이블명 변경\n// ALTER TABLE [database_name.]table_name RENAME TO new_table_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableRenameTo {\n    pub name: String,\n}\n\nimpl From\u003cAlterTableRenameTo\u003e for AlterTableAction {\n    fn from(value: AlterTableRenameTo) -\u003e AlterTableAction {\n        AlterTableAction::AlterTableRenameTo(value)\n    }\n}\n\n// 컬럼 이름 변경\n// ALTER TABLE [database_name.]table_name RENAME COLUMN from_name TO new_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableRenameColumn {\n    pub from_name: String,\n    pub to_name: String,\n}\n\nimpl From\u003cAlterTableRenameColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableRenameColumn) -\u003e AlterTableAction {\n        AlterTableAction::RenameColumn(value)\n    }\n}\n\n// 컬럼 추가\n// ALTER TABLE [database_name.]table_name ADD COLUMN column_name column_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'];\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableAddColumn {\n    pub column: Column,\n}\n\nimpl From\u003cAlterTableAddColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableAddColumn) -\u003e AlterTableAction {\n        AlterTableAction::AddColumn(value)\n    }\n}\n\n// 컬럼 삭제\n// ALTER TABLE [database_name.]table_name DROP COLUMN column_name;\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterTableDropColumn {\n    pub column_name: String,\n}\n\nimpl From\u003cAlterTableDropColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableDropColumn) -\u003e AlterTableAction {\n        AlterTableAction::DropColumn(value)\n    }\n}\n\n// 컬럼 변경\n// ALTER COLUMN column_name [TYPE type_name] [{SET | DROP} NOT NULL] [{SET | DROP} DEFAULT default_expr] [{SET | DROP} COMMENT 'comment']\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterTableAlterColumn {\n    pub column_name: String,\n    pub action: AlterColumnAction,\n}\n\nimpl From\u003cAlterTableAlterColumn\u003e for AlterTableAction {\n    fn from(value: AlterTableAlterColumn) -\u003e AlterTableAction {\n        AlterTableAction::AlterColumn(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum AlterColumnAction {\n    AlterColumnSetType(AlterColumnSetType),\n    AlterColumnSetNotNull,\n    AlterColumnDropNotNull,\n    AlterColumnSetDefault(AlterColumnSetDefault),\n    AlterColumnDropDefault(AlterColumnDropDefault),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnSetType {\n    pub data_type: DataType,\n}\n\nimpl From\u003cAlterColumnSetType\u003e for AlterColumnAction {\n    fn from(value: AlterColumnSetType) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetType(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnSetNotNull {}\n\nimpl From\u003cAlterColumnSetNotNull\u003e for AlterColumnAction {\n    fn from(_value: AlterColumnSetNotNull) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetNotNull\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnDropNotNull {}\n\nimpl From\u003cAlterColumnDropNotNull\u003e for AlterColumnAction {\n    fn from(_value: AlterColumnDropNotNull) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnDropNotNull\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct AlterColumnSetDefault {\n    pub expression: SQLExpression,\n}\n\nimpl From\u003cAlterColumnSetDefault\u003e for AlterColumnAction {\n    fn from(value: AlterColumnSetDefault) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnSetDefault(value)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct AlterColumnDropDefault {}\n\nimpl From\u003cAlterColumnDropDefault\u003e for AlterColumnAction {\n    fn from(value: AlterColumnDropDefault) -\u003e AlterColumnAction {\n        AlterColumnAction::AlterColumnDropDefault(value)\n    }\n}\n","traces":[{"line":26,"address":[5023040],"length":1,"stats":{"Line":2}},{"line":33,"address":[5023152,5023340],"length":1,"stats":{"Line":2}},{"line":34,"address":[5023288,5023179],"length":1,"stats":{"Line":4}},{"line":35,"address":[5023320],"length":1,"stats":{"Line":2}},{"line":38,"address":[5023501,5023360],"length":1,"stats":{"Line":2}},{"line":39,"address":[5023461,5023392],"length":1,"stats":{"Line":4}},{"line":40,"address":[5023481],"length":1,"stats":{"Line":2}},{"line":43,"address":[5023520],"length":1,"stats":{"Line":2}},{"line":44,"address":[5023537],"length":1,"stats":{"Line":2}},{"line":66,"address":[5023616],"length":1,"stats":{"Line":1}},{"line":67,"address":[5023619],"length":1,"stats":{"Line":1}},{"line":80,"address":[5023664],"length":1,"stats":{"Line":1}},{"line":81,"address":[5023681],"length":1,"stats":{"Line":1}},{"line":93,"address":[5023728],"length":1,"stats":{"Line":2}},{"line":94,"address":[5023736],"length":1,"stats":{"Line":2}},{"line":106,"address":[5023760],"length":1,"stats":{"Line":2}},{"line":107,"address":[5023763],"length":1,"stats":{"Line":2}},{"line":120,"address":[5023808],"length":1,"stats":{"Line":1}},{"line":121,"address":[5023825],"length":1,"stats":{"Line":1}},{"line":140,"address":[5023872],"length":1,"stats":{"Line":1}},{"line":141,"address":[5023885],"length":1,"stats":{"Line":2}},{"line":149,"address":[5023920],"length":1,"stats":{"Line":1}},{"line":150,"address":[5023923],"length":1,"stats":{"Line":1}},{"line":158,"address":[5023952],"length":1,"stats":{"Line":1}},{"line":159,"address":[5023955],"length":1,"stats":{"Line":1}},{"line":169,"address":[5023984],"length":1,"stats":{"Line":1}},{"line":170,"address":[5023992],"length":1,"stats":{"Line":1}},{"line":178,"address":[5024016],"length":1,"stats":{"Line":1}},{"line":179,"address":[5024019],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":29},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_database.rs"],"content":"pub use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nCREATE DATABASE [IF NOT EXISTS] database_name;\n*/\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct CreateDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub if_not_exists: bool,\n}\n\nimpl CreateDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        CreateDatabaseQuery {\n            database_name: None,\n            if_not_exists: false,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateDatabaseQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[1862816],"length":1,"stats":{"Line":1}},{"line":20,"address":[1863056,1862880],"length":1,"stats":{"Line":1}},{"line":21,"address":[1862907,1862995],"length":1,"stats":{"Line":4}},{"line":22,"address":[1863021],"length":1,"stats":{"Line":2}},{"line":25,"address":[1863088],"length":1,"stats":{"Line":2}},{"line":26,"address":[1863102],"length":1,"stats":{"Line":2}},{"line":27,"address":[1863108],"length":1,"stats":{"Line":2}},{"line":30,"address":[1863152],"length":1,"stats":{"Line":2}},{"line":31,"address":[1863172],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_index.rs"],"content":"use crate::ast::{\n    types::{Column, TableName},\n    DDLStatement, SQLStatement,\n};\n\n/*\nCREATE [ UNIQUE ] INDEX [ IF NOT EXISTS ] name ON table_name\n    ( column_name [, ...] )\n*/\n\n#[derive(Clone, Debug, PartialEq)]\npub struct CreateIndexQuery {\n    pub index_name: String,\n    pub table: TableName,\n    pub columns: Vec\u003cColumn\u003e,\n    pub is_unique: bool,\n    pub if_not_exists: bool,\n}\n\nimpl CreateIndexQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            table: Default::default(),\n            columns: vec![],\n            is_unique: false,\n            if_not_exists: false,\n            index_name: \"\".into(),\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = table;\n        self\n    }\n\n    pub fn set_index_name(mut self, index_name: String) -\u003e Self {\n        self.index_name = index_name;\n        self\n    }\n\n    pub fn add_column(mut self, column: Column) -\u003e Self {\n        self.columns.push(column);\n        self\n    }\n\n    pub fn set_unique(mut self, unique: bool) -\u003e Self {\n        self.is_unique = unique;\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateIndexQuery(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::DataType;\n\n    use super::*;\n\n    #[test]\n    fn test_create_index() {\n        let query = CreateIndexQuery::builder()\n            .set_table(TableName::new(None, \"table_name\".into()))\n            .set_index_name(\"index_name\".into())\n            .add_column(\n                Column::builder()\n                    .set_name(\"column_name\".into())\n                    .set_data_type(DataType::Boolean)\n                    .build(),\n            )\n            .set_unique(true)\n            .set_if_not_exists(true)\n            .build();\n\n        let expected = SQLStatement::DDL(DDLStatement::CreateIndexQuery(CreateIndexQuery {\n            table: TableName::new(None, \"table_name\".into()),\n            index_name: \"index_name\".into(),\n            columns: vec![Column::builder()\n                .set_name(\"column_name\".into())\n                .set_data_type(DataType::Boolean)\n                .build()],\n            is_unique: true,\n            if_not_exists: true,\n        }));\n\n        assert_eq!(query, expected);\n    }\n}\n","traces":[{"line":21,"address":[4228013,4227776],"length":1,"stats":{"Line":1}},{"line":23,"address":[4227798],"length":1,"stats":{"Line":1}},{"line":24,"address":[4227808],"length":1,"stats":{"Line":1}},{"line":27,"address":[4227849],"length":1,"stats":{"Line":1}},{"line":31,"address":[4228032,4228185],"length":1,"stats":{"Line":1}},{"line":32,"address":[4228064,4228141],"length":1,"stats":{"Line":2}},{"line":33,"address":[4228165],"length":1,"stats":{"Line":1}},{"line":36,"address":[4228208,4228355],"length":1,"stats":{"Line":1}},{"line":37,"address":[4228313,4228240],"length":1,"stats":{"Line":2}},{"line":38,"address":[4228335],"length":1,"stats":{"Line":1}},{"line":41,"address":[4228384,4228493],"length":1,"stats":{"Line":1}},{"line":42,"address":[4228424],"length":1,"stats":{"Line":1}},{"line":43,"address":[4228473],"length":1,"stats":{"Line":1}},{"line":46,"address":[4228512],"length":1,"stats":{"Line":1}},{"line":47,"address":[4228535],"length":1,"stats":{"Line":1}},{"line":48,"address":[4228540],"length":1,"stats":{"Line":1}},{"line":51,"address":[4228560],"length":1,"stats":{"Line":1}},{"line":52,"address":[4228583],"length":1,"stats":{"Line":1}},{"line":53,"address":[4228588],"length":1,"stats":{"Line":1}},{"line":56,"address":[4228608],"length":1,"stats":{"Line":1}},{"line":57,"address":[4228625],"length":1,"stats":{"Line":1}}],"covered":21,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","create_table.rs"],"content":"use crate::ast::{\n    types::{Column, ForeignKey, TableName, TableOptions, UniqueKey},\n    DDLStatement, SQLStatement,\n};\n\n/*\nCREATE TABLE [IF NOT EXISTS] [database_name.]table_name (\n    column_name data_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'],\n    column_name data_type [NOT NULL | NULL] [PRIMARY KEY] [COMMENT 'comment'],\n    ...\n    PRIMARY KEY (column_name),\n    UNIQUE (column_name),\n    FOREIGN KEY (column_name) REFERENCES table_name (column_name),\n    FOREIGN KEY (column_name) REFERENCES table_name (column_name),\n    ...\n);\n*/\n\n#[derive(Clone, Debug, PartialEq)]\npub struct CreateTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub columns: Vec\u003cColumn\u003e,\n    pub primary_key: Vec\u003cString\u003e,\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub unique_keys: Vec\u003cUniqueKey\u003e,\n    pub table_options: Option\u003cTableOptions\u003e,\n    pub if_not_exists: bool,\n}\n\nimpl CreateTableQuery {\n    pub fn builder() -\u003e Self {\n        CreateTableQuery {\n            table: None,\n            columns: vec![],\n            primary_key: vec![],\n            foreign_keys: vec![],\n            unique_keys: vec![],\n            table_options: None,\n            if_not_exists: false,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_table_option(mut self, option: TableOptions) -\u003e Self {\n        self.table_options = Some(option);\n        self\n    }\n\n    pub fn add_column(mut self, column: Column) -\u003e Self {\n        self.columns.push(column);\n        self\n    }\n\n    pub fn set_primary_key(mut self, columns: Vec\u003cString\u003e) -\u003e Self {\n        self.primary_key = columns;\n        self\n    }\n\n    pub fn add_unique_key(mut self, unique_key: UniqueKey) -\u003e Self {\n        self.unique_keys.push(unique_key);\n        self\n    }\n\n    pub fn set_if_not_exists(mut self, if_not_exists: bool) -\u003e Self {\n        self.if_not_exists = if_not_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::CreateTableQuery(self))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::DataType;\n\n    use super::*;\n\n    #[test]\n    fn test_create_table() {\n        let query = CreateTableQuery::builder()\n            .set_table(TableName::new(None, \"table_name\".into()))\n            .add_column(\n                Column::builder()\n                    .set_name(\"column_name\".into())\n                    .set_data_type(DataType::Int)\n                    .set_not_null(true)\n                    .set_primary_key(true)\n                    .set_comment(\"comment\".into())\n                    .build(),\n            )\n            .set_primary_key(vec![\"column_name\".into()])\n            .set_table_option(TableOptions {})\n            .add_unique_key(UniqueKey {\n                key_name: \"unique_key\".into(),\n                database_name: None,\n                columns: vec![\"column_name\".into()],\n            })\n            .set_if_not_exists(true)\n            .build();\n\n        let expected = SQLStatement::DDL(DDLStatement::CreateTableQuery(CreateTableQuery {\n            table: Some(TableName::new(None, \"table_name\".into())),\n            columns: vec![Column {\n                name: \"column_name\".into(),\n                data_type: DataType::Int,\n                comment: \"comment\".into(),\n                default: None,\n                not_null: true,\n                primary_key: true,\n            }],\n            primary_key: vec![\"column_name\".into()],\n            foreign_keys: vec![],\n            unique_keys: vec![UniqueKey {\n                key_name: \"unique_key\".into(),\n                database_name: None,\n                columns: vec![\"column_name\".into()],\n            }],\n            table_options: Some(TableOptions {}),\n            if_not_exists: true,\n        }));\n\n        assert_eq!(query, expected);\n    }\n}\n","traces":[{"line":31,"address":[5735987,5735568],"length":1,"stats":{"Line":1}},{"line":34,"address":[5735604],"length":1,"stats":{"Line":1}},{"line":35,"address":[5735648],"length":1,"stats":{"Line":1}},{"line":36,"address":[5735703],"length":1,"stats":{"Line":1}},{"line":37,"address":[5735756],"length":1,"stats":{"Line":1}},{"line":43,"address":[5736016,5736192],"length":1,"stats":{"Line":1}},{"line":44,"address":[5736043,5736143],"length":1,"stats":{"Line":2}},{"line":45,"address":[5736172],"length":1,"stats":{"Line":1}},{"line":48,"address":[5736224],"length":1,"stats":{"Line":1}},{"line":49,"address":[5736236],"length":1,"stats":{"Line":1}},{"line":50,"address":[5736253],"length":1,"stats":{"Line":1}},{"line":53,"address":[5736393,5736288],"length":1,"stats":{"Line":1}},{"line":54,"address":[5736328],"length":1,"stats":{"Line":1}},{"line":55,"address":[5736373],"length":1,"stats":{"Line":1}},{"line":58,"address":[5736569,5736416],"length":1,"stats":{"Line":1}},{"line":59,"address":[5736526,5736448],"length":1,"stats":{"Line":2}},{"line":60,"address":[5736549],"length":1,"stats":{"Line":1}},{"line":63,"address":[5736701,5736592],"length":1,"stats":{"Line":1}},{"line":64,"address":[5736632],"length":1,"stats":{"Line":1}},{"line":65,"address":[5736681],"length":1,"stats":{"Line":1}},{"line":68,"address":[5736720],"length":1,"stats":{"Line":1}},{"line":69,"address":[5736743],"length":1,"stats":{"Line":1}},{"line":70,"address":[5736751],"length":1,"stats":{"Line":1}},{"line":73,"address":[5736784],"length":1,"stats":{"Line":1}},{"line":74,"address":[5736801],"length":1,"stats":{"Line":1}}],"covered":25,"coverable":25},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","drop_database.rs"],"content":"pub use crate::ast::{DDLStatement, SQLStatement};\n\n/*\nDROP DATABASE [IF EXISTS] database_name;\n*/\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DropDatabaseQuery {\n    pub database_name: Option\u003cString\u003e,\n    pub if_exists: bool,\n}\n\nimpl DropDatabaseQuery {\n    pub fn builder() -\u003e Self {\n        DropDatabaseQuery {\n            database_name: None,\n            if_exists: false,\n        }\n    }\n\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.database_name = Some(name);\n        self\n    }\n\n    pub fn set_if_exists(mut self, set_if_exists: bool) -\u003e Self {\n        self.if_exists = set_if_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::DropDatabaseQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[4144272],"length":1,"stats":{"Line":1}},{"line":20,"address":[4144512,4144336],"length":1,"stats":{"Line":1}},{"line":21,"address":[4144451,4144363],"length":1,"stats":{"Line":2}},{"line":22,"address":[4144477],"length":1,"stats":{"Line":1}},{"line":25,"address":[4144544],"length":1,"stats":{"Line":1}},{"line":26,"address":[4144558],"length":1,"stats":{"Line":1}},{"line":27,"address":[4144564],"length":1,"stats":{"Line":1}},{"line":30,"address":[4144608],"length":1,"stats":{"Line":1}},{"line":31,"address":[4144628],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","drop_table.rs"],"content":"use crate::ast::{types::TableName, DDLStatement, SQLStatement};\n\n/*\nDROP TABLE [IF EXISTS] [database_name.]table_name;\n*/\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DropTableQuery {\n    pub table: Option\u003cTableName\u003e,\n    pub if_exists: bool,\n}\n\nimpl DropTableQuery {\n    pub fn builder() -\u003e Self {\n        DropTableQuery {\n            table: None,\n            if_exists: false,\n        }\n    }\n\n    pub fn set_table(mut self, table: TableName) -\u003e Self {\n        self.table = Some(table);\n        self\n    }\n\n    pub fn set_if_exists(mut self, set_if_exists: bool) -\u003e Self {\n        self.if_exists = set_if_exists;\n        self\n    }\n\n    pub fn build(self) -\u003e SQLStatement {\n        SQLStatement::DDL(DDLStatement::DropTableQuery(self))\n    }\n}\n","traces":[{"line":13,"address":[7538304],"length":1,"stats":{"Line":1}},{"line":20,"address":[7538384,7538548],"length":1,"stats":{"Line":1}},{"line":21,"address":[7538503,7538411],"length":1,"stats":{"Line":2}},{"line":22,"address":[7538528],"length":1,"stats":{"Line":1}},{"line":25,"address":[7538576],"length":1,"stats":{"Line":1}},{"line":26,"address":[7538599],"length":1,"stats":{"Line":1}},{"line":27,"address":[7538604],"length":1,"stats":{"Line":1}},{"line":30,"address":[7538624],"length":1,"stats":{"Line":1}},{"line":31,"address":[7538641],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","ddl","mod.rs"],"content":"pub mod alter_database;\npub mod alter_table;\npub mod create_database;\npub mod create_index;\npub mod create_table;\npub mod drop_database;\npub mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","delete.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::parts::{_where::WhereClause, target::UpdateTarget};\n\n#[derive(Clone, Debug, PartialEq, Default)]\npub struct DeleteQuery {\n    pub from_table: Option\u003cUpdateTarget\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n}\n\nimpl DeleteQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            from_table: None,\n            where_clause: None,\n        }\n    }\n\n    pub fn set_from_table(mut self, from: TableName) -\u003e Self {\n        self.from_table = Some(from.into());\n        self\n    }\n\n    pub fn set_from_alias(mut self, alias: String) -\u003e Self {\n        if self.from_table.is_some() {\n            self.from_table = self.from_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cDeleteQuery\u003e for SQLStatement {\n    fn from(value: DeleteQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::DeleteQuery(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    use super::*;\n\n    #[test]\n    fn test_builder_all() {\n        let delete_query = DeleteQuery::builder()\n            .set_from_table(TableName::new(None, \"table\".into()))\n            .set_where(WhereClause {\n                expression: SQLExpression::String(\"a\".into()),\n            })\n            .set_from_alias(\"alias\".into())\n            .build();\n\n        assert_eq!(\n            delete_query,\n            DeleteQuery {\n                from_table: Some(UpdateTarget {\n                    table: TableName::new(None, \"table\".into()),\n                    alias: Some(\"alias\".into()),\n                }),\n                where_clause: Some(WhereClause {\n                    expression: SQLExpression::String(\"a\".into()),\n                }),\n            }\n        );\n    }\n}\n","traces":[{"line":12,"address":[6205232],"length":1,"stats":{"Line":1}},{"line":19,"address":[6205344,6205607],"length":1,"stats":{"Line":1}},{"line":20,"address":[6205438,6205377],"length":1,"stats":{"Line":2}},{"line":21,"address":[6205584],"length":1,"stats":{"Line":1}},{"line":24,"address":[6206070,6205632,6206103],"length":1,"stats":{"Line":1}},{"line":25,"address":[6205770,6205988,6205666],"length":1,"stats":{"Line":3}},{"line":26,"address":[3435600,3435782],"length":1,"stats":{"Line":2}},{"line":27,"address":[3435627,3435735],"length":1,"stats":{"Line":2}},{"line":28,"address":[3435762],"length":1,"stats":{"Line":1}},{"line":31,"address":[6205786],"length":1,"stats":{"Line":1}},{"line":34,"address":[6206144,6206356],"length":1,"stats":{"Line":1}},{"line":35,"address":[6206307,6206171],"length":1,"stats":{"Line":2}},{"line":36,"address":[6206336],"length":1,"stats":{"Line":1}},{"line":39,"address":[6206384],"length":1,"stats":{"Line":1}},{"line":40,"address":[6206392],"length":1,"stats":{"Line":1}},{"line":45,"address":[5046384],"length":1,"stats":{"Line":1}},{"line":46,"address":[5046401],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","between.rs"],"content":"use std::ops::Not;\n\nuse crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::not_between::NotBetweenExpression;\n\n// a BETWEEN x AND y\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct BetweenExpression {\n    pub a: SQLExpression,\n    pub x: SQLExpression,\n    pub y: SQLExpression,\n}\n\nimpl From\u003cBetweenExpression\u003e for SQLExpression {\n    fn from(value: BetweenExpression) -\u003e SQLExpression {\n        SQLExpression::Between(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cBetweenExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cBetweenExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::Between(value)\n    }\n}\n\nimpl From\u003cBetweenExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: BetweenExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Between(Box::new(value))))\n    }\n}\n\nimpl Not for BetweenExpression {\n    type Output = NotBetweenExpression;\n\n    fn not(self) -\u003e Self::Output {\n        NotBetweenExpression {\n            a: self.a,\n            x: self.x,\n            y: self.y,\n        }\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_Box_BetweenExpression_for_SQLExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: SQLExpression = Box::new(between).into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::Between(Box::new(BetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into())\n            }))\n        );\n    }\n\n    #[test]\n    fn test_From_BetweenExpression_for_Option_Box_SQLExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: Option\u003cBox\u003cSQLExpression\u003e\u003e = between.into();\n        assert_eq!(\n            sql_expression,\n            Some(Box::new(SQLExpression::Between(Box::new(\n                BetweenExpression {\n                    a: SQLExpression::String(\"a\".into()),\n                    x: SQLExpression::String(\"x\".into()),\n                    y: SQLExpression::String(\"y\".into())\n                }\n            ))))\n        );\n    }\n\n    #[test]\n    fn test_Not_for_BetweenExpression() {\n        use super::BetweenExpression;\n        let between = BetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let not_between = !between;\n        assert_eq!(\n            not_between,\n            super::NotBetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into())\n            }\n        );\n    }\n}\n","traces":[{"line":17,"address":[8194704],"length":1,"stats":{"Line":1}},{"line":18,"address":[8194825],"length":1,"stats":{"Line":1}},{"line":23,"address":[8194848],"length":1,"stats":{"Line":1}},{"line":24,"address":[8194856],"length":1,"stats":{"Line":1}},{"line":29,"address":[7796976],"length":1,"stats":{"Line":1}},{"line":30,"address":[7797092,7797215],"length":1,"stats":{"Line":2}},{"line":37,"address":[2379904],"length":1,"stats":{"Line":1}},{"line":39,"address":[2379926],"length":1,"stats":{"Line":1}},{"line":40,"address":[2379946],"length":1,"stats":{"Line":1}},{"line":41,"address":[2379970],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","binary.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::operators::BinaryOperator;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct BinaryOperatorExpression {\n    pub operator: BinaryOperator,\n    pub lhs: SQLExpression,\n    pub rhs: SQLExpression,\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for SQLExpression {\n    fn from(value: BinaryOperatorExpression) -\u003e SQLExpression {\n        SQLExpression::Binary(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cBinaryOperatorExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cBinaryOperatorExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::Binary(value)\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Option\u003cSQLExpression\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Option\u003cSQLExpression\u003e {\n        Some(SQLExpression::Binary(Box::new(value)))\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Box\u003cSQLExpression\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Box\u003cSQLExpression\u003e {\n        Box::new(SQLExpression::Binary(Box::new(value)))\n    }\n}\n\nimpl From\u003cBinaryOperatorExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: BinaryOperatorExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Binary(Box::new(value))))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::dml::expressions::operators::BinaryOperator;\n\n    #[test]\n    fn test_From_BinaryOperatorExpression_for_Option_Box_SQLExpression() {\n        use crate::ast::dml::expressions::binary::BinaryOperatorExpression;\n        use crate::ast::types::SQLExpression;\n        use std::convert::From;\n\n        let binary_operator_expression = BinaryOperatorExpression {\n            operator: BinaryOperator::Add,\n            lhs: SQLExpression::Integer(1),\n            rhs: SQLExpression::Integer(2),\n        };\n        let res: Option\u003cBox\u003cSQLExpression\u003e\u003e = From::from(binary_operator_expression.clone());\n\n        assert_eq!(\n            res,\n            Some(Box::new(SQLExpression::Binary(Box::new(\n                binary_operator_expression\n            ))))\n        );\n    }\n}\n","traces":[{"line":14,"address":[8194880],"length":1,"stats":{"Line":1}},{"line":15,"address":[8195001],"length":1,"stats":{"Line":1}},{"line":20,"address":[8195024],"length":1,"stats":{"Line":1}},{"line":21,"address":[8195032],"length":1,"stats":{"Line":1}},{"line":26,"address":[7797248],"length":1,"stats":{"Line":1}},{"line":27,"address":[7797361],"length":1,"stats":{"Line":1}},{"line":32,"address":[7797408],"length":1,"stats":{"Line":1}},{"line":33,"address":[7797521],"length":1,"stats":{"Line":1}},{"line":38,"address":[7797664],"length":1,"stats":{"Line":1}},{"line":39,"address":[7797903,7797780],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","boolean.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct BooleanExpression {\n    pub value: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","call.rs"],"content":"use crate::ast::types::{Function, SQLExpression};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct CallExpression {\n    pub function: Function,\n    pub arguments: Vec\u003cSQLExpression\u003e,\n}\n\nimpl From\u003cCallExpression\u003e for SQLExpression {\n    fn from(value: CallExpression) -\u003e SQLExpression {\n        SQLExpression::FunctionCall(value)\n    }\n}\n","traces":[{"line":12,"address":[8195056],"length":1,"stats":{"Line":2}},{"line":13,"address":[8195064],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","float.rs"],"content":"#[derive(Clone, Debug, PartialEq)]\npub struct FloatExpression {\n    pub value: f64,\n}\n\nimpl FloatExpression {\n    pub fn new(value: f64) -\u003e Self {\n        Self { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::FloatExpression;\n\n    #[test]\n    fn test_new() {\n        let float = FloatExpression::new(1.0);\n        assert_eq!(float.value, 1.0);\n    }\n}\n","traces":[{"line":7,"address":[1142144],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","identifier.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct IdentifierExpression {\n    pub idendifier: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","integer.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct IntegerExpression {\n    pub value: i64,\n}\n\nimpl IntegerExpression {\n    pub fn new(value: i64) -\u003e Self {\n        Self { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::IntegerExpression;\n\n    #[test]\n    fn test_new() {\n        let integer = IntegerExpression::new(1);\n        assert_eq!(integer.value, 1);\n    }\n}\n","traces":[{"line":7,"address":[2328208],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","list.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct ListExpression {\n    pub value: Vec\u003cSQLExpression\u003e,\n}\n\nimpl From\u003cListExpression\u003e for SQLExpression {\n    fn from(value: ListExpression) -\u003e SQLExpression {\n        SQLExpression::List(value)\n    }\n}\n\nimpl From\u003cVec\u003cSQLExpression\u003e\u003e for ListExpression {\n    fn from(value: Vec\u003cSQLExpression\u003e) -\u003e ListExpression {\n        ListExpression { value }\n    }\n}\n","traces":[{"line":11,"address":[8195088],"length":1,"stats":{"Line":1}},{"line":12,"address":[8195091],"length":1,"stats":{"Line":1}},{"line":17,"address":[4144736],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","mod.rs"],"content":"pub mod between;\npub mod binary;\npub mod boolean;\npub mod call;\npub mod float;\npub mod identifier;\npub mod integer;\npub mod list;\npub mod not_between;\npub mod operators;\npub mod parentheses;\npub mod string;\npub mod subquery;\npub mod unary;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","not_between.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n// a NOT BETWEEN x AND y\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct NotBetweenExpression {\n    pub a: SQLExpression,\n    pub x: SQLExpression,\n    pub y: SQLExpression,\n}\n\nimpl From\u003cNotBetweenExpression\u003e for SQLExpression {\n    fn from(value: NotBetweenExpression) -\u003e SQLExpression {\n        SQLExpression::NotBetween(Box::new(value))\n    }\n}\n\nimpl From\u003cBox\u003cNotBetweenExpression\u003e\u003e for SQLExpression {\n    fn from(value: Box\u003cNotBetweenExpression\u003e) -\u003e SQLExpression {\n        SQLExpression::NotBetween(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use super::NotBetweenExpression;\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_Box_NotBetweenExpression_for_SQLExpression() {\n        let not_between = NotBetweenExpression {\n            a: SQLExpression::String(\"a\".into()),\n            x: SQLExpression::String(\"x\".into()),\n            y: SQLExpression::String(\"y\".into()),\n        };\n        let sql_expression: SQLExpression = Box::new(not_between).into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                a: SQLExpression::String(\"a\".into()),\n                x: SQLExpression::String(\"x\".into()),\n                y: SQLExpression::String(\"y\".into()),\n            }))\n        );\n    }\n}\n","traces":[{"line":14,"address":[8195136],"length":1,"stats":{"Line":1}},{"line":15,"address":[8195257],"length":1,"stats":{"Line":1}},{"line":20,"address":[8195280],"length":1,"stats":{"Line":1}},{"line":21,"address":[8195288],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","operators.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// 2항연산자\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum BinaryOperator {\n    Add,     // A + B\n    Sub,     // A - B\n    Mul,     // A * B\n    Div,     // A / B\n    And,     // A AND B\n    Or,      // A OR B\n    Lt,      // A \u003c B\n    Gt,      // A \u003e B\n    Lte,     // A \u003c= B\n    Gte,     // A \u003e= B\n    Eq,      // A = B\n    Neq,     // A != B, A \u003c\u003e B\n    Like,    // A LIKE B\n    NotLike, // A NOT LIKE B\n    In,      // A In B\n    NotIn,   // A Not In B\n    Is,      // A Is B\n    IsNot,   // A Is Not B\n}\n\n// 단항연산자\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum UnaryOperator {\n    Pos, // +A\n    Neg, // -A\n    Not, // Not A\n}\n\nimpl BinaryOperator {\n    // 2항연산자 우선순위 획득\n    pub fn get_precedence(\u0026self) -\u003e i32 {\n        match self {\n            BinaryOperator::Add =\u003e 10,\n            BinaryOperator::Sub =\u003e 10,\n            BinaryOperator::Mul =\u003e 40,\n            BinaryOperator::Div =\u003e 40,\n            BinaryOperator::And =\u003e 10,\n            BinaryOperator::Or =\u003e 10,\n            BinaryOperator::Lt =\u003e 10,\n            BinaryOperator::Gt =\u003e 10,\n            BinaryOperator::Lte =\u003e 10,\n            BinaryOperator::Gte =\u003e 10,\n            BinaryOperator::Eq =\u003e 10,\n            BinaryOperator::Neq =\u003e 10,\n            BinaryOperator::Like =\u003e 10,\n            BinaryOperator::NotLike =\u003e 10,\n            BinaryOperator::In =\u003e 10,\n            BinaryOperator::NotIn =\u003e 10,\n            BinaryOperator::Is =\u003e 10,\n            BinaryOperator::IsNot =\u003e 10,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::BinaryOperator;\n\n    #[test]\n    fn test_get_precedence() {\n        assert_eq!(BinaryOperator::Add.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Sub.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Mul.get_precedence(), 40);\n        assert_eq!(BinaryOperator::Div.get_precedence(), 40);\n        assert_eq!(BinaryOperator::And.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Or.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Lt.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Gt.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Lte.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Gte.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Eq.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Neq.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Like.get_precedence(), 10);\n        assert_eq!(BinaryOperator::NotLike.get_precedence(), 10);\n        assert_eq!(BinaryOperator::In.get_precedence(), 10);\n        assert_eq!(BinaryOperator::NotIn.get_precedence(), 10);\n        assert_eq!(BinaryOperator::Is.get_precedence(), 10);\n        assert_eq!(BinaryOperator::IsNot.get_precedence(), 10);\n    }\n}\n","traces":[{"line":36,"address":[5760864],"length":1,"stats":{"Line":1}},{"line":37,"address":[5760869],"length":1,"stats":{"Line":1}},{"line":38,"address":[5760900],"length":1,"stats":{"Line":1}},{"line":39,"address":[5760913],"length":1,"stats":{"Line":1}},{"line":40,"address":[5760926],"length":1,"stats":{"Line":1}},{"line":41,"address":[5760939],"length":1,"stats":{"Line":1}},{"line":42,"address":[5760952],"length":1,"stats":{"Line":1}},{"line":43,"address":[5760965],"length":1,"stats":{"Line":1}},{"line":44,"address":[5760975],"length":1,"stats":{"Line":1}},{"line":45,"address":[5760985],"length":1,"stats":{"Line":1}},{"line":46,"address":[5760995],"length":1,"stats":{"Line":1}},{"line":47,"address":[5761005],"length":1,"stats":{"Line":1}},{"line":48,"address":[5761015],"length":1,"stats":{"Line":1}},{"line":49,"address":[5761025],"length":1,"stats":{"Line":1}},{"line":50,"address":[5761035],"length":1,"stats":{"Line":1}},{"line":51,"address":[5761045],"length":1,"stats":{"Line":1}},{"line":52,"address":[5761055],"length":1,"stats":{"Line":1}},{"line":53,"address":[5761065],"length":1,"stats":{"Line":1}},{"line":54,"address":[5761075],"length":1,"stats":{"Line":1}},{"line":55,"address":[5761085],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","parentheses.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct ParenthesesExpression {\n    pub expression: SQLExpression,\n}\n\nimpl From\u003cParenthesesExpression\u003e for SQLExpression {\n    fn from(value: ParenthesesExpression) -\u003e SQLExpression {\n        SQLExpression::Parentheses(Box::new(value))\n    }\n}\n","traces":[{"line":11,"address":[8195312],"length":1,"stats":{"Line":1}},{"line":12,"address":[8195433],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","string.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct StringExpression {\n    pub value: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","subquery.rs"],"content":"use crate::ast::{dml::select::SelectQuery, types::SQLExpression};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SubqueryExpression {\n    Select(Box\u003cSelectQuery\u003e),\n}\n\nimpl From\u003cSubqueryExpression\u003e for SQLExpression {\n    fn from(value: SubqueryExpression) -\u003e SQLExpression {\n        SQLExpression::Subquery(value)\n    }\n}\n","traces":[{"line":11,"address":[8195456],"length":1,"stats":{"Line":1}},{"line":12,"address":[8195464],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","expressions","unary.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\nuse super::operators::UnaryOperator;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct UnaryOperatorExpression {\n    pub operator: UnaryOperator,\n    pub operand: SQLExpression,\n}\n\nimpl From\u003cUnaryOperatorExpression\u003e for SQLExpression {\n    fn from(value: UnaryOperatorExpression) -\u003e SQLExpression {\n        SQLExpression::Unary(Box::new(value))\n    }\n}\n\nimpl From\u003cUnaryOperatorExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: UnaryOperatorExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(SQLExpression::Unary(Box::new(value))))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use super::UnaryOperatorExpression;\n    use crate::ast::dml::expressions::operators::UnaryOperator;\n    use crate::ast::types::SQLExpression;\n\n    #[test]\n    fn test_From_UnaryOperatorExpression_for_SQLExpression() {\n        let unary = UnaryOperatorExpression {\n            operator: UnaryOperator::Neg,\n            operand: SQLExpression::Integer(1),\n        };\n        let sql_expression: SQLExpression = unary.into();\n        assert_eq!(\n            sql_expression,\n            SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                operator: UnaryOperator::Neg,\n                operand: SQLExpression::Integer(1),\n            }))\n        );\n    }\n\n    #[test]\n    fn test_From_UnaryOperatorExpression_for_Option_Box_SQLExpression() {\n        let unary = UnaryOperatorExpression {\n            operator: UnaryOperator::Neg,\n            operand: SQLExpression::Integer(1),\n        };\n        let sql_expression: Option\u003cBox\u003cSQLExpression\u003e\u003e = unary.into();\n\n        assert_eq!(\n            sql_expression,\n            Some(Box::new(SQLExpression::Unary(Box::new(\n                UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::Integer(1),\n                }\n            ))))\n        );\n    }\n}\n","traces":[{"line":13,"address":[8195488],"length":1,"stats":{"Line":1}},{"line":14,"address":[8195609],"length":1,"stats":{"Line":1}},{"line":19,"address":[7797936],"length":1,"stats":{"Line":1}},{"line":20,"address":[7798194,7798077],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","insert.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::{parts::insert_values::InsertValue, select::SelectQuery};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct InsertQuery {\n    pub into_table: Option\u003cTableName\u003e,\n    pub columns: Vec\u003cString\u003e,\n    pub data: InsertData,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum InsertData {\n    Select(Box\u003cSelectQuery\u003e),\n    Values(Vec\u003cInsertValue\u003e),\n    None,\n}\n\nimpl InsertQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            columns: vec![],\n            into_table: None,\n            data: InsertData::None,\n        }\n    }\n\n    pub fn set_into_table(mut self, from: TableName) -\u003e Self {\n        self.into_table = Some(from);\n        self\n    }\n\n    pub fn set_columns(mut self, columns: Vec\u003cString\u003e) -\u003e Self {\n        self.columns = columns;\n        self\n    }\n\n    pub fn set_values(mut self, values: Vec\u003cInsertValue\u003e) -\u003e Self {\n        self.data = InsertData::Values(values);\n        self\n    }\n\n    pub fn set_select(mut self, select: SelectQuery) -\u003e Self {\n        self.data = InsertData::Select(Box::new(select));\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cInsertQuery\u003e for SQLStatement {\n    fn from(value: InsertQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::InsertQuery(value))\n    }\n}\n","traces":[{"line":20,"address":[3942816],"length":1,"stats":{"Line":1}},{"line":22,"address":[3942830],"length":1,"stats":{"Line":4}},{"line":28,"address":[3943149,3942976],"length":1,"stats":{"Line":4}},{"line":29,"address":[3943003,3943100],"length":1,"stats":{"Line":8}},{"line":30,"address":[3943129],"length":1,"stats":{"Line":4}},{"line":33,"address":[3943168,3943315],"length":1,"stats":{"Line":4}},{"line":34,"address":[3943200,3943273],"length":1,"stats":{"Line":8}},{"line":35,"address":[3943295],"length":1,"stats":{"Line":4}},{"line":38,"address":[3943344,3943502],"length":1,"stats":{"Line":3}},{"line":39,"address":[3943371,3943455],"length":1,"stats":{"Line":6}},{"line":40,"address":[3943482],"length":1,"stats":{"Line":3}},{"line":43,"address":[3943536,3943842],"length":1,"stats":{"Line":1}},{"line":44,"address":[3943704],"length":1,"stats":{"Line":1}},{"line":45,"address":[3943822],"length":1,"stats":{"Line":1}},{"line":48,"address":[3943872],"length":1,"stats":{"Line":3}},{"line":49,"address":[3943880],"length":1,"stats":{"Line":3}},{"line":54,"address":[5046480],"length":1,"stats":{"Line":3}},{"line":55,"address":[5046497],"length":1,"stats":{"Line":3}}],"covered":18,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","mod.rs"],"content":"pub mod delete;\npub mod insert;\npub mod select;\npub mod update;\n\npub mod parts;\n\npub mod expressions;\n\npub mod plan;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","from.rs"],"content":"use crate::ast::{dml::expressions::subquery::SubqueryExpression, types::TableName};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct FromClause {\n    pub from: FromTarget,\n    pub alias: Option\u003cString\u003e,\n}\n\nimpl FromClause {}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum FromTarget {\n    Table(TableName),             // 일반 테이블 참조\n    Subquery(SubqueryExpression), // 서브쿼리 참조\n}\n\nimpl FromTarget {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","group_by.rs"],"content":"use crate::ast::types::SelectColumn;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct GroupByClause {\n    pub group_by_items: Vec\u003cGroupByItem\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash)]\npub struct GroupByItem {\n    pub item: SelectColumn,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","having.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct HavingClause {\n    pub expression: Box\u003cSQLExpression\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","insert_values.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct InsertValue {\n    pub list: Vec\u003cOption\u003cSQLExpression\u003e\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","join.rs"],"content":"use crate::ast::types::{SQLExpression, TableName};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct JoinClause {\n    pub join_type: JoinType,\n    pub right: TableName,\n    pub right_alias: Option\u003cString\u003e,\n    pub on: Option\u003cSQLExpression\u003e,\n}\n\nimpl JoinClause {}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum JoinType {\n    InnerJoin,\n    LeftOuterJoin,\n    RightOuterJoin,\n    FullOuterJoin,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","mod.rs"],"content":"#[path = \"./where.rs\"]\npub mod _where;\npub mod from;\npub mod group_by;\npub mod having;\npub mod insert_values;\npub mod join;\npub mod order_by;\npub mod select_item;\npub mod target;\npub mod update_item;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","order_by.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct OrderByClause {\n    pub order_by_items: Vec\u003cOrderByItem\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct OrderByItem {\n    pub item: SQLExpression,\n    pub order_type: OrderByType,\n    pub nulls: OrderByNulls,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum OrderByType {\n    Asc,\n    Desc,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum OrderByNulls {\n    First,\n    Last,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","select_item.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SelectKind {\n    WildCard(SelectWildCard),\n    SelectItem(SelectItem),\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct SelectWildCard {\n    pub alias: Option\u003cString\u003e,\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct SelectItem {\n    pub item: Option\u003cSQLExpression\u003e, // select 요소\n    pub alias: Option\u003cString\u003e,       // as 절이 있을 경우 alias 정보\n}\n\nimpl SelectItem {\n    pub fn builder() -\u003e Self {\n        Self {\n            item: None,\n            alias: None,\n        }\n    }\n\n    pub fn set_item(mut self, item: SQLExpression) -\u003e Self {\n        self.item = Some(item);\n        self\n    }\n\n    pub fn set_alias(mut self, alias: String) -\u003e Self {\n        self.alias = Some(alias);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n","traces":[{"line":23,"address":[8178800],"length":1,"stats":{"Line":1}},{"line":30,"address":[8178912,8179121],"length":1,"stats":{"Line":1}},{"line":31,"address":[8178939,8179072],"length":1,"stats":{"Line":2}},{"line":32,"address":[8179101],"length":1,"stats":{"Line":1}},{"line":35,"address":[8179152,8179308],"length":1,"stats":{"Line":1}},{"line":36,"address":[8179262,8179179],"length":1,"stats":{"Line":2}},{"line":37,"address":[8179288],"length":1,"stats":{"Line":1}},{"line":40,"address":[8179328],"length":1,"stats":{"Line":1}},{"line":41,"address":[8179336],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","target.rs"],"content":"use crate::ast::types::TableName;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UpdateTarget {\n    pub table: TableName,\n    pub alias: Option\u003cString\u003e,\n}\n\nimpl From\u003cTableName\u003e for UpdateTarget {\n    fn from(value: TableName) -\u003e UpdateTarget {\n        UpdateTarget {\n            table: value,\n            alias: None,\n        }\n    }\n}\n","traces":[{"line":12,"address":[5760768],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","update_item.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdateItem {\n    pub column: String,       // update할 컬럼\n    pub value: SQLExpression, // 수정할 값\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","parts","where.rs"],"content":"use crate::ast::types::SQLExpression;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct WhereClause {\n    pub expression: SQLExpression,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","delete_plan.rs"],"content":"use crate::ast::dml::plan::select::filter::FilterPlan;\n\nuse super::from::DeleteFromPlan;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct DeletePlan {\n    pub list: Vec\u003cDeletePlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DeletePlanItem {\n    DeleteFrom(DeleteFromPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cFilterPlan\u003e for DeletePlanItem {\n    fn from(value: FilterPlan) -\u003e DeletePlanItem {\n        DeletePlanItem::Filter(value)\n    }\n}\n\nimpl From\u003cDeleteFromPlan\u003e for DeletePlanItem {\n    fn from(value: DeleteFromPlan) -\u003e DeletePlanItem {\n        DeletePlanItem::DeleteFrom(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::plan::select::scan::ScanType,\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_FilterPlan_for_DeletePlanItem() {\n        use super::DeletePlanItem;\n\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let delete_plan_item: DeletePlanItem = filter.clone().into();\n        assert_eq!(delete_plan_item, DeletePlanItem::Filter(filter));\n    }\n\n    #[test]\n    fn From_DeleteFromPlan_for_DeletePlanItem() {\n        use super::DeleteFromPlan;\n\n        let delete_from = DeleteFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let delete_plan_item: DeletePlanItem = delete_from.clone().into();\n        assert_eq!(delete_plan_item, DeletePlanItem::DeleteFrom(delete_from));\n    }\n}\n","traces":[{"line":17,"address":[4152576],"length":1,"stats":{"Line":1}},{"line":18,"address":[4152593],"length":1,"stats":{"Line":1}},{"line":23,"address":[4152640],"length":1,"stats":{"Line":1}},{"line":24,"address":[4152648],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","from.rs"],"content":"use crate::ast::{dml::plan::select::scan::ScanType, types::TableName};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DeleteFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","delete","mod.rs"],"content":"pub mod delete_plan;\npub mod from;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","mod.rs"],"content":"pub mod delete;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","filter.rs"],"content":"use crate::ast::types::SQLExpression;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct FilterPlan {\n    pub expression: SQLExpression,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","from.rs"],"content":"use crate::ast::types::TableName;\n\nuse super::scan::ScanType;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct SelectFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","join.rs"],"content":"use crate::ast::{\n    dml::parts::join::JoinType,\n    types::{Index, SQLExpression, TableName},\n};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct JoinPlan {\n    pub left: TableName,\n    pub right: TableName,\n    pub join_type: JoinType,\n    pub join_scan_type: JoinScanType,\n    pub select_columns: Vec\u003cString\u003e,\n    pub index: Option\u003cIndex\u003e,\n    pub filter: Option\u003cSQLExpression\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum JoinScanType {\n    NestedLoop,\n    Hash,\n    Merge,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","limit_offset.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct LimitOffsetPlan {\n    pub limit: Option\u003cu32\u003e,\n    pub offset: Option\u003cu32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","mod.rs"],"content":"pub mod filter;\npub mod from;\npub mod join;\npub mod limit_offset;\npub mod scan;\npub mod select_plan;\npub mod subquery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","no_from.rs"],"content":"use crate::ast::predule::{Index, TableName};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectNoFromPlan {\n    select_columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","scan.rs"],"content":"use crate::ast::types::Index;\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum ScanType {\n    FullScan,\n    IndexScan(Index),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","select_plan.rs"],"content":"use crate::ast::dml::parts::{group_by::GroupByClause, order_by::OrderByClause};\n\nuse super::{\n    filter::FilterPlan, from::SelectFromPlan, join::JoinPlan, limit_offset::LimitOffsetPlan,\n    subquery::SelectSubqueryPlan,\n};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectPlan {\n    pub list: Vec\u003cSelectPlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SelectPlanItem {\n    From(SelectFromPlan),\n    Subquery(SelectSubqueryPlan),\n    Join(JoinPlan),\n    Order(OrderByClause),\n    Group(GroupByClause),\n    GroupAll,\n    LimitOffset(LimitOffsetPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cSelectFromPlan\u003e for SelectPlanItem {\n    fn from(value: SelectFromPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::From(value)\n    }\n}\n\nimpl From\u003cSelectSubqueryPlan\u003e for SelectPlanItem {\n    fn from(value: SelectSubqueryPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Subquery(value)\n    }\n}\n\nimpl From\u003cJoinPlan\u003e for SelectPlanItem {\n    fn from(value: JoinPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Join(value)\n    }\n}\n\nimpl From\u003cOrderByClause\u003e for SelectPlanItem {\n    fn from(value: OrderByClause) -\u003e SelectPlanItem {\n        SelectPlanItem::Order(value)\n    }\n}\n\nimpl From\u003cGroupByClause\u003e for SelectPlanItem {\n    fn from(value: GroupByClause) -\u003e SelectPlanItem {\n        SelectPlanItem::Group(value)\n    }\n}\n\nimpl From\u003cLimitOffsetPlan\u003e for SelectPlanItem {\n    fn from(value: LimitOffsetPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::LimitOffset(value)\n    }\n}\n\nimpl From\u003cFilterPlan\u003e for SelectPlanItem {\n    fn from(value: FilterPlan) -\u003e SelectPlanItem {\n        SelectPlanItem::Filter(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::{\n            parts::join::JoinType,\n            plan::select::{from::SelectFromPlan, join::JoinScanType, scan::ScanType},\n        },\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_SelectFromPlan_for_SelectPlanItem() {\n        let select_from = SelectFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let select_plan_item: SelectPlanItem = select_from.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::From(select_from));\n    }\n\n    #[test]\n    fn From_SelectSubqueryPlan_for_SelectPlanItem() {\n        let select_subquery = SelectSubqueryPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            select_columns: vec![],\n            index: None,\n            filter: None,\n        };\n        let select_plan_item: SelectPlanItem = select_subquery.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Subquery(select_subquery));\n    }\n\n    #[test]\n    fn From_JoinPlan_for_SelectPlanItem() {\n        let join = JoinPlan {\n            join_type: JoinType::InnerJoin,\n            left: TableName::new(None, \"l\".into()),\n            right: TableName::new(None, \"r\".into()),\n            join_scan_type: JoinScanType::Hash,\n            select_columns: vec![],\n            index: None,\n            filter: None,\n        };\n        let select_plan_item: SelectPlanItem = join.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Join(join));\n    }\n\n    #[test]\n    fn From_OrderByClause_for_SelectPlanItem() {\n        let order_by = OrderByClause {\n            order_by_items: vec![],\n        };\n        let select_plan_item: SelectPlanItem = order_by.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Order(order_by));\n    }\n\n    #[test]\n    fn From_GroupByClause_for_SelectPlanItem() {\n        let group_by = GroupByClause {\n            group_by_items: vec![],\n        };\n        let select_plan_item: SelectPlanItem = group_by.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Group(group_by));\n    }\n\n    #[test]\n    fn From_LimitOffsetPlan_for_SelectPlanItem() {\n        let limit_offset = LimitOffsetPlan {\n            limit: None,\n            offset: None,\n        };\n        let select_plan_item: SelectPlanItem = limit_offset.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::LimitOffset(limit_offset));\n    }\n\n    #[test]\n    fn From_FilterPlan_for_SelectPlanItem() {\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let select_plan_item: SelectPlanItem = filter.clone().into();\n        assert_eq!(select_plan_item, SelectPlanItem::Filter(filter));\n    }\n}\n","traces":[{"line":26,"address":[5476736],"length":1,"stats":{"Line":1}},{"line":27,"address":[5476753],"length":1,"stats":{"Line":1}},{"line":32,"address":[5476800],"length":1,"stats":{"Line":1}},{"line":33,"address":[5476817],"length":1,"stats":{"Line":1}},{"line":38,"address":[5476864],"length":1,"stats":{"Line":1}},{"line":39,"address":[5476872],"length":1,"stats":{"Line":1}},{"line":44,"address":[5476896],"length":1,"stats":{"Line":1}},{"line":45,"address":[5476899],"length":1,"stats":{"Line":1}},{"line":50,"address":[5476944],"length":1,"stats":{"Line":1}},{"line":51,"address":[5476947],"length":1,"stats":{"Line":1}},{"line":56,"address":[5476992],"length":1,"stats":{"Line":1}},{"line":57,"address":[5476995],"length":1,"stats":{"Line":1}},{"line":62,"address":[5477024],"length":1,"stats":{"Line":1}},{"line":63,"address":[5477041],"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","select","subquery.rs"],"content":"use crate::ast::types::{Index, SQLExpression, TableName};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SelectSubqueryPlan {\n    pub table_name: TableName,\n    pub select_columns: Vec\u003cString\u003e,\n    pub index: Option\u003cIndex\u003e,\n    pub filter: Option\u003cSQLExpression\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","from.rs"],"content":"use crate::ast::{dml::plan::select::scan::ScanType, types::TableName};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct UpdateFromPlan {\n    pub table_name: TableName,\n    pub alias: Option\u003cString\u003e,\n    pub scan: ScanType,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","mod.rs"],"content":"pub mod from;\npub mod update_plan;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","plan","update","update_plan.rs"],"content":"use crate::ast::dml::plan::select::filter::FilterPlan;\n\nuse super::from::UpdateFromPlan;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdatePlan {\n    pub list: Vec\u003cUpdatePlanItem\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum UpdatePlanItem {\n    UpdateFrom(UpdateFromPlan),\n    Filter(FilterPlan),\n}\n\nimpl From\u003cFilterPlan\u003e for UpdatePlanItem {\n    fn from(value: FilterPlan) -\u003e UpdatePlanItem {\n        UpdatePlanItem::Filter(value)\n    }\n}\n\nimpl From\u003cUpdateFromPlan\u003e for UpdatePlanItem {\n    fn from(value: UpdateFromPlan) -\u003e UpdatePlanItem {\n        UpdatePlanItem::UpdateFrom(value)\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::plan::select::scan::ScanType,\n        types::{SQLExpression, TableName},\n    };\n\n    use super::*;\n\n    #[test]\n    fn From_FilterPlan_for_UpdatePlanItem() {\n        use super::UpdatePlanItem;\n\n        let filter = FilterPlan {\n            expression: SQLExpression::String(\"a\".into()),\n        };\n        let update_plan_item: UpdatePlanItem = filter.clone().into();\n        assert_eq!(update_plan_item, UpdatePlanItem::Filter(filter));\n    }\n\n    #[test]\n    fn From_UpdateFromPlan_for_UpdatePlanItem() {\n        use super::UpdateFromPlan;\n\n        let update_from = UpdateFromPlan {\n            table_name: TableName::new(None, \"table\".into()),\n            alias: None,\n            scan: ScanType::FullScan,\n        };\n        let update_plan_item: UpdatePlanItem = update_from.clone().into();\n        assert_eq!(update_plan_item, UpdatePlanItem::UpdateFrom(update_from));\n    }\n}\n","traces":[{"line":17,"address":[4360624],"length":1,"stats":{"Line":1}},{"line":18,"address":[4360641],"length":1,"stats":{"Line":1}},{"line":23,"address":[4360688],"length":1,"stats":{"Line":1}},{"line":24,"address":[4360696],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","select.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::ast::{\n    ddl::drop_database::SQLStatement,\n    types::{SQLExpression, SelectColumn, TableName},\n    DMLStatement,\n};\n\nuse super::{\n    expressions::subquery::SubqueryExpression,\n    parts::{\n        _where::WhereClause,\n        from::{FromClause, FromTarget},\n        group_by::{GroupByClause, GroupByItem},\n        having::HavingClause,\n        join::JoinClause,\n        order_by::{OrderByClause, OrderByItem},\n        select_item::{SelectItem, SelectKind, SelectWildCard},\n    },\n};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct SelectQuery {\n    pub select_items: Vec\u003cSelectKind\u003e,\n    pub has_aggregate: bool,\n    pub from_table: Option\u003cFromClause\u003e,\n    pub join_clause: Vec\u003cJoinClause\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n    pub order_by_clause: Option\u003cOrderByClause\u003e,\n    pub group_by_clause: Option\u003cGroupByClause\u003e,\n    pub having_clause: Option\u003cHavingClause\u003e,\n    pub limit: Option\u003cu32\u003e,\n    pub offset: Option\u003cu32\u003e,\n}\n\nimpl SelectQuery {\n    pub fn builder() -\u003e Self {\n        SelectQuery {\n            select_items: vec![],\n            from_table: None,\n            join_clause: vec![],\n            where_clause: None,\n            group_by_clause: None,\n            having_clause: None,\n            order_by_clause: None,\n            limit: None,\n            offset: None,\n            has_aggregate: false,\n        }\n    }\n\n    pub fn add_select_item(mut self, item: SelectItem) -\u003e Self {\n        self.select_items.push(SelectKind::SelectItem(item));\n        self\n    }\n\n    pub fn add_select_wildcard(mut self, item: SelectWildCard) -\u003e Self {\n        self.select_items.push(SelectKind::WildCard(item));\n        self\n    }\n\n    pub fn set_from_table(mut self, from: TableName) -\u003e Self {\n        self.from_table = Some(from.into());\n        self\n    }\n\n    pub fn has_from_table(\u0026self) -\u003e bool {\n        self.from_table.is_some()\n    }\n\n    pub fn set_from_subquery(mut self, from: SubqueryExpression) -\u003e Self {\n        self.from_table = Some(FromClause {\n            from: FromTarget::Subquery(from),\n            alias: None,\n        });\n        self\n    }\n\n    pub fn set_from_alias(mut self, alias: String) -\u003e Self {\n        if self.from_table.is_some() {\n            self.from_table = self.from_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn add_join(mut self, join: JoinClause) -\u003e Self {\n        self.join_clause.push(join);\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn add_order_by(mut self, item: OrderByItem) -\u003e Self {\n        match self.order_by_clause {\n            Some(ref mut order_by_clause) =\u003e {\n                order_by_clause.order_by_items.push(item);\n            }\n            None =\u003e {\n                self.order_by_clause = Some(OrderByClause {\n                    order_by_items: vec![item],\n                })\n            }\n        }\n\n        self\n    }\n\n    pub fn add_group_by(mut self, item: GroupByItem) -\u003e Self {\n        match self.group_by_clause {\n            Some(ref mut group_by_clause) =\u003e {\n                group_by_clause.group_by_items.push(item);\n            }\n            None =\u003e {\n                self.group_by_clause = Some(GroupByClause {\n                    group_by_items: vec![item],\n                })\n            }\n        }\n\n        self\n    }\n\n    pub fn has_group_by(\u0026self) -\u003e bool {\n        match self.group_by_clause {\n            Some(ref group_by_clause) =\u003e !group_by_clause.group_by_items.is_empty(),\n            None =\u003e false,\n        }\n    }\n\n    pub fn set_having(mut self, having_clause: HavingClause) -\u003e Self {\n        self.having_clause = Some(having_clause);\n        self\n    }\n\n    pub fn set_offset(mut self, offset: u32) -\u003e Self {\n        self.offset = Some(offset);\n        self\n    }\n\n    pub fn set_limit(mut self, limit: u32) -\u003e Self {\n        self.limit = Some(limit);\n        self\n    }\n\n    pub fn set_has_aggregate(mut self, has_aggregate: bool) -\u003e Self {\n        self.has_aggregate = has_aggregate;\n        self\n    }\n\n    pub fn has_aggregate(\u0026self) -\u003e bool {\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n\n                    if item.has_aggregate() {\n                        return true;\n                    }\n                }\n                SelectKind::WildCard(_) =\u003e return false,\n            }\n        }\n\n        false\n    }\n\n    pub fn get_non_aggregate_column(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        let mut list = vec![];\n\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n                    let mut none_aggregate_columns = item.find_non_aggregate_columns();\n                    list.append(\u0026mut none_aggregate_columns);\n                }\n                SelectKind::WildCard(_) =\u003e {}\n            }\n        }\n\n        list\n    }\n\n    pub fn get_aggregate_column(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        let mut list = vec![];\n\n        for item in \u0026self.select_items {\n            match item {\n                SelectKind::SelectItem(item) =\u003e {\n                    let item = item.item.as_ref().unwrap();\n                    let mut aggregate_columns = item.find_aggregate_columns();\n                    list.append(\u0026mut aggregate_columns);\n                }\n                SelectKind::WildCard(_) =\u003e {}\n            }\n        }\n\n        list\n    }\n\n    pub fn build(self) -\u003e SelectQuery {\n        self\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SQLStatement {\n    fn from(value: SelectQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::SelectQuery(value))\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SubqueryExpression {\n    fn from(value: SelectQuery) -\u003e SubqueryExpression {\n        SubqueryExpression::Select(Box::new(value))\n    }\n}\n\nimpl From\u003cSelectQuery\u003e for SQLExpression {\n    fn from(value: SelectQuery) -\u003e SQLExpression {\n        SQLExpression::Subquery(SubqueryExpression::Select(Box::new(value)))\n    }\n}\n\n#[cfg(test)]\n#[allow(non_snake_case)]\nmod tests {\n    use crate::ast::{\n        dml::expressions::call::CallExpression,\n        types::{AggregateFunction, BuiltInFunction, Function},\n    };\n\n    use super::*;\n\n    #[test]\n    fn test_from_table() {\n        let select_query = SelectQuery::builder()\n            .set_from_table(TableName::new(None, \"table\".into()))\n            .build();\n\n        assert!(select_query.has_from_table());\n    }\n\n    #[test]\n    fn test_has_group_by() {\n        let select_query = SelectQuery::builder().build();\n\n        assert_eq!(select_query.has_group_by(), false);\n\n        let select_query = SelectQuery::builder()\n            .add_group_by(GroupByItem {\n                item: SelectColumn {\n                    table_name: None,\n                    column_name: \"foo\".into(),\n                },\n            })\n            .build();\n\n        assert_eq!(select_query.has_group_by(), true);\n    }\n\n    #[test]\n    fn test_get_aggregate_column() {\n        let select_query = SelectQuery::builder()\n            .add_select_item(\n                SelectItem::builder()\n                    .set_item(SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(BuiltInFunction::Aggregate(\n                            AggregateFunction::Count,\n                        )),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn {\n                            table_name: None,\n                            column_name: \"bar\".into(),\n                        })],\n                    }))\n                    .build(),\n            )\n            .build();\n\n        let aggregate_columns = select_query.get_aggregate_column();\n\n        assert_eq!(aggregate_columns.len(), 1);\n        assert_eq!(aggregate_columns[0].column_name, \"bar\");\n    }\n}\n","traces":[{"line":37,"address":[1850849,1850870,1850400],"length":1,"stats":{"Line":1}},{"line":39,"address":[1850421],"length":1,"stats":{"Line":1}},{"line":41,"address":[1850446],"length":1,"stats":{"Line":1}},{"line":52,"address":[1850896,1851058],"length":1,"stats":{"Line":1}},{"line":53,"address":[1850926],"length":1,"stats":{"Line":1}},{"line":54,"address":[1851035],"length":1,"stats":{"Line":1}},{"line":57,"address":[1851222,1851088],"length":1,"stats":{"Line":1}},{"line":58,"address":[1851116],"length":1,"stats":{"Line":1}},{"line":59,"address":[1851199],"length":1,"stats":{"Line":1}},{"line":62,"address":[1851248,1851523],"length":1,"stats":{"Line":1}},{"line":63,"address":[1851281,1851342],"length":1,"stats":{"Line":2}},{"line":64,"address":[1851500],"length":1,"stats":{"Line":1}},{"line":67,"address":[1851552],"length":1,"stats":{"Line":1}},{"line":68,"address":[1851557],"length":1,"stats":{"Line":1}},{"line":71,"address":[1851584,1851951],"length":1,"stats":{"Line":1}},{"line":72,"address":[1851899,1851656],"length":1,"stats":{"Line":2}},{"line":73,"address":[1851622],"length":1,"stats":{"Line":1}},{"line":74,"address":[1851648],"length":1,"stats":{"Line":1}},{"line":76,"address":[1851928],"length":1,"stats":{"Line":1}},{"line":79,"address":[1852440,1852616,1851984],"length":1,"stats":{"Line":1}},{"line":80,"address":[1852358,1852018,1852126],"length":1,"stats":{"Line":3}},{"line":81,"address":[1852196],"length":1,"stats":{"Line":2}},{"line":82,"address":[2179851,2179959],"length":1,"stats":{"Line":2}},{"line":83,"address":[2179986],"length":1,"stats":{"Line":1}},{"line":86,"address":[1852142],"length":1,"stats":{"Line":1}},{"line":89,"address":[1852765,1852656],"length":1,"stats":{"Line":1}},{"line":90,"address":[1852696],"length":1,"stats":{"Line":1}},{"line":91,"address":[1852745],"length":1,"stats":{"Line":1}},{"line":94,"address":[1853014,1852784],"length":1,"stats":{"Line":1}},{"line":95,"address":[1852811,1852962],"length":1,"stats":{"Line":2}},{"line":96,"address":[1852994],"length":1,"stats":{"Line":1}},{"line":99,"address":[1853040,1853673],"length":1,"stats":{"Line":2}},{"line":100,"address":[1853067],"length":1,"stats":{"Line":2}},{"line":101,"address":[1853149],"length":1,"stats":{"Line":1}},{"line":102,"address":[1853647,1853161],"length":1,"stats":{"Line":2}},{"line":105,"address":[1853430],"length":1,"stats":{"Line":2}},{"line":106,"address":[1853274,1853124],"length":1,"stats":{"Line":4}},{"line":111,"address":[1853624],"length":1,"stats":{"Line":2}},{"line":114,"address":[1853696,1854260],"length":1,"stats":{"Line":1}},{"line":115,"address":[1853723],"length":1,"stats":{"Line":1}},{"line":116,"address":[1853802],"length":1,"stats":{"Line":1}},{"line":117,"address":[1854234,1853814],"length":1,"stats":{"Line":2}},{"line":120,"address":[1854041],"length":1,"stats":{"Line":1}},{"line":121,"address":[1853780,1853909],"length":1,"stats":{"Line":2}},{"line":126,"address":[1854211],"length":1,"stats":{"Line":1}},{"line":129,"address":[1854288],"length":1,"stats":{"Line":1}},{"line":130,"address":[1854302],"length":1,"stats":{"Line":1}},{"line":131,"address":[1854345],"length":1,"stats":{"Line":1}},{"line":132,"address":[1854333],"length":1,"stats":{"Line":1}},{"line":136,"address":[1854384,1854513],"length":1,"stats":{"Line":1}},{"line":137,"address":[1854414,1854481],"length":1,"stats":{"Line":2}},{"line":138,"address":[1854493],"length":1,"stats":{"Line":1}},{"line":141,"address":[1854544],"length":1,"stats":{"Line":1}},{"line":142,"address":[1854559],"length":1,"stats":{"Line":1}},{"line":143,"address":[1854591],"length":1,"stats":{"Line":1}},{"line":146,"address":[1854624],"length":1,"stats":{"Line":1}},{"line":147,"address":[1854639],"length":1,"stats":{"Line":1}},{"line":148,"address":[1854671],"length":1,"stats":{"Line":1}},{"line":151,"address":[1854704],"length":1,"stats":{"Line":1}},{"line":152,"address":[1854727],"length":1,"stats":{"Line":1}},{"line":153,"address":[1854735],"length":1,"stats":{"Line":1}},{"line":156,"address":[1854768],"length":1,"stats":{"Line":1}},{"line":157,"address":[1854840,1854777],"length":1,"stats":{"Line":2}},{"line":158,"address":[1854854],"length":1,"stats":{"Line":1}},{"line":159,"address":[1854911],"length":1,"stats":{"Line":1}},{"line":160,"address":[1854974,1854916],"length":1,"stats":{"Line":2}},{"line":162,"address":[1854979],"length":1,"stats":{"Line":1}},{"line":163,"address":[1854993],"length":1,"stats":{"Line":1}},{"line":166,"address":[1854900],"length":1,"stats":{"Line":1}},{"line":170,"address":[1854833],"length":1,"stats":{"Line":1}},{"line":173,"address":[1855008,1855486],"length":1,"stats":{"Line":1}},{"line":174,"address":[1855043],"length":1,"stats":{"Line":1}},{"line":176,"address":[1855224,1855117,1855053],"length":1,"stats":{"Line":3}},{"line":177,"address":[1855242],"length":1,"stats":{"Line":1}},{"line":178,"address":[1855281],"length":1,"stats":{"Line":1}},{"line":179,"address":[1855385,1855289],"length":1,"stats":{"Line":2}},{"line":180,"address":[1855401],"length":1,"stats":{"Line":1}},{"line":181,"address":[1855421],"length":1,"stats":{"Line":1}},{"line":187,"address":[1855190],"length":1,"stats":{"Line":1}},{"line":190,"address":[1855998,1855520],"length":1,"stats":{"Line":1}},{"line":191,"address":[1855555],"length":1,"stats":{"Line":1}},{"line":193,"address":[1855736,1855565,1855629],"length":1,"stats":{"Line":3}},{"line":194,"address":[1855754],"length":1,"stats":{"Line":1}},{"line":195,"address":[1855793],"length":1,"stats":{"Line":1}},{"line":196,"address":[1855897,1855801],"length":1,"stats":{"Line":2}},{"line":197,"address":[1855913],"length":1,"stats":{"Line":1}},{"line":198,"address":[1855933],"length":1,"stats":{"Line":1}},{"line":204,"address":[1855702],"length":1,"stats":{"Line":1}},{"line":207,"address":[1856032],"length":1,"stats":{"Line":1}},{"line":208,"address":[1856040],"length":1,"stats":{"Line":1}},{"line":213,"address":[5046576],"length":1,"stats":{"Line":3}},{"line":214,"address":[5046593],"length":1,"stats":{"Line":3}},{"line":219,"address":[3943904],"length":1,"stats":{"Line":1}},{"line":220,"address":[3944002],"length":1,"stats":{"Line":1}},{"line":225,"address":[8194544],"length":1,"stats":{"Line":1}},{"line":226,"address":[8194662],"length":1,"stats":{"Line":1}}],"covered":96,"coverable":96},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","dml","update.rs"],"content":"use crate::ast::{types::TableName, DMLStatement, SQLStatement};\n\nuse super::parts::{_where::WhereClause, target::UpdateTarget, update_item::UpdateItem};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct UpdateQuery {\n    pub target_table: Option\u003cUpdateTarget\u003e,\n    pub where_clause: Option\u003cWhereClause\u003e,\n    pub update_items: Vec\u003cUpdateItem\u003e,\n}\n\nimpl UpdateQuery {\n    pub fn builder() -\u003e Self {\n        Self {\n            update_items: vec![],\n            target_table: None,\n            where_clause: None,\n        }\n    }\n\n    pub fn add_update_item(mut self, item: UpdateItem) -\u003e Self {\n        self.update_items.push(item);\n        self\n    }\n\n    pub fn set_target_table(mut self, from: TableName) -\u003e Self {\n        self.target_table = Some(from.into());\n        self\n    }\n\n    pub fn set_target_alias(mut self, alias: String) -\u003e Self {\n        if self.target_table.is_some() {\n            self.target_table = self.target_table.map(|mut e| {\n                e.alias = Some(alias);\n                e\n            });\n        }\n        self\n    }\n\n    pub fn set_where(mut self, where_clause: WhereClause) -\u003e Self {\n        self.where_clause = Some(where_clause);\n        self\n    }\n\n    pub fn build(self) -\u003e Self {\n        self\n    }\n}\n\nimpl From\u003cUpdateQuery\u003e for SQLStatement {\n    fn from(value: UpdateQuery) -\u003e SQLStatement {\n        SQLStatement::DML(DMLStatement::UpdateQuery(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::ast::types::SQLExpression;\n\n    use super::*;\n\n    #[test]\n    fn test_builder_all() {\n        let update_query = UpdateQuery::builder()\n            .set_target_table(TableName::new(None, \"table\".into()))\n            .add_update_item(UpdateItem {\n                column: \"a\".into(),\n                value: SQLExpression::String(\"b\".into()),\n            })\n            .set_where(WhereClause {\n                expression: SQLExpression::String(\"a\".into()),\n            })\n            .set_target_alias(\"alias\".into())\n            .build();\n        assert_eq!(\n            update_query,\n            UpdateQuery {\n                target_table: Some(UpdateTarget {\n                    table: TableName::new(None, \"table\".into()),\n                    alias: Some(\"alias\".into()),\n                }),\n                where_clause: Some(WhereClause {\n                    expression: SQLExpression::String(\"a\".into()),\n                }),\n                update_items: vec![UpdateItem {\n                    column: \"a\".into(),\n                    value: SQLExpression::String(\"b\".into()),\n                }],\n            }\n        );\n    }\n}\n","traces":[{"line":13,"address":[4316608],"length":1,"stats":{"Line":1}},{"line":15,"address":[4316624],"length":1,"stats":{"Line":1}},{"line":21,"address":[4316873,4316768],"length":1,"stats":{"Line":1}},{"line":22,"address":[4316808],"length":1,"stats":{"Line":1}},{"line":23,"address":[4316853],"length":1,"stats":{"Line":1}},{"line":26,"address":[4317171,4316896],"length":1,"stats":{"Line":1}},{"line":27,"address":[4316990,4316929],"length":1,"stats":{"Line":2}},{"line":28,"address":[4317148],"length":1,"stats":{"Line":1}},{"line":31,"address":[4317712,4317200,4317647],"length":1,"stats":{"Line":1}},{"line":32,"address":[4317342,4317565,4317234],"length":1,"stats":{"Line":3}},{"line":33,"address":[4168128,4168310],"length":1,"stats":{"Line":2}},{"line":34,"address":[4168155,4168263],"length":1,"stats":{"Line":2}},{"line":35,"address":[4168290],"length":1,"stats":{"Line":1}},{"line":38,"address":[4317358],"length":1,"stats":{"Line":1}},{"line":41,"address":[4317744,4317962],"length":1,"stats":{"Line":1}},{"line":42,"address":[4317913,4317771],"length":1,"stats":{"Line":2}},{"line":43,"address":[4317942],"length":1,"stats":{"Line":1}},{"line":46,"address":[4317984],"length":1,"stats":{"Line":1}},{"line":47,"address":[4317992],"length":1,"stats":{"Line":1}},{"line":52,"address":[5046656],"length":1,"stats":{"Line":2}},{"line":53,"address":[5046673],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","mod.rs"],"content":"pub mod commands;\npub mod dcl;\npub mod ddl;\npub mod dml;\npub mod other;\npub mod tcl;\npub mod types;\n\nuse crate::ast::{\n    ddl::{\n        alter_database::AlterDatabaseQuery, alter_table::AlterTableQuery,\n        create_database::CreateDatabaseQuery, create_index::CreateIndexQuery,\n        create_table::CreateTableQuery, drop_database::DropDatabaseQuery,\n        drop_table::DropTableQuery,\n    },\n    dml::{delete::DeleteQuery, insert::InsertQuery, select::SelectQuery, update::UpdateQuery},\n    other::{\n        desc_table::DescTableQuery, show_databases::ShowDatabasesQuery,\n        show_tables::ShowTablesQuery, use_database::UseDatabaseQuery,\n    },\n};\n\nuse self::tcl::{BeginTransactionQuery, CommitQuery, RollbackQuery};\n\n#[derive(Clone, Debug, PartialEq, Default)]\npub enum SQLStatement {\n    DDL(DDLStatement),\n    DML(DMLStatement),\n    DCL(DCLStatement),\n    TCL(TCLStatement),\n    Other(OtherStatement),\n    #[default]\n    None,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DDLStatement {\n    CreateDatabaseQuery(CreateDatabaseQuery),\n    AlterDatabase(AlterDatabaseQuery),\n    DropDatabaseQuery(DropDatabaseQuery),\n    CreateTableQuery(CreateTableQuery),\n    AlterTableQuery(AlterTableQuery),\n    DropTableQuery(DropTableQuery),\n    CreateIndexQuery(CreateIndexQuery),\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum DMLStatement {\n    InsertQuery(InsertQuery),\n    UpdateQuery(UpdateQuery),\n    DeleteQuery(DeleteQuery),\n    SelectQuery(SelectQuery),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DCLStatement {}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum OtherStatement {\n    ShowDatabases(ShowDatabasesQuery),\n    UseDatabase(UseDatabaseQuery),\n    ShowTables(ShowTablesQuery),\n    DescTable(DescTableQuery),\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum TCLStatement {\n    BeginTransaction(BeginTransactionQuery),\n    Commit(CommitQuery),\n    Rollback(RollbackQuery),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","desc_table.rs"],"content":"use crate::ast::{types::TableName, OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct DescTableQuery {\n    pub table_name: TableName,\n}\n\nimpl From\u003cDescTableQuery\u003e for SQLStatement {\n    fn from(value: DescTableQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::DescTable(value))\n    }\n}\n","traces":[{"line":9,"address":[5046752],"length":1,"stats":{"Line":1}},{"line":10,"address":[5046766],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","mod.rs"],"content":"pub mod desc_table;\npub mod show_databases;\npub mod show_tables;\npub mod use_database;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","show_databases.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShowDatabasesQuery {}\n\nimpl From\u003cShowDatabasesQuery\u003e for SQLStatement {\n    fn from(value: ShowDatabasesQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::ShowDatabases(value))\n    }\n}\n","traces":[{"line":7,"address":[5046848],"length":1,"stats":{"Line":1}},{"line":8,"address":[5046865],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","show_tables.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ShowTablesQuery {\n    pub database: String,\n}\n\nimpl From\u003cShowTablesQuery\u003e for SQLStatement {\n    fn from(value: ShowTablesQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::ShowTables(value))\n    }\n}\n","traces":[{"line":9,"address":[5046928],"length":1,"stats":{"Line":1}},{"line":10,"address":[5046945],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","other","use_database.rs"],"content":"use crate::ast::{OtherStatement, SQLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct UseDatabaseQuery {\n    pub database_name: String,\n}\n\nimpl From\u003cUseDatabaseQuery\u003e for SQLStatement {\n    fn from(value: UseDatabaseQuery) -\u003e SQLStatement {\n        SQLStatement::Other(OtherStatement::UseDatabase(value))\n    }\n}\n","traces":[{"line":9,"address":[5047040],"length":1,"stats":{"Line":1}},{"line":10,"address":[5047057],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","begin_transaction.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct BeginTransactionQuery {}\n\nimpl From\u003cBeginTransactionQuery\u003e for SQLStatement {\n    fn from(value: BeginTransactionQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::BeginTransaction(value))\n    }\n}\n","traces":[{"line":7,"address":[5047152],"length":1,"stats":{"Line":1}},{"line":8,"address":[5047155],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","commit.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct CommitQuery {}\n\nimpl From\u003cCommitQuery\u003e for SQLStatement {\n    fn from(value: CommitQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::Commit(value))\n    }\n}\n","traces":[{"line":7,"address":[5047184],"length":1,"stats":{"Line":1}},{"line":8,"address":[5047187],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","mod.rs"],"content":"mod begin_transaction;\nmod commit;\nmod rollback;\n\npub use begin_transaction::*;\npub use commit::*;\npub use rollback::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","tcl","rollback.rs"],"content":"use crate::ast::{SQLStatement, TCLStatement};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct RollbackQuery {}\n\nimpl From\u003cRollbackQuery\u003e for SQLStatement {\n    fn from(value: RollbackQuery) -\u003e SQLStatement {\n        SQLStatement::TCL(TCLStatement::Rollback(value))\n    }\n}\n","traces":[{"line":7,"address":[5047216],"length":1,"stats":{"Line":1}},{"line":8,"address":[5047219],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","column.rs"],"content":"use crate::ast::types::DataType;\nuse serde::{Deserialize, Serialize};\n\nuse super::expression::SQLExpression;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub struct Column {\n    pub name: String,\n    pub data_type: DataType,\n    pub comment: String,\n    pub default: Option\u003cSQLExpression\u003e,\n    pub not_null: bool,\n    pub primary_key: bool,\n}\n\nimpl Column {\n    pub fn builder() -\u003e ColumnBuilder {\n        ColumnBuilder::default()\n    }\n}\n\n#[derive(Default)]\npub struct ColumnBuilder {\n    name: Option\u003cString\u003e,\n    data_type: Option\u003cDataType\u003e,\n    comment: Option\u003cString\u003e,\n    default: Option\u003cSQLExpression\u003e,\n    not_null: Option\u003cbool\u003e,\n    primary_key: Option\u003cbool\u003e,\n}\n\nimpl ColumnBuilder {\n    pub fn set_name(mut self, name: String) -\u003e Self {\n        self.name = Some(name);\n        self\n    }\n\n    pub fn set_data_type(mut self, data_type: DataType) -\u003e Self {\n        self.data_type = Some(data_type);\n        self\n    }\n\n    pub fn set_comment(mut self, comment: String) -\u003e Self {\n        self.comment = Some(comment);\n        self\n    }\n\n    pub fn set_default(mut self, default: SQLExpression) -\u003e Self {\n        self.default = Some(default);\n        self\n    }\n\n    pub fn set_not_null(mut self, not_null: bool) -\u003e Self {\n        self.not_null = Some(not_null);\n        self\n    }\n\n    pub fn set_primary_key(mut self, primary_key: bool) -\u003e Self {\n        self.primary_key = Some(primary_key);\n        if primary_key {\n            self.not_null = Some(true);\n        }\n        self\n    }\n\n    pub fn build(self) -\u003e Column {\n        Column {\n            name: self.name.unwrap(),\n            data_type: self.data_type.unwrap(),\n            comment: self.comment.unwrap_or_else(|| \"\".into()),\n            default: self.default,\n            not_null: self.not_null.unwrap_or(false),\n            primary_key: self.primary_key.unwrap_or(false),\n        }\n    }\n}\n\n// [column_name.]table_name\n// 컬럼명을 가리키는 값입니다.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ColumnName {\n    pub table_name: Option\u003cString\u003e,\n    pub column_name: String,\n}\n\nimpl ColumnName {\n    pub fn new(table_name: Option\u003cString\u003e, column_name: String) -\u003e Self {\n        ColumnName {\n            table_name,\n            column_name,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_column_builder() {\n        let column = Column::builder()\n            .set_name(\"id\".into())\n            .set_data_type(DataType::Int)\n            .set_comment(\"id column\".into())\n            .set_default(SQLExpression::Integer(1))\n            .set_not_null(true)\n            .set_primary_key(true)\n            .build();\n\n        assert_eq!(column.name, \"id\");\n        assert_eq!(column.data_type, DataType::Int);\n        assert_eq!(column.comment, \"id column\");\n        assert_eq!(column.default, Some(SQLExpression::Integer(1)));\n        assert_eq!(column.not_null, true);\n        assert_eq!(column.primary_key, true);\n    }\n\n    #[test]\n    fn test_column_name() {\n        let column_name = ColumnName::new(Some(\"table\".into()), \"column\".into());\n        assert_eq!(column_name.table_name, Some(\"table\".into()));\n        assert_eq!(column_name.column_name, \"column\");\n    }\n}\n","traces":[{"line":17,"address":[2886272],"length":1,"stats":{"Line":1}},{"line":18,"address":[2886280],"length":1,"stats":{"Line":1}},{"line":33,"address":[2886466,2886304],"length":1,"stats":{"Line":1}},{"line":34,"address":[2886419,2886331],"length":1,"stats":{"Line":2}},{"line":35,"address":[2886446],"length":1,"stats":{"Line":1}},{"line":38,"address":[2886496],"length":1,"stats":{"Line":1}},{"line":39,"address":[2886517],"length":1,"stats":{"Line":1}},{"line":40,"address":[2886544],"length":1,"stats":{"Line":1}},{"line":43,"address":[2886738,2886576],"length":1,"stats":{"Line":1}},{"line":44,"address":[2886691,2886603],"length":1,"stats":{"Line":2}},{"line":45,"address":[2886718],"length":1,"stats":{"Line":1}},{"line":48,"address":[2886768,2886980],"length":1,"stats":{"Line":1}},{"line":49,"address":[2886931,2886795],"length":1,"stats":{"Line":2}},{"line":50,"address":[2886960],"length":1,"stats":{"Line":1}},{"line":53,"address":[2887008],"length":1,"stats":{"Line":1}},{"line":54,"address":[2887031],"length":1,"stats":{"Line":1}},{"line":55,"address":[2887047],"length":1,"stats":{"Line":1}},{"line":58,"address":[2887072],"length":1,"stats":{"Line":1}},{"line":59,"address":[2887102],"length":1,"stats":{"Line":1}},{"line":60,"address":[2887175,2887121],"length":1,"stats":{"Line":2}},{"line":61,"address":[2887160],"length":1,"stats":{"Line":1}},{"line":63,"address":[2887135],"length":1,"stats":{"Line":1}},{"line":66,"address":[2887184,2887996,2887936],"length":1,"stats":{"Line":1}},{"line":68,"address":[2887206],"length":1,"stats":{"Line":1}},{"line":69,"address":[2887387],"length":1,"stats":{"Line":1}},{"line":70,"address":[2887558],"length":1,"stats":{"Line":3}},{"line":71,"address":[2887622],"length":1,"stats":{"Line":1}},{"line":72,"address":[2887693],"length":1,"stats":{"Line":1}},{"line":73,"address":[2887761],"length":1,"stats":{"Line":1}},{"line":87,"address":[2888032],"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","data_types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n// SQL 데이터 타입\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum DataType {\n    Int,\n    Float,\n    Boolean,\n    Varchar(i64),\n}\n\nimpl DataType {\n    pub fn type_code(\u0026self) -\u003e isize {\n        match self {\n            DataType::Int =\u003e 1,\n            DataType::Float =\u003e 2,\n            DataType::Boolean =\u003e 3,\n            DataType::Varchar(_) =\u003e 4,\n        }\n    }\n}\n\nimpl From\u003cDataType\u003e for String {\n    fn from(value: DataType) -\u003e Self {\n        match value {\n            DataType::Int =\u003e \"integer\".into(),\n            DataType::Float =\u003e \"float\".into(),\n            DataType::Boolean =\u003e \"boolean\".into(),\n            DataType::Varchar(number) =\u003e format!(\"varchar({})\", number),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_data_type_type_code() {\n        assert_eq!(DataType::Int.type_code(), 1);\n        assert_eq!(DataType::Float.type_code(), 2);\n        assert_eq!(DataType::Boolean.type_code(), 3);\n        assert_eq!(DataType::Varchar(255).type_code(), 4);\n    }\n\n    #[test]\n    fn test_data_type_into_string() {\n        assert_eq!(String::from(DataType::Int), \"integer\");\n        assert_eq!(String::from(DataType::Float), \"float\");\n        assert_eq!(String::from(DataType::Boolean), \"boolean\");\n        assert_eq!(String::from(DataType::Varchar(255)), \"varchar(255)\");\n    }\n}\n","traces":[{"line":13,"address":[1561472],"length":1,"stats":{"Line":1}},{"line":14,"address":[1561477],"length":1,"stats":{"Line":1}},{"line":15,"address":[1561508],"length":1,"stats":{"Line":1}},{"line":16,"address":[1561519],"length":1,"stats":{"Line":1}},{"line":17,"address":[1561530],"length":1,"stats":{"Line":1}},{"line":18,"address":[1561541],"length":1,"stats":{"Line":1}},{"line":24,"address":[2005328],"length":1,"stats":{"Line":1}},{"line":25,"address":[2005354],"length":1,"stats":{"Line":1}},{"line":26,"address":[2005391],"length":1,"stats":{"Line":1}},{"line":27,"address":[2005425],"length":1,"stats":{"Line":1}},{"line":28,"address":[2005459],"length":1,"stats":{"Line":1}},{"line":29,"address":[2005587,2005489],"length":1,"stats":{"Line":2}}],"covered":12,"coverable":12},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","expression.rs"],"content":"use crate::{\n    ast::dml::{\n        expressions::{\n            between::BetweenExpression, binary::BinaryOperatorExpression, call::CallExpression,\n            list::ListExpression, not_between::NotBetweenExpression,\n            parentheses::ParenthesesExpression, subquery::SubqueryExpression,\n            unary::UnaryOperatorExpression,\n        },\n        parts::_where::WhereClause,\n    },\n    executor::config::row::TableDataFieldType,\n    utils::collection::join_vec,\n};\n\nuse serde::{Deserialize, Serialize};\n\nuse super::select_column::SelectColumn;\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\npub enum SQLExpression {\n    // 복합 표현식\n    Unary(Box\u003cUnaryOperatorExpression\u003e),     // 단항 연산식\n    Binary(Box\u003cBinaryOperatorExpression\u003e),   // 2항 연산식\n    Between(Box\u003cBetweenExpression\u003e),         // BETWEEN 식\n    NotBetween(Box\u003cNotBetweenExpression\u003e),   // NOT BETWEEN 식\n    Parentheses(Box\u003cParenthesesExpression\u003e), // 소괄호 표현식\n    FunctionCall(CallExpression),            // 함수호출 표현식\n    Subquery(SubqueryExpression),            // SQL 서브쿼리 (미구현)\n\n    // 끝단 Primitive 값\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    String(String),\n    List(ListExpression),\n    SelectColumn(SelectColumn),\n    Null,\n}\n\nimpl SQLExpression {\n    pub fn is_unary(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self.clone() {\n            Self::Unary(_) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    // Select 절의 표현식 목록에서 실제로 DB에서 가져와야하는 대상 컬럼 목록을 추출합니다.\n    pub fn get_select_column_list(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::get_select_column_list_recursion(self)\n    }\n\n    fn get_select_column_list_recursion(expression: \u0026Self) -\u003e Vec\u003cSelectColumn\u003e {\n        match expression {\n            SQLExpression::Integer(_)\n            | SQLExpression::Float(_)\n            | SQLExpression::Boolean(_)\n            | SQLExpression::String(_)\n            | SQLExpression::Null =\u003e {\n                vec![]\n            }\n            SQLExpression::List(list) =\u003e list\n                .value\n                .iter()\n                .flat_map(Self::get_select_column_list_recursion)\n                .collect(),\n            SQLExpression::SelectColumn(column) =\u003e {\n                vec![column.to_owned()]\n            }\n            SQLExpression::Unary(unary) =\u003e Self::get_select_column_list(\u0026unary.operand),\n            SQLExpression::Binary(binary) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026binary.lhs),\n                Self::get_select_column_list(\u0026binary.rhs)\n            ),\n            SQLExpression::Between(between) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026between.a),\n                Self::get_select_column_list(\u0026between.x),\n                Self::get_select_column_list(\u0026between.y)\n            ),\n            SQLExpression::NotBetween(between) =\u003e join_vec!(\n                Self::get_select_column_list(\u0026between.a),\n                Self::get_select_column_list(\u0026between.x),\n                Self::get_select_column_list(\u0026between.y)\n            ),\n            SQLExpression::Parentheses(paren) =\u003e Self::get_select_column_list(\u0026paren.expression),\n            SQLExpression::FunctionCall(function_call) =\u003e function_call\n                .arguments\n                .iter()\n                .flat_map(Self::get_select_column_list_recursion)\n                .collect(),\n            SQLExpression::Subquery(_subquery) =\u003e unimplemented!(),\n        }\n    }\n\n    pub fn has_aggregate(\u0026self) -\u003e bool {\n        Self::has_aggregate_recursion(self)\n    }\n\n    fn has_aggregate_recursion(this: \u0026Self) -\u003e bool {\n        match this {\n            Self::Unary(unary) =\u003e Self::has_aggregate_recursion(\u0026unary.operand),\n            Self::Binary(binary) =\u003e {\n                Self::has_aggregate_recursion(\u0026binary.lhs)\n                    | Self::has_aggregate_recursion(\u0026binary.rhs)\n            }\n            Self::Between(between) =\u003e {\n                Self::has_aggregate_recursion(\u0026between.a)\n                    | Self::has_aggregate_recursion(\u0026between.x)\n                    | Self::has_aggregate_recursion(\u0026between.y)\n            }\n            Self::NotBetween(not_between) =\u003e {\n                Self::has_aggregate_recursion(\u0026not_between.a)\n                    | Self::has_aggregate_recursion(\u0026not_between.x)\n                    | Self::has_aggregate_recursion(\u0026not_between.y)\n            }\n            Self::Parentheses(paren) =\u003e Self::has_aggregate_recursion(\u0026paren.expression),\n            Self::FunctionCall(call) =\u003e call.function.is_aggregate(),\n            _ =\u003e false,\n        }\n    }\n\n    pub fn find_non_aggregate_columns(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::find_non_aggregate_columns_recursion(self)\n    }\n\n    fn find_non_aggregate_columns_recursion(this: \u0026Self) -\u003e Vec\u003cSelectColumn\u003e {\n        match this {\n            Self::Unary(unary) =\u003e Self::find_non_aggregate_columns_recursion(\u0026unary.operand),\n            Self::Binary(binary) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026binary.lhs),\n                Self::find_non_aggregate_columns_recursion(\u0026binary.rhs)\n            ),\n            Self::Between(between) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026between.a),\n                Self::find_non_aggregate_columns_recursion(\u0026between.x),\n                Self::find_non_aggregate_columns_recursion(\u0026between.y)\n            ),\n            Self::NotBetween(not_between) =\u003e join_vec!(\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.a),\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.x),\n                Self::find_non_aggregate_columns_recursion(\u0026not_between.y)\n            ),\n            Self::Parentheses(paren) =\u003e {\n                Self::find_non_aggregate_columns_recursion(\u0026paren.expression)\n            }\n            Self::FunctionCall(call) =\u003e {\n                if call.function.is_aggregate() {\n                    vec![]\n                } else {\n                    call.arguments\n                        .iter()\n                        .cloned()\n                        .flat_map(|e| Self::find_non_aggregate_columns_recursion(\u0026e))\n                        .collect()\n                }\n            }\n            Self::SelectColumn(column) =\u003e vec![column.to_owned()],\n            _ =\u003e vec![],\n        }\n    }\n\n    pub fn find_aggregate_columns(\u0026self) -\u003e Vec\u003cSelectColumn\u003e {\n        Self::find_aggregate_columns_recursion(self, Default::default())\n    }\n\n    fn find_aggregate_columns_recursion(\n        this: \u0026Self,\n        mut context: RecursionContext,\n    ) -\u003e Vec\u003cSelectColumn\u003e {\n        match this {\n            Self::Unary(unary) =\u003e Self::find_aggregate_columns_recursion(\u0026unary.operand, context),\n            Self::Binary(binary) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026binary.lhs, context),\n                Self::find_aggregate_columns_recursion(\u0026binary.rhs, context)\n            ),\n            Self::Between(between) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026between.a, context),\n                Self::find_aggregate_columns_recursion(\u0026between.x, context),\n                Self::find_aggregate_columns_recursion(\u0026between.y, context)\n            ),\n            Self::NotBetween(not_between) =\u003e join_vec!(\n                Self::find_aggregate_columns_recursion(\u0026not_between.a, context),\n                Self::find_aggregate_columns_recursion(\u0026not_between.x, context),\n                Self::find_aggregate_columns_recursion(\u0026not_between.y, context)\n            ),\n            Self::Parentheses(paren) =\u003e {\n                Self::find_aggregate_columns_recursion(\u0026paren.expression, context)\n            }\n            Self::FunctionCall(call) =\u003e {\n                if call.function.is_aggregate() {\n                    context.in_aggregate = true;\n                    call.arguments\n                        .iter()\n                        .cloned()\n                        .flat_map(|e| Self::find_aggregate_columns_recursion(\u0026e, context))\n                        .collect()\n                } else {\n                    vec![]\n                }\n            }\n            Self::SelectColumn(column) =\u003e {\n                if context.in_aggregate {\n                    vec![column.to_owned()]\n                } else {\n                    vec![]\n                }\n            }\n            _ =\u003e vec![],\n        }\n    }\n}\n\nimpl From\u003cSQLExpression\u003e for WhereClause {\n    fn from(value: SQLExpression) -\u003e WhereClause {\n        WhereClause { expression: value }\n    }\n}\n\nimpl From\u003cSQLExpression\u003e for Option\u003cBox\u003cSQLExpression\u003e\u003e {\n    fn from(value: SQLExpression) -\u003e Option\u003cBox\u003cSQLExpression\u003e\u003e {\n        Some(Box::new(value))\n    }\n}\n\nimpl From\u003cTableDataFieldType\u003e for SQLExpression {\n    fn from(value: TableDataFieldType) -\u003e SQLExpression {\n        match value {\n            TableDataFieldType::Integer(value) =\u003e SQLExpression::Integer(value),\n            TableDataFieldType::Float(value) =\u003e SQLExpression::Float(value.into()),\n            TableDataFieldType::Boolean(value) =\u003e SQLExpression::Boolean(value),\n            TableDataFieldType::String(value) =\u003e SQLExpression::String(value),\n            TableDataFieldType::Null =\u003e SQLExpression::Null,\n            TableDataFieldType::Array(value) =\u003e SQLExpression::List(\n                value\n                    .into_iter()\n                    .map(|e| e.into())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .into(),\n            ),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Default, Copy)]\nstruct RecursionContext {\n    pub in_aggregate: bool,\n}\n\n#[allow(non_snake_case)]\n#[cfg(test)]\nmod tests {\n    use crate::ast::{\n        dml::expressions::{\n            between::BetweenExpression,\n            binary::BinaryOperatorExpression,\n            call::CallExpression,\n            not_between::NotBetweenExpression,\n            operators::{BinaryOperator, UnaryOperator},\n            parentheses::ParenthesesExpression,\n            unary::UnaryOperatorExpression,\n        },\n        types::{AggregateFunction, ConditionalFunction, Function, SQLExpression, SelectColumn},\n    };\n\n    #[test]\n    fn test_SQLExpression_get_select_column_list() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"List 필드\".into(),\n                expression: SQLExpression::List(\n                    vec![\n                        SQLExpression::Integer(1),\n                        SQLExpression::Integer(2),\n                        SQLExpression::Integer(3),\n                    ]\n                    .into(),\n                ),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"유효한 Select 필드\".into(),\n                expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 단항연산 필드\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 이항연산 필드\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![\n                    SelectColumn::new(None, \"id\".into()),\n                    SelectColumn::new(None, \"name\".into()),\n                ],\n            },\n            TestCase {\n                name: \"유효한 BETWEEN 필드\".into(),\n                expression: SQLExpression::Between(Box::new(\n                    crate::ast::dml::expressions::between::BetweenExpression {\n                        a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(10),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 NOT BETWEEN 필드\".into(),\n                expression: SQLExpression::NotBetween(Box::new(\n                    crate::ast::dml::expressions::not_between::NotBetweenExpression {\n                        a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(10),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 소괄호 필드\".into(),\n                expression: SQLExpression::Parentheses(Box::new(\n                    crate::ast::dml::expressions::parentheses::ParenthesesExpression {\n                        expression: SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        )),\n                    },\n                )),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"유효한 함수호출 필드\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(AggregateFunction::Count.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.get_select_column_list(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExpression_has_aggregate() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: false,\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::Integer(4444),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::Integer(1),\n                    rhs: SQLExpression::Integer(2),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    rhs: SQLExpression::Integer(2),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::Integer(1),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::Integer(1),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                    x: SQLExpression::Integer(2),\n                    y: SQLExpression::Integer(3),\n                })),\n                expected: true,\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::Integer(1),\n                })),\n                expected: false,\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::Integer(1)],\n                    }),\n                })),\n                expected: true,\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.has_aggregate(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExperssion_find_aggregate_columns() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"이항 중첩 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"함수호출 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(ConditionalFunction::NullIf.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.find_aggregate_columns(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_From_SQLExpression_for_Option_Box_SQLExpression() {\n        let expression = SQLExpression::Integer(1);\n        let expected = Some(Box::new(expression.clone()));\n\n        assert_eq!(Option::\u003cBox\u003cSQLExpression\u003e\u003e::from(expression), expected);\n    }\n\n    #[test]\n    fn test_From_TableDataFieldType_for_SQLExpression() {\n        use crate::executor::config::row::TableDataFieldType;\n\n        struct TestCase {\n            name: String,\n            value: TableDataFieldType,\n            expected: SQLExpression,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"정수형\".into(),\n                value: TableDataFieldType::Integer(1),\n                expected: SQLExpression::Integer(1),\n            },\n            TestCase {\n                name: \"실수형\".into(),\n                value: TableDataFieldType::Float(1.0.into()),\n                expected: SQLExpression::Float(1.0),\n            },\n            TestCase {\n                name: \"부울형\".into(),\n                value: TableDataFieldType::Boolean(true),\n                expected: SQLExpression::Boolean(true),\n            },\n            TestCase {\n                name: \"문자열형\".into(),\n                value: TableDataFieldType::String(\"hello\".into()),\n                expected: SQLExpression::String(\"hello\".into()),\n            },\n            TestCase {\n                name: \"배열형\".into(),\n                value: TableDataFieldType::Array(vec![\n                    TableDataFieldType::Integer(1),\n                    TableDataFieldType::Integer(2),\n                    TableDataFieldType::Integer(3),\n                ]),\n                expected: SQLExpression::List(\n                    vec![\n                        SQLExpression::Integer(1),\n                        SQLExpression::Integer(2),\n                        SQLExpression::Integer(3),\n                    ]\n                    .into(),\n                ),\n            },\n            TestCase {\n                name: \"NULL 값\".into(),\n                value: TableDataFieldType::Null,\n                expected: SQLExpression::Null,\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                SQLExpression::from(test_case.value),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n\n    #[test]\n    fn test_SQLExpression_find_non_aggregate_columns() {\n        struct TestCase {\n            name: String,\n            expression: SQLExpression,\n            expected: Vec\u003cSelectColumn\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"단일 값 필드\".into(),\n                expression: SQLExpression::Integer(4444),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"단일 Select 필드\".into(),\n                expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"단항 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Unary(Box::new(UnaryOperatorExpression {\n                    operator: UnaryOperator::Neg,\n                    operand: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"이항 연산 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![\n                    SelectColumn::new(None, \"id\".into()),\n                    SelectColumn::new(None, \"name\".into()),\n                ],\n            },\n            TestCase {\n                name: \"이항 중첩 연산 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Binary(Box::new(BinaryOperatorExpression {\n                    lhs: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    rhs: SQLExpression::SelectColumn(SelectColumn::new(None, \"name\".into())),\n                    operator: BinaryOperator::Add,\n                })),\n                expected: vec![SelectColumn::new(None, \"name\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Between(Box::new(BetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"NOT BETWEEN 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::NotBetween(Box::new(NotBetweenExpression {\n                    a: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                    x: SQLExpression::Integer(1),\n                    y: SQLExpression::Integer(10),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::SelectColumn(SelectColumn::new(None, \"id\".into())),\n                })),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n            TestCase {\n                name: \"소괄호 필드 (aggregate 있음)\".into(),\n                expression: SQLExpression::Parentheses(Box::new(ParenthesesExpression {\n                    expression: SQLExpression::FunctionCall(CallExpression {\n                        function: Function::BuiltIn(AggregateFunction::Count.into()),\n                        arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                            None,\n                            \"id\".into(),\n                        ))],\n                    }),\n                })),\n                expected: vec![],\n            },\n            TestCase {\n                name: \"함수호출 필드 (aggregate 없음)\".into(),\n                expression: SQLExpression::FunctionCall(CallExpression {\n                    function: Function::BuiltIn(ConditionalFunction::Coalesce.into()),\n                    arguments: vec![SQLExpression::SelectColumn(SelectColumn::new(\n                        None,\n                        \"id\".into(),\n                    ))],\n                }),\n                expected: vec![SelectColumn::new(None, \"id\".into())],\n            },\n        ];\n\n        for test_case in test_cases {\n            assert_eq!(\n                test_case.expression.find_non_aggregate_columns(),\n                test_case.expected,\n                \"{}\",\n                test_case.name\n            );\n        }\n    }\n}\n","traces":[{"line":41,"address":[8195696],"length":1,"stats":{"Line":2}},{"line":43,"address":[8195708],"length":1,"stats":{"Line":2}},{"line":50,"address":[8195792],"length":1,"stats":{"Line":1}},{"line":51,"address":[8195809],"length":1,"stats":{"Line":1}},{"line":54,"address":[8195824,8196704,8196732],"length":1,"stats":{"Line":1}},{"line":55,"address":[8195854],"length":1,"stats":{"Line":1}},{"line":61,"address":[8196388],"length":1,"stats":{"Line":1}},{"line":63,"address":[8196403],"length":1,"stats":{"Line":1}},{"line":68,"address":[8196466],"length":1,"stats":{"Line":1}},{"line":69,"address":[8196493,8197532],"length":1,"stats":{"Line":1}},{"line":71,"address":[8195964],"length":1,"stats":{"Line":1}},{"line":72,"address":[8195998],"length":1,"stats":{"Line":1}},{"line":73,"address":[8196013],"length":1,"stats":{"Line":1}},{"line":74,"address":[8196043],"length":1,"stats":{"Line":1}},{"line":76,"address":[8196074],"length":1,"stats":{"Line":1}},{"line":77,"address":[8196094],"length":1,"stats":{"Line":1}},{"line":78,"address":[8196784,8196124],"length":1,"stats":{"Line":2}},{"line":79,"address":[8196792],"length":1,"stats":{"Line":1}},{"line":81,"address":[8196155],"length":1,"stats":{"Line":1}},{"line":82,"address":[8196175],"length":1,"stats":{"Line":1}},{"line":83,"address":[8197177,8196205],"length":1,"stats":{"Line":2}},{"line":84,"address":[8197185],"length":1,"stats":{"Line":1}},{"line":86,"address":[8196241],"length":1,"stats":{"Line":1}},{"line":87,"address":[8196275],"length":1,"stats":{"Line":1}},{"line":96,"address":[8197680],"length":1,"stats":{"Line":1}},{"line":97,"address":[8197685],"length":1,"stats":{"Line":1}},{"line":100,"address":[8197712],"length":1,"stats":{"Line":1}},{"line":101,"address":[8197726],"length":1,"stats":{"Line":1}},{"line":102,"address":[8197805],"length":1,"stats":{"Line":1}},{"line":103,"address":[8197842],"length":1,"stats":{"Line":1}},{"line":104,"address":[8197854,8197893],"length":1,"stats":{"Line":2}},{"line":105,"address":[8197874],"length":1,"stats":{"Line":1}},{"line":107,"address":[8197911],"length":1,"stats":{"Line":1}},{"line":108,"address":[8197967,8197995,8197923],"length":1,"stats":{"Line":3}},{"line":109,"address":[8197943],"length":1,"stats":{"Line":1}},{"line":110,"address":[8197973],"length":1,"stats":{"Line":1}},{"line":112,"address":[8198013],"length":1,"stats":{"Line":1}},{"line":113,"address":[8198025,8198069,8198097],"length":1,"stats":{"Line":3}},{"line":114,"address":[8198045],"length":1,"stats":{"Line":1}},{"line":115,"address":[8198075],"length":1,"stats":{"Line":1}},{"line":117,"address":[8198112],"length":1,"stats":{"Line":1}},{"line":118,"address":[8198146],"length":1,"stats":{"Line":1}},{"line":119,"address":[8197790],"length":1,"stats":{"Line":1}},{"line":123,"address":[8198192],"length":1,"stats":{"Line":1}},{"line":124,"address":[8198209],"length":1,"stats":{"Line":1}},{"line":127,"address":[8198968,8198940,8198224],"length":1,"stats":{"Line":1}},{"line":128,"address":[8198254],"length":1,"stats":{"Line":1}},{"line":129,"address":[8198383],"length":1,"stats":{"Line":1}},{"line":130,"address":[8198417],"length":1,"stats":{"Line":1}},{"line":131,"address":[8198432],"length":1,"stats":{"Line":1}},{"line":132,"address":[8198462],"length":1,"stats":{"Line":1}},{"line":134,"address":[8198493],"length":1,"stats":{"Line":1}},{"line":135,"address":[8198513],"length":1,"stats":{"Line":1}},{"line":136,"address":[8199020,8198543],"length":1,"stats":{"Line":2}},{"line":137,"address":[8199028],"length":1,"stats":{"Line":1}},{"line":139,"address":[8198574],"length":1,"stats":{"Line":1}},{"line":140,"address":[8198594],"length":1,"stats":{"Line":1}},{"line":141,"address":[8198624,8199413],"length":1,"stats":{"Line":2}},{"line":142,"address":[8199421],"length":1,"stats":{"Line":1}},{"line":144,"address":[8198660],"length":1,"stats":{"Line":1}},{"line":145,"address":[8198675],"length":1,"stats":{"Line":1}},{"line":147,"address":[8198691],"length":1,"stats":{"Line":1}},{"line":148,"address":[8198699],"length":1,"stats":{"Line":1}},{"line":149,"address":[8199836],"length":1,"stats":{"Line":1}},{"line":151,"address":[8199765],"length":1,"stats":{"Line":1}},{"line":154,"address":[3125440,3125468],"length":1,"stats":{"Line":2}},{"line":158,"address":[8199854,8198726],"length":1,"stats":{"Line":1}},{"line":159,"address":[8198363],"length":1,"stats":{"Line":1}},{"line":163,"address":[8200000],"length":1,"stats":{"Line":1}},{"line":164,"address":[8200024],"length":1,"stats":{"Line":1}},{"line":167,"address":[8200064,8200824,8200852],"length":1,"stats":{"Line":1}},{"line":171,"address":[8200102],"length":1,"stats":{"Line":1}},{"line":172,"address":[8200231],"length":1,"stats":{"Line":1}},{"line":173,"address":[8200274],"length":1,"stats":{"Line":1}},{"line":174,"address":[8200289],"length":1,"stats":{"Line":1}},{"line":175,"address":[8200327],"length":1,"stats":{"Line":1}},{"line":177,"address":[8200366],"length":1,"stats":{"Line":1}},{"line":178,"address":[8200386],"length":1,"stats":{"Line":1}},{"line":179,"address":[8200424,8200904],"length":1,"stats":{"Line":2}},{"line":180,"address":[8200912],"length":1,"stats":{"Line":1}},{"line":182,"address":[8200463],"length":1,"stats":{"Line":1}},{"line":183,"address":[8200483],"length":1,"stats":{"Line":1}},{"line":184,"address":[8201305,8200521],"length":1,"stats":{"Line":2}},{"line":185,"address":[8201313],"length":1,"stats":{"Line":1}},{"line":187,"address":[8200565],"length":1,"stats":{"Line":1}},{"line":188,"address":[8200580],"length":1,"stats":{"Line":1}},{"line":190,"address":[8200605],"length":1,"stats":{"Line":1}},{"line":191,"address":[8200613],"length":1,"stats":{"Line":1}},{"line":192,"address":[8201680],"length":1,"stats":{"Line":1}},{"line":193,"address":[8201685],"length":1,"stats":{"Line":1}},{"line":196,"address":[3125580,3125552],"length":1,"stats":{"Line":2}},{"line":199,"address":[8201665],"length":1,"stats":{"Line":1}},{"line":202,"address":[8200640],"length":1,"stats":{"Line":1}},{"line":203,"address":[8200657],"length":1,"stats":{"Line":1}},{"line":204,"address":[8201781],"length":1,"stats":{"Line":1}},{"line":206,"address":[8201761],"length":1,"stats":{"Line":1}},{"line":209,"address":[8200211],"length":1,"stats":{"Line":1}},{"line":215,"address":[7538736],"length":1,"stats":{"Line":1}},{"line":221,"address":[7798224],"length":1,"stats":{"Line":1}},{"line":222,"address":[7798322],"length":1,"stats":{"Line":1}},{"line":227,"address":[8201968],"length":1,"stats":{"Line":1}},{"line":228,"address":[8201989],"length":1,"stats":{"Line":1}},{"line":229,"address":[8202029],"length":1,"stats":{"Line":1}},{"line":230,"address":[8202067],"length":1,"stats":{"Line":1}},{"line":231,"address":[8202130],"length":1,"stats":{"Line":1}},{"line":232,"address":[8202178],"length":1,"stats":{"Line":1}},{"line":233,"address":[8202412],"length":1,"stats":{"Line":1}},{"line":235,"address":[8202281],"length":1,"stats":{"Line":1}},{"line":237,"address":[3125692,3125664],"length":1,"stats":{"Line":2}}],"covered":109,"coverable":109},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","foreign_key.rs"],"content":"use crate::ast::types::TableName;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct ForeignKey {\n    pub key_name: String,\n    pub table: TableName,\n    pub columns: Vec\u003cString\u003e,\n    pub referenced_table: TableName,\n    pub referenced_columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","function.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum Function {\n    BuiltIn(BuiltInFunction),         // 내장함수\n    UserDefined(UserDefinedFunction), // 사용자 정의 함수\n}\n\nimpl Function {\n    pub fn is_aggregate(\u0026self) -\u003e bool {\n        match self {\n            Self::BuiltIn(built_in) =\u003e match built_in {\n                BuiltInFunction::Aggregate(_) =\u003e true,\n                BuiltInFunction::Conditional(_) =\u003e false,\n            },\n            Self::UserDefined(_) =\u003e false,\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum BuiltInFunction {\n    Aggregate(AggregateFunction),\n    Conditional(ConditionalFunction),\n}\n\nimpl From\u003cBuiltInFunction\u003e for Function {\n    fn from(value: BuiltInFunction) -\u003e Function {\n        Function::BuiltIn(value)\n    }\n}\n\n// 집합 함수\n// 참고 https://www.postgresql.org/docs/9.5/functions-aggregate.html\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum AggregateFunction {\n    Sum,\n    Count,\n    Max,\n    Min,\n    Avg,\n    Every,\n    ArrayAgg,\n    StringAgg,\n}\n\nimpl From\u003cAggregateFunction\u003e for BuiltInFunction {\n    fn from(value: AggregateFunction) -\u003e BuiltInFunction {\n        BuiltInFunction::Aggregate(value)\n    }\n}\n\nimpl From\u003cAggregateFunction\u003e for Function {\n    fn from(value: AggregateFunction) -\u003e Function {\n        BuiltInFunction::Aggregate(value).into()\n    }\n}\n\nimpl TryFrom\u003cString\u003e for BuiltInFunction {\n    type Error = ();\n\n    fn try_from(function_name: String) -\u003e Result\u003cBuiltInFunction, Self::Error\u003e {\n        match function_name.to_uppercase().as_str() {\n            \"SUM\" =\u003e Ok(AggregateFunction::Sum.into()),\n            \"COUNT\" =\u003e Ok(AggregateFunction::Count.into()),\n            \"MAX\" =\u003e Ok(AggregateFunction::Max.into()),\n            \"MIN\" =\u003e Ok(AggregateFunction::Min.into()),\n            \"AVG\" =\u003e Ok(AggregateFunction::Avg.into()),\n            \"EVERY\" =\u003e Ok(AggregateFunction::Every.into()),\n            \"ARRAYAGG\" =\u003e Ok(AggregateFunction::ArrayAgg.into()),\n            \"STRINGAGG\" =\u003e Ok(AggregateFunction::StringAgg.into()),\n            \"NULLIF\" =\u003e Ok(ConditionalFunction::NullIf.into()),\n            \"COALESCE\" =\u003e Ok(ConditionalFunction::Coalesce.into()),\n            \"GREATEST\" =\u003e Ok(ConditionalFunction::Greatest.into()),\n            \"LEAST\" =\u003e Ok(ConditionalFunction::Least.into()),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n// 집합 함수\n// 참고 https://www.postgresql.org/docs/9.5/functions-aggregate.html\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub enum ConditionalFunction {\n    NullIf,\n    Coalesce,\n    Greatest,\n    Least,\n}\n\nimpl From\u003cConditionalFunction\u003e for BuiltInFunction {\n    fn from(value: ConditionalFunction) -\u003e BuiltInFunction {\n        BuiltInFunction::Conditional(value)\n    }\n}\n\nimpl From\u003cConditionalFunction\u003e for Function {\n    fn from(value: ConditionalFunction) -\u003e Function {\n        BuiltInFunction::Conditional(value).into()\n    }\n}\n\n// 함수명을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UserDefinedFunction {\n    pub database_name: Option\u003cString\u003e,\n    pub function_name: String,\n}\n\nimpl From\u003cUserDefinedFunction\u003e for Function {\n    fn from(value: UserDefinedFunction) -\u003e Function {\n        Function::UserDefined(value)\n    }\n}\n\nimpl UserDefinedFunction {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_function_is_aggregate() {\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Sum)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Count)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Max)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Min)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Avg)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Every)).is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::ArrayAgg))\n                .is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::StringAgg))\n                .is_aggregate(),\n            true\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::NullIf))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Coalesce))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Greatest))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::BuiltIn(BuiltInFunction::Conditional(ConditionalFunction::Least))\n                .is_aggregate(),\n            false\n        );\n        assert_eq!(\n            Function::UserDefined(UserDefinedFunction {\n                database_name: None,\n                function_name: \"my_function\".into()\n            })\n            .is_aggregate(),\n            false\n        );\n    }\n\n    #[allow(non_snake_case)]\n    #[test]\n    fn test_From_AggregateFunction_for_Function() {\n        assert_eq!(\n            Function::from(AggregateFunction::Sum),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Sum))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Count),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Count))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Max),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Max))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Min),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Min))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Avg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Avg))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::Every),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::Every))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::ArrayAgg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::ArrayAgg))\n        );\n        assert_eq!(\n            Function::from(AggregateFunction::StringAgg),\n            Function::BuiltIn(BuiltInFunction::Aggregate(AggregateFunction::StringAgg))\n        );\n    }\n}\n","traces":[{"line":10,"address":[4100384],"length":1,"stats":{"Line":1}},{"line":11,"address":[4100394],"length":1,"stats":{"Line":1}},{"line":12,"address":[4100429],"length":1,"stats":{"Line":1}},{"line":13,"address":[4100464],"length":1,"stats":{"Line":1}},{"line":14,"address":[4100471],"length":1,"stats":{"Line":1}},{"line":16,"address":[4100457],"length":1,"stats":{"Line":1}},{"line":28,"address":[4100496],"length":1,"stats":{"Line":1}},{"line":29,"address":[4100520],"length":1,"stats":{"Line":1}},{"line":48,"address":[4100544],"length":1,"stats":{"Line":1}},{"line":49,"address":[4100551],"length":1,"stats":{"Line":1}},{"line":54,"address":[4100576],"length":1,"stats":{"Line":1}},{"line":55,"address":[4100595],"length":1,"stats":{"Line":1}},{"line":62,"address":[4102143,4100640],"length":1,"stats":{"Line":2}},{"line":63,"address":[4100720,4100652,4100806],"length":1,"stats":{"Line":6}},{"line":64,"address":[4100822,4100888,4102097],"length":1,"stats":{"Line":2}},{"line":65,"address":[4100933,4100972,4100865,4102073],"length":1,"stats":{"Line":6}},{"line":66,"address":[4100949,4101056,4102049,4101017],"length":1,"stats":{"Line":4}},{"line":67,"address":[4101101,4101033,4102025,4101140],"length":1,"stats":{"Line":4}},{"line":68,"address":[4101185,4101117,4101224,4102001],"length":1,"stats":{"Line":4}},{"line":69,"address":[4101977,4101201,4101308,4101269],"length":1,"stats":{"Line":4}},{"line":70,"address":[4101285,4101353,4101953,4101392],"length":1,"stats":{"Line":4}},{"line":71,"address":[4101369,4101437,4101476,4101932],"length":1,"stats":{"Line":4}},{"line":72,"address":[4101911,4101453,4101560,4101521],"length":1,"stats":{"Line":4}},{"line":73,"address":[4101890,4101644,4101537,4101605],"length":1,"stats":{"Line":6}},{"line":74,"address":[4101689,4101728,4101621,4101869],"length":1,"stats":{"Line":2}},{"line":75,"address":[4101705,4101783,4101770,4101848],"length":1,"stats":{"Line":2}},{"line":76,"address":[4101776],"length":1,"stats":{"Line":1}},{"line":92,"address":[4102176],"length":1,"stats":{"Line":1}},{"line":93,"address":[4102183],"length":1,"stats":{"Line":1}},{"line":98,"address":[4102208],"length":1,"stats":{"Line":1}},{"line":99,"address":[4102227],"length":1,"stats":{"Line":1}},{"line":111,"address":[4102272],"length":1,"stats":{"Line":1}},{"line":112,"address":[4102280],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":33},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","index.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Index {\n    pub index_name: String,\n    pub database_name: Option\u003cString\u003e,\n    pub columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","mod.rs"],"content":"pub mod column;\npub use column::*;\n\npub mod table;\npub use table::*;\n\npub mod foreign_key;\npub use foreign_key::*;\n\npub mod unique_key;\npub use unique_key::*;\n\npub mod table_options;\npub use table_options::*;\n\npub mod data_types;\npub use data_types::*;\n\npub mod select_column;\npub use select_column::*;\n\npub mod function;\npub use function::*;\n\npub mod expression;\npub use expression::*;\n\npub mod index;\npub use index::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","select_column.rs"],"content":"use crate::ast::types::SQLExpression;\nuse serde::{Deserialize, Serialize};\n\n// [table_alias.]column_name\n// SELECT시 컬럼 지정을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash)]\npub struct SelectColumn {\n    pub table_name: Option\u003cString\u003e,\n    pub column_name: String,\n}\n\nimpl SelectColumn {\n    pub fn new(table_name: Option\u003cString\u003e, column_name: String) -\u003e Self {\n        SelectColumn {\n            column_name,\n            table_name,\n        }\n    }\n}\n\nimpl From\u003cSelectColumn\u003e for SQLExpression {\n    fn from(value: SelectColumn) -\u003e SQLExpression {\n        SQLExpression::SelectColumn(value)\n    }\n}\n","traces":[{"line":13,"address":[4152672],"length":1,"stats":{"Line":1}},{"line":22,"address":[8195632],"length":1,"stats":{"Line":1}},{"line":23,"address":[8195649],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","table.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::ast::dml::parts::from::{FromClause, FromTarget};\n\n// [database_name.]table_name\n// 테이블명을 가리키는 값입니다.\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, Hash, Default)]\npub struct TableName {\n    pub database_name: Option\u003cString\u003e,\n    pub table_name: String,\n}\n\nimpl TableName {\n    pub fn new(database_name: Option\u003cString\u003e, table_name: String) -\u003e Self {\n        TableName {\n            database_name,\n            table_name,\n        }\n    }\n}\n\nimpl From\u003cTableName\u003e for FromClause {\n    fn from(value: TableName) -\u003e FromClause {\n        FromClause {\n            from: FromTarget::Table(value),\n            alias: None,\n        }\n    }\n}\n","traces":[{"line":14,"address":[2873168],"length":1,"stats":{"Line":1}},{"line":23,"address":[1604656],"length":1,"stats":{"Line":1}},{"line":25,"address":[1604669],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","table_options.rs"],"content":"#[derive(Clone, Debug, PartialEq, Eq)]\npub struct TableOptions {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","ast","types","unique_key.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]\npub struct UniqueKey {\n    pub key_name: String,\n    pub database_name: Option\u003cString\u003e,\n    pub columns: Vec\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","init.rs"],"content":"use serde::Deserialize;\n\nuse clap::Args;\n\n/// Config options for the build system.\n#[derive(Clone, Debug, Default, Deserialize, Args)]\npub struct ConfigOptions {\n    /// 파일이 세팅될 경로\n    #[clap(long, short)]\n    pub config_path: Option\u003cString\u003e,\n}\n\n#[derive(Clone, Debug, Args)]\n#[clap(name = \"init\")]\npub struct Command {\n    #[clap(flatten)]\n    pub init: ConfigOptions,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","mod.rs"],"content":"pub mod init;\npub mod run;\n\nuse clap::Parser;\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about, long_about = None)]\npub struct Command {\n    #[clap(subcommand)]\n    pub action: SubCommand,\n}\n\n#[derive(clap::Subcommand, Debug)]\npub enum SubCommand {\n    /// 설정 파일 및 저장공간 초기화\n    Init(init::Command),\n    /// DB 서버 실행\n    Run(run::Command),\n    /// DB 클라이언트 실행\n    Client,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","command","run.rs"],"content":"use serde::Deserialize;\n\nuse clap::Args;\n\n/// Config options for the build system.\n#[derive(Clone, Debug, Default, Deserialize, Args)]\npub struct ConfigOptions {\n    #[clap(name = \"config\", long, help = \"config file path\")]\n    pub config: Option\u003cString\u003e,\n}\n\n#[derive(Clone, Debug, Args)]\n#[clap(name = \"run\")]\npub struct Command {\n    #[clap(flatten)]\n    pub value: ConfigOptions,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","constants.rs"],"content":"// 기본 데이터베이스 이름\npub const DEFAULT_DATABASE_NAME: \u0026str = \"rrdb\";\n\n// 기본 설정파일 이름.\npub const DEFAULT_CONFIG_FILENAME: \u0026str = \"rrdb.config\";\n\n// 기본 Data 디렉터리 이름\npub const DEFAULT_DATA_DIRNAME: \u0026str = \"data\";\n\n// 운영체제별 기본 저장 경로를 반환합니다.\n#[cfg(target_os = \"linux\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = \"/var/lib/rrdb\";\n\n#[cfg(target_os = \"windows\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = r\"C:\\Program Files\\rrdb\";\n\n#[cfg(target_os = \"macos\")]\npub const DEFAULT_CONFIG_BASEPATH: \u0026str = \"/var/lib/rrdb\";\n\npub const LAUNCHD_PLIST_PATH: \u0026str = \"/Library/LaunchDaemons/io.github.myyrakle.rrdb.plist\";\n\n#[cfg(target_os = \"linux\")]\npub const SYSTEMD_DAEMON_SCRIPT: \u0026str = r#\"[Unit]\nDescription=RRDB\n\n[Service]\nType=simple\nRestart=on-failure\nExecStart=/usr/bin/rrdb run\nRemainAfterExit=on\nUser=root\nStandardOutput=file:/var/log/rrdb.stdout.log\nStandardError=file:/var/log/rrdb.stderr.log\n\n[Install]\nWantedBy=multi-user.target\"#;\n\n#[cfg(target_os = \"macos\")]\npub const LAUNCHD_DAEMON_SCRIPT: \u0026str = r#\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e\n\u003cplist version=\"1.0\"\u003e\n\u003cdict\u003e\n        \u003ckey\u003eLabel\u003c/key\u003e\n        \u003cstring\u003emyyrakle.github.io.rrdb\u003c/string\u003e\n        \u003ckey\u003eUserName\u003c/key\u003e\n        \u003cstring\u003eroot\u003c/string\u003e\n        \u003ckey\u003eProgram\u003c/key\u003e\n        \u003cstring\u003e/usr/local/bin/rrdb\u003c/string\u003e\n        \u003ckey\u003eProgramArguments\u003c/key\u003e\n        \u003carray\u003e\n            \u003cstring\u003erun\u003c/string\u003e\n        \u003c/array\u003e\n        \u003ckey\u003eRunAtLoad\u003c/key\u003e\n        \u003ctrue/\u003e\n        \u003ckey\u003eStandardOutPath\u003c/key\u003e\n        \u003cstring\u003e/var/log/rrdb.stdout.log\u003c/string\u003e\n        \u003ckey\u003eStandardErrorPath\u003c/key\u003e\n        \u003cstring\u003e/var/log/rrdb.stderr.log\u003c/string\u003e\n\u003c/dict\u003e\n\u003c/plist\u003e\"#;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","execute_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ExecuteError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ExecuteError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ExecuteError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ExecuteError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ExecuteError {}\n\nimpl std::fmt::Display for ExecuteError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"{}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_execute_error_eq() {\n        let error1 = ExecuteError::wrap(\"test\");\n        let error2 = ExecuteError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_execute_error_display() {\n        let error = ExecuteError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"test\"));\n    }\n}\n","traces":[{"line":10,"address":[5247824],"length":1,"stats":{"Line":1}},{"line":11,"address":[5247838],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[5247872],"length":1,"stats":{"Line":1}},{"line":28,"address":[5247893,5247954],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","into_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct IntoError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for IntoError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl IntoError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::IntoError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for IntoError {}\n\nimpl std::fmt::Display for IntoError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error(into error): {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_error_eq() {\n        let error1 = IntoError::wrap(\"test\");\n        let error2 = IntoError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_into_error_display() {\n        let error = IntoError::wrap(\"test\");\n\n        assert!(error\n            .to_string()\n            .contains(\"parsing error(into error): test\"));\n    }\n}\n","traces":[{"line":10,"address":[1693024],"length":1,"stats":{"Line":1}},{"line":11,"address":[1693038],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[1693072],"length":1,"stats":{"Line":1}},{"line":28,"address":[1693154,1693093],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","lexing_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct LexingError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for LexingError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl LexingError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::LexingError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for LexingError {}\n\nimpl std::fmt::Display for LexingError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"lexing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_lexing_error_eq() {\n        let error1 = LexingError::wrap(\"test\");\n        let error2 = LexingError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_lexing_error_display() {\n        let error = LexingError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"lexing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[1670496],"length":1,"stats":{"Line":1}},{"line":11,"address":[1670510],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[1670544],"length":1,"stats":{"Line":1}},{"line":28,"address":[1670626,1670565],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","mod.rs"],"content":"pub mod execute_error;\npub mod into_error;\npub mod lexing_error;\npub mod parsing_error;\npub mod predule;\npub mod server_error;\npub mod type_error;\n\n#[derive(Debug, PartialEq)]\npub enum RRDBError {\n    ExecuteError(execute_error::ExecuteError),\n    IntoError(into_error::IntoError),\n    LexingError(lexing_error::LexingError),\n    ParsingError(parsing_error::ParsingError),\n    ServerError(server_error::ServerError),\n    TypeError(type_error::TypeError),\n}\n\nimpl ToString for RRDBError {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            RRDBError::ExecuteError(e) =\u003e e.to_string(),\n            RRDBError::IntoError(e) =\u003e e.to_string(),\n            RRDBError::LexingError(e) =\u003e e.to_string(),\n            RRDBError::ParsingError(e) =\u003e e.to_string(),\n            RRDBError::ServerError(e) =\u003e e.to_string(),\n            RRDBError::TypeError(e) =\u003e e.to_string(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use predule::{ExecuteError, IntoError, LexingError, ParsingError, ServerError, TypeError};\n\n    use super::*;\n\n    #[test]\n    fn test_rrdb_error_to_string() {\n        let error = ExecuteError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = IntoError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = LexingError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = ParsingError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = ServerError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n\n        let error = TypeError::wrap(\"test\");\n        assert!(error.to_string().contains(\"test\"));\n    }\n}\n","traces":[{"line":20,"address":[2328224],"length":1,"stats":{"Line":2}},{"line":21,"address":[2328247],"length":1,"stats":{"Line":2}},{"line":22,"address":[2328287],"length":1,"stats":{"Line":1}},{"line":23,"address":[2328312],"length":1,"stats":{"Line":1}},{"line":24,"address":[2328337],"length":1,"stats":{"Line":1}},{"line":25,"address":[2328362],"length":1,"stats":{"Line":1}},{"line":26,"address":[2328387],"length":1,"stats":{"Line":1}},{"line":27,"address":[2328412],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","parsing_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ParsingError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ParsingError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ParsingError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ParsingError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ParsingError {}\n\nimpl std::fmt::Display for ParsingError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parsing_error_eq() {\n        let error1 = ParsingError::wrap(\"test\");\n        let error2 = ParsingError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_parsing_error_display() {\n        let error = ParsingError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"parsing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[2081328],"length":1,"stats":{"Line":1}},{"line":11,"address":[2081342],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[2081376],"length":1,"stats":{"Line":1}},{"line":28,"address":[2081397,2081458],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","predule.rs"],"content":"pub use super::execute_error::*;\npub use super::into_error::*;\npub use super::lexing_error::*;\npub use super::parsing_error::*;\npub use super::server_error::*;\npub use super::type_error::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","server_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct ServerError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for ServerError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl ServerError {\n    pub fn new\u003cT: ToString\u003e(message: T) -\u003e Self {\n        Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        }\n    }\n\n    pub fn boxed\u003cT: ToString\u003e(message: T) -\u003e Box\u003cSelf\u003e {\n        Box::new(Self::new(message))\n    }\n}\n\nimpl ServerError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::ServerError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for ServerError {}\n\nimpl std::fmt::Display for ServerError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"server error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_server_error_eq() {\n        let error1 = ServerError::wrap(\"test\");\n        let error2 = ServerError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_server_error_display() {\n        let error = ServerError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"server error: test\"));\n    }\n\n    #[test]\n    fn test_server_error_new() {\n        let error = ServerError::new(\"test\");\n\n        assert_eq!(error.message, \"test\");\n    }\n\n    #[test]\n    fn test_server_error_boxed() {\n        let error = ServerError::boxed(\"test\");\n\n        assert_eq!(error.message, \"test\");\n    }\n}\n","traces":[{"line":10,"address":[2081536],"length":1,"stats":{"Line":1}},{"line":11,"address":[2081550],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[2081584],"length":1,"stats":{"Line":1}},{"line":41,"address":[2081605,2081666],"length":1,"stats":{"Line":2}}],"covered":13,"coverable":13},{"path":["/","home","runner","work","rrdb","rrdb","src","errors","type_error.rs"],"content":"use super::RRDBError;\n\n#[derive(Debug)]\npub struct TypeError {\n    pub message: String,\n    pub backtrace: std::backtrace::Backtrace,\n}\n\nimpl PartialEq for TypeError {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.message == other.message\n    }\n}\n\nimpl TypeError {\n    pub fn wrap\u003cT: ToString\u003e(message: T) -\u003e RRDBError {\n        RRDBError::TypeError(Self {\n            message: message.to_string(),\n            backtrace: std::backtrace::Backtrace::capture(),\n        })\n    }\n}\n\nimpl std::error::Error for TypeError {}\n\nimpl std::fmt::Display for TypeError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(formatter, \"parsing error: {}\", self.message)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_type_error_eq() {\n        let error1 = TypeError::wrap(\"test\");\n        let error2 = TypeError::wrap(\"test\");\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_type_error_display() {\n        let error = TypeError::wrap(\"test\");\n\n        assert!(error.to_string().contains(\"parsing error: test\"));\n    }\n}\n","traces":[{"line":10,"address":[5248032],"length":1,"stats":{"Line":1}},{"line":11,"address":[5248046],"length":1,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[5248080],"length":1,"stats":{"Line":2}},{"line":28,"address":[5248101,5248162],"length":1,"stats":{"Line":4}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","common.rs"],"content":"use std::io::ErrorKind;\n\nuse super::config::table::TableConfig;\nuse super::encoder::storage::StorageEncoder;\nuse super::predule::Executor;\nuse crate::ast::types::TableName;\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\n\nimpl Executor {\n    pub async fn get_table_config(\u0026self, table_name: TableName) -\u003e Result\u003cTableConfig, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = table_name;\n\n        let database_name = database_name.unwrap();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // config data 파일 내용 변경\n        let config_path = table_path.clone().join(\"table.config\");\n\n        match tokio::fs::read(\u0026config_path).await {\n            Ok(data) =\u003e {\n                let table_config: Option\u003cTableConfig\u003e = encoder.decode(data.as_slice());\n\n                match table_config {\n                    Some(table_config) =\u003e Ok(table_config),\n                    None =\u003e Err(ExecuteError::wrap(\"invalid config data\")),\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"table not found\")),\n                _ =\u003e Err(ExecuteError::wrap(format!(\"{:?}\", error))),\n            },\n        }\n    }\n}\n","traces":[{"line":11,"address":[3185797,3189193,3185568,3187349,3185612,3185666,3187187],"length":1,"stats":{"Line":0}},{"line":12,"address":[3185790],"length":1,"stats":{"Line":0}},{"line":14,"address":[3185890],"length":1,"stats":{"Line":0}},{"line":17,"address":[3185909],"length":1,"stats":{"Line":0}},{"line":18,"address":[3185968],"length":1,"stats":{"Line":0}},{"line":21,"address":[3186032],"length":1,"stats":{"Line":0}},{"line":23,"address":[3186188,3186271],"length":1,"stats":{"Line":0}},{"line":24,"address":[3186441],"length":1,"stats":{"Line":0}},{"line":27,"address":[3186810],"length":1,"stats":{"Line":0}},{"line":29,"address":[3187648,3187021,3185659,3185824,3187115,3187381],"length":1,"stats":{"Line":0}},{"line":30,"address":[3187683],"length":1,"stats":{"Line":0}},{"line":31,"address":[3187868,3187715],"length":1,"stats":{"Line":0}},{"line":33,"address":[3187875],"length":1,"stats":{"Line":0}},{"line":34,"address":[3187937],"length":1,"stats":{"Line":0}},{"line":35,"address":[3187991,3187910],"length":1,"stats":{"Line":0}},{"line":38,"address":[3188183,3187763],"length":1,"stats":{"Line":0}},{"line":39,"address":[3188204,3188327],"length":1,"stats":{"Line":0}},{"line":40,"address":[3188397],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","database.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct DatabaseConfig {\n    pub database_name: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","global.rs"],"content":"use std::path::PathBuf;\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::constants::{DEFAULT_CONFIG_BASEPATH, DEFAULT_CONFIG_FILENAME, DEFAULT_DATA_DIRNAME};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct GlobalConfig {\n    pub port: u32,\n    pub host: String,\n    pub data_directory: String,\n}\n\n#[allow(clippy::derivable_impls)]\nimpl std::default::Default for GlobalConfig {\n    fn default() -\u003e Self {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n\n        Self {\n            port: 22208,\n            host: \"0.0.0.0\".to_string(),\n            data_directory: base_path\n                .join(DEFAULT_DATA_DIRNAME)\n                .to_str()\n                .unwrap()\n                .to_string(),\n        }\n    }\n}\n\nimpl GlobalConfig {\n    pub fn default_config_path() -\u003e PathBuf {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n        base_path.join(DEFAULT_CONFIG_FILENAME)\n    }\n\n    pub fn load_from_path(filepath: Option\u003cString\u003e) -\u003e anyhow::Result\u003cSelf\u003e {\n        let filepath = match filepath {\n            Some(path) =\u003e PathBuf::from(path),\n            None =\u003e Self::default_config_path(),\n        };\n\n        let config = std::fs::read_to_string(filepath)?;\n        let decoded = toml::from_str(\u0026config)?;\n\n        Ok(decoded)\n    }\n}\n","traces":[{"line":16,"address":[4157538,4157513,4156944],"length":1,"stats":{"Line":1}},{"line":17,"address":[4156961],"length":1,"stats":{"Line":1}},{"line":21,"address":[4156983],"length":1,"stats":{"Line":1}},{"line":22,"address":[4157222,4157366,4157118,4157053],"length":1,"stats":{"Line":4}},{"line":32,"address":[4157703,4157552],"length":1,"stats":{"Line":0}},{"line":33,"address":[4157566],"length":1,"stats":{"Line":0}},{"line":34,"address":[4157598,4157662],"length":1,"stats":{"Line":0}},{"line":37,"address":[4158311,4157728],"length":1,"stats":{"Line":0}},{"line":38,"address":[4157750],"length":1,"stats":{"Line":0}},{"line":39,"address":[4157797],"length":1,"stats":{"Line":0}},{"line":40,"address":[4157780],"length":1,"stats":{"Line":0}},{"line":43,"address":[4158031,4157838],"length":1,"stats":{"Line":0}},{"line":44,"address":[4158009,4158255,4158123],"length":1,"stats":{"Line":0}},{"line":46,"address":[4158219],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":14},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","mod.rs"],"content":"pub mod database;\npub mod global;\npub mod row;\npub mod table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","row.rs"],"content":"use itertools::Itertools;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{ast::types::TableName, utils::float::Float64};\n\n#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, PartialOrd, Eq, Hash)]\npub enum TableDataFieldType {\n    // 끝단 Primitive 값\n    Integer(i64),\n    Float(Float64),\n    Boolean(bool),\n    String(String),\n    Array(Vec\u003cTableDataFieldType\u003e),\n    Null,\n}\n\nimpl TableDataFieldType {\n    pub fn type_code(\u0026self) -\u003e isize {\n        match self {\n            TableDataFieldType::Integer(_) =\u003e 1,\n            TableDataFieldType::Float(_) =\u003e 2,\n            TableDataFieldType::Boolean(_) =\u003e 3,\n            TableDataFieldType::String(_) =\u003e 4,\n            TableDataFieldType::Array(_) =\u003e 5,\n            TableDataFieldType::Null =\u003e 0,\n        }\n    }\n\n    pub fn to_array(self) -\u003e Self {\n        Self::Array(vec![self])\n    }\n\n    pub fn push(\u0026mut self, value: Self) {\n        #[allow(clippy::single_match)]\n        match self {\n            TableDataFieldType::Array(array) =\u003e array.push(value),\n            _ =\u003e {}\n        }\n    }\n\n    pub fn is_null(\u0026self) -\u003e bool {\n        self.type_code() == 0\n    }\n\n    pub fn is_array(\u0026self) -\u003e bool {\n        self.type_code() == 5\n    }\n}\n\nimpl ToString for TableDataFieldType {\n    fn to_string(\u0026self) -\u003e String {\n        #[allow(unstable_name_collisions)]\n        match self {\n            TableDataFieldType::Integer(value) =\u003e value.to_string(),\n            TableDataFieldType::Float(value) =\u003e value.to_string(),\n            TableDataFieldType::Boolean(value) =\u003e value.to_string(),\n            TableDataFieldType::String(value) =\u003e value.to_owned(),\n            TableDataFieldType::Array(value) =\u003e value\n                .iter()\n                .map(|e| e.to_string())\n                .intersperse(\", \".to_owned())\n                .collect(),\n            TableDataFieldType::Null =\u003e \"NULL\".into(),\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq, Hash)]\npub struct TableDataField {\n    pub table_name: TableName,\n    pub column_name: String,\n    pub data: TableDataFieldType,\n}\n\nimpl TableDataField {\n    pub fn to_array(self) -\u003e Self {\n        Self {\n            table_name: self.table_name,\n            column_name: self.column_name,\n            data: self.data.to_array(),\n        }\n    }\n\n    pub fn push(\u0026mut self, value: TableDataFieldType) {\n        #[allow(clippy::single_match)]\n        match \u0026mut self.data {\n            TableDataFieldType::Array(array) =\u003e array.push(value),\n            _ =\u003e {}\n        }\n    }\n}\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct TableDataRow {\n    pub fields: Vec\u003cTableDataField\u003e,\n}\n","traces":[{"line":18,"address":[5029424],"length":1,"stats":{"Line":0}},{"line":19,"address":[5029429],"length":1,"stats":{"Line":0}},{"line":20,"address":[5029460],"length":1,"stats":{"Line":0}},{"line":21,"address":[5029471],"length":1,"stats":{"Line":0}},{"line":22,"address":[5029482],"length":1,"stats":{"Line":0}},{"line":23,"address":[5029493],"length":1,"stats":{"Line":0}},{"line":24,"address":[5029504],"length":1,"stats":{"Line":0}},{"line":25,"address":[5029515],"length":1,"stats":{"Line":0}},{"line":29,"address":[5029536,5029789,5029811],"length":1,"stats":{"Line":0}},{"line":30,"address":[5029555,5029629],"length":1,"stats":{"Line":0}},{"line":33,"address":[5029824],"length":1,"stats":{"Line":0}},{"line":35,"address":[5029842],"length":1,"stats":{"Line":0}},{"line":36,"address":[5029870],"length":1,"stats":{"Line":0}},{"line":41,"address":[5029968],"length":1,"stats":{"Line":0}},{"line":42,"address":[5029973],"length":1,"stats":{"Line":0}},{"line":45,"address":[5030000],"length":1,"stats":{"Line":0}},{"line":46,"address":[5030005],"length":1,"stats":{"Line":0}},{"line":51,"address":[5030032],"length":1,"stats":{"Line":0}},{"line":53,"address":[5030062],"length":1,"stats":{"Line":0}},{"line":54,"address":[5030103],"length":1,"stats":{"Line":0}},{"line":55,"address":[5030136],"length":1,"stats":{"Line":0}},{"line":56,"address":[5030168],"length":1,"stats":{"Line":0}},{"line":57,"address":[5030200],"length":1,"stats":{"Line":0}},{"line":58,"address":[5030228,5030307],"length":1,"stats":{"Line":0}},{"line":60,"address":[4939072,4939107],"length":1,"stats":{"Line":0}},{"line":61,"address":[5030276],"length":1,"stats":{"Line":0}},{"line":63,"address":[5030344],"length":1,"stats":{"Line":0}},{"line":76,"address":[5030649,5030384,5030628],"length":1,"stats":{"Line":0}},{"line":78,"address":[5030400],"length":1,"stats":{"Line":0}},{"line":79,"address":[5030426],"length":1,"stats":{"Line":0}},{"line":80,"address":[5030444],"length":1,"stats":{"Line":0}},{"line":84,"address":[5030672],"length":1,"stats":{"Line":0}},{"line":86,"address":[5030685],"length":1,"stats":{"Line":0}},{"line":87,"address":[5030726],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","config","table.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::ast::{\n    ddl::create_table::CreateTableQuery,\n    types::{Column, ForeignKey, TableName, UniqueKey},\n};\n\n#[derive(Deserialize, Serialize, Debug, Clone)]\npub struct TableConfig {\n    pub table: TableName,\n    pub columns: Vec\u003cColumn\u003e,\n    pub primary_key: Vec\u003cString\u003e,\n    pub foreign_keys: Vec\u003cForeignKey\u003e,\n    pub unique_keys: Vec\u003cUniqueKey\u003e,\n}\n\nimpl TableConfig {\n    pub fn get_columns_map(\u0026self) -\u003e HashMap\u003cString, Column\u003e {\n        HashMap::from_iter(self.columns.iter().cloned().map(|e| (e.name.clone(), e)))\n    }\n\n    pub fn get_required_columns(\u0026self) -\u003e Vec\u003cColumn\u003e {\n        self.columns\n            .iter()\n            .filter(|e| e.not_null \u0026\u0026 e.default.is_none())\n            .cloned()\n            .collect()\n    }\n}\n\nimpl From\u003cCreateTableQuery\u003e for TableConfig {\n    fn from(query: CreateTableQuery) -\u003e Self {\n        Self {\n            table: query.table.unwrap(),\n            columns: query.columns,\n            primary_key: query.primary_key,\n            foreign_keys: query.foreign_keys,\n            unique_keys: query.unique_keys,\n        }\n    }\n}\n","traces":[{"line":20,"address":[4065040],"length":1,"stats":{"Line":0}},{"line":21,"address":[4065072],"length":1,"stats":{"Line":0}},{"line":24,"address":[4065152],"length":1,"stats":{"Line":0}},{"line":25,"address":[4065184],"length":1,"stats":{"Line":0}},{"line":27,"address":[6096640,6096659],"length":1,"stats":{"Line":0}},{"line":34,"address":[4065793,4065735,4065264],"length":1,"stats":{"Line":0}},{"line":36,"address":[4065285],"length":1,"stats":{"Line":0}},{"line":37,"address":[4065415],"length":1,"stats":{"Line":0}},{"line":38,"address":[4065447],"length":1,"stats":{"Line":0}},{"line":39,"address":[4065483],"length":1,"stats":{"Line":0}},{"line":40,"address":[4065519],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","encoder","mod.rs"],"content":"pub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","encoder","storage.rs"],"content":"use serde::{Deserialize, Serialize};\n\npub struct StorageEncoder {}\n\n#[allow(clippy::new_without_default)]\nimpl StorageEncoder {\n    pub fn new() -\u003e Self {\n        StorageEncoder {}\n    }\n\n    pub fn encode(\u0026self, data: impl Serialize) -\u003e Vec\u003cu8\u003e {\n        bson::to_vec(\u0026data).unwrap()\n    }\n\n    pub fn decode\u003c'a, T\u003e(\u0026self, data: \u0026'a [u8]) -\u003e Option\u003cT\u003e\n    where\n        T: Deserialize\u003c'a\u003e,\n    {\n        match bson::from_slice(data) {\n            Ok(data) =\u003e Some(data),\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[8180944,8181232,8180656],"length":1,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","executor.rs"],"content":"use std::sync::Arc;\n\nuse crate::ast::{DDLStatement, DMLStatement, OtherStatement, SQLStatement};\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::ExecuteResult;\nuse crate::logger::predule::Logger;\n\nuse super::config::global::GlobalConfig;\nuse super::mocking::{CommandRunner, FileSystem, RealCommandRunner, RealFileSystem};\n\npub struct Executor {\n    pub(crate) config: Arc\u003cGlobalConfig\u003e,\n    pub(crate) file_system: Arc\u003cdyn FileSystem + Send + Sync\u003e,\n    pub(crate) command_runner: Arc\u003cdyn CommandRunner + Send + Sync\u003e,\n}\n\nimpl Executor {\n    pub fn new(config: Arc\u003cGlobalConfig\u003e) -\u003e Self {\n        Self {\n            config,\n            file_system: Arc::new(RealFileSystem {}),\n            command_runner: Arc::new(RealCommandRunner {}),\n        }\n    }\n\n    // 쿼리 최적화 및 실행, 결과 반환\n    pub async fn process_query(\n        \u0026self,\n        statement: SQLStatement,\n        _connection_id: String,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        Logger::info(format!(\"AST echo: {:?}\", statement));\n\n        // 쿼리 실행\n        let result = match statement {\n            SQLStatement::DDL(DDLStatement::CreateDatabaseQuery(query)) =\u003e {\n                self.create_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::AlterDatabase(query)) =\u003e {\n                self.alter_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::DropDatabaseQuery(query)) =\u003e {\n                self.drop_database(query).await\n            }\n            SQLStatement::DDL(DDLStatement::CreateTableQuery(query)) =\u003e {\n                self.create_table(query).await\n            }\n            SQLStatement::DDL(DDLStatement::AlterTableQuery(query)) =\u003e {\n                self.alter_table(query).await\n            }\n            SQLStatement::DDL(DDLStatement::DropTableQuery(query)) =\u003e self.drop_table(query).await,\n            SQLStatement::DML(DMLStatement::InsertQuery(query)) =\u003e self.insert(query).await,\n            SQLStatement::DML(DMLStatement::SelectQuery(query)) =\u003e self.select(query).await,\n            SQLStatement::DML(DMLStatement::UpdateQuery(query)) =\u003e self.update(query).await,\n            SQLStatement::DML(DMLStatement::DeleteQuery(query)) =\u003e self.delete(query).await,\n            SQLStatement::Other(OtherStatement::ShowDatabases(query)) =\u003e {\n                self.show_databases(query).await\n            }\n            SQLStatement::Other(OtherStatement::UseDatabase(query)) =\u003e {\n                self.use_databases(query).await\n            }\n            SQLStatement::Other(OtherStatement::ShowTables(query)) =\u003e self.show_tables(query).await,\n            SQLStatement::Other(OtherStatement::DescTable(query)) =\u003e self.desc_table(query).await,\n            _ =\u003e unimplemented!(\"no execute implementation\"),\n        };\n\n        match result {\n            Ok(result) =\u003e Ok(result),\n            Err(error) =\u003e Err(ExecuteError::wrap(error.to_string())),\n        }\n    }\n}\n","traces":[{"line":19,"address":[5588336,5588526],"length":1,"stats":{"Line":0}},{"line":22,"address":[5588360,5588408],"length":1,"stats":{"Line":0}},{"line":23,"address":[5588425],"length":1,"stats":{"Line":0}},{"line":28,"address":[5588560],"length":1,"stats":{"Line":0}},{"line":33,"address":[4106830,4106366],"length":1,"stats":{"Line":0}},{"line":36,"address":[4106918,4107018],"length":1,"stats":{"Line":0}},{"line":37,"address":[4107245],"length":1,"stats":{"Line":0}},{"line":38,"address":[4822310],"length":1,"stats":{"Line":0}},{"line":40,"address":[4107332],"length":1,"stats":{"Line":0}},{"line":41,"address":[4106514,4107925,4110261,4107416],"length":1,"stats":{"Line":0}},{"line":43,"address":[4107434],"length":1,"stats":{"Line":0}},{"line":44,"address":[4822354],"length":1,"stats":{"Line":0}},{"line":46,"address":[4107513],"length":1,"stats":{"Line":0}},{"line":47,"address":[4822376],"length":1,"stats":{"Line":0}},{"line":49,"address":[4107607],"length":1,"stats":{"Line":0}},{"line":50,"address":[4107691,4108198,4106577,4111278],"length":1,"stats":{"Line":0}},{"line":52,"address":[4822420],"length":1,"stats":{"Line":0}},{"line":53,"address":[4822442],"length":1,"stats":{"Line":0}},{"line":54,"address":[4112292,4108693,4106640,4109061],"length":1,"stats":{"Line":0}},{"line":55,"address":[4112628,4106661,4108511,4108885],"length":1,"stats":{"Line":0}},{"line":56,"address":[4108605,4108973,4106682,4112964],"length":1,"stats":{"Line":0}},{"line":58,"address":[4822530],"length":1,"stats":{"Line":0}},{"line":60,"address":[4109167],"length":1,"stats":{"Line":0}},{"line":61,"address":[4106724,4109539,4109236,4113636],"length":1,"stats":{"Line":0}},{"line":63,"address":[4113972,4109254,4109627,4106745],"length":1,"stats":{"Line":0}},{"line":64,"address":[4109341,4114308,4109715,4106766],"length":1,"stats":{"Line":0}},{"line":68,"address":[4110217],"length":1,"stats":{"Line":0}},{"line":69,"address":[4114644],"length":1,"stats":{"Line":0}},{"line":70,"address":[4114718,4114858],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","alter_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::alter_database::{AlterDatabaseAction, AlterDatabaseQuery};\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn alter_database(\n        \u0026self,\n        query: AlterDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        #[allow(clippy::single_match)]\n        match query.action {\n            Some(action) =\u003e match action {\n                AlterDatabaseAction::RenameTo(rename) =\u003e {\n                    // 기존 데이터베이스명\n                    let from_database_name = query\n                        .database_name\n                        .clone()\n                        .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n                    // 변경할 데이터베이스명\n                    let to_database_name = rename.name;\n\n                    // 실제 데이터베이스 디렉터리 경로\n                    let mut from_path = base_path.clone();\n                    let mut to_path = base_path.clone();\n\n                    from_path.push(from_database_name);\n                    to_path.push(to_database_name.clone());\n\n                    // 디렉터리명 변경\n                    let result = tokio::fs::rename(\u0026from_path, \u0026to_path).await;\n\n                    if let Err(error) = result {\n                        match error.kind() {\n                            ErrorKind::NotFound =\u003e {\n                                return Err(ExecuteError::wrap(\"database not found\"))\n                            }\n                            _ =\u003e {\n                                return Err(ExecuteError::wrap(\"database alter failed\"));\n                            }\n                        }\n                    }\n\n                    // config data 파일 내용 변경\n                    let mut config_path = to_path.clone();\n                    config_path.push(\"database.config\");\n\n                    match tokio::fs::read(\u0026config_path).await {\n                        Ok(data) =\u003e {\n                            let database_config: Option\u003cDatabaseConfig\u003e =\n                                encoder.decode(data.as_slice());\n\n                            match database_config {\n                                Some(mut database_config) =\u003e {\n                                    database_config.database_name = to_database_name;\n                                    if let Err(_error) = tokio::fs::write(\n                                        config_path,\n                                        encoder.encode(database_config),\n                                    )\n                                    .await\n                                    {\n                                        return Err(ExecuteError::wrap(\"no database name\"));\n                                    }\n                                }\n                                None =\u003e {\n                                    return Err(ExecuteError::wrap(\"invalid config data\"));\n                                }\n                            }\n                        }\n                        Err(error) =\u003e match error.kind() {\n                            ErrorKind::NotFound =\u003e {\n                                return Err(ExecuteError::wrap(\"database not found\"));\n                            }\n                            _ =\u003e {\n                                return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                            }\n                        },\n                    }\n                }\n            },\n            None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(\"alter database\".into())],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5588672],"length":1,"stats":{"Line":0}},{"line":16,"address":[1208212],"length":1,"stats":{"Line":0}},{"line":18,"address":[1208363],"length":1,"stats":{"Line":0}},{"line":21,"address":[1208014,1208382],"length":1,"stats":{"Line":0}},{"line":22,"address":[1208449],"length":1,"stats":{"Line":0}},{"line":23,"address":[1208494],"length":1,"stats":{"Line":0}},{"line":25,"address":[1208951,1209472,1208545,1208634],"length":1,"stats":{"Line":0}},{"line":28,"address":[1208871,1215712,1215724],"length":1,"stats":{"Line":0}},{"line":31,"address":[1208773],"length":1,"stats":{"Line":0}},{"line":34,"address":[1208839],"length":1,"stats":{"Line":0}},{"line":35,"address":[1209035],"length":1,"stats":{"Line":0}},{"line":37,"address":[1209112],"length":1,"stats":{"Line":0}},{"line":38,"address":[1209235],"length":1,"stats":{"Line":0}},{"line":41,"address":[1209309,1209400,1209526,1208252],"length":1,"stats":{"Line":0}},{"line":43,"address":[1209756],"length":1,"stats":{"Line":0}},{"line":44,"address":[1209831,1209925],"length":1,"stats":{"Line":0}},{"line":46,"address":[1209946,1210000],"length":1,"stats":{"Line":0}},{"line":49,"address":[1210045,1209973],"length":1,"stats":{"Line":0}},{"line":55,"address":[1209842,1210386],"length":1,"stats":{"Line":0}},{"line":56,"address":[1210401],"length":1,"stats":{"Line":0}},{"line":58,"address":[1210897,1210483,1210577,1211196,1208273],"length":1,"stats":{"Line":0}},{"line":59,"address":[1211238],"length":1,"stats":{"Line":0}},{"line":60,"address":[1211435,1211274],"length":1,"stats":{"Line":0}},{"line":63,"address":[1211457],"length":1,"stats":{"Line":0}},{"line":64,"address":[1211529],"length":1,"stats":{"Line":0}},{"line":65,"address":[1211717,1211580,1211812],"length":1,"stats":{"Line":0}},{"line":67,"address":[1211865],"length":1,"stats":{"Line":0}},{"line":68,"address":[1211926],"length":1,"stats":{"Line":0}},{"line":70,"address":[4723003],"length":1,"stats":{"Line":0}},{"line":72,"address":[1213212,1213119],"length":1,"stats":{"Line":0}},{"line":76,"address":[1211662,1211499],"length":1,"stats":{"Line":0}},{"line":80,"address":[1211324,1212313],"length":1,"stats":{"Line":0}},{"line":82,"address":[1212334,1212457],"length":1,"stats":{"Line":0}},{"line":85,"address":[1212505],"length":1,"stats":{"Line":0}},{"line":94,"address":[1215242],"length":1,"stats":{"Line":0}},{"line":95,"address":[1215473,1214322,1214376,1208431,1214416],"length":1,"stats":{"Line":0}},{"line":96,"address":[1214330],"length":1,"stats":{"Line":0}},{"line":97,"address":[1214408],"length":1,"stats":{"Line":0}},{"line":99,"address":[1214733,1215437,1214695,1215017,1214641,1215468],"length":1,"stats":{"Line":0}},{"line":100,"address":[1214770,1214713,1215432],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","alter_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::alter_table::{AlterColumnAction, AlterTableAction, AlterTableQuery};\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn alter_table(\u0026self, query: AlterTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = query.table.clone().unwrap();\n\n        let database_name = database_name.unwrap();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        match query.action {\n            AlterTableAction::AlterTableRenameTo(action) =\u003e {\n                let change_name = action.name;\n                let change_path = database_path.clone().join(\u0026change_name);\n\n                // table 디렉터리명 변경\n                if let Err(error) = tokio::fs::rename(\u0026table_path, \u0026change_path).await {\n                    return Err(ExecuteError::wrap(format!(\n                        \"table rename failed: {}\",\n                        error\n                    )));\n                }\n\n                // config data 파일 내용 변경\n                let config_path = change_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                table_config.table.table_name = change_name;\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::AddColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let column_to_add = action.column;\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if table_config.columns.contains(\u0026column_to_add) {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' already exists \",\n                        column_to_add.name\n                    )));\n                }\n\n                table_config.columns.push(column_to_add);\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::AlterColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                let column_name = action.column_name;\n\n                match action.action {\n                    AlterColumnAction::AlterColumnSetDefault(action) =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                        let target = table_config\n                            .columns\n                            .iter_mut()\n                            .find(|e| e.name == column_name);\n\n                        match target {\n                            Some(target) =\u003e {\n                                target.default = Some(action.expression);\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists \",\n                                    column_name\n                                )));\n                            }\n                        }\n\n                        if let Err(error) =\n                            tokio::fs::write(config_path, encoder.encode(table_config)).await\n                        {\n                            return Err(ExecuteError::wrap(error.to_string()));\n                        }\n                    }\n                    AlterColumnAction::AlterColumnDropDefault(_) =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.default = None;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnSetNotNull =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.not_null = true;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnDropNotNull =\u003e {\n                        // config data 파일 내용 변경\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.not_null = false;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                    AlterColumnAction::AlterColumnSetType(action) =\u003e {\n                        let config_path = table_path.clone().join(\"table.config\");\n\n                        match tokio::fs::read(\u0026config_path).await {\n                            Ok(data) =\u003e {\n                                let table_config: Option\u003cTableConfig\u003e =\n                                    encoder.decode(data.as_slice());\n\n                                match table_config {\n                                    Some(mut table_config) =\u003e {\n                                        let target = table_config\n                                            .columns\n                                            .iter_mut()\n                                            .find(|e| e.name == column_name);\n\n                                        match target {\n                                            Some(target) =\u003e {\n                                                target.data_type = action.data_type;\n                                            }\n                                            None =\u003e {\n                                                return Err(ExecuteError::wrap(format!(\n                                                    \"column '{}' not exists \",\n                                                    column_name\n                                                )));\n                                            }\n                                        }\n\n                                        if let Err(error) = tokio::fs::write(\n                                            config_path,\n                                            encoder.encode(table_config),\n                                        )\n                                        .await\n                                        {\n                                            return Err(ExecuteError::wrap(error.to_string()));\n                                        }\n                                    }\n                                    None =\u003e {\n                                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                                    }\n                                }\n                            }\n                            Err(error) =\u003e match error.kind() {\n                                ErrorKind::NotFound =\u003e {\n                                    return Err(ExecuteError::wrap(\"table not found\"));\n                                }\n                                _ =\u003e {\n                                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                                }\n                            },\n                        }\n                    }\n                }\n            }\n            AlterTableAction::DropColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if !table_config\n                    .columns\n                    .iter()\n                    .any(|e| e.name == action.column_name)\n                {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' not exists \",\n                        action.column_name\n                    )));\n                }\n\n                table_config\n                    .columns\n                    .retain(|e| e.name != action.column_name);\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::RenameColumn(action) =\u003e {\n                // TODO: 실 데이터 목록에도 반영하기\n\n                // config data 파일 내용 변경\n                let config_path = table_path.clone().join(\"table.config\");\n\n                let mut table_config = self.get_table_config(query.table.unwrap()).await?;\n\n                if table_config\n                    .columns\n                    .iter()\n                    .any(|e| e.name == action.to_name)\n                {\n                    return Err(ExecuteError::wrap(format!(\n                        \"column '{}' already exists \",\n                        action.to_name\n                    )));\n                }\n\n                let target = table_config\n                    .columns\n                    .iter_mut()\n                    .find(|e| e.name == action.from_name);\n\n                match target {\n                    Some(target) =\u003e {\n                        target.name = action.to_name;\n                    }\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(format!(\n                            \"column '{}' not exists \",\n                            action.from_name\n                        )));\n                    }\n                }\n\n                if let Err(error) =\n                    tokio::fs::write(config_path, encoder.encode(table_config)).await\n                {\n                    return Err(ExecuteError::wrap(error.to_string()));\n                }\n            }\n            AlterTableAction::None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(\"alter table\".into())],\n            }]),\n        })\n    }\n}\n","traces":[{"line":14,"address":[4323306,4330966,4323905,4326700,4323184,4323363,4355526],"length":1,"stats":{"Line":0}},{"line":15,"address":[4323895],"length":1,"stats":{"Line":0}},{"line":17,"address":[4324374],"length":1,"stats":{"Line":0}},{"line":19,"address":[4324403],"length":1,"stats":{"Line":0}},{"line":20,"address":[4324557],"length":1,"stats":{"Line":0}},{"line":21,"address":[4324620],"length":1,"stats":{"Line":0}},{"line":24,"address":[4324673],"length":1,"stats":{"Line":0}},{"line":26,"address":[4324987,4324901],"length":1,"stats":{"Line":0}},{"line":27,"address":[4325169],"length":1,"stats":{"Line":0}},{"line":29,"address":[4323353,4325571],"length":1,"stats":{"Line":0}},{"line":30,"address":[4325638],"length":1,"stats":{"Line":0}},{"line":31,"address":[4325691],"length":1,"stats":{"Line":0}},{"line":32,"address":[4326387,4325744],"length":1,"stats":{"Line":0}},{"line":35,"address":[4323935,4326569,4330998],"length":1,"stats":{"Line":0}},{"line":36,"address":[4331426],"length":1,"stats":{"Line":0}},{"line":43,"address":[4331650],"length":1,"stats":{"Line":0}},{"line":45,"address":[4323956,4332146,4332596,4331876,4332051],"length":1,"stats":{"Line":0}},{"line":47,"address":[4332709,4332794,4332514],"length":1,"stats":{"Line":0}},{"line":48,"address":[4333702],"length":1,"stats":{"Line":0}},{"line":51,"address":[4333755,4333871],"length":1,"stats":{"Line":0}},{"line":54,"address":[4325777],"length":1,"stats":{"Line":0}},{"line":58,"address":[4325846,4326765],"length":1,"stats":{"Line":0}},{"line":60,"address":[4326950],"length":1,"stats":{"Line":0}},{"line":62,"address":[4334687,4323998,4327245,4335716,4327020,4334278],"length":1,"stats":{"Line":0}},{"line":64,"address":[4334646,4334863],"length":1,"stats":{"Line":0}},{"line":65,"address":[4335496,4335006],"length":1,"stats":{"Line":0}},{"line":71,"address":[4334905],"length":1,"stats":{"Line":0}},{"line":73,"address":[4336106],"length":1,"stats":{"Line":0}},{"line":76,"address":[4336275,4336151],"length":1,"stats":{"Line":0}},{"line":79,"address":[4325879],"length":1,"stats":{"Line":0}},{"line":82,"address":[4325994],"length":1,"stats":{"Line":0}},{"line":84,"address":[4326030],"length":1,"stats":{"Line":0}},{"line":85,"address":[4327478],"length":1,"stats":{"Line":0}},{"line":87,"address":[4329039,4327579],"length":1,"stats":{"Line":0}},{"line":89,"address":[4324040,4336914,4329399,4329224,4338243,4336505],"length":1,"stats":{"Line":0}},{"line":91,"address":[4336873,4337090,4337168],"length":1,"stats":{"Line":0}},{"line":94,"address":[4357873,4337145,4357856],"length":1,"stats":{"Line":0}},{"line":96,"address":[4337199],"length":1,"stats":{"Line":0}},{"line":97,"address":[4337325],"length":1,"stats":{"Line":0}},{"line":98,"address":[4337776,4337349,4337833],"length":1,"stats":{"Line":0}},{"line":101,"address":[4337228,4337541],"length":1,"stats":{"Line":0}},{"line":108,"address":[4338495],"length":1,"stats":{"Line":0}},{"line":111,"address":[4338649,4338540],"length":1,"stats":{"Line":0}},{"line":116,"address":[4327612,4329547],"length":1,"stats":{"Line":0}},{"line":118,"address":[4339239,4338937,4324082,4329841,4329747],"length":1,"stats":{"Line":0}},{"line":119,"address":[4339281],"length":1,"stats":{"Line":0}},{"line":120,"address":[4339499,4339317],"length":1,"stats":{"Line":0}},{"line":123,"address":[4339521],"length":1,"stats":{"Line":0}},{"line":124,"address":[4339590],"length":1,"stats":{"Line":0}},{"line":125,"address":[4339801,4339879,4339644],"length":1,"stats":{"Line":0}},{"line":128,"address":[4357921,4357904,4339856],"length":1,"stats":{"Line":0}},{"line":130,"address":[4339910],"length":1,"stats":{"Line":0}},{"line":131,"address":[4340033],"length":1,"stats":{"Line":0}},{"line":132,"address":[4340245,4340067,4340302],"length":1,"stats":{"Line":0}},{"line":135,"address":[4340089,4339939],"length":1,"stats":{"Line":0}},{"line":143,"address":[4340365],"length":1,"stats":{"Line":0}},{"line":144,"address":[4340426],"length":1,"stats":{"Line":0}},{"line":146,"address":[4324103,4341210,4341363,4340679,4340639],"length":1,"stats":{"Line":0}},{"line":148,"address":[4341476,4341585],"length":1,"stats":{"Line":0}},{"line":152,"address":[4339682,4339563],"length":1,"stats":{"Line":0}},{"line":156,"address":[4339376,4340797],"length":1,"stats":{"Line":0}},{"line":158,"address":[4340818,4340941],"length":1,"stats":{"Line":0}},{"line":161,"address":[4340989],"length":1,"stats":{"Line":0}},{"line":168,"address":[4327412,4328155],"length":1,"stats":{"Line":0}},{"line":170,"address":[4341981,4342283,4328449,4328355,4324124],"length":1,"stats":{"Line":0}},{"line":171,"address":[4342325],"length":1,"stats":{"Line":0}},{"line":172,"address":[4342361,4342543],"length":1,"stats":{"Line":0}},{"line":175,"address":[4342565],"length":1,"stats":{"Line":0}},{"line":176,"address":[4342634],"length":1,"stats":{"Line":0}},{"line":177,"address":[4342845,4342688,4342923],"length":1,"stats":{"Line":0}},{"line":180,"address":[4342900,4357969,4357952],"length":1,"stats":{"Line":0}},{"line":182,"address":[4342954],"length":1,"stats":{"Line":0}},{"line":183,"address":[4343080],"length":1,"stats":{"Line":0}},{"line":184,"address":[4343096],"length":1,"stats":{"Line":0}},{"line":187,"address":[4343276,4342983],"length":1,"stats":{"Line":0}},{"line":195,"address":[4343103],"length":1,"stats":{"Line":0}},{"line":196,"address":[4343164],"length":1,"stats":{"Line":0}},{"line":198,"address":[4343528,4344252,4344099,4324145,4343568],"length":1,"stats":{"Line":0}},{"line":200,"address":[4344474,4344365],"length":1,"stats":{"Line":0}},{"line":204,"address":[4342726,4342607],"length":1,"stats":{"Line":0}},{"line":208,"address":[4343686,4342420],"length":1,"stats":{"Line":0}},{"line":210,"address":[4343707,4343830],"length":1,"stats":{"Line":0}},{"line":213,"address":[4343878],"length":1,"stats":{"Line":0}},{"line":220,"address":[4327445,4328594],"length":1,"stats":{"Line":0}},{"line":222,"address":[4344870,4328794,4328888,4345172,4324166],"length":1,"stats":{"Line":0}},{"line":223,"address":[4345214],"length":1,"stats":{"Line":0}},{"line":224,"address":[4345432,4345250],"length":1,"stats":{"Line":0}},{"line":227,"address":[4345454],"length":1,"stats":{"Line":0}},{"line":228,"address":[4345523],"length":1,"stats":{"Line":0}},{"line":229,"address":[4345734,4345577,4345812],"length":1,"stats":{"Line":0}},{"line":232,"address":[4345789,4358000,4358017],"length":1,"stats":{"Line":0}},{"line":234,"address":[4345843],"length":1,"stats":{"Line":0}},{"line":235,"address":[4345969],"length":1,"stats":{"Line":0}},{"line":236,"address":[4345985],"length":1,"stats":{"Line":0}},{"line":239,"address":[4346165,4345872],"length":1,"stats":{"Line":0}},{"line":247,"address":[4345992],"length":1,"stats":{"Line":0}},{"line":248,"address":[4346053],"length":1,"stats":{"Line":0}},{"line":250,"address":[4346417,4346457,4324187,4346988,4347141],"length":1,"stats":{"Line":0}},{"line":252,"address":[4347254,4347363],"length":1,"stats":{"Line":0}},{"line":256,"address":[4345615,4345496],"length":1,"stats":{"Line":0}},{"line":260,"address":[4345309,4346575],"length":1,"stats":{"Line":0}},{"line":262,"address":[4346719,4346596],"length":1,"stats":{"Line":0}},{"line":265,"address":[4346767],"length":1,"stats":{"Line":0}},{"line":270,"address":[4327343],"length":1,"stats":{"Line":0}},{"line":271,"address":[4327379,4327695],"length":1,"stats":{"Line":0}},{"line":273,"address":[4347759,4324208,4348061,4327989,4327895],"length":1,"stats":{"Line":0}},{"line":274,"address":[4348103],"length":1,"stats":{"Line":0}},{"line":275,"address":[4348139,4348321],"length":1,"stats":{"Line":0}},{"line":278,"address":[4348343],"length":1,"stats":{"Line":0}},{"line":279,"address":[4348412],"length":1,"stats":{"Line":0}},{"line":280,"address":[4348466,4348701,4348623],"length":1,"stats":{"Line":0}},{"line":283,"address":[4358048,4348678,4358065],"length":1,"stats":{"Line":0}},{"line":285,"address":[4348732],"length":1,"stats":{"Line":0}},{"line":286,"address":[4348858],"length":1,"stats":{"Line":0}},{"line":287,"address":[4348874],"length":1,"stats":{"Line":0}},{"line":290,"address":[4348761,4349076],"length":1,"stats":{"Line":0}},{"line":298,"address":[4348903],"length":1,"stats":{"Line":0}},{"line":299,"address":[4348964],"length":1,"stats":{"Line":0}},{"line":301,"address":[4349328,4349368,4350052,4324229,4349899],"length":1,"stats":{"Line":0}},{"line":303,"address":[4350165,4350274],"length":1,"stats":{"Line":0}},{"line":307,"address":[4348504,4348385],"length":1,"stats":{"Line":0}},{"line":311,"address":[4348198,4349486],"length":1,"stats":{"Line":0}},{"line":313,"address":[4349630,4349507],"length":1,"stats":{"Line":0}},{"line":316,"address":[4349678],"length":1,"stats":{"Line":0}},{"line":323,"address":[4326106],"length":1,"stats":{"Line":0}},{"line":327,"address":[4329991,4326157],"length":1,"stats":{"Line":0}},{"line":329,"address":[4324250,4351079,4330176,4352063,4330351,4350670],"length":1,"stats":{"Line":0}},{"line":331,"address":[4351255,4351333,4351038],"length":1,"stats":{"Line":0}},{"line":334,"address":[4358096,4358121,4351310],"length":1,"stats":{"Line":0}},{"line":336,"address":[4351360,4351489],"length":1,"stats":{"Line":0}},{"line":342,"address":[4351479,4351454],"length":1,"stats":{"Line":0}},{"line":344,"address":[4358169,4351472,4358144],"length":1,"stats":{"Line":0}},{"line":346,"address":[4324271,4352093,4351716,4352031,4352044],"length":1,"stats":{"Line":0}},{"line":349,"address":[4352359,4352468],"length":1,"stats":{"Line":0}},{"line":352,"address":[4326190],"length":1,"stats":{"Line":0}},{"line":356,"address":[4330508,4326270],"length":1,"stats":{"Line":0}},{"line":358,"address":[4330693,4324292,4353011,4354485,4330868,4352602],"length":1,"stats":{"Line":0}},{"line":360,"address":[4352970,4353265,4353187],"length":1,"stats":{"Line":0}},{"line":363,"address":[4353242,4358217,4358192],"length":1,"stats":{"Line":0}},{"line":365,"address":[4353330,4354332],"length":1,"stats":{"Line":0}},{"line":371,"address":[4353292,4353447,4353513],"length":1,"stats":{"Line":0}},{"line":374,"address":[4353490,4358240,4358257],"length":1,"stats":{"Line":0}},{"line":376,"address":[4353538],"length":1,"stats":{"Line":0}},{"line":377,"address":[4353661],"length":1,"stats":{"Line":0}},{"line":378,"address":[4353682,4353905,4353973],"length":1,"stats":{"Line":0}},{"line":381,"address":[4353753,4353567],"length":1,"stats":{"Line":0}},{"line":388,"address":[4354722],"length":1,"stats":{"Line":0}},{"line":391,"address":[4354767,4354876],"length":1,"stats":{"Line":0}},{"line":397,"address":[4356642],"length":1,"stats":{"Line":0}},{"line":398,"address":[4355773,4326313,4357299,4355813,4355719],"length":1,"stats":{"Line":0}},{"line":399,"address":[4355727],"length":1,"stats":{"Line":0}},{"line":400,"address":[4355805],"length":1,"stats":{"Line":0}},{"line":402,"address":[4356133,4356095,4356417,4356041,4357294,4357260],"length":1,"stats":{"Line":0}},{"line":403,"address":[4357255,4356170,4356113],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":154},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","create_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn create_database(\n        \u0026self,\n        query: CreateDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        let database_name = query\n            .database_name\n            .clone()\n            .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        if let Err(error) = tokio::fs::create_dir(database_path.clone()).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e {\n                    if query.if_not_exists {\n                        return Ok(ExecuteResult {\n                            columns: (vec![ExecuteColumn {\n                                name: \"desc\".into(),\n                                data_type: ExecuteColumnType::String,\n                            }]),\n                            rows: (vec![ExecuteRow {\n                                fields: vec![ExecuteField::String(\n                                    \"database already exists\".into(),\n                                )],\n                            }]),\n                        });\n                    } else {\n                        return Err(ExecuteError::wrap(\"already exists database\"));\n                    }\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"database create failed\"));\n                }\n            }\n        }\n\n        // tables 경로 추가\n        let tables_path = database_path.clone().join(\"tables\");\n\n        if let Err(error) = tokio::fs::create_dir(\u0026tables_path).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e {\n                    return Err(ExecuteError::wrap(\"already exists tables\"))\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"tables create failed\"));\n                }\n            }\n        }\n\n        // 각 데이터베이스 단위 설정파일 생성\n        let config_path = database_path.clone().join(\"database.config\");\n        let database_info = DatabaseConfig {\n            database_name: database_name.clone(),\n        };\n\n        if let Err(error) = tokio::fs::write(config_path, encoder.encode(database_info)).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database created: {}\",\n                    database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5588832],"length":1,"stats":{"Line":0}},{"line":16,"address":[3110602],"length":1,"stats":{"Line":0}},{"line":18,"address":[3110749],"length":1,"stats":{"Line":0}},{"line":20,"address":[3111499,3110510,3110860,3111090,3110768],"length":1,"stats":{"Line":0}},{"line":23,"address":[3111010,3116796,3116784],"length":1,"stats":{"Line":0}},{"line":25,"address":[3111179,3110980],"length":1,"stats":{"Line":0}},{"line":27,"address":[4726484],"length":1,"stats":{"Line":0}},{"line":28,"address":[3111833,3111920],"length":1,"stats":{"Line":0}},{"line":30,"address":[3111941],"length":1,"stats":{"Line":0}},{"line":31,"address":[3113009],"length":1,"stats":{"Line":0}},{"line":32,"address":[3113167,3112095,3112024,3112189,3112149],"length":1,"stats":{"Line":0}},{"line":33,"address":[3112103],"length":1,"stats":{"Line":0}},{"line":34,"address":[3112181],"length":1,"stats":{"Line":0}},{"line":36,"address":[3112775,3112375,3113157,3112479,3112438],"length":1,"stats":{"Line":0}},{"line":37,"address":[3112573,3112456,3113152,3112519],"length":1,"stats":{"Line":0}},{"line":38,"address":[3112527],"length":1,"stats":{"Line":0}},{"line":43,"address":[3112039,3111987],"length":1,"stats":{"Line":0}},{"line":47,"address":[3113172,3111957],"length":1,"stats":{"Line":0}},{"line":53,"address":[3113229],"length":1,"stats":{"Line":0}},{"line":55,"address":[4726503],"length":1,"stats":{"Line":0}},{"line":56,"address":[3113901,3113820],"length":1,"stats":{"Line":0}},{"line":58,"address":[3113922,3113976],"length":1,"stats":{"Line":0}},{"line":61,"address":[3114021,3113949],"length":1,"stats":{"Line":0}},{"line":67,"address":[3114078,3114155],"length":1,"stats":{"Line":0}},{"line":69,"address":[3114333],"length":1,"stats":{"Line":0}},{"line":72,"address":[3114396,3114675,3114662,3110684],"length":1,"stats":{"Line":0}},{"line":73,"address":[3114945,3115054],"length":1,"stats":{"Line":0}},{"line":76,"address":[3116341],"length":1,"stats":{"Line":0}},{"line":77,"address":[3116745,3115342,3115413,3115453],"length":1,"stats":{"Line":0}},{"line":78,"address":[3115367],"length":1,"stats":{"Line":0}},{"line":79,"address":[3115445],"length":1,"stats":{"Line":0}},{"line":81,"address":[3115696,3116740,3115750,3116191,3115788],"length":1,"stats":{"Line":0}},{"line":82,"address":[3115933,3115825,3115768,3116735],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","create_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn create_table(\u0026self, query: CreateTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = query.table.clone().unwrap().database_name.unwrap();\n        let table_name = query.table.clone().unwrap().table_name;\n\n        let base_path = self.get_data_directory();\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        if let Err(error) = tokio::fs::create_dir(\u0026table_path).await {\n            match error.kind() {\n                ErrorKind::AlreadyExists =\u003e return Err(ExecuteError::wrap(\"already exists table\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"table create failed\"));\n                }\n            }\n        }\n\n        // 각 데이터베이스 단위 설정파일 생성\n        let config_path = table_path.clone().join(\"table.config\");\n        let table_info: TableConfig = query.into();\n\n        if let Err(error) = tokio::fs::write(\u0026config_path, encoder.encode(table_info)).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        let rows_path = table_path.clone().join(\"rows\");\n\n        // 데이터 경로 생성\n        if let Err(error) = tokio::fs::create_dir(\u0026rows_path).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        let index_path = table_path.clone().join(\"index\");\n\n        // 인덱스 경로 생성\n        if let Err(error) = tokio::fs::create_dir(\u0026index_path).await {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        // TODO: primary key 데이터 생성\n        // TODO: unique key 데이터 생성\n        // TODO: foreign key 데이터 생성\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"table created: {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":12,"address":[5588931,5588896],"length":1,"stats":{"Line":0}},{"line":13,"address":[1978205],"length":1,"stats":{"Line":0}},{"line":15,"address":[1978369,1978634,1978472],"length":1,"stats":{"Line":0}},{"line":16,"address":[1978851,1978748],"length":1,"stats":{"Line":0}},{"line":18,"address":[1978967],"length":1,"stats":{"Line":0}},{"line":19,"address":[1978989,1979078],"length":1,"stats":{"Line":0}},{"line":21,"address":[1979260],"length":1,"stats":{"Line":0}},{"line":23,"address":[4719825],"length":1,"stats":{"Line":0}},{"line":24,"address":[1980182,1980095],"length":1,"stats":{"Line":0}},{"line":25,"address":[1980257,1980203],"length":1,"stats":{"Line":0}},{"line":27,"address":[1980302,1980230],"length":1,"stats":{"Line":0}},{"line":33,"address":[1980359],"length":1,"stats":{"Line":0}},{"line":34,"address":[1980585],"length":1,"stats":{"Line":0}},{"line":36,"address":[1978266,1980849,1980675],"length":1,"stats":{"Line":0}},{"line":37,"address":[1981115,1981224],"length":1,"stats":{"Line":0}},{"line":40,"address":[1981359],"length":1,"stats":{"Line":0}},{"line":43,"address":[1981579,1978287,1981694],"length":1,"stats":{"Line":0}},{"line":44,"address":[1981945,1982054],"length":1,"stats":{"Line":0}},{"line":47,"address":[1982189],"length":1,"stats":{"Line":0}},{"line":50,"address":[1982518,1978308,1982403],"length":1,"stats":{"Line":0}},{"line":51,"address":[1982878,1982769],"length":1,"stats":{"Line":0}},{"line":58,"address":[1984294],"length":1,"stats":{"Line":0}},{"line":59,"address":[1984995,1983416,1983305,1983376],"length":1,"stats":{"Line":0}},{"line":60,"address":[1983330],"length":1,"stats":{"Line":0}},{"line":61,"address":[1983408],"length":1,"stats":{"Line":0}},{"line":63,"address":[1983698,1983644,1983736,1984990,1984141],"length":1,"stats":{"Line":0}},{"line":64,"address":[1983773,1983716,1983883,1984985],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","drop_database.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::drop_database::DropDatabaseQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn drop_database(\n        \u0026self,\n        query: DropDatabaseQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let base_path = self.get_data_directory();\n        let mut database_path = base_path.clone();\n\n        let database_name = query\n            .database_name\n            .clone()\n            .ok_or_else(|| ExecuteError::wrap(\"no database name\"))?;\n\n        database_path.push(\u0026database_name);\n\n        if let Err(error) = tokio::fs::remove_dir_all(database_path.clone()).await {\n            match error.kind() {\n                ErrorKind::NotFound =\u003e return Err(ExecuteError::wrap(\"database not found\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"database drop failed\"));\n                }\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database dropped: {}\",\n                    database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":10,"address":[5588976],"length":1,"stats":{"Line":0}},{"line":14,"address":[1693357],"length":1,"stats":{"Line":0}},{"line":15,"address":[1693454],"length":1,"stats":{"Line":0}},{"line":17,"address":[1693305,1693519,1693822,1693605,1694026],"length":1,"stats":{"Line":0}},{"line":20,"address":[1696028,1693745,1696016],"length":1,"stats":{"Line":0}},{"line":22,"address":[1693719],"length":1,"stats":{"Line":0}},{"line":24,"address":[1693400,1693900,1694083],"length":1,"stats":{"Line":0}},{"line":25,"address":[1694327,1694408],"length":1,"stats":{"Line":0}},{"line":26,"address":[1694429,1694483],"length":1,"stats":{"Line":0}},{"line":28,"address":[1694456,1694528],"length":1,"stats":{"Line":0}},{"line":33,"address":[1695704],"length":1,"stats":{"Line":0}},{"line":34,"address":[1694729,1694800,1696004,1694840],"length":1,"stats":{"Line":0}},{"line":35,"address":[1694754],"length":1,"stats":{"Line":0}},{"line":36,"address":[1694832],"length":1,"stats":{"Line":0}},{"line":38,"address":[1695999,1695062,1695554,1695154,1695116],"length":1,"stats":{"Line":0}},{"line":39,"address":[1695994,1695191,1695296,1695134],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","drop_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ExecuteResult, Executor};\nuse crate::executor::result::{ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteRow};\n\nimpl Executor {\n    pub async fn drop_table(\u0026self, query: DropTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let base_path = self.get_data_directory();\n\n        let TableName {\n            database_name,\n            table_name,\n        } = query.table.unwrap();\n\n        let table_path = base_path\n            .clone()\n            .join(database_name.unwrap())\n            .join(\"tables\")\n            .join(\u0026table_name);\n\n        if let Err(error) = tokio::fs::remove_dir_all(table_path).await {\n            match error.kind() {\n                ErrorKind::NotFound =\u003e return Err(ExecuteError::wrap(\"table not found\")),\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(\"table drop failed\"));\n                }\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"table dropped: {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":11,"address":[4319170,4320434,4322550,4319016,4318912,4318959],"length":1,"stats":{"Line":0}},{"line":12,"address":[4319151],"length":1,"stats":{"Line":0}},{"line":14,"address":[4319261],"length":1,"stats":{"Line":0}},{"line":15,"address":[4319429],"length":1,"stats":{"Line":0}},{"line":16,"address":[4319476],"length":1,"stats":{"Line":0}},{"line":19,"address":[4319857,4319943,4319514,4319615,4320070],"length":1,"stats":{"Line":0}},{"line":21,"address":[4319673],"length":1,"stats":{"Line":0}},{"line":23,"address":[4319889,4319632,4319996,4320077],"length":1,"stats":{"Line":0}},{"line":25,"address":[4320475,4319006,4319200,4320279],"length":1,"stats":{"Line":0}},{"line":26,"address":[4320734,4320815],"length":1,"stats":{"Line":0}},{"line":27,"address":[4320836,4320890],"length":1,"stats":{"Line":0}},{"line":29,"address":[4320935,4320863],"length":1,"stats":{"Line":0}},{"line":34,"address":[4322173],"length":1,"stats":{"Line":0}},{"line":35,"address":[4321283,4322469,4321243,4321172],"length":1,"stats":{"Line":0}},{"line":36,"address":[4321197],"length":1,"stats":{"Line":0}},{"line":37,"address":[4321275],"length":1,"stats":{"Line":0}},{"line":39,"address":[4321580,4322023,4322464,4321526,4321618],"length":1,"stats":{"Line":0}},{"line":40,"address":[4321655,4321598,4321765,4322459],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","ddl","mod.rs"],"content":"pub mod alter_database;\npub mod alter_table;\npub mod create_database;\npub mod create_table;\npub mod drop_database;\npub mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","delete.rs"],"content":"use std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::delete::DeleteQuery;\nuse crate::ast::dml::plan::delete::delete_plan::DeletePlanItem;\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataFieldType;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::executor::result::ExecuteColumnType;\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn delete(\u0026self, query: DeleteQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let table = query.from_table.as_ref().unwrap().table.clone();\n\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let plan = optimizer.optimize_delete(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        for each_plan in plan.list {\n            match each_plan {\n                // From 처리\n                DeletePlanItem::DeleteFrom(from) =\u003e {\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias, table_name.clone());\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result =\n                                self.full_scan(table_name).await?.into_iter().collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                // 필터링 처리\n                DeletePlanItem::Filter(filter) =\u003e {\n                    let total_count = rows.len();\n                    let futures = rows.iter().cloned().map(|(path, row)| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(row.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((path, row, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((path, row, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, _, boolean)| *boolean)\n                        .map(|(path, row, _)| (path, row))\n                        .collect();\n                }\n            }\n        }\n\n        // 삭제 작업\n        for (path, _) in rows.into_iter() {\n            if let Err(error) = tokio::fs::remove_file(\u0026path).await {\n                return Err(ExecuteError::wrap(format!(\n                    \"file {:?} remove failed: {}\",\n                    path, error\n                )));\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"deleted from {:?}\",\n                    table.table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":19,"address":[1672718,1672430,1682702,1672368,1673297,1674332,1672487],"length":1,"stats":{"Line":0}},{"line":20,"address":[1672685,1672982],"length":1,"stats":{"Line":0}},{"line":23,"address":[1673004],"length":1,"stats":{"Line":0}},{"line":25,"address":[1672748,1673740,1673329,1673058,1674290,1673225,1672477],"length":1,"stats":{"Line":0}},{"line":27,"address":[1673715],"length":1,"stats":{"Line":0}},{"line":28,"address":[1673901],"length":1,"stats":{"Line":0}},{"line":30,"address":[1673967],"length":1,"stats":{"Line":0}},{"line":32,"address":[1674187,1675465,1674048,1675401],"length":1,"stats":{"Line":0}},{"line":33,"address":[1675505],"length":1,"stats":{"Line":0}},{"line":35,"address":[1675758],"length":1,"stats":{"Line":0}},{"line":36,"address":[1675827,1676060],"length":1,"stats":{"Line":0}},{"line":38,"address":[1676207,1676760,1672769,1678613,1676075,1674341],"length":1,"stats":{"Line":0}},{"line":40,"address":[1676683],"length":1,"stats":{"Line":0}},{"line":42,"address":[1676921],"length":1,"stats":{"Line":0}},{"line":43,"address":[1677283,1677163,1677020],"length":1,"stats":{"Line":0}},{"line":46,"address":[1677112],"length":1,"stats":{"Line":0}},{"line":48,"address":[1674376,1672790,1678517,1677302,1677550],"length":1,"stats":{"Line":0}},{"line":51,"address":[1678087],"length":1,"stats":{"Line":0}},{"line":53,"address":[1677403],"length":1,"stats":{"Line":0}},{"line":59,"address":[1675862],"length":1,"stats":{"Line":0}},{"line":60,"address":[1675948,1679407],"length":1,"stats":{"Line":0}},{"line":61,"address":[1683228,1683261,1682782,1682752,1679410],"length":1,"stats":{"Line":0}},{"line":62,"address":[1682857,1682918],"length":1,"stats":{"Line":0}},{"line":63,"address":[1682926],"length":1,"stats":{"Line":0}},{"line":64,"address":[1683488,1683331,1685578,1683296,1684163,1684190,1683376,1682993],"length":1,"stats":{"Line":0}},{"line":65,"address":[1683743,1683384],"length":1,"stats":{"Line":0}},{"line":66,"address":[1683585,1683468],"length":1,"stats":{"Line":0}},{"line":67,"address":[1683617],"length":1,"stats":{"Line":0}},{"line":68,"address":[1683684],"length":1,"stats":{"Line":0}},{"line":69,"address":[1683731],"length":1,"stats":{"Line":0}},{"line":72,"address":[1684107,1684689,1683855,1684077,1684320,1684472],"length":1,"stats":{"Line":0}},{"line":73,"address":[1683872,1683941],"length":1,"stats":{"Line":0}},{"line":74,"address":[1683515,1684400,1684100,1683369,1684222,1684137,1684609],"length":1,"stats":{"Line":0}},{"line":76,"address":[1684569],"length":1,"stats":{"Line":0}},{"line":77,"address":[1684752],"length":1,"stats":{"Line":0}},{"line":78,"address":[1685028],"length":1,"stats":{"Line":0}},{"line":79,"address":[1684722,1685334],"length":1,"stats":{"Line":0}},{"line":86,"address":[1674556,1675008,1679621,1674707,1679651],"length":1,"stats":{"Line":0}},{"line":87,"address":[1674443,1674588,1672811,1679684,1679644,1674411],"length":1,"stats":{"Line":0}},{"line":91,"address":[1675098,1674862,1675268],"length":1,"stats":{"Line":0}},{"line":93,"address":[1685930,1685920],"length":1,"stats":{"Line":0}},{"line":94,"address":[1685960,1685952],"length":1,"stats":{"Line":0}},{"line":95,"address":[1675241],"length":1,"stats":{"Line":0}},{"line":101,"address":[1675556,1681111,1681047],"length":1,"stats":{"Line":0}},{"line":102,"address":[1680052,1682567,1681147,1679795,1679766,1672832],"length":1,"stats":{"Line":0}},{"line":103,"address":[1680351,1680097],"length":1,"stats":{"Line":0}},{"line":110,"address":[1682190],"length":1,"stats":{"Line":0}},{"line":111,"address":[1681190,1682546,1681301,1681261],"length":1,"stats":{"Line":0}},{"line":112,"address":[1681215],"length":1,"stats":{"Line":0}},{"line":113,"address":[1681293],"length":1,"stats":{"Line":0}},{"line":115,"address":[1681594,1681540,1682541,1682037,1681632],"length":1,"stats":{"Line":0}},{"line":116,"address":[1681612,1681669,1681779,1682536],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","insert.rs"],"content":"use std::collections::HashSet;\nuse std::io::ErrorKind;\n\nuse crate::ast::dml::insert::{InsertData, InsertQuery};\nuse crate::ast::types::SQLExpression;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::{TableDataField, TableDataRow};\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn insert(\u0026self, query: InsertQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let into_table = query.into_table.as_ref().unwrap();\n\n        let database_name = into_table.clone().database_name.unwrap();\n        let table_name = into_table.clone().table_name;\n\n        let base_path = self.get_data_directory();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // 데이터 행 파일 경로\n        let rows_path = table_path.clone().join(\"rows\");\n\n        // 설정파일 경로\n        let config_path = table_path.join(\"table.config\");\n\n        let table_config = match tokio::fs::read(\u0026config_path).await {\n            Ok(data) =\u003e {\n                let table_config: Option\u003cTableConfig\u003e = encoder.decode(data.as_slice());\n\n                match table_config {\n                    Some(table_config) =\u003e table_config,\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(\"invalid config data\"));\n                    }\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e {\n                    return Err(ExecuteError::wrap(\"table not found\"));\n                }\n                _ =\u003e {\n                    return Err(ExecuteError::wrap(format!(\"{:?}\", error)));\n                }\n            },\n        };\n\n        // 입력된 컬럼\n        let input_columns_set: HashSet\u003cString\u003e = HashSet::from_iter(query.columns.iter().cloned());\n\n        // 필수 컬럼\n        let required_columns = table_config.get_required_columns();\n\n        // 테이블 컬럼 맵\n        let columns_map = table_config.get_columns_map();\n\n        // 필수 입력 컬럼값 검증\n        for required_column in required_columns {\n            if !input_columns_set.contains(\u0026required_column.name) {\n                return Err(ExecuteError::wrap(format!(\n                    \"column '{}' is required, but it was not provided\",\n                    \u0026required_column.name\n                )));\n            }\n        }\n\n        let remain_columns = table_config\n            .columns\n            .iter()\n            .filter(|e| !query.columns.contains(\u0026(*e).clone().name))\n            .map(|e| \u0026e.name);\n\n        match \u0026query.data {\n            InsertData::Values(values) =\u003e {\n                let mut rows = vec![];\n\n                for value in values {\n                    let mut fields = vec![];\n\n                    // 명시적으로 전달된 컬럼값 리스트 처리\n                    for (i, column_name) in query.columns.iter().enumerate() {\n                        let column_config_info = columns_map.get(column_name).unwrap();\n\n                        let default_value = match \u0026column_config_info.default {\n                            Some(default) =\u003e default.to_owned(),\n                            None =\u003e SQLExpression::Null,\n                        };\n\n                        let value = value.list[i].clone().unwrap_or(default_value);\n\n                        let data = self.reduce_expression(value, Default::default()).await?;\n\n                        match columns_map.get(column_name) {\n                            Some(column) =\u003e {\n                                if column.not_null \u0026\u0026 data.type_code() == 0 {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' is not null column\n                                        \",\n                                        column_name\n                                    )));\n                                }\n\n                                if column.data_type.type_code() != data.type_code()\n                                    \u0026\u0026 data.type_code() != 0\n                                {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' type mismatch\n                                        \",\n                                        column_name\n                                    )));\n                                }\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists\",\n                                    column_name\n                                )))\n                            }\n                        }\n\n                        let column_name = column_name.to_owned();\n\n                        fields.push(TableDataField {\n                            column_name,\n                            data,\n                            table_name: into_table.clone(),\n                        });\n                    }\n\n                    // 명시되지 않은 컬럼 리스트 처리\n                    for column_name in remain_columns.clone() {\n                        let column_config_info = columns_map.get(column_name).unwrap();\n\n                        let default_value = match \u0026column_config_info.default {\n                            Some(default) =\u003e default.to_owned(),\n                            None =\u003e {\n                                if column_config_info.not_null {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' is not null column\n                                        \",\n                                        column_name\n                                    )));\n                                }\n\n                                SQLExpression::Null\n                            }\n                        };\n\n                        let data = self\n                            .reduce_expression(default_value, Default::default())\n                            .await?;\n\n                        match columns_map.get(column_name) {\n                            Some(column) =\u003e {\n                                if column.data_type.type_code() != data.type_code()\n                                    \u0026\u0026 data.type_code() != 0\n                                {\n                                    return Err(ExecuteError::wrap(format!(\n                                        \"column '{}' type mismatch\n                                        \",\n                                        column_name\n                                    )));\n                                }\n                            }\n                            None =\u003e {\n                                return Err(ExecuteError::wrap(format!(\n                                    \"column '{}' not exists\",\n                                    column_name\n                                )))\n                            }\n                        }\n\n                        let column_name = column_name.to_owned();\n\n                        fields.push(TableDataField {\n                            column_name,\n                            data,\n                            table_name: into_table.clone(),\n                        });\n                    }\n\n                    let row = TableDataRow { fields };\n                    rows.push(row);\n                }\n\n                for row in rows {\n                    let file_name = uuid::Uuid::new_v4().to_string();\n\n                    let row_file_path = rows_path.join(file_name);\n\n                    if let Err(error) = tokio::fs::write(row_file_path, encoder.encode(row)).await {\n                        return Err(ExecuteError::wrap(error.to_string()));\n                    }\n                }\n            }\n            InsertData::Select(_select) =\u003e {\n                todo!(\"아직 미구현\")\n            }\n            InsertData::None =\u003e {}\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"inserted into {}\",\n                    table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":16,"address":[2077557,2065126,2065069,2064992,2067291,2065361],"length":1,"stats":{"Line":0}},{"line":17,"address":[2065351],"length":1,"stats":{"Line":0}},{"line":19,"address":[2065661,2065511],"length":1,"stats":{"Line":0}},{"line":21,"address":[2065856,2065664],"length":1,"stats":{"Line":0}},{"line":22,"address":[2065970],"length":1,"stats":{"Line":0}},{"line":24,"address":[2066108],"length":1,"stats":{"Line":0}},{"line":26,"address":[2066134,2066223],"length":1,"stats":{"Line":0}},{"line":28,"address":[2066405],"length":1,"stats":{"Line":0}},{"line":31,"address":[2066807],"length":1,"stats":{"Line":0}},{"line":34,"address":[2067033],"length":1,"stats":{"Line":0}},{"line":36,"address":[2067219,2065391,2067122,2067332,2065116],"length":1,"stats":{"Line":0}},{"line":37,"address":[2067580],"length":1,"stats":{"Line":0}},{"line":38,"address":[2067612,2067786],"length":1,"stats":{"Line":0}},{"line":40,"address":[2067793],"length":1,"stats":{"Line":0}},{"line":41,"address":[2067907],"length":1,"stats":{"Line":0}},{"line":43,"address":[2067972,2067828],"length":1,"stats":{"Line":0}},{"line":47,"address":[2069919,2067669],"length":1,"stats":{"Line":0}},{"line":49,"address":[2070063,2069940],"length":1,"stats":{"Line":0}},{"line":52,"address":[2070111],"length":1,"stats":{"Line":0}},{"line":58,"address":[2068202,2068100],"length":1,"stats":{"Line":0}},{"line":61,"address":[2068398,2068306],"length":1,"stats":{"Line":0}},{"line":64,"address":[2068413],"length":1,"stats":{"Line":0}},{"line":67,"address":[2068610,2068493,2068806,2068737],"length":1,"stats":{"Line":0}},{"line":68,"address":[2068808,2069497],"length":1,"stats":{"Line":0}},{"line":69,"address":[2069637],"length":1,"stats":{"Line":0}},{"line":71,"address":[2069503],"length":1,"stats":{"Line":0}},{"line":76,"address":[2068848,2068961],"length":1,"stats":{"Line":0}},{"line":79,"address":[2068941,2080460,2080432],"length":1,"stats":{"Line":0}},{"line":80,"address":[2080637,2080624],"length":1,"stats":{"Line":0}},{"line":82,"address":[2068998],"length":1,"stats":{"Line":0}},{"line":83,"address":[2069123],"length":1,"stats":{"Line":0}},{"line":84,"address":[2069131],"length":1,"stats":{"Line":0}},{"line":86,"address":[2072190,2069296,2069395,2072064],"length":1,"stats":{"Line":0}},{"line":87,"address":[2072213],"length":1,"stats":{"Line":0}},{"line":90,"address":[2072383,2072728,2075407],"length":1,"stats":{"Line":0}},{"line":91,"address":[2072985,2072775],"length":1,"stats":{"Line":0}},{"line":93,"address":[2072993],"length":1,"stats":{"Line":0}},{"line":94,"address":[2073082,2073192],"length":1,"stats":{"Line":0}},{"line":95,"address":[2073039],"length":1,"stats":{"Line":0}},{"line":98,"address":[2073270,2073113],"length":1,"stats":{"Line":0}},{"line":100,"address":[2070238,2075652,2065412,2073403,2075631,2074131,2073680,2075604],"length":1,"stats":{"Line":0}},{"line":102,"address":[2074088,2074293],"length":1,"stats":{"Line":0}},{"line":103,"address":[2074424],"length":1,"stats":{"Line":0}},{"line":104,"address":[2074448,2074640],"length":1,"stats":{"Line":0}},{"line":105,"address":[2074761,2074669],"length":1,"stats":{"Line":0}},{"line":112,"address":[2074896,2074614],"length":1,"stats":{"Line":0}},{"line":113,"address":[2074971],"length":1,"stats":{"Line":0}},{"line":115,"address":[2075434,2074994],"length":1,"stats":{"Line":0}},{"line":123,"address":[2074330,2074466],"length":1,"stats":{"Line":0}},{"line":130,"address":[2074926],"length":1,"stats":{"Line":0}},{"line":132,"address":[2075091,2075257],"length":1,"stats":{"Line":0}},{"line":133,"address":[2075110],"length":1,"stats":{"Line":0}},{"line":134,"address":[2075142],"length":1,"stats":{"Line":0}},{"line":135,"address":[2075182],"length":1,"stats":{"Line":0}},{"line":140,"address":[2071831,2072831,2071745,2071983,2072698],"length":1,"stats":{"Line":0}},{"line":141,"address":[2075760,2072006],"length":1,"stats":{"Line":0}},{"line":143,"address":[2075768],"length":1,"stats":{"Line":0}},{"line":144,"address":[2075832,2076222],"length":1,"stats":{"Line":0}},{"line":146,"address":[2075816],"length":1,"stats":{"Line":0}},{"line":147,"address":[2076095,2075878],"length":1,"stats":{"Line":0}},{"line":154,"address":[2075858],"length":1,"stats":{"Line":0}},{"line":158,"address":[2076343,2070409,2075972,2076273,2076589,2070608,2070836],"length":1,"stats":{"Line":0}},{"line":159,"address":[2076402,2075989,2076312,2076227,2076381],"length":1,"stats":{"Line":0}},{"line":160,"address":[2076376,2070756,2065433,2070489,2070305,2076336,2070273],"length":1,"stats":{"Line":0}},{"line":162,"address":[2070713,2070918],"length":1,"stats":{"Line":0}},{"line":163,"address":[2071049],"length":1,"stats":{"Line":0}},{"line":164,"address":[2071231,2071065],"length":1,"stats":{"Line":0}},{"line":165,"address":[2071312],"length":1,"stats":{"Line":0}},{"line":167,"address":[2076431,2071341],"length":1,"stats":{"Line":0}},{"line":175,"address":[2070955,2071083],"length":1,"stats":{"Line":0}},{"line":182,"address":[2071267],"length":1,"stats":{"Line":0}},{"line":184,"address":[2071610,2071438],"length":1,"stats":{"Line":0}},{"line":185,"address":[2071460],"length":1,"stats":{"Line":0}},{"line":186,"address":[2071492],"length":1,"stats":{"Line":0}},{"line":187,"address":[2071532],"length":1,"stats":{"Line":0}},{"line":191,"address":[2071868],"length":1,"stats":{"Line":0}},{"line":192,"address":[2071953],"length":1,"stats":{"Line":0}},{"line":195,"address":[2077727,2072114,2077779,2077843,2072238],"length":1,"stats":{"Line":0}},{"line":196,"address":[2079815,2077896],"length":1,"stats":{"Line":0}},{"line":198,"address":[2079928,2079850],"length":1,"stats":{"Line":0}},{"line":200,"address":[2076927,2076686,2080305,2076657,2080257,2065454,2079991],"length":1,"stats":{"Line":0}},{"line":201,"address":[2076972,2077089],"length":1,"stats":{"Line":0}},{"line":205,"address":[2069101],"length":1,"stats":{"Line":0}},{"line":211,"address":[2078914],"length":1,"stats":{"Line":0}},{"line":212,"address":[2069166,2079775,2078000,2078040,2077946],"length":1,"stats":{"Line":0}},{"line":213,"address":[2077954],"length":1,"stats":{"Line":0}},{"line":214,"address":[2078032],"length":1,"stats":{"Line":0}},{"line":216,"address":[2078318,2078761,2079770,2078264,2078356],"length":1,"stats":{"Line":0}},{"line":217,"address":[2078336,2079765,2078393,2078503],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","mod.rs"],"content":"pub mod delete;\npub mod insert;\npub mod scan;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","scan.rs"],"content":"use std::io::ErrorKind;\nuse std::path::PathBuf;\n\nuse futures::future::join_all;\n\nuse crate::ast::types::TableName;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataRow;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::Executor;\n\nimpl Executor {\n    pub async fn full_scan(\n        \u0026self,\n        table_name: TableName,\n    ) -\u003e Result\u003cVec\u003c(PathBuf, TableDataRow)\u003e, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = table_name.database_name.unwrap();\n        let table_name = table_name.table_name;\n\n        let base_path = self.get_data_directory();\n\n        let database_path = base_path.clone().join(\u0026database_name);\n\n        let table_path = database_path.clone().join(\"tables\").join(\u0026table_name);\n\n        // 데이터 행 파일 경로\n        let rows_path = table_path.clone().join(\"rows\");\n\n        match std::fs::read_dir(\u0026rows_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_file() {\n                                    let path = entry.path();\n\n                                    match tokio::fs::read(\u0026path).await {\n                                        Ok(result) =\u003e {\n                                            match encoder.decode::\u003cTableDataRow\u003e(result.as_slice())\n                                            {\n                                                Some(decoded) =\u003e Ok((path.to_path_buf(), decoded)),\n                                                None =\u003e Err(ExecuteError::wrap(format!(\n                                                    \"full scan failed {:?}\",\n                                                    path\n                                                ))),\n                                            }\n                                        }\n                                        Err(error) =\u003e Err(ExecuteError::wrap(format!(\n                                            \"full scan failed {}\",\n                                            error\n                                        ))),\n                                    }\n                                } else {\n                                    Err(ExecuteError::wrap(\"full scan failed\"))\n                                }\n                            }\n                            Err(error) =\u003e {\n                                Err(ExecuteError::wrap(format!(\"full scan failed {}\", error)))\n                            }\n                        },\n                        Err(error) =\u003e Err(ExecuteError::wrap(format!(\"full scan failed {}\", error))),\n                    }\n                });\n\n                let rows = join_all(futures)\n                    .await\n                    .into_iter()\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n                match rows {\n                    Ok(rows) =\u003e Ok(rows),\n                    Err(error) =\u003e Err(ExecuteError::wrap(error.to_string())),\n                }\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists (3)\")),\n                _ =\u003e Err(ExecuteError::wrap(\"full scan failed\")),\n            },\n        }\n    }\n\n    pub async fn index_scan(\u0026self, _table_name: TableName) {}\n}\n","traces":[{"line":14,"address":[5589280],"length":1,"stats":{"Line":0}},{"line":18,"address":[6185806,6182530],"length":1,"stats":{"Line":0}},{"line":20,"address":[6182625],"length":1,"stats":{"Line":0}},{"line":21,"address":[6182793],"length":1,"stats":{"Line":0}},{"line":23,"address":[6182838],"length":1,"stats":{"Line":0}},{"line":25,"address":[6182908,6182994],"length":1,"stats":{"Line":0}},{"line":27,"address":[6183161],"length":1,"stats":{"Line":0}},{"line":30,"address":[6183530],"length":1,"stats":{"Line":0}},{"line":32,"address":[6182399,6183824,6183741],"length":1,"stats":{"Line":0}},{"line":33,"address":[6183878,6183856],"length":1,"stats":{"Line":0}},{"line":34,"address":[6187262,6185776,6185952,6186677,6185811,6183871,6185872,6187167,6185907,6185992,6183897],"length":1,"stats":{"Line":0}},{"line":35,"address":[6185945,6185960],"length":1,"stats":{"Line":0}},{"line":36,"address":[6186032,6186252],"length":1,"stats":{"Line":0}},{"line":37,"address":[6186266],"length":1,"stats":{"Line":0}},{"line":38,"address":[6186423,6186280],"length":1,"stats":{"Line":0}},{"line":39,"address":[6186456],"length":1,"stats":{"Line":0}},{"line":41,"address":[4740705],"length":1,"stats":{"Line":0}},{"line":42,"address":[6187563],"length":1,"stats":{"Line":0}},{"line":43,"address":[6187595,6187822],"length":1,"stats":{"Line":0}},{"line":45,"address":[6188166,6187953],"length":1,"stats":{"Line":0}},{"line":46,"address":[6187864,6188014],"length":1,"stats":{"Line":0}},{"line":52,"address":[6188527,6187640],"length":1,"stats":{"Line":0}},{"line":58,"address":[6186429,6186483],"length":1,"stats":{"Line":0}},{"line":61,"address":[6186303],"length":1,"stats":{"Line":0}},{"line":62,"address":[6186730],"length":1,"stats":{"Line":0}},{"line":65,"address":[6186091,6186928],"length":1,"stats":{"Line":0}},{"line":69,"address":[6184042,6184664,6184072,6184774],"length":1,"stats":{"Line":0}},{"line":70,"address":[4704601],"length":1,"stats":{"Line":0}},{"line":74,"address":[6184804],"length":1,"stats":{"Line":0}},{"line":75,"address":[6184830],"length":1,"stats":{"Line":0}},{"line":76,"address":[6184943],"length":1,"stats":{"Line":0}},{"line":79,"address":[6183930,6184184],"length":1,"stats":{"Line":0}},{"line":80,"address":[6184205,6184259],"length":1,"stats":{"Line":0}},{"line":81,"address":[6184304,6184232],"length":1,"stats":{"Line":0}},{"line":86,"address":[5589360,5589395],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","select.rs"],"content":"use std::cmp::Ordering;\nuse std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::parts::order_by::{OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectKind};\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::ast::dml::plan::select::select_plan::SelectPlanItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::{TableDataField, TableDataFieldType, TableDataRow};\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn select(\u0026self, query: SelectQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let select_items = query.select_items.clone();\n\n        let plan = optimizer.optimize_select(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_alias_reverse_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        let mut no_from_clause = true;\n\n        for each_plan in plan.list {\n            match each_plan {\n                // Select From 처리\n                SelectPlanItem::From(from) =\u003e {\n                    no_from_clause = false;\n\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias.clone(), table_name.clone());\n                        table_alias_reverse_map.insert(table_name.clone().table_name, alias);\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result = self\n                                .full_scan(table_name)\n                                .await?\n                                .into_iter()\n                                .map(|(_, e)| e)\n                                .collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                SelectPlanItem::Filter(filter) =\u003e {\n                    let futures = rows.iter().cloned().map(|e| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(e.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((e, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((e, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, boolean)| *boolean)\n                        .map(|(e, _)| e)\n                        .collect();\n                }\n                SelectPlanItem::Group(ref group_by_clause) =\u003e {\n                    let mut grouped_map =\n                        HashMap::\u003cVec\u003cTableDataField\u003e, Vec\u003cTableDataField\u003e\u003e::new();\n\n                    for row in rows {\n                        let mut group_key = vec![];\n                        let mut group_value = vec![];\n\n                        for field in row.fields {\n                            // group by 절에 포함된 컬럼일 경우 키값으로 사용\n                            if let Some(_found) = group_by_clause.group_by_items.iter().find(|e| {\n                                let mut table_name_matched = false;\n\n                                if let Some(table_name) = \u0026e.item.table_name {\n                                    if table_name == \u0026field.table_name.table_name {\n                                        table_name_matched = true;\n                                    } else if let Some(table_name) = table_alias_map.get(table_name)\n                                    {\n                                        if table_name.table_name == field.table_name.table_name {\n                                            table_name_matched = true;\n                                        }\n                                    } else if let Some(table_name) =\n                                        table_alias_reverse_map.get(table_name)\n                                    {\n                                        if table_name == \u0026field.table_name.table_name {\n                                            table_name_matched = true;\n                                        }\n                                    }\n                                } else {\n                                    table_name_matched = true;\n                                }\n\n                                e.item.column_name == field.column_name \u0026\u0026 table_name_matched\n                            }) {\n                                group_key.push(field);\n                            }\n                            // 미포함된 컬럼일 경우 배열 형태로 값 중첩\n                            else {\n                                group_value.push(field);\n                            }\n                        }\n\n                        match grouped_map.get_mut(\u0026group_key) {\n                            Some(value) =\u003e {\n                                for i in 0..value.len() {\n                                    value[i].push(group_value[i].data.clone());\n                                }\n                            }\n                            None =\u003e {\n                                grouped_map.insert(\n                                    group_key,\n                                    group_value\n                                        .into_iter()\n                                        .map(|e| e.to_array())\n                                        .collect::\u003cVec\u003c_\u003e\u003e(),\n                                );\n                            }\n                        }\n                    }\n\n                    rows = grouped_map\n                        .into_iter()\n                        .map(|(mut key, mut value)| {\n                            key.append(\u0026mut value);\n                            TableDataRow { fields: key }\n                        })\n                        .collect();\n                }\n                SelectPlanItem::GroupAll =\u003e {\n                    let mut fields = vec![];\n\n                    for row in rows {\n                        if fields.is_empty() {\n                            for field in row.fields {\n                                fields.push(field.to_array());\n                            }\n                        } else {\n                            for (i, field) in row.fields.into_iter().enumerate() {\n                                fields[i].push(field.data)\n                            }\n                        }\n                    }\n\n                    rows = vec![TableDataRow { fields }];\n                }\n                SelectPlanItem::LimitOffset(limit_offset) =\u003e {\n                    let offset = limit_offset.offset.unwrap_or(0) as usize;\n\n                    match limit_offset.limit {\n                        Some(limit) =\u003e {\n                            rows = rows.drain(offset..(offset + limit as usize)).collect()\n                        }\n                        None =\u003e rows = rows.drain(offset..).collect(),\n                    }\n                }\n                SelectPlanItem::Order(ref order_by_clause) =\u003e {\n                    let futures = rows.into_iter().map(|e| {\n                        let table_alias_map = table_alias_map.clone();\n\n                        async move {\n                            let mut order_by_values = vec![];\n\n                            let reduce_context = ReduceContext {\n                                row: Some(e.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            for order_by_item in \u0026order_by_clause.order_by_items {\n                                let expression = \u0026order_by_item.item;\n\n                                let value = match self\n                                    .reduce_expression(expression.clone(), reduce_context.clone())\n                                    .await\n                                {\n                                    Ok(value) =\u003e value,\n                                    Err(error) =\u003e return Err(error),\n                                };\n\n                                order_by_values.push(value);\n                            }\n\n                            Ok((e, order_by_values))\n                        }\n                    });\n\n                    let mut order_by_rows = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    let order_by_items = \u0026order_by_clause.order_by_items;\n\n                    order_by_rows.sort_by(|(_, l), (_, r)| {\n                        for (i, order_by_item) in order_by_items.iter().enumerate() {\n                            let lhs = \u0026l[i];\n                            let rhs = \u0026r[i];\n\n                            if lhs.is_null() \u0026\u0026 rhs.is_null() {\n                                continue;\n                            }\n\n                            if lhs.is_null() {\n                                match order_by_item.nulls {\n                                    OrderByNulls::First =\u003e {\n                                        return Ordering::Less;\n                                    }\n                                    OrderByNulls::Last =\u003e {\n                                        return Ordering::Greater;\n                                    }\n                                }\n                            }\n\n                            if rhs.is_null() {\n                                match order_by_item.nulls {\n                                    OrderByNulls::First =\u003e {\n                                        return Ordering::Greater;\n                                    }\n                                    OrderByNulls::Last =\u003e {\n                                        return Ordering::Less;\n                                    }\n                                }\n                            }\n\n                            match order_by_item.order_type {\n                                OrderByType::Asc =\u003e {\n                                    if lhs \u003c rhs {\n                                        return Ordering::Less;\n                                    } else if lhs \u003e rhs {\n                                        return Ordering::Greater;\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                OrderByType::Desc =\u003e {\n                                    if lhs \u003c rhs {\n                                        return Ordering::Greater;\n                                    } else if lhs \u003e rhs {\n                                        return Ordering::Less;\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n\n                        Ordering::Equal\n                    });\n\n                    rows = order_by_rows.into_iter().map(|(e, _)| e).collect();\n                }\n                _ =\u003e unimplemented!(\"미구현\"),\n            }\n        }\n\n        if no_from_clause {\n            rows.push(TableDataRow {\n                fields: vec![TableDataField {\n                    table_name: TableName::new(None, \"no_table\".into()),\n                    column_name: \"result\".into(),\n                    data: TableDataFieldType::Null,\n                }],\n            });\n        }\n\n        let config_columns = table_infos\n            .into_iter()\n            .flat_map(|table_info| {\n                table_info\n                    .columns\n                    .iter()\n                    .cloned()\n                    .map(|column| (table_info.table.to_owned(), column))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // *까지 전부 유효한 항목으로 펼침\n        let select_items = select_items\n            .into_iter()\n            .flat_map(|e| match e {\n                SelectKind::SelectItem(item) =\u003e vec![item],\n                SelectKind::WildCard(wildcard) =\u003e match wildcard.alias {\n                    // a.* 와 같은 형태일 경우\n                    Some(alias) =\u003e match table_alias_map.get(\u0026alias) {\n                        Some(found_table_name) =\u003e config_columns\n                            .iter()\n                            .filter(|(table_name, _)| {\n                                found_table_name.table_name == table_name.table_name\n                            })\n                            .map(|(table_name, column_name)| {\n                                SelectItem::builder()\n                                    .set_item(\n                                        SelectColumn::new(\n                                            Some(table_name.table_name.clone()),\n                                            column_name.name.clone(),\n                                        )\n                                        .into(),\n                                    )\n                                    .build()\n                            })\n                            .collect(),\n                        None =\u003e config_columns\n                            .iter()\n                            .filter(|(table_name, _)| alias == table_name.table_name)\n                            .map(|(table_name, column_name)| {\n                                SelectItem::builder()\n                                    .set_item(\n                                        SelectColumn::new(\n                                            Some(table_name.table_name.clone()),\n                                            column_name.name.clone(),\n                                        )\n                                        .into(),\n                                    )\n                                    .build()\n                            })\n                            .collect(),\n                    },\n                    None =\u003e config_columns\n                        .iter()\n                        .map(|(table_name, column_name)| {\n                            SelectItem::builder()\n                                .set_item(\n                                    SelectColumn::new(\n                                        Some(table_name.table_name.clone()),\n                                        column_name.name.clone(),\n                                    )\n                                    .into(),\n                                )\n                                .build()\n                        })\n                        .collect(),\n                },\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // 필요한 SELECT Item만 최종 계산\n        let total_count = rows.len();\n        let rows = rows.into_iter().map(|row| {\n            let table_alias_map = table_alias_map.clone();\n            let select_items = select_items.clone();\n            async move {\n                let fields = select_items.iter().map(|select_item| {\n                    let table_alias_map = table_alias_map.clone();\n                    let row = row.clone();\n                    async move {\n                        let reduce_context = ReduceContext {\n                            row: Some(row.clone()),\n                            table_alias_map: table_alias_map.clone(),\n                            config_columns: vec![],\n                            total_count,\n                        };\n\n                        let value = self\n                            .reduce_expression(\n                                select_item.item.as_ref().unwrap().clone(),\n                                reduce_context.clone(),\n                            )\n                            .await;\n\n                        match value {\n                            Ok(value) =\u003e Ok(ExecuteField::from(value)),\n                            Err(error) =\u003e Err(error),\n                        }\n                    }\n                });\n\n                let fields = join_all(fields)\n                    .await\n                    .into_iter()\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n                match fields {\n                    Ok(fields) =\u003e Ok(ExecuteRow { fields }),\n                    Err(error) =\u003e Err(error),\n                }\n            }\n        });\n\n        let rows = join_all(rows)\n            .await\n            .into_iter()\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e();\n\n        let reduce_context = ReduceContext {\n            row: None,\n            table_alias_map,\n            config_columns,\n            total_count: 0,\n        };\n\n        let columns = select_items\n            .into_iter()\n            .map(|e| {\n                let item = e.item.unwrap();\n\n                let name = match e.alias {\n                    Some(alias) =\u003e alias,\n                    None =\u003e match \u0026item {\n                        SQLExpression::SelectColumn(column) =\u003e column.column_name.to_owned(),\n                        _ =\u003e \"?column?\".into(),\n                    },\n                };\n                let data_type = self.reduce_type(item, reduce_context.clone())?;\n\n                Ok(ExecuteColumn { name, data_type })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        match rows {\n            Ok(rows) =\u003e Ok(ExecuteResult { columns, rows }),\n            Err(error) =\u003e Err(error),\n        }\n    }\n\n    pub async fn filter(\u0026self) {}\n\n    pub async fn order_by(\u0026self) {}\n\n    pub async fn inner_join(\u0026self) {}\n}\n","traces":[{"line":21,"address":[3681173,3699097,3682355,3680198,3680064,3680141,3680631],"length":1,"stats":{"Line":0}},{"line":23,"address":[3680621],"length":1,"stats":{"Line":0}},{"line":25,"address":[3680827,3680898],"length":1,"stats":{"Line":0}},{"line":27,"address":[3680188,3681205,3681101,3680913,3680661,3681616,3682312],"length":1,"stats":{"Line":0}},{"line":29,"address":[3681591],"length":1,"stats":{"Line":0}},{"line":30,"address":[3681792],"length":1,"stats":{"Line":0}},{"line":31,"address":[3681874],"length":1,"stats":{"Line":0}},{"line":33,"address":[3681955],"length":1,"stats":{"Line":0}},{"line":35,"address":[3682055],"length":1,"stats":{"Line":0}},{"line":37,"address":[3683659,3682085,3683486,3682209,3683592],"length":1,"stats":{"Line":0}},{"line":38,"address":[3683728],"length":1,"stats":{"Line":0}},{"line":40,"address":[3685451],"length":1,"stats":{"Line":0}},{"line":41,"address":[3685535],"length":1,"stats":{"Line":0}},{"line":43,"address":[3685550,3686019],"length":1,"stats":{"Line":0}},{"line":45,"address":[3682364,3680682,3686034,3686166,3686719,3688946],"length":1,"stats":{"Line":0}},{"line":47,"address":[3686642],"length":1,"stats":{"Line":0}},{"line":49,"address":[3687553,3686880],"length":1,"stats":{"Line":0}},{"line":50,"address":[3687118,3687558,3687083,3686983],"length":1,"stats":{"Line":0}},{"line":51,"address":[3687305],"length":1,"stats":{"Line":0}},{"line":54,"address":[3687032],"length":1,"stats":{"Line":0}},{"line":56,"address":[3687612,3688009,3687867,3688173,3688341,3688850,3687703],"length":1,"stats":{"Line":0}},{"line":57,"address":[3687627],"length":1,"stats":{"Line":0}},{"line":58,"address":[3687900,3688261,3682399,3687860,3688089,3680703],"length":1,"stats":{"Line":0}},{"line":60,"address":[3699152,3699180],"length":1,"stats":{"Line":0}},{"line":63,"address":[3688420],"length":1,"stats":{"Line":0}},{"line":65,"address":[3687713],"length":1,"stats":{"Line":0}},{"line":70,"address":[3685815],"length":1,"stats":{"Line":0}},{"line":71,"address":[3685916,3699582,3699232,3695368],"length":1,"stats":{"Line":0}},{"line":72,"address":[3699352,3699267],"length":1,"stats":{"Line":0}},{"line":73,"address":[3699360],"length":1,"stats":{"Line":0}},{"line":74,"address":[3701610,3700453,3699429,3699616,3700480,3699696,3699651,3699784],"length":1,"stats":{"Line":0}},{"line":75,"address":[3699704,3700024],"length":1,"stats":{"Line":0}},{"line":76,"address":[3699881,3699764],"length":1,"stats":{"Line":0}},{"line":77,"address":[3699913],"length":1,"stats":{"Line":0}},{"line":78,"address":[3699977],"length":1,"stats":{"Line":0}},{"line":82,"address":[3700979,3700397,3700610,3700367,3700145,3700762],"length":1,"stats":{"Line":0}},{"line":83,"address":[3700231,3700162],"length":1,"stats":{"Line":0}},{"line":84,"address":[3700690,3700512,3699811,3699689,3700390,3700427,3700899],"length":1,"stats":{"Line":0}},{"line":86,"address":[3700859],"length":1,"stats":{"Line":0}},{"line":87,"address":[3701042],"length":1,"stats":{"Line":0}},{"line":88,"address":[3701251],"length":1,"stats":{"Line":0}},{"line":89,"address":[3701490,3701012],"length":1,"stats":{"Line":0}},{"line":96,"address":[3695517,3695730,3696147,3695582,3695846],"length":1,"stats":{"Line":0}},{"line":97,"address":[3695615,3682434,3695575,3695762,3680724],"length":1,"stats":{"Line":0}},{"line":101,"address":[3696407,3696237,3696001],"length":1,"stats":{"Line":0}},{"line":103,"address":[3701882,3701872],"length":1,"stats":{"Line":0}},{"line":104,"address":[3701904,3701912],"length":1,"stats":{"Line":0}},{"line":105,"address":[3696380],"length":1,"stats":{"Line":0}},{"line":107,"address":[3685689],"length":1,"stats":{"Line":0}},{"line":108,"address":[3685727],"length":1,"stats":{"Line":0}},{"line":111,"address":[3690203,3691967,3690078,3690330,3690380],"length":1,"stats":{"Line":0}},{"line":112,"address":[3690428],"length":1,"stats":{"Line":0}},{"line":113,"address":[3690679],"length":1,"stats":{"Line":0}},{"line":115,"address":[3692719,3690747,3691046,3690985,3690858],"length":1,"stats":{"Line":0}},{"line":117,"address":[3692215,3701936,3691166],"length":1,"stats":{"Line":0}},{"line":118,"address":[3701959],"length":1,"stats":{"Line":0}},{"line":120,"address":[3702059,3701964],"length":1,"stats":{"Line":0}},{"line":121,"address":[3702120,3702024],"length":1,"stats":{"Line":0}},{"line":122,"address":[3702115],"length":1,"stats":{"Line":0}},{"line":123,"address":[3702126,3702068],"length":1,"stats":{"Line":0}},{"line":125,"address":[3702231,3702136],"length":1,"stats":{"Line":0}},{"line":126,"address":[3702226],"length":1,"stats":{"Line":0}},{"line":128,"address":[3702173,3702237],"length":1,"stats":{"Line":0}},{"line":129,"address":[3702154],"length":1,"stats":{"Line":0}},{"line":131,"address":[3702282,3702247],"length":1,"stats":{"Line":0}},{"line":132,"address":[3702277],"length":1,"stats":{"Line":0}},{"line":136,"address":[3702054],"length":1,"stats":{"Line":0}},{"line":139,"address":[3702208,3702284],"length":1,"stats":{"Line":0}},{"line":141,"address":[3692420,3692709],"length":1,"stats":{"Line":0}},{"line":145,"address":[3692724,3692566],"length":1,"stats":{"Line":0}},{"line":149,"address":[3691272,3691208],"length":1,"stats":{"Line":0}},{"line":150,"address":[3691420],"length":1,"stats":{"Line":0}},{"line":151,"address":[3691444,3691674],"length":1,"stats":{"Line":0}},{"line":152,"address":[3691848,3692027],"length":1,"stats":{"Line":0}},{"line":156,"address":[3691549],"length":1,"stats":{"Line":0}},{"line":157,"address":[3691309],"length":1,"stats":{"Line":0}},{"line":158,"address":[3691357,3691519],"length":1,"stats":{"Line":0}},{"line":160,"address":[3702320,3702348],"length":1,"stats":{"Line":0}},{"line":167,"address":[3690438],"length":1,"stats":{"Line":0}},{"line":169,"address":[3702389,3702586,3702368],"length":1,"stats":{"Line":0}},{"line":170,"address":[3702444],"length":1,"stats":{"Line":0}},{"line":171,"address":[3702486],"length":1,"stats":{"Line":0}},{"line":176,"address":[3685745],"length":1,"stats":{"Line":0}},{"line":178,"address":[3693137,3693087,3692835,3694034,3692960],"length":1,"stats":{"Line":0}},{"line":179,"address":[3693185,3693540],"length":1,"stats":{"Line":0}},{"line":180,"address":[3694486,3694306,3693609,3694433],"length":1,"stats":{"Line":0}},{"line":181,"address":[3694614],"length":1,"stats":{"Line":0}},{"line":184,"address":[3693810,3694257,3693546,3693691,3693863],"length":1,"stats":{"Line":0}},{"line":185,"address":[3694084,3693999],"length":1,"stats":{"Line":0}},{"line":190,"address":[3693209],"length":1,"stats":{"Line":0}},{"line":192,"address":[3685755],"length":1,"stats":{"Line":0}},{"line":193,"address":[3685778,3694702],"length":1,"stats":{"Line":0}},{"line":195,"address":[3694717],"length":1,"stats":{"Line":0}},{"line":196,"address":[3694770],"length":1,"stats":{"Line":0}},{"line":197,"address":[3695064,3694784],"length":1,"stats":{"Line":0}},{"line":199,"address":[3694735,3694844],"length":1,"stats":{"Line":0}},{"line":202,"address":[3685585],"length":1,"stats":{"Line":0}},{"line":203,"address":[3702817,3702624,3689870,3685610],"length":1,"stats":{"Line":0}},{"line":204,"address":[3702653],"length":1,"stats":{"Line":0}},{"line":206,"address":[3703591,3702928,3702883,3702848,3703567,3705002,3702714,3703028],"length":1,"stats":{"Line":0}},{"line":207,"address":[3702936],"length":1,"stats":{"Line":0}},{"line":209,"address":[3703125,3703327],"length":1,"stats":{"Line":0}},{"line":210,"address":[3703137,3703196],"length":1,"stats":{"Line":0}},{"line":211,"address":[3703219],"length":1,"stats":{"Line":0}},{"line":212,"address":[3703280],"length":1,"stats":{"Line":0}},{"line":216,"address":[3702921,3704595,3703444,3704323,3703521],"length":1,"stats":{"Line":0}},{"line":217,"address":[3704611],"length":1,"stats":{"Line":0}},{"line":219,"address":[3704818,3703747,3704888,3703918,3704619],"length":1,"stats":{"Line":0}},{"line":220,"address":[3704857,3704708,3704931,3704641,3704743],"length":1,"stats":{"Line":0}},{"line":221,"address":[3703055,3704918,3704881,3703623,3703649,3703827],"length":1,"stats":{"Line":0}},{"line":223,"address":[3703948],"length":1,"stats":{"Line":0}},{"line":224,"address":[3704087],"length":1,"stats":{"Line":0}},{"line":227,"address":[3704020],"length":1,"stats":{"Line":0}},{"line":230,"address":[3704374],"length":1,"stats":{"Line":0}},{"line":234,"address":[3690005,3689975,3682765,3682614,3683065],"length":1,"stats":{"Line":0}},{"line":235,"address":[3689998,3682501,3680745,3682646,3690038,3682469],"length":1,"stats":{"Line":0}},{"line":239,"address":[3682920],"length":1,"stats":{"Line":0}},{"line":241,"address":[3682959,3705151,3705120,3683163],"length":1,"stats":{"Line":0}},{"line":242,"address":[3705185,3705329],"length":1,"stats":{"Line":0}},{"line":243,"address":[3705367],"length":1,"stats":{"Line":0}},{"line":244,"address":[3705413],"length":1,"stats":{"Line":0}},{"line":246,"address":[3705438,3705525],"length":1,"stats":{"Line":0}},{"line":250,"address":[3705485],"length":1,"stats":{"Line":0}},{"line":251,"address":[3705560],"length":1,"stats":{"Line":0}},{"line":253,"address":[3705856],"length":1,"stats":{"Line":0}},{"line":256,"address":[3705866],"length":1,"stats":{"Line":0}},{"line":261,"address":[3705545],"length":1,"stats":{"Line":0}},{"line":262,"address":[3705607],"length":1,"stats":{"Line":0}},{"line":264,"address":[3705836],"length":1,"stats":{"Line":0}},{"line":267,"address":[3705846],"length":1,"stats":{"Line":0}},{"line":272,"address":[3705587],"length":1,"stats":{"Line":0}},{"line":274,"address":[3705635],"length":1,"stats":{"Line":0}},{"line":275,"address":[3705753],"length":1,"stats":{"Line":0}},{"line":276,"address":[3705715],"length":1,"stats":{"Line":0}},{"line":277,"address":[3705763],"length":1,"stats":{"Line":0}},{"line":283,"address":[3705675],"length":1,"stats":{"Line":0}},{"line":284,"address":[3705816],"length":1,"stats":{"Line":0}},{"line":285,"address":[3705778],"length":1,"stats":{"Line":0}},{"line":286,"address":[3705826],"length":1,"stats":{"Line":0}},{"line":294,"address":[3705314],"length":1,"stats":{"Line":0}},{"line":297,"address":[3705916,3683170,3705888],"length":1,"stats":{"Line":0}},{"line":303,"address":[3683814],"length":1,"stats":{"Line":0}},{"line":304,"address":[3684531,3683910],"length":1,"stats":{"Line":0}},{"line":305,"address":[3683942,3684211,3685415,3685387,3685441],"length":1,"stats":{"Line":0}},{"line":306,"address":[3685422,3685399,3683973],"length":1,"stats":{"Line":0}},{"line":307,"address":[3684125],"length":1,"stats":{"Line":0}},{"line":308,"address":[3684203],"length":1,"stats":{"Line":0}},{"line":313,"address":[3683831,3684641],"length":1,"stats":{"Line":0}},{"line":315,"address":[3705968,3706168],"length":1,"stats":{"Line":0}},{"line":316,"address":[3706000,3706062],"length":1,"stats":{"Line":0}},{"line":320,"address":[3706192,3706222],"length":1,"stats":{"Line":0}},{"line":326,"address":[3684873,3684693],"length":1,"stats":{"Line":0}},{"line":328,"address":[3684832,3706419,3707156,3706384],"length":1,"stats":{"Line":0}},{"line":329,"address":[3707178,3706543],"length":1,"stats":{"Line":0}},{"line":330,"address":[3706462],"length":1,"stats":{"Line":0}},{"line":332,"address":[3706820,3706703],"length":1,"stats":{"Line":0}},{"line":333,"address":[3706888,3707064],"length":1,"stats":{"Line":0}},{"line":335,"address":[3707437,3707424],"length":1,"stats":{"Line":0}},{"line":336,"address":[3707445],"length":1,"stats":{"Line":0}},{"line":338,"address":[3707472,3707510,3707914],"length":1,"stats":{"Line":0}},{"line":339,"address":[3707551,3707820,3707869],"length":1,"stats":{"Line":0}},{"line":341,"address":[3707743,3707790],"length":1,"stats":{"Line":0}},{"line":342,"address":[3707642,3707577],"length":1,"stats":{"Line":0}},{"line":343,"address":[3707682],"length":1,"stats":{"Line":0}},{"line":350,"address":[3706940,3706862],"length":1,"stats":{"Line":0}},{"line":352,"address":[3707952,3707965],"length":1,"stats":{"Line":0}},{"line":353,"address":[3708442,3708038,3708000],"length":1,"stats":{"Line":0}},{"line":354,"address":[3708348,3708079,3708397],"length":1,"stats":{"Line":0}},{"line":356,"address":[3708271,3708318],"length":1,"stats":{"Line":0}},{"line":357,"address":[3708170,3708105],"length":1,"stats":{"Line":0}},{"line":358,"address":[3708210],"length":1,"stats":{"Line":0}},{"line":366,"address":[3706652],"length":1,"stats":{"Line":0}},{"line":368,"address":[3708480,3708518,3708922],"length":1,"stats":{"Line":0}},{"line":369,"address":[3708877,3708559,3708828],"length":1,"stats":{"Line":0}},{"line":371,"address":[3708798,3708751],"length":1,"stats":{"Line":0}},{"line":372,"address":[3708650,3708585],"length":1,"stats":{"Line":0}},{"line":373,"address":[3708690],"length":1,"stats":{"Line":0}},{"line":385,"address":[3684925,3685036],"length":1,"stats":{"Line":0}},{"line":386,"address":[3685039,3709252,3708960],"length":1,"stats":{"Line":0}},{"line":387,"address":[3708995],"length":1,"stats":{"Line":0}},{"line":388,"address":[3709052],"length":1,"stats":{"Line":0}},{"line":389,"address":[3709112,3709680,3709390,3709315,3709360,3710402,3710307,3709280],"length":1,"stats":{"Line":0}},{"line":390,"address":[3710448,3709368,3709477,3710688],"length":1,"stats":{"Line":0}},{"line":391,"address":[3710488],"length":1,"stats":{"Line":0}},{"line":392,"address":[3710506],"length":1,"stats":{"Line":0}},{"line":393,"address":[3710800,3710569,3710833,3710755,3711580,3710720,3712131],"length":1,"stats":{"Line":0}},{"line":394,"address":[3710808,3711057],"length":1,"stats":{"Line":0}},{"line":395,"address":[3710816,3710910],"length":1,"stats":{"Line":0}},{"line":396,"address":[3710933],"length":1,"stats":{"Line":0}},{"line":397,"address":[3710999],"length":1,"stats":{"Line":0}},{"line":398,"address":[3711043],"length":1,"stats":{"Line":0}},{"line":401,"address":[3711396,3711154,3711507,3711718],"length":1,"stats":{"Line":0}},{"line":403,"address":[3711311,3711168],"length":1,"stats":{"Line":0}},{"line":404,"address":[3711326],"length":1,"stats":{"Line":0}},{"line":406,"address":[3711621,3711798,3711459,3710860,3710793,3711537],"length":1,"stats":{"Line":0}},{"line":408,"address":[3711854],"length":1,"stats":{"Line":0}},{"line":409,"address":[3711989,3711880],"length":1,"stats":{"Line":0}},{"line":410,"address":[3711935],"length":1,"stats":{"Line":0}},{"line":415,"address":[3709599,3709917,3709816,3709629],"length":1,"stats":{"Line":0}},{"line":416,"address":[3709622,3709417,3709656,3709848,3709353,3709712],"length":1,"stats":{"Line":0}},{"line":420,"address":[3709947],"length":1,"stats":{"Line":0}},{"line":421,"address":[3709977],"length":1,"stats":{"Line":0}},{"line":422,"address":[3710135],"length":1,"stats":{"Line":0}},{"line":427,"address":[3685238,3697086,3696970,3685311],"length":1,"stats":{"Line":0}},{"line":428,"address":[3680766,3685304,3696857,3685344,3697002],"length":1,"stats":{"Line":0}},{"line":439,"address":[3697558,3697395,3697856],"length":1,"stats":{"Line":0}},{"line":441,"address":[3713471,3697519,3713437,3712256],"length":1,"stats":{"Line":0}},{"line":442,"address":[3712487,3712299],"length":1,"stats":{"Line":0}},{"line":444,"address":[3712495],"length":1,"stats":{"Line":0}},{"line":445,"address":[3712572],"length":1,"stats":{"Line":0}},{"line":446,"address":[3712525],"length":1,"stats":{"Line":0}},{"line":447,"address":[3712665,3712779],"length":1,"stats":{"Line":0}},{"line":448,"address":[3712894,3712697],"length":1,"stats":{"Line":0}},{"line":451,"address":[3712786,3713275,3713427,3712896,3713053],"length":1,"stats":{"Line":0}},{"line":453,"address":[3713102],"length":1,"stats":{"Line":0}},{"line":457,"address":[3697745],"length":1,"stats":{"Line":0}},{"line":458,"address":[3697889],"length":1,"stats":{"Line":0}},{"line":459,"address":[3698141],"length":1,"stats":{"Line":0}},{"line":463,"address":[5589520,5589528],"length":1,"stats":{"Line":0}},{"line":465,"address":[5589544,5589536],"length":1,"stats":{"Line":0}},{"line":467,"address":[5589552,5589560],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":221},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","dml","update.rs"],"content":"use std::collections::HashMap;\n\nuse futures::future::join_all;\n\nuse crate::ast::dml::plan::select::scan::ScanType;\nuse crate::ast::dml::plan::update::update_plan::UpdatePlanItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::type_error::TypeError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::row::TableDataFieldType;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteField, ExecuteResult, ExecuteRow, Executor, ReduceContext,\n};\nuse crate::executor::result::ExecuteColumnType;\nuse crate::optimizer::predule::Optimizer;\n\nimpl Executor {\n    pub async fn update(\u0026self, query: UpdateQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let table = query.target_table.clone().unwrap().table;\n        let update_items = query.update_items.clone();\n\n        // 최적화 작업\n        let optimizer = Optimizer::new();\n\n        let plan = optimizer.optimize_update(query).await?;\n\n        let mut table_alias_map = HashMap::new();\n        let mut table_infos = vec![];\n\n        let mut rows = vec![];\n\n        for each_plan in plan.list {\n            match each_plan {\n                // Select From 처리\n                UpdatePlanItem::UpdateFrom(from) =\u003e {\n                    let table_name = from.table_name.clone();\n\n                    let table_config = self.get_table_config(table_name.clone()).await?;\n\n                    table_infos.push(table_config);\n\n                    if let Some(alias) = from.alias {\n                        table_alias_map.insert(alias, table_name.clone());\n                    }\n\n                    match from.scan {\n                        ScanType::FullScan =\u003e {\n                            let mut result =\n                                self.full_scan(table_name).await?.into_iter().collect();\n\n                            rows.append(\u0026mut result);\n                        }\n                        ScanType::IndexScan(_index) =\u003e {\n                            unimplemented!()\n                        }\n                    }\n                }\n                // 필터링 처리\n                UpdatePlanItem::Filter(filter) =\u003e {\n                    let futures = rows.iter().cloned().map(|(path, row)| {\n                        let table_alias_map = table_alias_map.clone();\n                        let filter = filter.clone();\n                        async move {\n                            let reduce_context = ReduceContext {\n                                row: Some(row.to_owned()),\n                                table_alias_map,\n                                config_columns: vec![],\n                                total_count: 0,\n                            };\n\n                            let condition = self\n                                .reduce_expression(filter.expression.clone(), reduce_context)\n                                .await?;\n\n                            match condition {\n                                TableDataFieldType::Boolean(boolean) =\u003e Ok((path, row, boolean)),\n                                TableDataFieldType::Null =\u003e Ok((path, row, false)),\n                                _ =\u003e Err(TypeError::wrap(\n                                    \"condition expression is valid only for boolean and null types\",\n                                )),\n                            }\n                        }\n                    });\n\n                    let result = join_all(futures)\n                        .await\n                        .into_iter()\n                        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n                    rows = result\n                        .into_iter()\n                        .filter(|(_, _, boolean)| *boolean)\n                        .map(|(path, row, _)| (path, row))\n                        .collect();\n                }\n            }\n        }\n\n        let config_columns = table_infos\n            .into_iter()\n            .flat_map(|table_info| {\n                table_info\n                    .columns\n                    .iter()\n                    .cloned()\n                    .map(|column| (table_info.table.to_owned(), column))\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // 수정 작업\n        for (path, mut row) in rows.into_iter() {\n            let reduce_context = ReduceContext {\n                row: None,\n                table_alias_map: table_alias_map.clone(),\n                config_columns: config_columns.clone(),\n                total_count: 0,\n            };\n\n            for update_item in \u0026update_items {\n                let column_name = update_item.column.clone();\n                let set_value = update_item.value.clone();\n\n                let set_value = self\n                    .reduce_expression(set_value, reduce_context.clone())\n                    .await?;\n\n                let found = row.fields.iter_mut().find(|e| e.column_name == column_name);\n\n                match found {\n                    Some(found) =\u003e found.data = set_value,\n                    None =\u003e {\n                        return Err(ExecuteError::wrap(format!(\n                            \"column '{}' not found in data row\",\n                            column_name\n                        )));\n                    }\n                }\n            }\n\n            if let Err(error) = tokio::fs::write(\u0026path, encoder.encode(row)).await {\n                return Err(ExecuteError::wrap(format!(\n                    \"path '{:?}' write failed: {}\",\n                    path, error\n                )));\n            }\n        }\n\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"updated from {:?}\",\n                    table.table_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":20,"address":[5589568,5589603],"length":1,"stats":{"Line":0}},{"line":21,"address":[5652450],"length":1,"stats":{"Line":0}},{"line":23,"address":[5652656,5652759],"length":1,"stats":{"Line":0}},{"line":24,"address":[5652878],"length":1,"stats":{"Line":0}},{"line":27,"address":[5652910],"length":1,"stats":{"Line":0}},{"line":29,"address":[4700613],"length":1,"stats":{"Line":0}},{"line":31,"address":[5653618],"length":1,"stats":{"Line":0}},{"line":32,"address":[5653804],"length":1,"stats":{"Line":0}},{"line":34,"address":[5653885],"length":1,"stats":{"Line":0}},{"line":36,"address":[5655402,5653985,5655338,5654124],"length":1,"stats":{"Line":0}},{"line":37,"address":[5655442],"length":1,"stats":{"Line":0}},{"line":39,"address":[5655871],"length":1,"stats":{"Line":0}},{"line":40,"address":[5656164,5655940],"length":1,"stats":{"Line":0}},{"line":42,"address":[4700635],"length":1,"stats":{"Line":0}},{"line":44,"address":[5656787],"length":1,"stats":{"Line":0}},{"line":46,"address":[5657025],"length":1,"stats":{"Line":0}},{"line":47,"address":[5657387,5657267,5657124],"length":1,"stats":{"Line":0}},{"line":50,"address":[5657216],"length":1,"stats":{"Line":0}},{"line":52,"address":[4700983,4700657,4700943],"length":1,"stats":{"Line":0}},{"line":55,"address":[5658191],"length":1,"stats":{"Line":0}},{"line":57,"address":[5657507],"length":1,"stats":{"Line":0}},{"line":63,"address":[5655975],"length":1,"stats":{"Line":0}},{"line":64,"address":[5665744,5659511,5665774,5666194,5656061,5666227],"length":1,"stats":{"Line":0}},{"line":65,"address":[5665849,5665910],"length":1,"stats":{"Line":0}},{"line":66,"address":[5665918],"length":1,"stats":{"Line":0}},{"line":67,"address":[5665985,5666448,5666336,5666256,5667120,5668535,5666291,5667147],"length":1,"stats":{"Line":0}},{"line":68,"address":[5666691,5666344],"length":1,"stats":{"Line":0}},{"line":69,"address":[5666428,5666545],"length":1,"stats":{"Line":0}},{"line":70,"address":[5666577],"length":1,"stats":{"Line":0}},{"line":71,"address":[5666644],"length":1,"stats":{"Line":0}},{"line":75,"address":[5667064,5667034,5667646,5666812,5667277,5667429],"length":1,"stats":{"Line":0}},{"line":76,"address":[5666898,5666829],"length":1,"stats":{"Line":0}},{"line":77,"address":[5666329,5667179,5667357,5667057,5667094,5667566,5666475],"length":1,"stats":{"Line":0}},{"line":79,"address":[5667526],"length":1,"stats":{"Line":0}},{"line":80,"address":[5667709],"length":1,"stats":{"Line":0}},{"line":81,"address":[5667985],"length":1,"stats":{"Line":0}},{"line":82,"address":[5668291,5667679],"length":1,"stats":{"Line":0}},{"line":89,"address":[5659686,5654644,5659716,5654493,5654945],"length":1,"stats":{"Line":0}},{"line":90,"address":[4700679],"length":1,"stats":{"Line":0}},{"line":94,"address":[5654799,5655035,5655205],"length":1,"stats":{"Line":0}},{"line":96,"address":[5668874,5668864],"length":1,"stats":{"Line":0}},{"line":97,"address":[5668904,5668896],"length":1,"stats":{"Line":0}},{"line":98,"address":[5655178],"length":1,"stats":{"Line":0}},{"line":103,"address":[5655493],"length":1,"stats":{"Line":0}},{"line":105,"address":[5669024,5669224],"length":1,"stats":{"Line":0}},{"line":106,"address":[5669118,5669056],"length":1,"stats":{"Line":0}},{"line":110,"address":[5669278,5669248],"length":1,"stats":{"Line":0}},{"line":116,"address":[5661072,5661005,5655622,5655761],"length":1,"stats":{"Line":0}},{"line":119,"address":[5661177],"length":1,"stats":{"Line":0}},{"line":120,"address":[5662790],"length":1,"stats":{"Line":0}},{"line":124,"address":[5663075,5663267,5662986],"length":1,"stats":{"Line":0}},{"line":125,"address":[5663288],"length":1,"stats":{"Line":0}},{"line":126,"address":[5663458],"length":1,"stats":{"Line":0}},{"line":128,"address":[5663817,5664120,5663528,5665102,5663712,5664340,5663956],"length":1,"stats":{"Line":0}},{"line":129,"address":[5665513,5663751,5663548,5665534],"length":1,"stats":{"Line":0}},{"line":130,"address":[4700701],"length":1,"stats":{"Line":0}},{"line":132,"address":[5669440,5664225,5669457,5664424],"length":1,"stats":{"Line":0}},{"line":134,"address":[5664515],"length":1,"stats":{"Line":0}},{"line":135,"address":[5665023,5664638,5664944],"length":1,"stats":{"Line":0}},{"line":137,"address":[5664544,5664712],"length":1,"stats":{"Line":0}},{"line":145,"address":[4700723],"length":1,"stats":{"Line":0}},{"line":146,"address":[5660227,5660484],"length":1,"stats":{"Line":0}},{"line":153,"address":[5662226],"length":1,"stats":{"Line":0}},{"line":154,"address":[5661220,5662745,5661337,5661297],"length":1,"stats":{"Line":0}},{"line":155,"address":[5661251],"length":1,"stats":{"Line":0}},{"line":156,"address":[5661329],"length":1,"stats":{"Line":0}},{"line":158,"address":[5662073,5661668,5661570,5661630,5662740],"length":1,"stats":{"Line":0}},{"line":159,"address":[5662735,5661705,5661648,5661815],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":68},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","mod.rs"],"content":"pub mod ddl;\npub mod dml;\npub mod other;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","desc_table.rs"],"content":"use std::io::ErrorKind;\n\nuse crate::ast::other::desc_table::DescTableQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn desc_table(\u0026self, query: DescTableQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let database_name = query.table_name.database_name.unwrap();\n        let table_name = query.table_name.table_name;\n\n        let base_path = self.get_data_directory();\n        let table_path = base_path\n            .join(database_name)\n            .join(\"tables\")\n            .join(\u0026table_name);\n        let config_path = table_path.join(\"table.config\");\n\n        match std::fs::read(config_path) {\n            Ok(read_result) =\u003e {\n                let table_info: TableConfig = encoder\n                    .decode(read_result.as_slice())\n                    .ok_or_else(|| ExecuteError::wrap(\"config decode error\"))?;\n\n                Ok(ExecuteResult {\n                    columns: (vec![\n                        ExecuteColumn {\n                            name: \"Field\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Type\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Null\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Default\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                        ExecuteColumn {\n                            name: \"Comment\".into(),\n                            data_type: ExecuteColumnType::String,\n                        },\n                    ]),\n                    rows: table_info\n                        .columns\n                        .iter()\n                        .map(|e| ExecuteRow {\n                            fields: vec![\n                                ExecuteField::String(e.name.to_owned()),\n                                ExecuteField::String(e.data_type.to_owned().into()),\n                                ExecuteField::String(if e.not_null { \"NO\" } else { \"YES\" }.into()),\n                                ExecuteField::String(format!(\"{:?}\", e.default)), // TODO: 표현식 역 parsing 구현\n                                ExecuteField::String(e.comment.to_owned()),\n                            ],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(format!(\n                    \"table '{}' not exists\",\n                    table_name\n                ))),\n                _ =\u003e Err(ExecuteError::wrap(\"database listup failed\")),\n            },\n        }\n    }\n}\n","traces":[{"line":13,"address":[4914537,4910384,4910469,4910587,4913444,4914581,4910423],"length":1,"stats":{"Line":0}},{"line":14,"address":[4910580],"length":1,"stats":{"Line":0}},{"line":16,"address":[4910650,4910846],"length":1,"stats":{"Line":0}},{"line":17,"address":[4910854],"length":1,"stats":{"Line":0}},{"line":19,"address":[4910902],"length":1,"stats":{"Line":0}},{"line":20,"address":[4911195,4910961,4911097,4911330],"length":1,"stats":{"Line":0}},{"line":21,"address":[4911041],"length":1,"stats":{"Line":0}},{"line":23,"address":[4911254,4911337,4911135],"length":1,"stats":{"Line":0}},{"line":24,"address":[4911468],"length":1,"stats":{"Line":0}},{"line":26,"address":[4910467,4911545,4911596],"length":1,"stats":{"Line":0}},{"line":27,"address":[4911631],"length":1,"stats":{"Line":0}},{"line":28,"address":[4911800,4912063],"length":1,"stats":{"Line":0}},{"line":29,"address":[4911663],"length":1,"stats":{"Line":0}},{"line":30,"address":[4914636,4914624,4911983],"length":1,"stats":{"Line":0}},{"line":32,"address":[4913220],"length":1,"stats":{"Line":0}},{"line":33,"address":[4913607,4911968,4912459,4912825,4912723,4912591,4912327,4913655,4912141,4913479,4912195],"length":1,"stats":{"Line":0}},{"line":34,"address":[4912235],"length":1,"stats":{"Line":0}},{"line":35,"address":[4912149],"length":1,"stats":{"Line":0}},{"line":36,"address":[4912227],"length":1,"stats":{"Line":0}},{"line":38,"address":[4912367],"length":1,"stats":{"Line":0}},{"line":39,"address":[4912281],"length":1,"stats":{"Line":0}},{"line":40,"address":[4912359],"length":1,"stats":{"Line":0}},{"line":42,"address":[4912499],"length":1,"stats":{"Line":0}},{"line":43,"address":[4912413],"length":1,"stats":{"Line":0}},{"line":44,"address":[4912491],"length":1,"stats":{"Line":0}},{"line":46,"address":[4912631],"length":1,"stats":{"Line":0}},{"line":47,"address":[4912545],"length":1,"stats":{"Line":0}},{"line":48,"address":[4912623],"length":1,"stats":{"Line":0}},{"line":50,"address":[4912763],"length":1,"stats":{"Line":0}},{"line":51,"address":[4912677],"length":1,"stats":{"Line":0}},{"line":52,"address":[4912755],"length":1,"stats":{"Line":0}},{"line":55,"address":[4913151,4913076],"length":1,"stats":{"Line":0}},{"line":58,"address":[4915725,4915784,4914672],"length":1,"stats":{"Line":0}},{"line":59,"address":[4914839,4915498,4914720,4915418,4914760,4915245,4915068,4915763],"length":1,"stats":{"Line":0}},{"line":60,"address":[4914735,4914797],"length":1,"stats":{"Line":0}},{"line":61,"address":[4914817,4914878],"length":1,"stats":{"Line":0}},{"line":62,"address":[4915105,4914953],"length":1,"stats":{"Line":0}},{"line":63,"address":[4915277,4915153],"length":1,"stats":{"Line":0}},{"line":64,"address":[4915387,4915450],"length":1,"stats":{"Line":0}},{"line":70,"address":[4911692,4914017],"length":1,"stats":{"Line":0}},{"line":71,"address":[4914164],"length":1,"stats":{"Line":0}},{"line":75,"address":[4914308,4914134],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","mod.rs"],"content":"pub mod desc_table;\npub mod show_databases;\npub mod show_tables;\npub mod use_database;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","show_databases.rs"],"content":"use std::io::ErrorKind;\n\nuse futures::future::join_all;\n\nuse crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::database::DatabaseConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn show_databases(\n        \u0026self,\n        _query: ShowDatabasesQuery,\n    ) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n\n        match std::fs::read_dir(\u0026base_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_dir() {\n                                    let mut path = entry.path();\n                                    path.push(\"database.config\");\n\n                                    match tokio::fs::read(path).await {\n                                        Ok(result) =\u003e {\n                                            let database_config: DatabaseConfig =\n                                                encoder.decode(result.as_slice()).unwrap();\n\n                                            Some(database_config.database_name)\n                                        }\n                                        Err(_) =\u003e None,\n                                    }\n                                } else {\n                                    None\n                                }\n                            }\n                            Err(_) =\u003e None,\n                        },\n                        Err(_) =\u003e None,\n                    }\n                });\n\n                let database_list = join_all(futures).await.into_iter().flatten();\n\n                Ok(ExecuteResult {\n                    columns: (vec![ExecuteColumn {\n                        name: \"database name\".into(),\n                        data_type: ExecuteColumnType::String,\n                    }]),\n                    rows: database_list\n                        .map(|e| ExecuteRow {\n                            fields: vec![ExecuteField::String(e)],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists\")),\n                _ =\u003e Err(ExecuteError::wrap(\"database listup failed\")),\n            },\n        }\n    }\n\n    pub async fn find_database(\u0026self, database_name: String) -\u003e Result\u003cbool, RRDBError\u003e {\n        let result = self.show_databases(ShowDatabasesQuery {}).await?;\n\n        Ok(result.rows.iter().any(|e| {\n            if let ExecuteField::String(name) = \u0026e.fields[0] {\n                name == \u0026database_name\n            } else {\n                false\n            }\n        }))\n    }\n}\n","traces":[{"line":15,"address":[5589728],"length":1,"stats":{"Line":0}},{"line":19,"address":[4364606,4362837],"length":1,"stats":{"Line":0}},{"line":21,"address":[4362936],"length":1,"stats":{"Line":0}},{"line":23,"address":[4362793,4362952,4363017],"length":1,"stats":{"Line":0}},{"line":24,"address":[4363056,4363043],"length":1,"stats":{"Line":0}},{"line":25,"address":[4366325,4364611,4363052,4364707,4364792,4365350,4363075,4364672,4364576,4365398,4364752],"length":1,"stats":{"Line":0}},{"line":26,"address":[4364745,4364760],"length":1,"stats":{"Line":0}},{"line":27,"address":[4364832,4364956],"length":1,"stats":{"Line":0}},{"line":28,"address":[4364970],"length":1,"stats":{"Line":0}},{"line":29,"address":[4365076,4365100,4364984],"length":1,"stats":{"Line":0}},{"line":30,"address":[4365102],"length":1,"stats":{"Line":0}},{"line":31,"address":[4365152],"length":1,"stats":{"Line":0}},{"line":33,"address":[4365430,4365225,4364819],"length":1,"stats":{"Line":0}},{"line":34,"address":[4365683],"length":1,"stats":{"Line":0}},{"line":36,"address":[4365709,4365839],"length":1,"stats":{"Line":0}},{"line":38,"address":[4365941],"length":1,"stats":{"Line":0}},{"line":40,"address":[4365750],"length":1,"stats":{"Line":0}},{"line":43,"address":[4365082],"length":1,"stats":{"Line":0}},{"line":46,"address":[4365007],"length":1,"stats":{"Line":0}},{"line":48,"address":[4364888],"length":1,"stats":{"Line":0}},{"line":52,"address":[4363254,4362871,4363575,4363199],"length":1,"stats":{"Line":0}},{"line":54,"address":[4364346],"length":1,"stats":{"Line":0}},{"line":55,"address":[4363879,4363933,4363973,4363825,4364545],"length":1,"stats":{"Line":0}},{"line":56,"address":[4363887],"length":1,"stats":{"Line":0}},{"line":57,"address":[4363965],"length":1,"stats":{"Line":0}},{"line":59,"address":[4364178,4364339],"length":1,"stats":{"Line":0}},{"line":60,"address":[4366400,4366648,4366682,4366707],"length":1,"stats":{"Line":0}},{"line":61,"address":[4366426,4366502],"length":1,"stats":{"Line":0}},{"line":66,"address":[4363363,4363102],"length":1,"stats":{"Line":0}},{"line":67,"address":[4363438,4363384],"length":1,"stats":{"Line":0}},{"line":68,"address":[4363411,4363483],"length":1,"stats":{"Line":0}},{"line":73,"address":[4367823,4366720,4366860,4366755,4366800,4367728,4367016],"length":1,"stats":{"Line":0}},{"line":74,"address":[4367440,4367048,4366958,4366853,4366793,4366887],"length":1,"stats":{"Line":0}},{"line":76,"address":[4367600,4367856,4367420],"length":1,"stats":{"Line":0}},{"line":77,"address":[4367888],"length":1,"stats":{"Line":0}},{"line":78,"address":[4367959],"length":1,"stats":{"Line":0}},{"line":80,"address":[4367991],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","show_tables.rs"],"content":"use std::io::ErrorKind;\n\nuse futures::future::join_all;\n\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::errors::predule::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::table::TableConfig;\nuse crate::executor::encoder::storage::StorageEncoder;\nuse crate::executor::predule::{\n    ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n};\n\nimpl Executor {\n    pub async fn show_tables(\u0026self, query: ShowTablesQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        let encoder = StorageEncoder::new();\n\n        let base_path = self.get_data_directory();\n        let database_path = base_path.clone().join(query.database);\n        let tables_path = database_path.join(\"tables\");\n\n        match std::fs::read_dir(\u0026tables_path) {\n            Ok(read_dir_result) =\u003e {\n                let futures = read_dir_result.map(|e| async {\n                    match e {\n                        Ok(entry) =\u003e match entry.file_type() {\n                            Ok(file_type) =\u003e {\n                                if file_type.is_dir() {\n                                    let mut path = entry.path();\n                                    path.push(\"table.config\");\n\n                                    match tokio::fs::read(path).await {\n                                        Ok(result) =\u003e {\n                                            let table_config: TableConfig =\n                                                match encoder.decode(result.as_slice()) {\n                                                    Some(decoded) =\u003e decoded,\n                                                    None =\u003e return None,\n                                                };\n\n                                            Some(table_config.table.table_name)\n                                        }\n                                        Err(_) =\u003e None,\n                                    }\n                                } else {\n                                    None\n                                }\n                            }\n                            Err(_) =\u003e None,\n                        },\n                        Err(_) =\u003e None,\n                    }\n                });\n\n                let table_list = join_all(futures).await.into_iter().flatten();\n\n                Ok(ExecuteResult {\n                    columns: (vec![ExecuteColumn {\n                        name: \"table name\".into(),\n                        data_type: ExecuteColumnType::String,\n                    }]),\n                    rows: table_list\n                        .map(|e| ExecuteRow {\n                            fields: vec![ExecuteField::String(e)],\n                        })\n                        .collect(),\n                })\n            }\n            Err(error) =\u003e match error.kind() {\n                ErrorKind::NotFound =\u003e Err(ExecuteError::wrap(\"base path not exists\")),\n                _ =\u003e Err(ExecuteError::wrap(\"table listup failed\")),\n            },\n        }\n    }\n}\n","traces":[{"line":15,"address":[5589808,5589816],"length":1,"stats":{"Line":0}},{"line":16,"address":[4271550,4269170],"length":1,"stats":{"Line":0}},{"line":18,"address":[4269267],"length":1,"stats":{"Line":0}},{"line":19,"address":[4269351,4269283],"length":1,"stats":{"Line":0}},{"line":20,"address":[4269542],"length":1,"stats":{"Line":0}},{"line":22,"address":[4269607,4269675,4269081],"length":1,"stats":{"Line":0}},{"line":23,"address":[4269723,4269704],"length":1,"stats":{"Line":0}},{"line":24,"address":[4271696,4272348,4272300,4271555,4273362,4271616,4271736,4269742,4271520,4271651,4269716],"length":1,"stats":{"Line":0}},{"line":25,"address":[4271689,4271704],"length":1,"stats":{"Line":0}},{"line":26,"address":[4271776,4271900],"length":1,"stats":{"Line":0}},{"line":27,"address":[4271914],"length":1,"stats":{"Line":0}},{"line":28,"address":[4272044,4271928,4272020],"length":1,"stats":{"Line":0}},{"line":29,"address":[4272046],"length":1,"stats":{"Line":0}},{"line":30,"address":[4272096],"length":1,"stats":{"Line":0}},{"line":32,"address":[4744046],"length":1,"stats":{"Line":0}},{"line":33,"address":[4272636],"length":1,"stats":{"Line":0}},{"line":35,"address":[4272797,4272665],"length":1,"stats":{"Line":0}},{"line":36,"address":[4272922],"length":1,"stats":{"Line":0}},{"line":37,"address":[4272849],"length":1,"stats":{"Line":0}},{"line":40,"address":[4272949],"length":1,"stats":{"Line":0}},{"line":42,"address":[4272707],"length":1,"stats":{"Line":0}},{"line":45,"address":[4272026],"length":1,"stats":{"Line":0}},{"line":48,"address":[4271951],"length":1,"stats":{"Line":0}},{"line":50,"address":[4271832],"length":1,"stats":{"Line":0}},{"line":54,"address":[4269204,4269875,4270299,4269930],"length":1,"stats":{"Line":0}},{"line":56,"address":[4271091],"length":1,"stats":{"Line":0}},{"line":57,"address":[4270558,4271429,4270615,4270669,4270709],"length":1,"stats":{"Line":0}},{"line":58,"address":[4270623],"length":1,"stats":{"Line":0}},{"line":59,"address":[4270701],"length":1,"stats":{"Line":0}},{"line":61,"address":[4270917,4271084],"length":1,"stats":{"Line":0}},{"line":62,"address":[4274074,4274040,4274099,4273792],"length":1,"stats":{"Line":0}},{"line":63,"address":[4273894,4273818],"length":1,"stats":{"Line":0}},{"line":68,"address":[4269772,4270044],"length":1,"stats":{"Line":0}},{"line":69,"address":[4270119,4270065],"length":1,"stats":{"Line":0}},{"line":70,"address":[4270164,4270092],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","implements","other","use_database.rs"],"content":"use crate::{\n    ast::other::use_database::UseDatabaseQuery,\n    errors::RRDBError,\n    executor::predule::{\n        ExecuteColumn, ExecuteColumnType, ExecuteField, ExecuteResult, ExecuteRow, Executor,\n    },\n};\n\nimpl Executor {\n    pub async fn use_databases(\u0026self, query: UseDatabaseQuery) -\u003e Result\u003cExecuteResult, RRDBError\u003e {\n        Ok(ExecuteResult {\n            columns: (vec![ExecuteColumn {\n                name: \"desc\".into(),\n                data_type: ExecuteColumnType::String,\n            }]),\n            rows: (vec![ExecuteRow {\n                fields: vec![ExecuteField::String(format!(\n                    \"database changed: {}\",\n                    query.database_name\n                ))],\n            }]),\n        })\n    }\n}\n","traces":[{"line":10,"address":[1671940,1672029,1670829,1670734,1672053,1670704],"length":1,"stats":{"Line":0}},{"line":11,"address":[1671810],"length":1,"stats":{"Line":0}},{"line":12,"address":[1670817,1672048,1670947,1670893,1670987],"length":1,"stats":{"Line":0}},{"line":13,"address":[1670901],"length":1,"stats":{"Line":0}},{"line":14,"address":[1670979],"length":1,"stats":{"Line":0}},{"line":16,"address":[1671221,1672043,1671660,1671259,1671164],"length":1,"stats":{"Line":0}},{"line":17,"address":[1671296,1671239,1671402,1672038],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","initializer.rs"],"content":"use std::path::PathBuf;\nuse std::process::{Command, Output};\n\nuse std::io::Error;\n\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::constants::{DEFAULT_CONFIG_BASEPATH, DEFAULT_CONFIG_FILENAME, DEFAULT_DATABASE_NAME};\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\n\nuse super::config::global::GlobalConfig;\nuse super::predule::Executor;\n\n#[cfg(target_os = \"macos\")]\nuse crate::constants::LAUNCHD_PLIST_PATH;\n\nimpl Executor {\n    // 기본 설정파일 세팅\n    pub async fn init_config(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // 1. 루트 디렉터리 생성 (없다면)\n        self.create_top_level_directory_if_not_exists().await?;\n\n        // 2. 전역 설정파일 생성 (없다면)\n        self.create_global_config_if_not_exists().await?;\n\n        // 3. 데이터 디렉터리 생성 (없다면)\n        self.create_data_directory_if_not_exists().await?;\n\n        // 4. 데몬 설정파일 생성 (없다면)\n        self.create_daemon_config_if_not_exists().await?;\n\n        // 5. 데몬 실행\n        self.start_daemon().await?;\n\n        Ok(())\n    }\n\n    pub async fn init_database(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // 6. 기본 데이터베이스 생성 (rrdb)\n        self.create_database(\n            CreateDatabaseQuery::builder()\n                .set_name(DEFAULT_DATABASE_NAME.into())\n                .set_if_not_exists(true),\n        )\n        .await?;\n\n        Ok(())\n    }\n\n    async fn create_top_level_directory_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let base_path = DEFAULT_CONFIG_BASEPATH;\n\n        if let Err(error) = self.file_system.create_dir(base_path).await {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                println!(\"path {:?}\", base_path);\n                println!(\"error: {:?}\", error.to_string());\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn create_global_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let base_path = PathBuf::from(DEFAULT_CONFIG_BASEPATH);\n\n        let mut global_path = base_path;\n        global_path.push(DEFAULT_CONFIG_FILENAME);\n\n        let global_info = GlobalConfig::default();\n        let global_config = toml::to_string(\u0026global_info).unwrap();\n\n        if let Err(error) = self\n            .file_system\n            .write_file(\n                global_path.to_str().unwrap_or_default(),\n                global_config.as_bytes(),\n            )\n            .await\n        {\n            return Err(ExecuteError::wrap(error.to_string()));\n        }\n\n        Ok(())\n    }\n\n    async fn create_data_directory_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let data_path = self.config.data_directory.clone();\n\n        if let Err(error) = self.file_system.create_dir(\u0026data_path).await {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n\n        Ok(())\n    }\n\n    #[cfg(target_os = \"linux\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        use crate::constants::SYSTEMD_DAEMON_SCRIPT;\n\n        let base_path = PathBuf::from(\"/etc/systemd/system/rrdb.service\");\n\n        self.write_and_check_err(base_path, SYSTEMD_DAEMON_SCRIPT)\n            .await\n    }\n\n    #[cfg(target_os = \"macos\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        use crate::constants::LAUNCHD_DAEMON_SCRIPT;\n\n        let base_path = PathBuf::from(LAUNCHD_PLIST_PATH);\n\n        self.write_and_check_err(base_path, LAUNCHD_DAEMON_SCRIPT)\n            .await\n    }\n\n    #[cfg(target_os = \"windows\")]\n    async fn create_daemon_config_if_not_exists(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        Command::new(\"winget\").args([\"install\", \"--accept-package-agreements\", \"nssm\"]);\n\n        let output = Command::new(\"nssm.exe\")\n            .args([\n                \"install\",\n                \"rrdb\",\n                \"C:\\\\Program Files\\\\rrdb\\\\rrdb.exe\",\n                \"run\",\n            ])\n            .output();\n\n        self.check_output_status(output)\n    }\n\n    async fn write_and_check_err(\n        \u0026self,\n        base_path: PathBuf,\n        contents: \u0026str,\n    ) -\u003e Result\u003c(), RRDBError\u003e {\n        if let Err(error) = self\n            .file_system\n            .write_file(base_path.to_str().unwrap_or_default(), contents.as_bytes())\n            .await\n        {\n            if error.kind() != std::io::ErrorKind::AlreadyExists {\n                return Err(ExecuteError::wrap(error.to_string()));\n            }\n        }\n        Ok(())\n    }\n\n    async fn start_daemon(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        let (program, args) = self.get_daemon_start_command();\n        let output = self.command_runner.run(Command::new(program).args(args));\n\n        self.check_output_status(output)\n    }\n\n    #[cfg(target_os = \"linux\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"systemctl\", vec![\"enable\", \"--now\", \"rrdb.service\"])\n    }\n\n    #[cfg(target_os = \"macos\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"launchctl\", vec![\"load\", LAUNCHD_PLIST_PATH])\n    }\n\n    #[cfg(target_os = \"windows\")]\n    fn get_daemon_start_command(\u0026self) -\u003e (\u0026'static str, Vec\u003c\u0026'static str\u003e) {\n        (\"sc.exe\", vec![\"start\", \"rrdb\"])\n    }\n\n    fn check_output_status(\u0026self, output: Result\u003cOutput, Error\u003e) -\u003e Result\u003c(), RRDBError\u003e {\n        if output.is_err() {\n            Err(ExecuteError::wrap(\"failed to start daemon\"))\n        } else {\n            Ok(())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[cfg(target_os = \"linux\")]\n    #[tokio::test]\n    async fn test_init_config() {\n        use mockall::predicate::eq;\n\n        use crate::executor::mocking::{\n            CommandRunner, FileSystem, MockCommandRunner, MockFileSystem,\n        };\n\n        use super::*;\n        use std::sync::Arc;\n\n        const CONFIG: \u0026[u8] = br##\"port = 22208\nhost = \"0.0.0.0\"\ndata_directory = \"/var/lib/rrdb/data\"\n\"##;\n\n        use crate::constants::SYSTEMD_DAEMON_SCRIPT;\n\n        struct TestCase {\n            name: \u0026'static str,\n            want_error: bool,\n            mock_file_system: Box\u003cdyn Fn() -\u003e Arc\u003cdyn FileSystem + Send + Sync\u003e\u003e,\n            mock_command_runner: Box\u003cdyn Fn() -\u003e Arc\u003cdyn CommandRunner + Send + Sync\u003e\u003e,\n            mock_config: Box\u003cdyn Fn() -\u003e Arc\u003cGlobalConfig\u003e\u003e,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"init 정상 동작 (linux)\",\n                want_error: false,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run().returning(|_| {\n                        Ok(Output {\n                            stderr: Vec::new(),\n                            stdout: Vec::new(),\n                            status: Default::default(),\n                        })\n                    });\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"최종 Command 실행 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run()\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"데몬 설정파일 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Ok(()));\n\n                    // 4. 데몬 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(\"/etc/systemd/system/rrdb.service\"),\n                            eq(SYSTEMD_DAEMON_SCRIPT.as_bytes()),\n                        )\n                        .returning(|_, _| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mut mock = MockCommandRunner::new();\n\n                    mock.expect_run()\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"데이터 디렉터리 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Ok(()));\n\n                    // 3. 데이터 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/data\"))\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"전역 설정파일 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Ok(()));\n\n                    // 2. 전역 설정파일 생성\n                    mock.expect_write_file()\n                        .times(1)\n                        .with(\n                            eq(DEFAULT_CONFIG_BASEPATH.to_owned() + \"/\" + DEFAULT_CONFIG_FILENAME),\n                            eq(CONFIG),\n                        )\n                        .returning(|_, _| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n            TestCase {\n                name: \"최상위 디렉터리 생성 실패\",\n                want_error: true,\n                mock_config: Box::new(|| {\n                    let config = GlobalConfig::default();\n\n                    Arc::new(config)\n                }),\n                mock_file_system: Box::new(move || {\n                    let mut mock = MockFileSystem::new();\n\n                    // 1. 최상위 디렉터리 생성\n                    mock.expect_create_dir()\n                        .times(1)\n                        .with(eq(DEFAULT_CONFIG_BASEPATH))\n                        .returning(|_| Err(Error::from_raw_os_error(1)));\n\n                    Arc::new(mock)\n                }),\n                mock_command_runner: Box::new(|| {\n                    let mock = MockCommandRunner::new();\n\n                    Arc::new(mock)\n                }),\n            },\n        ];\n\n        for test_case in test_cases[..5].iter() {\n            let executor = Executor {\n                config: (test_case.mock_config)(),\n                file_system: (test_case.mock_file_system)(),\n                command_runner: (test_case.mock_command_runner)(),\n            };\n\n            let result = executor.init_config().await;\n\n            assert_eq!(\n                test_case.want_error,\n                result.is_err(),\n                \"{} - wanr_eror = {}, error = {:?}\",\n                test_case.name,\n                test_case.want_error,\n                result.err(),\n            );\n        }\n    }\n}\n","traces":[{"line":19,"address":[3607420,3607538,3607219,3607261,3608084,3607184,3607308],"length":1,"stats":{"Line":5}},{"line":21,"address":[3607281,3607254,3607570,3607862,3607335,3607480,3608037],"length":1,"stats":{"Line":2}},{"line":24,"address":[3607353,3608575,3607979,3608391,3607838,3608093],"length":1,"stats":{"Line":4}},{"line":27,"address":[3607371,3609062,3608878,3608367,3608517,3608580],"length":1,"stats":{"Line":4}},{"line":30,"address":[3609550,3607389,3609067,3608854,3609004,3609365],"length":1,"stats":{"Line":4}},{"line":33,"address":[3609341,3607407,3609491,3609845,3609555],"length":1,"stats":{"Line":3}},{"line":35,"address":[3609828],"length":1,"stats":{"Line":1}},{"line":38,"address":[3610514,3609968,3610048,3610100,3610003,3610337],"length":1,"stats":{"Line":0}},{"line":40,"address":[3611092,3610796,3610405,3610435,3611002,3610650],"length":1,"stats":{"Line":0}},{"line":41,"address":[3610262,3610093,3610330],"length":1,"stats":{"Line":0}},{"line":42,"address":[3610175,3610486,3610301,3610140,3610507],"length":1,"stats":{"Line":0}},{"line":45,"address":[3610462,3610555,3610127,3610730,3610041,3610918,3610428],"length":1,"stats":{"Line":0}},{"line":47,"address":[3611032],"length":1,"stats":{"Line":0}},{"line":50,"address":[3611465,3611139,3611181,3612511,3611306,3611104,3611258],"length":1,"stats":{"Line":5}},{"line":51,"address":[3611213],"length":1,"stats":{"Line":1}},{"line":53,"address":[3611497,3611285,3611237,3611360,3611174],"length":1,"stats":{"Line":2}},{"line":54,"address":[3611739,3611833],"length":1,"stats":{"Line":0}},{"line":55,"address":[3611898,3611985],"length":1,"stats":{"Line":0}},{"line":56,"address":[3612177,3612054],"length":1,"stats":{"Line":0}},{"line":57,"address":[3612309],"length":1,"stats":{"Line":0}},{"line":61,"address":[3612538],"length":1,"stats":{"Line":1}},{"line":64,"address":[3612680,3612742,3612623,3612785,3613696,3614308,3612576],"length":1,"stats":{"Line":5}},{"line":65,"address":[3612715],"length":1,"stats":{"Line":1}},{"line":67,"address":[3612835],"length":1,"stats":{"Line":1}},{"line":68,"address":[3612867],"length":1,"stats":{"Line":1}},{"line":70,"address":[3612946],"length":1,"stats":{"Line":1}},{"line":71,"address":[3612965,3613065],"length":1,"stats":{"Line":2}},{"line":73,"address":[3613313,3613926,3613837,3613653,3613598],"length":1,"stats":{"Line":5}},{"line":76,"address":[3613417],"length":1,"stats":{"Line":1}},{"line":77,"address":[3613536],"length":1,"stats":{"Line":1}},{"line":79,"address":[3613861,3613669,3612772,3613626,3613728,3612670],"length":1,"stats":{"Line":3}},{"line":81,"address":[3614080,3613971],"length":1,"stats":{"Line":2}},{"line":84,"address":[3614317],"length":1,"stats":{"Line":1}},{"line":87,"address":[3615618,3614447,3614596,3614924,3614553,3614501,3614400],"length":1,"stats":{"Line":5}},{"line":88,"address":[3614541,3614648],"length":1,"stats":{"Line":2}},{"line":90,"address":[3614583,3614777,3614680,3614956,3614491],"length":1,"stats":{"Line":2}},{"line":91,"address":[3615222,3615319],"length":1,"stats":{"Line":2}},{"line":92,"address":[3615384],"length":1,"stats":{"Line":1}},{"line":96,"address":[3615645],"length":1,"stats":{"Line":1}},{"line":100,"address":[3615879,3615712,3615789,3615842,3616329,3616028,3615747],"length":1,"stats":{"Line":5}},{"line":103,"address":[3615818],"length":1,"stats":{"Line":1}},{"line":105,"address":[3615928,3615981,3616154],"length":1,"stats":{"Line":3}},{"line":106,"address":[3615974,3616005,3615869,3616060,3616234,3615782],"length":1,"stats":{"Line":3}},{"line":135,"address":[5590032],"length":1,"stats":{"Line":1}},{"line":140,"address":[3617250,3617156,3616970,3616915,3616560],"length":1,"stats":{"Line":5}},{"line":142,"address":[3616718],"length":1,"stats":{"Line":1}},{"line":143,"address":[3616617,3616443,3616943,3617045,3616986,3617188],"length":1,"stats":{"Line":3}},{"line":145,"address":[3617408,3617311],"length":1,"stats":{"Line":2}},{"line":146,"address":[3617473],"length":1,"stats":{"Line":1}},{"line":149,"address":[3617781],"length":1,"stats":{"Line":1}},{"line":152,"address":[3617840,3618638,3617870,3618600,3617956],"length":1,"stats":{"Line":4}},{"line":153,"address":[3617949,3618027],"length":1,"stats":{"Line":2}},{"line":154,"address":[3618103,3618211],"length":1,"stats":{"Line":2}},{"line":156,"address":[3618426],"length":1,"stats":{"Line":1}},{"line":160,"address":[5590112],"length":1,"stats":{"Line":1}},{"line":161,"address":[5590130,5590305],"length":1,"stats":{"Line":1}},{"line":174,"address":[5590502,5590336],"length":1,"stats":{"Line":1}},{"line":175,"address":[5590500,5590432,5590414,5590369],"length":1,"stats":{"Line":4}},{"line":176,"address":[5590434,5590485],"length":1,"stats":{"Line":2}},{"line":178,"address":[5590425],"length":1,"stats":{"Line":1}}],"covered":50,"coverable":60},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","mocking.rs"],"content":"use std::process::{Command, Output};\n\nuse futures::io;\n\n#[mockall::automock]\n#[async_trait::async_trait]\npub trait FileSystem {\n    async fn create_dir(\u0026self, path: \u0026str) -\u003e io::Result\u003c()\u003e;\n    async fn write_file(\u0026self, path: \u0026str, content: \u0026[u8]) -\u003e io::Result\u003c()\u003e;\n}\n\npub struct RealFileSystem;\n\n#[async_trait::async_trait]\nimpl FileSystem for RealFileSystem {\n    async fn create_dir(\u0026self, path: \u0026str) -\u003e io::Result\u003c()\u003e {\n        tokio::fs::create_dir(path).await\n    }\n\n    async fn write_file(\u0026self, path: \u0026str, content: \u0026[u8]) -\u003e io::Result\u003c()\u003e {\n        tokio::fs::write(path, content).await\n    }\n}\n\n#[mockall::automock]\npub trait CommandRunner {\n    fn run(\u0026self, command: \u0026mut Command) -\u003e io::Result\u003cOutput\u003e;\n}\n\npub struct RealCommandRunner;\n\nimpl CommandRunner for RealCommandRunner {\n    fn run(\u0026self, command: \u0026mut Command) -\u003e io::Result\u003cOutput\u003e {\n        command.output()\n    }\n}\n","traces":[{"line":16,"address":[2083356],"length":1,"stats":{"Line":0}},{"line":17,"address":[4552518,4552300,4552646,4552361],"length":1,"stats":{"Line":0}},{"line":20,"address":[2083599],"length":1,"stats":{"Line":0}},{"line":21,"address":[4553287,4552927,4553151,4552988],"length":1,"stats":{"Line":0}},{"line":33,"address":[2081760],"length":1,"stats":{"Line":0}},{"line":34,"address":[2081795],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","mod.rs"],"content":"pub mod common;\npub mod config;\npub mod encoder;\n#[allow(clippy::module_inception)]\npub mod executor;\npub mod implements;\npub mod initializer;\npub mod mocking;\npub mod predule;\npub mod reduce;\npub mod result;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","predule.rs"],"content":"#![allow(unused_imports)]\npub use super::common::*;\npub use super::config::*;\npub use super::encoder::*;\npub use super::executor::*;\npub use super::implements::*;\npub use super::reduce::*;\npub use super::result::*;\npub use super::util::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","reduce.rs"],"content":"\n\nuse std::collections::HashMap;\n\nuse futures::future::join_all;\nuse itertools::Itertools;\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::types::{ AggregateFunction, BuiltInFunction, Column, Function, SQLExpression, TableName};\nuse crate::errors::predule::{TypeError, ExecuteError};\nuse crate::errors::RRDBError;\nuse crate::executor::predule::{ Executor, ExecuteColumnType};\n\nuse super::config::row::{TableDataFieldType, TableDataRow};\n\n#[derive(Debug, Default, Clone)]\npub struct ReduceContext {\n    pub table_alias_map: HashMap\u003cString, TableName\u003e,\n    pub row: Option\u003cTableDataRow\u003e,\n    pub config_columns: Vec\u003c(TableName, Column)\u003e,\n    pub total_count: usize,\n}\n\nimpl Executor {\n    pub async fn reduce_expression(\n        \u0026self,\n        expression: SQLExpression,\n        context: ReduceContext\n    ) -\u003e Result\u003cTableDataFieldType, RRDBError\u003e {\n        match expression {\n            SQLExpression::Integer(value) =\u003e Ok(TableDataFieldType::Integer(value)),\n            SQLExpression::Boolean(value) =\u003e Ok(TableDataFieldType::Boolean(value)),\n            SQLExpression::Float(value) =\u003e Ok(TableDataFieldType::Float(value.into())),\n            SQLExpression::String(value) =\u003e Ok(TableDataFieldType::String(value)),\n            SQLExpression::Null =\u003e Ok(TableDataFieldType::Null),\n            SQLExpression::List(list) =\u003e  {\n                let futures = list.value.into_iter().map(|e|{self.reduce_expression(e, context.clone())});\n                let fields = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, \n                _\u003e\u003e()?;\n\n                #[allow(unstable_name_collisions)]\n                let serialized: String = fields.into_iter().map(|e|e.to_string()).intersperse(\", \".to_owned()).collect();\n\n                Ok(TableDataFieldType::String(format!(\"({})\", serialized)))\n            }\n            SQLExpression::Unary(unary) =\u003e match unary.operator {\n                UnaryOperator::Neg =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Integer(value) =\u003e {\n                            Ok(TableDataFieldType::Integer(-value))\n                        }\n                        TableDataFieldType::Float(value) =\u003e {\n                            Ok(TableDataFieldType::Float(-value))\n                        }\n                        TableDataFieldType::Array(mut array) =\u003e {\n                            for e in \u0026mut array {\n                                match e {\n                                    TableDataFieldType::Integer(value) =\u003e {\n                                        *e = TableDataFieldType::Integer(-*value);\n                                    }\n                                    TableDataFieldType::Float(value) =\u003e {\n                                        *e = TableDataFieldType::Float(-*value);\n                                    }\n                                    _ =\u003e return  Err(TypeError::wrap(\n                                        \"unary '!' operator is valid only for integer and float types.\",\n                                    )),\n                                }\n                            }\n                            Ok(TableDataFieldType::Array(array))\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '-' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n                UnaryOperator::Pos =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Integer(_) =\u003e Ok(operand),\n                        TableDataFieldType::Float(_) =\u003e Ok(operand),\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '+' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n                UnaryOperator::Not =\u003e {\n                    let operand = Box::pin(self.reduce_expression(unary.operand, context)).await?;\n\n                    match operand {\n                        TableDataFieldType::Boolean(value) =\u003e {\n                            Ok(TableDataFieldType::Boolean(!value))\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"unary '!' operator is valid only for integer and float types.\",\n                        )),\n                    }\n                }\n            },\n            SQLExpression::Binary(binary) =\u003e {\n                let lhs = Box::pin(self.reduce_expression(binary.lhs.clone(), context.clone())).await?;\n                let rhs = Box::pin(self.reduce_expression(binary.rhs.clone(), context.clone())).await?;\n\n                if lhs.type_code() != rhs.type_code() {\n                    return Err(TypeError::wrap(\n                        \"The types of lhs and rhs do not match.\",\n                    ));\n                }\n\n                if let TableDataFieldType::Array(ref left_array) = lhs {\n                    if let TableDataFieldType::Array(ref right_array) = rhs{\n                        let futures = (0..left_array.len()).map(|i|\n                           {\n                            let binary = binary.clone(); \n                            let context = context.clone(); \n                       \n                            async move {\n                                let expression = BinaryOperatorExpression {\n                                    operator: binary.operator.clone(),\n                                    lhs: left_array[i].clone().into(), \n                                    rhs: right_array[i].clone().into(),\n                                };\n                            \n                                match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                                    Ok(expression)=\u003e Ok(expression), \n                                    Err(error)=\u003eErr(error),\n                                }\n                            }\n                        });\n    \n                        let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                        return Ok(TableDataFieldType::Array(result));\n                    } else {\n                        let futures = left_array.iter().map(|e|async {\n                            let expression = BinaryOperatorExpression {\n                                operator: binary.operator.clone(),\n                                lhs: e.clone().into(), \n                                rhs: rhs.clone().into(),\n                            };\n                        \n                            match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                                Ok(expression)=\u003e Ok(expression), \n                                Err(error)=\u003eErr(error),\n                            }\n                        });\n\n                        let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                        return Ok(TableDataFieldType::Array(result));\n                    }\n                } else if let TableDataFieldType::Array(ref right_array) = rhs{\n                    let futures = right_array.iter().map(|e|async {\n                        let expression = BinaryOperatorExpression {\n                            operator: binary.operator.clone(),\n                            lhs: lhs.clone().into(), \n                            rhs: e.clone().into(),\n                        };\n                    \n                        match Box::pin(self.reduce_expression(expression.into(), context.clone())).await {\n                            Ok(expression)=\u003e Ok(expression), \n                            Err(error)=\u003eErr(error),\n                        }\n                    });\n\n                    let result = Box::pin(join_all(futures)).await.into_iter().collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n                    return Ok(TableDataFieldType::Array(result));\n                }\n\n                match binary.operator {\n                    BinaryOperator::Add =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::String(\n                                    lhs_value + rhs_value.as_str(),\n                                ));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '-' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Sub =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value -rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value + rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '-' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::Mul =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value *rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value * rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '*' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::Div =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Integer(lhs_value / rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Float(lhs_value / rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '/' operator is valid only for integer and float types.\",\n                        )),\n                    },\n                    BinaryOperator::And =\u003e match lhs {\n                        TableDataFieldType::Boolean(lhs_value) =\u003e {\n                            if let TableDataFieldType::Boolean(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u0026\u0026 rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary 'And' operator is valid only for boolean type.\",\n                        )),\n                    },\n                    BinaryOperator::Or =\u003e match lhs {\n                        TableDataFieldType::Boolean(lhs_value) =\u003e {\n                            if let TableDataFieldType::Boolean(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value || rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary 'Or' operator is valid only for boolean type.\",\n                        )),\n                    },\n                    BinaryOperator::Lt =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003c' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Gt =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003e' operator is valid only for integer and float and string types.\",\n                        )),\n                    }, \n                    BinaryOperator::Lte =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003c= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003c=' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Gte =\u003e match lhs {\n                        TableDataFieldType::Integer(lhs_value) =\u003e {\n                            if let TableDataFieldType::Integer(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::Float(lhs_value) =\u003e {\n                            if let TableDataFieldType::Float(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        TableDataFieldType::String(lhs_value) =\u003e {\n                            if let TableDataFieldType::String(rhs_value) = rhs {\n                                return Ok(TableDataFieldType::Boolean(lhs_value \u003e= rhs_value));\n                            }\n                            unreachable!()\n                        }\n                        _ =\u003e Err(TypeError::wrap(\n                            \"binary '\u003e=' operator is valid only for integer and float and string types.\",\n                        )),\n                    },\n                    BinaryOperator::Eq =\u003e\n                         Ok(TableDataFieldType::Boolean(lhs == rhs)),    \n                    BinaryOperator::Neq =\u003e\n                         Ok(TableDataFieldType::Boolean(lhs != rhs)),    \n                    BinaryOperator::Like =\u003e unimplemented!(\"미구현\"),   \n                    BinaryOperator::NotLike =\u003e unimplemented!(\"미구현\"),  \n                    BinaryOperator::In =\u003e unimplemented!(\"미구현\"),      \n                    BinaryOperator::NotIn =\u003e unimplemented!(\"미구현\"),  \n                    BinaryOperator::Is =\u003e unimplemented!(\"미구현\"),      \n                    BinaryOperator::IsNot =\u003e unimplemented!(\"미구현\"),  \n                }\n            }\n            SQLExpression::Between(between) =\u003e {\n                let _a =  Box::pin(self.reduce_expression(between.a, context.clone())).await?;\n                let _x =  Box::pin(self.reduce_expression(between.x, context.clone())).await?;\n                let _y =  Box::pin(self.reduce_expression(between.y, context)).await?;\n           \n                //Ok(TableDataFieldType::Boolean(x \u003c= a \u0026\u0026 a \u003c= y ))\n\n                unimplemented!(\"미구현\")\n            },\n            SQLExpression::NotBetween(_between) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::Parentheses(paren) =\u003e {\n                Box::pin(self.reduce_expression(paren.expression, context)).await\n            }\n            SQLExpression::FunctionCall(call) =\u003e {\n                match call.function {\n                    Function::BuiltIn(builtin)=\u003e{\n                        match builtin {\n                            BuiltInFunction::Aggregate(aggregate)=\u003e{\n                                match aggregate {\n                                    AggregateFunction::Count =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Count function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        let argument = call.arguments[0].clone();\n                                        let value = Box::pin(self.reduce_expression(argument, context.clone())).await?;\n\n                                        match value {\n                                            TableDataFieldType::Array(array) =\u003e {\n                                                \n                                                let value = array.into_iter().filter(|e|{\n                                                    #[allow(clippy::match_like_matches_macro)]\n                                                    match e {\n                                                        TableDataFieldType::Null =\u003e {\n                                                            false\n                                                        }, \n                                                        _ =\u003e true,\n                                                    }\n                                                }).count();\n\n                                                Ok(TableDataFieldType::Integer(value as i64))\n                                            }\n                                            TableDataFieldType::Null=\u003e {\n                                                Ok(TableDataFieldType::Integer(0))\n                                            }\n                                            _ =\u003e {\n                                                match context.row {\n                                                    Some(row) =\u003e {\n                                                        if let TableDataFieldType::Array(array) = \u0026row.fields[0].data {\n                                                            Ok(TableDataFieldType::Integer(array.len() as i64))\n                                                        }\n                                                        else {\n                                                            Ok(TableDataFieldType::Integer(0))\n                                                        }\n                                                    }\n                                                    None=\u003e {\n                                                        Ok(TableDataFieldType::Integer(0))\n                                                    }\n                                                }\n                                                \n                                            }\n                                        }\n                                    }\n                                    AggregateFunction::Sum =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Sum function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        let argument = call.arguments[0].clone();\n                                        let value = Box::pin(self.reduce_expression(argument, context.clone())).await?;\n\n                                        match value {\n                                            TableDataFieldType::Array(array) =\u003e {\n                                                let value = array.into_iter().fold(TableDataFieldType::Null, |acc, e|{\n                                                    match e {\n                                                        TableDataFieldType::Integer(integer) =\u003e {\n                                                            if let TableDataFieldType::Integer(acc_value) = acc  {\n                                                                TableDataFieldType::Integer(acc_value + integer)\n                                                            } else {\n                                                                TableDataFieldType::Integer(integer)\n                                                            }\n                                                        }, \n                                                        TableDataFieldType::Float(integer) =\u003e {\n                                                            if let TableDataFieldType::Float(acc_value) = acc  {\n                                                                TableDataFieldType::Float(acc_value + integer)\n                                                            } else {\n                                                                TableDataFieldType::Float(integer)\n                                                            }\n                                                        }, \n                                                        _ =\u003e acc,\n                                                    }\n                                                });\n\n                                                Ok(value)\n                                            }\n                                            _ =\u003e {\n                                                unimplemented!(\"미구현\");\n                                            }\n                                        } \n                                    }\n                                    AggregateFunction::Max =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Max function takes only one parameter.\",\n                                            ));\n                                        }\n\n                                        unimplemented!(\"미구현\");\n                                    }\n                                    AggregateFunction::Min =\u003e {\n                                        if call.arguments.len() != 1 {\n                                            return Err(ExecuteError::wrap(\n                                                \"Min function takes only one parameter.\",\n                                            ));\n                                        }\n                                        \n                                        unimplemented!(\"미구현\");\n                                    }\n                                    _ =\u003e unimplemented!(\"미구현\")\n                                }\n                            }\n                            BuiltInFunction::Conditional(_)=\u003e{\n                                unimplemented!(\"미구현\")\n                            }\n                        }\n                    }\n                    Function::UserDefined(_)=\u003eunimplemented!(\"미구현\"),\n                }\n            },\n            SQLExpression::Subquery(_) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::SelectColumn(select_column) =\u003e {\n                let column_name  = select_column.column_name.clone();\n\n                match context.row {\n                    Some(ref row) =\u003e {\n                        let same_name_datas = row.fields.iter().filter(|e|e.column_name == column_name).cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n                        // 없으면 오류\n                        if same_name_datas.is_empty() {\n                            return Err(ExecuteError::wrap(\n                                format!(\"1 column select '{:?}' not exists\", select_column),\n                            ));\n                        }\n\n                        // 테이블명 선택한게 있으면 \n                        match select_column.table_name {\n                            Some(ref table_name)=\u003e {\n                                \n                                if let Some(found) = same_name_datas.iter().find(|e|{\n                            \n                                    // alias가 있으면\n                                    if let Some(table_name) = context.table_alias_map.get(table_name) {\n                                        *table_name == e.table_name\n                                    }\n                                    // 없으면 자체 테이블명 비교\n                                    else {\n                                        table_name == \u0026e.table_name.table_name\n                                    }\n                                }) \n                                {\n                                    Ok(found.data.to_owned())\n                                } else{\n                                    Err(ExecuteError::wrap(\n                                        format!(\"column select '{:?}' is ambiguous\", select_column),\n                                    ))\n                                }\n                            }\n                            None=\u003e{\n                                if same_name_datas.len()\u003e=2 {\n                                     Err(ExecuteError::wrap(\n                                        format!(\"column select '{:?}' is ambiguous\", select_column),\n                                    ))\n                                } else {\n                                    Ok(same_name_datas[0].data.to_owned())\n                                }\n                            }\n                        }\n                    }\n                    None =\u003e {\n                        Err(ExecuteError::wrap(\n                            format!(\"column select '{:?}' not exists\", select_column),\n                        ))\n                    }\n                }\n                \n            },\n        }\n    }\n\n    #[allow(clippy::only_used_in_recursion)]\n    pub fn reduce_type(\n        \u0026self,\n        expression: SQLExpression,\n        context: ReduceContext\n    ) -\u003e Result\u003cExecuteColumnType, RRDBError\u003e {\n        match expression {\n            SQLExpression::Integer(_) =\u003e Ok(ExecuteColumnType::Integer),\n            SQLExpression::Boolean(_) =\u003e Ok(ExecuteColumnType::Bool),\n            SQLExpression::Float(_) =\u003e Ok(ExecuteColumnType::Float),\n            SQLExpression::String(_) =\u003e Ok(ExecuteColumnType::String),\n            SQLExpression::Null =\u003e Ok(ExecuteColumnType::Null),\n            SQLExpression::List(_list) =\u003e  {\n                unimplemented!()\n            }\n            SQLExpression::Unary(unary) =\u003e match unary.operator {\n                UnaryOperator::Neg | UnaryOperator::Pos | UnaryOperator::Not =\u003e {\n                    self.reduce_type(unary.operand, context)\n                }\n            },\n            SQLExpression::Binary(binary) =\u003e {\n                let lhs = self.reduce_type(binary.lhs, context.clone())?;\n                let rhs = self.reduce_type(binary.rhs, context)?;\n\n                match binary.operator {\n                    BinaryOperator::Add | BinaryOperator::Sub | BinaryOperator::Mul | BinaryOperator::Div =\u003e {\n                        if let ExecuteColumnType::Null = lhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n        \n                        if let ExecuteColumnType::Null = rhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n\n                        Ok(lhs)\n                    },\n                    BinaryOperator::And | BinaryOperator::Or | BinaryOperator::Lt | BinaryOperator::Gt | BinaryOperator::Lte | BinaryOperator::Gte |  BinaryOperator::Eq | BinaryOperator::Neq | BinaryOperator::Like | BinaryOperator::NotLike | BinaryOperator::In | BinaryOperator::NotIn =\u003e {\n                        if let ExecuteColumnType::Null = lhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n        \n                        if let ExecuteColumnType::Null = rhs {\n                            return Ok(ExecuteColumnType::Null);\n                        }\n\n                        Ok(ExecuteColumnType::Bool)\n                    },   \n                    BinaryOperator::Is | BinaryOperator::IsNot =\u003e {\n                        Ok(ExecuteColumnType::Bool)\n                    }\n                }\n            }\n            SQLExpression::Between(_) =\u003e {\n                Ok(ExecuteColumnType::Bool)\n            },\n            SQLExpression::NotBetween(_between) =\u003e Ok(ExecuteColumnType::Bool),\n            SQLExpression::Parentheses(paren) =\u003e {\n                 self.reduce_type(paren.expression, context)\n            }\n            SQLExpression::FunctionCall(call) =\u003e match call.function {\n                Function::BuiltIn(builtin) =\u003e {\n                    match builtin  {\n                        BuiltInFunction::Aggregate(aggregate)=\u003e {\n                            match aggregate {\n                                AggregateFunction::Sum =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Count =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Max =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                AggregateFunction::Min =\u003e {\n                                    Ok(ExecuteColumnType::Integer)\n                                }\n                                _ =\u003e unimplemented!(\"미구현\"),\n                            }\n                        }\n                        BuiltInFunction::Conditional(_)=\u003eunimplemented!(\"미구현\"),\n                    }\n                }\n                Function::UserDefined(_)=\u003e{\n                    unimplemented!(\"미구현\")\n                }\n            },\n            SQLExpression::Subquery(_) =\u003e unimplemented!(\"미구현\"),\n            SQLExpression::SelectColumn(select_column) =\u003e {\n                let column_name  = select_column.column_name.clone();\n                \n                if context.config_columns.is_empty() {\n                    return Err(ExecuteError::wrap(\n                        format!(\"column select '{:?}' not exists\", select_column),\n                    ));\n                }\n\n                let same_name_columns = context.config_columns.iter().filter(|(_, e)|e.name == column_name).cloned().collect::\u003cVec\u003c_\u003e\u003e();\n\n                // 테이블명 선택한게 있으면 \n                match select_column.table_name {\n                    Some(ref table_name)=\u003e {\n                        \n                        if let Some(found) = context.config_columns.iter().find(|(each_table_name, _)|{\n                    \n                            // alias가 있으면\n                            if let Some(table_name) = context.table_alias_map.get(table_name) {\n                                table_name == each_table_name\n                            }\n                            // 없으면 자체 테이블명 비교\n                            else {\n                                table_name == \u0026each_table_name.table_name\n                            }\n                        }) \n                        {\n                            Ok(found.1.data_type.to_owned().into())\n                        } else{\n                             Err(ExecuteError::wrap(\n                                format!(\"column select '{:?}' is ambiguous\", select_column),\n                            ))\n                        }\n                    }\n                    None=\u003e{\n                        if same_name_columns.len()\u003e=2 {\n                             Err(ExecuteError::wrap(\n                                format!(\"column select '{:?}' is ambiguous\", select_column),\n                            ))\n                        } else {\n                            Ok(same_name_columns[0].1.data_type.to_owned().into())\n                        }\n                    }\n                }\n            },\n        }\n    }\n}\n","traces":[{"line":26,"address":[5590528],"length":1,"stats":{"Line":0}},{"line":31,"address":[4011065,4011539],"length":1,"stats":{"Line":0}},{"line":32,"address":[4012459],"length":1,"stats":{"Line":0}},{"line":33,"address":[4012630],"length":1,"stats":{"Line":0}},{"line":34,"address":[4019310,4012579],"length":1,"stats":{"Line":0}},{"line":35,"address":[4012754],"length":1,"stats":{"Line":0}},{"line":36,"address":[4013123],"length":1,"stats":{"Line":0}},{"line":37,"address":[4012944],"length":1,"stats":{"Line":0}},{"line":38,"address":[4019408,4012982,4049616,4049641],"length":1,"stats":{"Line":0}},{"line":39,"address":[4019728,4011645,4022348,4021818,4019500],"length":1,"stats":{"Line":0}},{"line":43,"address":[4022432,4022976,4049856,4022202,4022955,4049884,4022381],"length":1,"stats":{"Line":0}},{"line":45,"address":[4022766],"length":1,"stats":{"Line":0}},{"line":47,"address":[4011952],"length":1,"stats":{"Line":0}},{"line":49,"address":[4023458,4013277,4014010,4023014,4025257,4011666,4014508],"length":1,"stats":{"Line":0}},{"line":51,"address":[4023391],"length":1,"stats":{"Line":0}},{"line":52,"address":[4023601],"length":1,"stats":{"Line":0}},{"line":53,"address":[4023765,4023864,4023625],"length":1,"stats":{"Line":0}},{"line":55,"address":[4023646],"length":1,"stats":{"Line":0}},{"line":56,"address":[4023962,4023664],"length":1,"stats":{"Line":0}},{"line":58,"address":[4023683],"length":1,"stats":{"Line":0}},{"line":59,"address":[4024113,4024386,4023731],"length":1,"stats":{"Line":0}},{"line":60,"address":[4024410],"length":1,"stats":{"Line":0}},{"line":61,"address":[4024482],"length":1,"stats":{"Line":0}},{"line":62,"address":[4024589,4024497],"length":1,"stats":{"Line":0}},{"line":64,"address":[4024534],"length":1,"stats":{"Line":0}},{"line":65,"address":[4024795,4024549],"length":1,"stats":{"Line":0}},{"line":67,"address":[4024444,4024961],"length":1,"stats":{"Line":0}},{"line":72,"address":[4024201],"length":1,"stats":{"Line":0}},{"line":74,"address":[4023571,4025098],"length":1,"stats":{"Line":0}},{"line":80,"address":[4025287,4013212,4025707,4013921,4011687,4013423],"length":1,"stats":{"Line":0}},{"line":82,"address":[4025660],"length":1,"stats":{"Line":0}},{"line":83,"address":[4025850],"length":1,"stats":{"Line":0}},{"line":84,"address":[4026003],"length":1,"stats":{"Line":0}},{"line":85,"address":[4026203,4025820],"length":1,"stats":{"Line":0}},{"line":91,"address":[4011708,4014597,4026724,4027071,4013342,4015107,4026272],"length":1,"stats":{"Line":0}},{"line":93,"address":[4026705],"length":1,"stats":{"Line":0}},{"line":94,"address":[4026837],"length":1,"stats":{"Line":0}},{"line":95,"address":[4026856],"length":1,"stats":{"Line":0}},{"line":97,"address":[4026953,4027038],"length":1,"stats":{"Line":0}},{"line":103,"address":[4012037],"length":1,"stats":{"Line":0}},{"line":104,"address":[4011729,4015180,4027086,4027528,4012059,4028147,4015593,4015674,4015215],"length":1,"stats":{"Line":0}},{"line":105,"address":[4028608,4011750,4027476,4027641,4028189,4027676,4028137,4028059,4039351],"length":1,"stats":{"Line":0}},{"line":107,"address":[4028575,4028872],"length":1,"stats":{"Line":0}},{"line":108,"address":[4028946,4039320],"length":1,"stats":{"Line":0}},{"line":113,"address":[4028923,4028976],"length":1,"stats":{"Line":0}},{"line":114,"address":[4029063,4029010],"length":1,"stats":{"Line":0}},{"line":115,"address":[4029167,4029088,4049968,4050189],"length":1,"stats":{"Line":0}},{"line":117,"address":[4050011],"length":1,"stats":{"Line":0}},{"line":118,"address":[4050029],"length":1,"stats":{"Line":0}},{"line":120,"address":[4050224,4050097,4051232,4050259,4050304,4050347,4051793],"length":1,"stats":{"Line":0}},{"line":121,"address":[4050312,4050662],"length":1,"stats":{"Line":0}},{"line":122,"address":[4050320],"length":1,"stats":{"Line":0}},{"line":123,"address":[4050448],"length":1,"stats":{"Line":0}},{"line":124,"address":[4050533,4050621],"length":1,"stats":{"Line":0}},{"line":127,"address":[4051222,4050374,4051273,4050826,4050905,4051159,4050297],"length":1,"stats":{"Line":0}},{"line":128,"address":[4051537],"length":1,"stats":{"Line":0}},{"line":129,"address":[4051679],"length":1,"stats":{"Line":0}},{"line":134,"address":[4029304,4039398,4039895,4029465,4011771],"length":1,"stats":{"Line":0}},{"line":135,"address":[4039758],"length":1,"stats":{"Line":0}},{"line":137,"address":[4052899,4052080,4029554,4052120,4051968,4051904,4052003,4052045,4051923,4029118],"length":1,"stats":{"Line":0}},{"line":138,"address":[4052336,4052053],"length":1,"stats":{"Line":0}},{"line":139,"address":[4052061],"length":1,"stats":{"Line":0}},{"line":140,"address":[4052184],"length":1,"stats":{"Line":0}},{"line":141,"address":[4052238,4052302],"length":1,"stats":{"Line":0}},{"line":144,"address":[4052940,4052573,4052889,4052831,4052107,4052497,4052038],"length":1,"stats":{"Line":0}},{"line":145,"address":[4053195],"length":1,"stats":{"Line":0}},{"line":146,"address":[4053337],"length":1,"stats":{"Line":0}},{"line":150,"address":[4029709,4029870,4040010,4011792,4040507],"length":1,"stats":{"Line":0}},{"line":151,"address":[4040370],"length":1,"stats":{"Line":0}},{"line":153,"address":[4029033,4029943],"length":1,"stats":{"Line":0}},{"line":154,"address":[4053520,4053597,4053555,4054451,4053632,4053672,4029966,4053466,4030059,4053440],"length":1,"stats":{"Line":0}},{"line":155,"address":[4053605,4053888],"length":1,"stats":{"Line":0}},{"line":156,"address":[4053613],"length":1,"stats":{"Line":0}},{"line":157,"address":[4053736],"length":1,"stats":{"Line":0}},{"line":158,"address":[4053854,4053790],"length":1,"stats":{"Line":0}},{"line":161,"address":[4054049,4054441,4053659,4054383,4054125,4054492,4053590],"length":1,"stats":{"Line":0}},{"line":162,"address":[4054747],"length":1,"stats":{"Line":0}},{"line":163,"address":[4054889],"length":1,"stats":{"Line":0}},{"line":167,"address":[4041119,4030214,4030375,4011813,4040622],"length":1,"stats":{"Line":0}},{"line":168,"address":[4040982],"length":1,"stats":{"Line":0}},{"line":171,"address":[4029989],"length":1,"stats":{"Line":0}},{"line":172,"address":[4030448],"length":1,"stats":{"Line":0}},{"line":173,"address":[4031208],"length":1,"stats":{"Line":0}},{"line":174,"address":[4031239,4031447],"length":1,"stats":{"Line":0}},{"line":175,"address":[4031533,4031627,4031470],"length":1,"stats":{"Line":0}},{"line":179,"address":[4031269],"length":1,"stats":{"Line":0}},{"line":180,"address":[4031303,4031687],"length":1,"stats":{"Line":0}},{"line":181,"address":[4031712,4031770],"length":1,"stats":{"Line":0}},{"line":185,"address":[4031333],"length":1,"stats":{"Line":0}},{"line":186,"address":[4031868,4031409],"length":1,"stats":{"Line":0}},{"line":187,"address":[4032129],"length":1,"stats":{"Line":0}},{"line":188,"address":[4032033,4032306,4032279,4031921],"length":1,"stats":{"Line":0}},{"line":193,"address":[4031178,4032357],"length":1,"stats":{"Line":0}},{"line":197,"address":[4030525],"length":1,"stats":{"Line":0}},{"line":198,"address":[4032438],"length":1,"stats":{"Line":0}},{"line":199,"address":[4032564,4032469],"length":1,"stats":{"Line":0}},{"line":200,"address":[4032587,4032747,4032650],"length":1,"stats":{"Line":0}},{"line":204,"address":[4032492],"length":1,"stats":{"Line":0}},{"line":205,"address":[4032526,4032777],"length":1,"stats":{"Line":0}},{"line":206,"address":[4032802,4032860],"length":1,"stats":{"Line":0}},{"line":210,"address":[4032408,4032958],"length":1,"stats":{"Line":0}},{"line":214,"address":[4030582],"length":1,"stats":{"Line":0}},{"line":215,"address":[4033019],"length":1,"stats":{"Line":0}},{"line":216,"address":[4033145,4033050],"length":1,"stats":{"Line":0}},{"line":217,"address":[4033168,4033232,4033329],"length":1,"stats":{"Line":0}},{"line":221,"address":[4033073],"length":1,"stats":{"Line":0}},{"line":222,"address":[4033359,4033107],"length":1,"stats":{"Line":0}},{"line":223,"address":[4033384,4033442],"length":1,"stats":{"Line":0}},{"line":227,"address":[4032989,4033540],"length":1,"stats":{"Line":0}},{"line":231,"address":[4030639],"length":1,"stats":{"Line":0}},{"line":232,"address":[4033601],"length":1,"stats":{"Line":0}},{"line":233,"address":[4033632,4033719],"length":1,"stats":{"Line":0}},{"line":234,"address":[4033750,4033981,4033807],"length":1,"stats":{"Line":0}},{"line":238,"address":[4033655],"length":1,"stats":{"Line":0}},{"line":239,"address":[4033689,4034011],"length":1,"stats":{"Line":0}},{"line":240,"address":[4034036,4034094],"length":1,"stats":{"Line":0}},{"line":244,"address":[4034192,4033571],"length":1,"stats":{"Line":0}},{"line":248,"address":[4030696],"length":1,"stats":{"Line":0}},{"line":249,"address":[4034223],"length":1,"stats":{"Line":0}},{"line":250,"address":[4034253,4034313],"length":1,"stats":{"Line":0}},{"line":251,"address":[4034383,4034344],"length":1,"stats":{"Line":0}},{"line":255,"address":[4034276,4034514],"length":1,"stats":{"Line":0}},{"line":259,"address":[4030726],"length":1,"stats":{"Line":0}},{"line":260,"address":[4034545],"length":1,"stats":{"Line":0}},{"line":261,"address":[4034575,4034635],"length":1,"stats":{"Line":0}},{"line":262,"address":[4034666,4034712],"length":1,"stats":{"Line":0}},{"line":266,"address":[4034598,4034836],"length":1,"stats":{"Line":0}},{"line":270,"address":[4030756],"length":1,"stats":{"Line":0}},{"line":271,"address":[4034897],"length":1,"stats":{"Line":0}},{"line":272,"address":[4034928,4035119],"length":1,"stats":{"Line":0}},{"line":273,"address":[4035142],"length":1,"stats":{"Line":0}},{"line":277,"address":[4034958],"length":1,"stats":{"Line":0}},{"line":278,"address":[4034983,4035279],"length":1,"stats":{"Line":0}},{"line":279,"address":[4035320,4035374],"length":1,"stats":{"Line":0}},{"line":283,"address":[4035013],"length":1,"stats":{"Line":0}},{"line":284,"address":[4035081,4035472],"length":1,"stats":{"Line":0}},{"line":285,"address":[4035541,4035636],"length":1,"stats":{"Line":0}},{"line":289,"address":[4034867,4035782],"length":1,"stats":{"Line":0}},{"line":293,"address":[4030833],"length":1,"stats":{"Line":0}},{"line":294,"address":[4035843],"length":1,"stats":{"Line":0}},{"line":295,"address":[4036065,4035874],"length":1,"stats":{"Line":0}},{"line":296,"address":[4036088],"length":1,"stats":{"Line":0}},{"line":300,"address":[4035904],"length":1,"stats":{"Line":0}},{"line":301,"address":[4035929,4036225],"length":1,"stats":{"Line":0}},{"line":302,"address":[4036266,4036320],"length":1,"stats":{"Line":0}},{"line":306,"address":[4035959],"length":1,"stats":{"Line":0}},{"line":307,"address":[4036418,4036027],"length":1,"stats":{"Line":0}},{"line":308,"address":[4036487,4036582],"length":1,"stats":{"Line":0}},{"line":312,"address":[4035813,4036728],"length":1,"stats":{"Line":0}},{"line":316,"address":[4030910],"length":1,"stats":{"Line":0}},{"line":317,"address":[4036789],"length":1,"stats":{"Line":0}},{"line":318,"address":[4037011,4036820],"length":1,"stats":{"Line":0}},{"line":319,"address":[4037034],"length":1,"stats":{"Line":0}},{"line":323,"address":[4036850],"length":1,"stats":{"Line":0}},{"line":324,"address":[4036875,4037171],"length":1,"stats":{"Line":0}},{"line":325,"address":[4037266,4037212],"length":1,"stats":{"Line":0}},{"line":329,"address":[4036905],"length":1,"stats":{"Line":0}},{"line":330,"address":[4036973,4037364],"length":1,"stats":{"Line":0}},{"line":331,"address":[4037532,4037417],"length":1,"stats":{"Line":0}},{"line":335,"address":[4036759,4037678],"length":1,"stats":{"Line":0}},{"line":339,"address":[4030987],"length":1,"stats":{"Line":0}},{"line":340,"address":[4037739],"length":1,"stats":{"Line":0}},{"line":341,"address":[4037770,4037961],"length":1,"stats":{"Line":0}},{"line":342,"address":[4037984],"length":1,"stats":{"Line":0}},{"line":346,"address":[4037800],"length":1,"stats":{"Line":0}},{"line":347,"address":[4037825,4038121],"length":1,"stats":{"Line":0}},{"line":348,"address":[4038162,4038216],"length":1,"stats":{"Line":0}},{"line":352,"address":[4037855],"length":1,"stats":{"Line":0}},{"line":353,"address":[4037923,4038314],"length":1,"stats":{"Line":0}},{"line":354,"address":[4038383,4038478],"length":1,"stats":{"Line":0}},{"line":358,"address":[4037709,4038624],"length":1,"stats":{"Line":0}},{"line":363,"address":[4038662,4031064],"length":1,"stats":{"Line":0}},{"line":365,"address":[4038767,4031106],"length":1,"stats":{"Line":0}},{"line":374,"address":[4012107],"length":1,"stats":{"Line":0}},{"line":375,"address":[4011834,4012167,4016221,4015701,4042059,4042725,4016148,4016242,4041538],"length":1,"stats":{"Line":0}},{"line":376,"address":[4042630,4042180,4042697,4043257,4043931,4041975,4011855,4042753,4042718],"length":1,"stats":{"Line":0}},{"line":377,"address":[4044393,4043380,4043958,4043870,4043187,4011876],"length":1,"stats":{"Line":0}},{"line":384,"address":[4012268],"length":1,"stats":{"Line":0}},{"line":385,"address":[4016900,4045049,4011897,4016390,4012298],"length":1,"stats":{"Line":0}},{"line":387,"address":[4012363],"length":1,"stats":{"Line":0}},{"line":388,"address":[4012403],"length":1,"stats":{"Line":0}},{"line":389,"address":[4016973],"length":1,"stats":{"Line":0}},{"line":390,"address":[4017010],"length":1,"stats":{"Line":0}},{"line":391,"address":[4017035],"length":1,"stats":{"Line":0}},{"line":392,"address":[4017049],"length":1,"stats":{"Line":0}},{"line":394,"address":[4018035,4017138],"length":1,"stats":{"Line":0}},{"line":395,"address":[4018693,4018082],"length":1,"stats":{"Line":0}},{"line":400,"address":[4018041,4018128],"length":1,"stats":{"Line":0}},{"line":401,"address":[4011918,4018592,4018135,4045417,4018686,4045832,4018665],"length":1,"stats":{"Line":0}},{"line":403,"address":[4045790],"length":1,"stats":{"Line":0}},{"line":404,"address":[4045996],"length":1,"stats":{"Line":0}},{"line":406,"address":[4046052,4046224,4054992],"length":1,"stats":{"Line":0}},{"line":408,"address":[4055002],"length":1,"stats":{"Line":0}},{"line":414,"address":[4055012],"length":1,"stats":{"Line":0}},{"line":416,"address":[4046264],"length":1,"stats":{"Line":0}},{"line":419,"address":[4046062],"length":1,"stats":{"Line":0}},{"line":422,"address":[4045945],"length":1,"stats":{"Line":0}},{"line":423,"address":[4046477],"length":1,"stats":{"Line":0}},{"line":424,"address":[4046606,4046530,4046753],"length":1,"stats":{"Line":0}},{"line":425,"address":[4046760,4046645],"length":1,"stats":{"Line":0}},{"line":428,"address":[4046657],"length":1,"stats":{"Line":0}},{"line":432,"address":[4046379],"length":1,"stats":{"Line":0}},{"line":440,"address":[4017105,4017318],"length":1,"stats":{"Line":0}},{"line":441,"address":[4017365,4017976],"length":1,"stats":{"Line":0}},{"line":446,"address":[4017411,4017324],"length":1,"stats":{"Line":0}},{"line":447,"address":[4017948,4011939,4017875,4047011,4047471,4017969,4017418],"length":1,"stats":{"Line":0}},{"line":449,"address":[4047452],"length":1,"stats":{"Line":0}},{"line":450,"address":[4047584],"length":1,"stats":{"Line":0}},{"line":451,"address":[4047640,4055500,4047697,4055434,4055024],"length":1,"stats":{"Line":0}},{"line":452,"address":[4055056],"length":1,"stats":{"Line":0}},{"line":453,"address":[4055154],"length":1,"stats":{"Line":0}},{"line":454,"address":[4055275,4055234,4055294,4055168],"length":1,"stats":{"Line":0}},{"line":455,"address":[4055287,4055243,4055296],"length":1,"stats":{"Line":0}},{"line":457,"address":[4055268],"length":1,"stats":{"Line":0}},{"line":460,"address":[4055189],"length":1,"stats":{"Line":0}},{"line":461,"address":[4055206,4055432,4055412,4055367],"length":1,"stats":{"Line":0}},{"line":462,"address":[4055381,4055424],"length":1,"stats":{"Line":0}},{"line":464,"address":[4055404],"length":1,"stats":{"Line":0}},{"line":467,"address":[4055104],"length":1,"stats":{"Line":0}},{"line":471,"address":[4047736],"length":1,"stats":{"Line":0}},{"line":479,"address":[4018732,4017171],"length":1,"stats":{"Line":0}},{"line":480,"address":[4018740,4018830],"length":1,"stats":{"Line":0}},{"line":488,"address":[4017204,4018869],"length":1,"stats":{"Line":0}},{"line":489,"address":[4018967,4018877],"length":1,"stats":{"Line":0}},{"line":508,"address":[4013040],"length":1,"stats":{"Line":0}},{"line":509,"address":[4013093],"length":1,"stats":{"Line":0}},{"line":511,"address":[4019841],"length":1,"stats":{"Line":0}},{"line":512,"address":[4019979],"length":1,"stats":{"Line":0}},{"line":513,"address":[4020002,4055553,4020232,4055536],"length":1,"stats":{"Line":0}},{"line":516,"address":[4020348,4020409],"length":1,"stats":{"Line":0}},{"line":517,"address":[4021624],"length":1,"stats":{"Line":0}},{"line":518,"address":[4021535],"length":1,"stats":{"Line":0}},{"line":523,"address":[4020415],"length":1,"stats":{"Line":0}},{"line":524,"address":[4020574],"length":1,"stats":{"Line":0}},{"line":526,"address":[4021512,4055584,4020598,4021385,4021032],"length":1,"stats":{"Line":0}},{"line":529,"address":[4055611],"length":1,"stats":{"Line":0}},{"line":530,"address":[4055672],"length":1,"stats":{"Line":0}},{"line":534,"address":[4055698],"length":1,"stats":{"Line":0}},{"line":538,"address":[4021194,4021309],"length":1,"stats":{"Line":0}},{"line":540,"address":[4021479],"length":1,"stats":{"Line":0}},{"line":541,"address":[4021390],"length":1,"stats":{"Line":0}},{"line":546,"address":[4021011,4020559,4020632],"length":1,"stats":{"Line":0}},{"line":547,"address":[4020978],"length":1,"stats":{"Line":0}},{"line":548,"address":[4020889],"length":1,"stats":{"Line":0}},{"line":551,"address":[4020638,4020776],"length":1,"stats":{"Line":0}},{"line":557,"address":[4020161],"length":1,"stats":{"Line":0}},{"line":558,"address":[4020072],"length":1,"stats":{"Line":0}},{"line":568,"address":[5596265,5591835,5590640],"length":1,"stats":{"Line":0}},{"line":573,"address":[5590695],"length":1,"stats":{"Line":0}},{"line":574,"address":[5591136],"length":1,"stats":{"Line":0}},{"line":575,"address":[5591212],"length":1,"stats":{"Line":0}},{"line":576,"address":[5591174],"length":1,"stats":{"Line":0}},{"line":577,"address":[5591250],"length":1,"stats":{"Line":0}},{"line":578,"address":[5591427],"length":1,"stats":{"Line":0}},{"line":579,"address":[5591288],"length":1,"stats":{"Line":0}},{"line":582,"address":[5590801],"length":1,"stats":{"Line":0}},{"line":584,"address":[5591457],"length":1,"stats":{"Line":0}},{"line":587,"address":[5590826],"length":1,"stats":{"Line":0}},{"line":588,"address":[5590846,5593163,5593279,5591862,5592209,5592122],"length":1,"stats":{"Line":0}},{"line":589,"address":[5593158,5592338,5592687,5592162],"length":1,"stats":{"Line":0}},{"line":591,"address":[5592615],"length":1,"stats":{"Line":0}},{"line":593,"address":[5592792],"length":1,"stats":{"Line":0}},{"line":594,"address":[5592877],"length":1,"stats":{"Line":0}},{"line":597,"address":[5592904],"length":1,"stats":{"Line":0}},{"line":598,"address":[5592947],"length":1,"stats":{"Line":0}},{"line":601,"address":[5592982],"length":1,"stats":{"Line":0}},{"line":604,"address":[5592808],"length":1,"stats":{"Line":0}},{"line":605,"address":[5593025],"length":1,"stats":{"Line":0}},{"line":608,"address":[5593055],"length":1,"stats":{"Line":0}},{"line":609,"address":[5593077],"length":1,"stats":{"Line":0}},{"line":612,"address":[5593115],"length":1,"stats":{"Line":0}},{"line":615,"address":[5592839],"length":1,"stats":{"Line":0}},{"line":620,"address":[5590897],"length":1,"stats":{"Line":0}},{"line":622,"address":[5590943],"length":1,"stats":{"Line":0}},{"line":623,"address":[5591006],"length":1,"stats":{"Line":0}},{"line":624,"address":[5593360,5591018],"length":1,"stats":{"Line":0}},{"line":626,"address":[5591061],"length":1,"stats":{"Line":0}},{"line":627,"address":[5593624],"length":1,"stats":{"Line":0}},{"line":628,"address":[5593655],"length":1,"stats":{"Line":0}},{"line":629,"address":[5593680],"length":1,"stats":{"Line":0}},{"line":630,"address":[5593694],"length":1,"stats":{"Line":0}},{"line":632,"address":[5593758],"length":1,"stats":{"Line":0}},{"line":635,"address":[5593793],"length":1,"stats":{"Line":0}},{"line":638,"address":[5593828],"length":1,"stats":{"Line":0}},{"line":641,"address":[5593863],"length":1,"stats":{"Line":0}},{"line":654,"address":[5591353],"length":1,"stats":{"Line":0}},{"line":655,"address":[5591389],"length":1,"stats":{"Line":0}},{"line":657,"address":[5594400,5594338],"length":1,"stats":{"Line":0}},{"line":658,"address":[5595734],"length":1,"stats":{"Line":0}},{"line":659,"address":[5595645],"length":1,"stats":{"Line":0}},{"line":663,"address":[4055744,4055760],"length":1,"stats":{"Line":0}},{"line":666,"address":[5594660],"length":1,"stats":{"Line":0}},{"line":667,"address":[5594723],"length":1,"stats":{"Line":0}},{"line":669,"address":[4055830,4055808],"length":1,"stats":{"Line":0}},{"line":672,"address":[4055838],"length":1,"stats":{"Line":0}},{"line":673,"address":[4055894],"length":1,"stats":{"Line":0}},{"line":677,"address":[4055922],"length":1,"stats":{"Line":0}},{"line":681,"address":[5595309,5595436],"length":1,"stats":{"Line":0}},{"line":683,"address":[5595570],"length":1,"stats":{"Line":0}},{"line":684,"address":[5595481],"length":1,"stats":{"Line":0}},{"line":689,"address":[5594804,5594703,5595153],"length":1,"stats":{"Line":0}},{"line":690,"address":[5595120],"length":1,"stats":{"Line":0}},{"line":691,"address":[5595031],"length":1,"stats":{"Line":0}},{"line":694,"address":[5594942,5594810],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":304},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","result.rs"],"content":"use itertools::Itertools;\n\nuse crate::{ast::types::DataType, pgwire::protocol::DataTypeOid};\n\nuse super::config::row::TableDataFieldType;\n\n#[derive(Debug, Clone)]\npub struct ExecuteResult {\n    pub rows: Vec\u003cExecuteRow\u003e,       // 데이터 행 -\u003e 실 데이터\n    pub columns: Vec\u003cExecuteColumn\u003e, // 데이터 열에 대한 메타데이터\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ExecuteColumn {\n    pub data_type: ExecuteColumnType,\n    pub name: String,\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct ExecuteRow {\n    pub fields: Vec\u003cExecuteField\u003e,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum ExecuteColumnType {\n    Bool,\n    Integer,\n    Float,\n    String,\n    Null,\n}\n\nimpl From\u003cExecuteColumnType\u003e for DataTypeOid {\n    fn from(value: ExecuteColumnType) -\u003e DataTypeOid {\n        match value {\n            ExecuteColumnType::Bool =\u003e DataTypeOid::Bool,\n            ExecuteColumnType::Integer =\u003e DataTypeOid::Int8,\n            ExecuteColumnType::Float =\u003e DataTypeOid::Float8,\n            ExecuteColumnType::String =\u003e DataTypeOid::Text,\n            ExecuteColumnType::Null =\u003e DataTypeOid::Unspecified,\n        }\n    }\n}\n\nimpl From\u003cDataType\u003e for ExecuteColumnType {\n    fn from(value: DataType) -\u003e ExecuteColumnType {\n        match value {\n            DataType::Boolean =\u003e ExecuteColumnType::Bool,\n            DataType::Int =\u003e ExecuteColumnType::Integer,\n            DataType::Float =\u003e ExecuteColumnType::Float,\n            DataType::Varchar(_) =\u003e ExecuteColumnType::String,\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum ExecuteField {\n    Bool(bool),\n    Integer(i64),\n    Float(f64),\n    String(String),\n    Null,\n}\n\nimpl From\u003cTableDataFieldType\u003e for ExecuteField {\n    fn from(value: TableDataFieldType) -\u003e ExecuteField {\n        #[allow(unstable_name_collisions)]\n        match value {\n            TableDataFieldType::Boolean(value) =\u003e ExecuteField::Bool(value),\n            TableDataFieldType::Integer(value) =\u003e ExecuteField::Integer(value),\n            TableDataFieldType::Float(value) =\u003e ExecuteField::Float(value.into()),\n            TableDataFieldType::String(value) =\u003e ExecuteField::String(value),\n            TableDataFieldType::Array(value) =\u003e ExecuteField::String(\n                value\n                    .iter()\n                    .map(|e| e.to_string())\n                    .intersperse(\", \".to_owned())\n                    .collect(),\n            ),\n            TableDataFieldType::Null =\u003e ExecuteField::Null,\n        }\n    }\n}\n","traces":[{"line":34,"address":[1858352],"length":1,"stats":{"Line":0}},{"line":35,"address":[1858359],"length":1,"stats":{"Line":0}},{"line":36,"address":[1858392],"length":1,"stats":{"Line":0}},{"line":37,"address":[1858402],"length":1,"stats":{"Line":0}},{"line":38,"address":[1858412],"length":1,"stats":{"Line":0}},{"line":39,"address":[1858422],"length":1,"stats":{"Line":0}},{"line":40,"address":[1858432],"length":1,"stats":{"Line":0}},{"line":46,"address":[1204416],"length":1,"stats":{"Line":0}},{"line":47,"address":[1204426],"length":1,"stats":{"Line":0}},{"line":48,"address":[1204473],"length":1,"stats":{"Line":0}},{"line":49,"address":[1204459],"length":1,"stats":{"Line":0}},{"line":50,"address":[1204466],"length":1,"stats":{"Line":0}},{"line":51,"address":[1204480],"length":1,"stats":{"Line":0}},{"line":66,"address":[1204496,1205106],"length":1,"stats":{"Line":0}},{"line":68,"address":[1204518],"length":1,"stats":{"Line":0}},{"line":69,"address":[1204662],"length":1,"stats":{"Line":0}},{"line":70,"address":[1204559],"length":1,"stats":{"Line":0}},{"line":71,"address":[1204598],"length":1,"stats":{"Line":0}},{"line":72,"address":[1204711],"length":1,"stats":{"Line":0}},{"line":74,"address":[1205018,1204803,1204901],"length":1,"stats":{"Line":0}},{"line":76,"address":[1691840,1691875],"length":1,"stats":{"Line":0}},{"line":77,"address":[1204965],"length":1,"stats":{"Line":0}},{"line":80,"address":[1204825],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","runner","work","rrdb","rrdb","src","executor","util.rs"],"content":"use std::path::PathBuf;\n\nuse crate::executor::predule::Executor;\n\nimpl Executor {\n    // 데이터 저장 경로를 반환합니다..\n    pub fn get_data_directory(\u0026self) -\u003e PathBuf {\n        PathBuf::from(self.config.data_directory.clone())\n    }\n}\n","traces":[{"line":7,"address":[5596288],"length":1,"stats":{"Line":0}},{"line":8,"address":[5596318],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","mod.rs"],"content":"pub mod operator_token;\npub mod predule;\npub mod tokenizer;\npub mod tokens;\n\npub(crate) mod test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","operator_token.rs"],"content":"use crate::{\n    ast::dml::expressions::operators::{BinaryOperator, UnaryOperator},\n    errors::{predule::IntoError, RRDBError},\n};\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum OperatorToken {\n    Plus,     // +\n    Minus,    // -\n    Asterisk, // *\n    Slash,    // /\n    Lt,       // A \u003c B\n    Gt,       // A \u003e B\n    Lte,      // A \u003c= B\n    Gte,      // A \u003e= B\n    Eq,       // A = B\n    Neq,      // A != B, A \u003c\u003e B\n    Not,      // !A\n}\n\nimpl OperatorToken {\n    pub fn is_binary_operator(\u0026self) -\u003e bool {\n        [\n            Self::Plus,\n            Self::Minus,\n            Self::Asterisk,\n            Self::Slash,\n            Self::Lt,\n            Self::Gt,\n            Self::Lte,\n            Self::Gte,\n            Self::Eq,\n            Self::Neq,\n        ]\n        .contains(self)\n    }\n\n    pub fn is_unary_operator(\u0026self) -\u003e bool {\n        [Self::Plus, Self::Minus, Self::Not].contains(self)\n    }\n}\n\nimpl TryInto\u003cBinaryOperator\u003e for OperatorToken {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cBinaryOperator, Self::Error\u003e {\n        match self {\n            Self::Plus =\u003e Ok(BinaryOperator::Add),\n            Self::Minus =\u003e Ok(BinaryOperator::Sub),\n            Self::Asterisk =\u003e Ok(BinaryOperator::Mul),\n            Self::Slash =\u003e Ok(BinaryOperator::Div),\n            Self::Lt =\u003e Ok(BinaryOperator::Lt),\n            Self::Gt =\u003e Ok(BinaryOperator::Gt),\n            Self::Lte =\u003e Ok(BinaryOperator::Lte),\n            Self::Gte =\u003e Ok(BinaryOperator::Gte),\n            Self::Eq =\u003e Ok(BinaryOperator::Eq),\n            Self::Neq =\u003e Ok(BinaryOperator::Neq),\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n}\n\nimpl TryInto\u003cUnaryOperator\u003e for OperatorToken {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cUnaryOperator, Self::Error\u003e {\n        match self {\n            Self::Plus =\u003e Ok(UnaryOperator::Pos),\n            Self::Minus =\u003e Ok(UnaryOperator::Neg),\n            Self::Not =\u003e Ok(UnaryOperator::Not),\n            _ =\u003e Err(IntoError::wrap(\"UnaryOperator Cast Error\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_operator_token_is_binary_operator() {\n        use super::OperatorToken;\n\n        let test_cases = vec![\n            (OperatorToken::Plus, true),\n            (OperatorToken::Minus, true),\n            (OperatorToken::Asterisk, true),\n            (OperatorToken::Slash, true),\n            (OperatorToken::Lt, true),\n            (OperatorToken::Gt, true),\n            (OperatorToken::Lte, true),\n            (OperatorToken::Gte, true),\n            (OperatorToken::Eq, true),\n            (OperatorToken::Neq, true),\n            (OperatorToken::Not, false),\n        ];\n\n        for (input, expected) in test_cases {\n            let got = input.is_binary_operator();\n            assert_eq!(got, expected);\n        }\n    }\n\n    #[test]\n    fn test_operator_token_is_unary_operator() {\n        use super::OperatorToken;\n\n        let test_cases = vec![\n            (OperatorToken::Plus, true),\n            (OperatorToken::Minus, true),\n            (OperatorToken::Asterisk, false),\n            (OperatorToken::Slash, false),\n            (OperatorToken::Lt, false),\n            (OperatorToken::Gt, false),\n            (OperatorToken::Lte, false),\n            (OperatorToken::Gte, false),\n            (OperatorToken::Eq, false),\n            (OperatorToken::Neq, false),\n            (OperatorToken::Not, true),\n        ];\n\n        for (input, expected) in test_cases {\n            let got = input.is_unary_operator();\n            assert_eq!(got, expected);\n        }\n    }\n\n    #[test]\n    fn test_operator_token_try_into_binary_operator() {\n        use super::{BinaryOperator, OperatorToken};\n        use std::convert::TryInto;\n\n        struct TestCase {\n            name: String,\n            input: OperatorToken,\n            want_error: bool,\n            expected: BinaryOperator,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"연산자: +\".to_owned(),\n                input: OperatorToken::Plus,\n                want_error: false,\n                expected: BinaryOperator::Add,\n            },\n            TestCase {\n                name: \"연산자: -\".to_owned(),\n                input: OperatorToken::Minus,\n                want_error: false,\n                expected: BinaryOperator::Sub,\n            },\n            TestCase {\n                name: \"연산자: *\".to_owned(),\n                input: OperatorToken::Asterisk,\n                want_error: false,\n                expected: BinaryOperator::Mul,\n            },\n            TestCase {\n                name: \"연산자: /\".to_owned(),\n                input: OperatorToken::Slash,\n                want_error: false,\n                expected: BinaryOperator::Div,\n            },\n            TestCase {\n                name: \"연산자: \u003c\".to_owned(),\n                input: OperatorToken::Lt,\n                want_error: false,\n                expected: BinaryOperator::Lt,\n            },\n            TestCase {\n                name: \"연산자: \u003e\".to_owned(),\n                input: OperatorToken::Gt,\n                want_error: false,\n                expected: BinaryOperator::Gt,\n            },\n            TestCase {\n                name: \"연산자: \u003c=\".to_owned(),\n                input: OperatorToken::Lte,\n                want_error: false,\n                expected: BinaryOperator::Lte,\n            },\n            TestCase {\n                name: \"연산자: \u003e=\".to_owned(),\n                input: OperatorToken::Gte,\n                want_error: false,\n                expected: BinaryOperator::Gte,\n            },\n            TestCase {\n                name: \"연산자: =\".to_owned(),\n                input: OperatorToken::Eq,\n                want_error: false,\n                expected: BinaryOperator::Eq,\n            },\n            TestCase {\n                name: \"연산자: !=\".to_owned(),\n                input: OperatorToken::Neq,\n                want_error: false,\n                expected: BinaryOperator::Neq,\n            },\n            TestCase {\n                name: \"연산자: !\".to_owned(),\n                input: OperatorToken::Not,\n                want_error: true,\n                expected: BinaryOperator::Neq,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cBinaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n\n    #[test]\n    fn test_operator_token_try_into_unary_operator() {\n        use super::{OperatorToken, UnaryOperator};\n        use std::convert::TryInto;\n\n        struct TestCase {\n            name: String,\n            input: OperatorToken,\n            want_error: bool,\n            expected: UnaryOperator,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"연산자: +\".to_owned(),\n                input: OperatorToken::Plus,\n                want_error: false,\n                expected: UnaryOperator::Pos,\n            },\n            TestCase {\n                name: \"연산자: -\".to_owned(),\n                input: OperatorToken::Minus,\n                want_error: false,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: *\".to_owned(),\n                input: OperatorToken::Asterisk,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: /\".to_owned(),\n                input: OperatorToken::Slash,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003c\".to_owned(),\n                input: OperatorToken::Lt,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003e\".to_owned(),\n                input: OperatorToken::Gt,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003c=\".to_owned(),\n                input: OperatorToken::Lte,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: \u003e=\".to_owned(),\n                input: OperatorToken::Gte,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: =\".to_owned(),\n                input: OperatorToken::Eq,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: !=\".to_owned(),\n                input: OperatorToken::Neq,\n                want_error: true,\n                expected: UnaryOperator::Neg,\n            },\n            TestCase {\n                name: \"연산자: !\".to_owned(),\n                input: OperatorToken::Not,\n                want_error: false,\n                expected: UnaryOperator::Not,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cUnaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[5643424],"length":1,"stats":{"Line":1}},{"line":38,"address":[5643456],"length":1,"stats":{"Line":1}},{"line":39,"address":[5643464],"length":1,"stats":{"Line":1}},{"line":46,"address":[5643539,5643488],"length":1,"stats":{"Line":1}},{"line":47,"address":[5643508],"length":1,"stats":{"Line":1}},{"line":48,"address":[5643545],"length":1,"stats":{"Line":1}},{"line":49,"address":[5643573],"length":1,"stats":{"Line":1}},{"line":50,"address":[5643601],"length":1,"stats":{"Line":1}},{"line":51,"address":[5643629],"length":1,"stats":{"Line":1}},{"line":52,"address":[5643657],"length":1,"stats":{"Line":1}},{"line":53,"address":[5643685],"length":1,"stats":{"Line":1}},{"line":54,"address":[5643713],"length":1,"stats":{"Line":1}},{"line":55,"address":[5643738],"length":1,"stats":{"Line":1}},{"line":56,"address":[5643763],"length":1,"stats":{"Line":1}},{"line":57,"address":[5643788],"length":1,"stats":{"Line":1}},{"line":58,"address":[5643809],"length":1,"stats":{"Line":1}},{"line":66,"address":[5643872],"length":1,"stats":{"Line":1}},{"line":67,"address":[5643893],"length":1,"stats":{"Line":1}},{"line":68,"address":[5643985],"length":1,"stats":{"Line":1}},{"line":69,"address":[5644011],"length":1,"stats":{"Line":1}},{"line":70,"address":[5644037],"length":1,"stats":{"Line":1}},{"line":71,"address":[5643936],"length":1,"stats":{"Line":1}}],"covered":22,"coverable":22},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","predule.rs"],"content":"pub use super::operator_token::*;\npub use super::tokenizer::*;\npub use super::tokens::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","comment.rs"],"content":"#[cfg(test)]\nuse crate::lexer::predule::{Token, Tokenizer};\n\n#[test]\npub fn comment_1() {\n    let text = r#\"SELECT 1 -- asdf\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Integer(1),\n            Token::CodeComment(\" asdf\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn comment_2() {\n    let text = r#\"SELECT /*asdf*/1\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::CodeComment(\"asdf\".to_owned()),\n            Token::Integer(1),\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","mod.rs"],"content":"pub(crate) mod comment;\npub(crate) mod select;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","test","select.rs"],"content":"#[cfg(test)]\nuse crate::lexer::predule::OperatorToken;\n#[cfg(test)]\nuse crate::lexer::predule::{Token, Tokenizer};\n\n#[test]\npub fn test_number_literal() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"한자리수 정수\".to_owned(),\n            input: \"SELECT 1\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Integer(1)],\n        },\n        TestCase {\n            name: \"여러자리 정수\".to_owned(),\n            input: \"SELECT 1432\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Integer(1432)],\n        },\n        TestCase {\n            name: \"정수 파싱 실패\".to_owned(),\n            input: \"SELECT 1444444444444444444444444444444444444444444444444444444432\".to_owned(),\n            want_error: true,\n            expected: vec![],\n        },\n        TestCase {\n            name: \"실수: 3.14\".to_owned(),\n            input: \"SELECT 3.14\".to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Float(3.14)],\n        },\n        TestCase {\n            name: \"실수 파싱 실패: 3..14\".to_owned(),\n            input: \"SELECT 3..14\".to_owned(),\n            want_error: true,\n            expected: vec![],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn select_text() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"문자열: 'I''m Sam'\".to_owned(),\n        input: r#\"SELECT 'I''m Sam'\"#.to_owned(),\n        want_error: false,\n        expected: vec![Token::Select, Token::String(\"I'm Sam\".to_owned())],\n    }];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn test_errors() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"예상하지 못한 특수문자\".to_owned(),\n            input: r#\"SELECT @\"#.to_owned(),\n            want_error: true,\n        },\n        // TestCase {\n        //     name: \"예상하지 못한 특수문자: $\".to_owned(),\n        //     input: r#\"SELECT $\"#.to_owned(),\n        //     want_error: true,\n        // },\n        TestCase {\n            name: \"예상하지 못한 특수문자: $$$\".to_owned(),\n            input: r#\"SELECT $$$\"#.to_owned(),\n            want_error: true,\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n    }\n}\n\n#[test]\npub fn test_operators() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"연산자: /\".to_owned(),\n            input: r#\"SELECT 1 / 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Slash),\n                Token::Integer(2),\n            ],\n        },\n        TestCase {\n            name: \"연산자: \u003c\".to_owned(),\n            input: r#\"SELECT 1 \u003c 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Lt),\n                Token::Integer(2),\n            ],\n        },\n        TestCase {\n            name: \"연산자: \u003e\".to_owned(),\n            input: r#\"SELECT 1 \u003e 2\"#.to_owned(),\n            want_error: false,\n            expected: vec![\n                Token::Select,\n                Token::Integer(1),\n                Token::Operator(OperatorToken::Gt),\n                Token::Integer(2),\n            ],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn test_identifier() {\n    struct TestCase {\n        name: String,\n        input: String,\n        want_error: bool,\n        expected: Vec\u003cToken\u003e,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"백틱 파싱\".to_owned(),\n            input: r#\"SELECT `foo`\"#.to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Identifier(\"foo\".to_owned())],\n        },\n        TestCase {\n            name: \"백틱 안에 백틱 파싱\".to_owned(),\n            input: r#\"SELECT `foo``bar`\"#.to_owned(),\n            want_error: false,\n            expected: vec![Token::Select, Token::Identifier(\"foo`bar\".to_owned())],\n        },\n    ];\n\n    for t in test_cases {\n        let got = Tokenizer::string_to_tokens(t.input);\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(tokens) = got {\n            assert_eq!(tokens, t.expected, \"{}\", t.name);\n        }\n    }\n}\n\n#[test]\npub fn select_from_1() {\n    let text = r#\"SELECT name from person\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Identifier(\"name\".to_owned()),\n            Token::From,\n            Token::Identifier(\"person\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn select_from_2() {\n    let text = r#\"SELECT 1 from \"boom\"\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Integer(1),\n            Token::From,\n            Token::Identifier(\"boom\".to_owned())\n        ]\n    );\n}\n\n#[test]\npub fn select_from_where_1() {\n    let text = r#\"SELECT name from person where\"#.to_owned();\n\n    let tokens = Tokenizer::string_to_tokens(text).unwrap();\n\n    assert_eq!(\n        tokens,\n        vec![\n            Token::Select,\n            Token::Identifier(\"name\".to_owned()),\n            Token::From,\n            Token::Identifier(\"person\".to_owned()),\n            Token::Where,\n        ]\n    );\n}\n\n// #[test]\n// pub fn inner_join() {\n//     let text = r#\"\n//         SELECT\n//             p.name as name,\n//             s.name as schoolName\n//         from person as p\n//         inner join school as s\n//         on 1=1\n//             and p.school_id = s.id\n//     \"#\n//     .to_owned();\n\n//     let tokens = Tokenizer::string_to_tokens(text);\n\n//     assert_eq!(\n//         tokens,\n//         vec![\n//             Token::Select,\n//             Token::Identifier(\"p.name\".to_owned()),\n//             Token::As,\n//             Token::Identifier(\"name\".to_owned()),\n//             Token::From,\n//             Token::Identifier(\"person\".to_owned()),\n//             Token::Where,\n//         ]\n//     );\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","tokenizer.rs"],"content":"use crate::errors::predule::LexingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::logger::predule::Logger;\n\n#[derive(Debug)]\npub struct Tokenizer {\n    buffer: Vec\u003cchar\u003e,\n    buffer_index: usize,\n    last_char: char,\n}\n\nimpl Tokenizer {\n    pub fn new(text: String) -\u003e Self {\n        Logger::info(format!(\"SQL echo: {:?}\", text));\n        Self {\n            last_char: ' ',\n            buffer: text.chars().collect(),\n            buffer_index: 0,\n        }\n    }\n\n    pub fn is_whitespace(\u0026self) -\u003e bool {\n        self.last_char == ' ' || self.last_char == '\\n' || self.last_char == '\\t'\n    }\n\n    pub fn is_digit(\u0026self) -\u003e bool {\n        self.last_char.is_ascii_digit()\n    }\n\n    pub fn is_alphabet(\u0026self) -\u003e bool {\n        self.last_char.is_alphabetic()\n    }\n\n    pub fn is_alphabet_or_number(\u0026self) -\u003e bool {\n        self.last_char.is_alphanumeric()\n    }\n\n    pub fn is_underscore(\u0026self) -\u003e bool {\n        self.last_char == '_'\n    }\n\n    pub fn is_special_character(\u0026self) -\u003e bool {\n        ['+', '-', '*', '/', ',', '\u003e', '\u003c', '=', '!', '\\\\', '@'].contains(\u0026self.last_char)\n    }\n\n    pub fn is_quote(\u0026self) -\u003e bool {\n        ['\\'', '\"'].contains(\u0026self.last_char)\n    }\n\n    pub fn is_semicolon(\u0026self) -\u003e bool {\n        self.last_char == ';'\n    }\n\n    pub fn is_dot(\u0026self) -\u003e bool {\n        self.last_char == '.'\n    }\n\n    pub fn is_backtick(\u0026self) -\u003e bool {\n        self.last_char == '`'\n    }\n\n    pub fn is_parentheses(\u0026self) -\u003e bool {\n        self.last_char == '(' || self.last_char == ')'\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.buffer_index \u003e= self.buffer.len()\n    }\n\n    // 버퍼에서 문자 하나를 읽어서 last_char에 보관합니다.\n    pub fn read_char(\u0026mut self) {\n        if self.buffer_index \u003e= self.buffer.len() {\n            self.last_char = ' ';\n        } else {\n            self.last_char = self.buffer[self.buffer_index];\n            self.buffer_index += 1;\n        }\n    }\n\n    // 보관했던 문자 하나를 다시 버퍼에 돌려놓습니다.\n    pub fn unread_char(\u0026mut self) {\n        if self.buffer_index != 0 {\n            self.buffer_index -= 1;\n            self.last_char = self.buffer[self.buffer_index];\n        }\n    }\n\n    // 주어진 텍스트에서 토큰을 순서대로 획득해 반환합니다.\n    // 끝을 만날 경우 Token::EOF를 반환합니다.\n    pub fn get_token(\u0026mut self) -\u003e Result\u003cToken, RRDBError\u003e {\n        // 화이트 스페이스 삼킴\n        while self.is_whitespace() \u0026\u0026 !self.is_eof() {\n            self.read_char();\n        }\n\n        // 첫번째 글짜가 알파벳일 경우 식별자 및 키워드로 인식\n        let token = if self.is_alphabet() || self.is_underscore() {\n            let mut identifier = vec![self.last_char];\n\n            self.read_char();\n            while self.is_alphabet_or_number() || self.is_underscore() {\n                identifier.push(self.last_char);\n                self.read_char();\n            }\n\n            let identifier: String = identifier.into_iter().collect::\u003cString\u003e();\n\n            let token = match identifier.to_uppercase().as_str() {\n                \"SELECT\" =\u003e Token::Select,\n                \"FROM\" =\u003e Token::From,\n                \"WHERE\" =\u003e Token::Where,\n                \"AS\" =\u003e Token::As,\n                \"ORDER\" =\u003e Token::Order,\n                \"BY\" =\u003e Token::By,\n                \"ASC\" =\u003e Token::Asc,\n                \"DESC\" =\u003e Token::Desc,\n                \"GROUP\" =\u003e Token::Group,\n                \"HAVING\" =\u003e Token::Having,\n                \"LIMIT\" =\u003e Token::Limit,\n                \"OFFSET\" =\u003e Token::Offset,\n                \"INSERT\" =\u003e Token::Insert,\n                \"INTO\" =\u003e Token::Into,\n                \"VALUES\" =\u003e Token::Values,\n                \"UPDATE\" =\u003e Token::Update,\n                \"SET\" =\u003e Token::Set,\n                \"DELETE\" =\u003e Token::Delete,\n                \"JOIN\" =\u003e Token::Join,\n                \"INNER\" =\u003e Token::Inner,\n                \"LEFT\" =\u003e Token::Left,\n                \"RIGHT\" =\u003e Token::Right,\n                \"FULL\" =\u003e Token::Full,\n                \"OUTER\" =\u003e Token::Outer,\n                \"CREATE\" =\u003e Token::Create,\n                \"ALTER\" =\u003e Token::Alter,\n                \"DROP\" =\u003e Token::Drop,\n                \"DATABASE\" =\u003e Token::Database,\n                \"TABLE\" =\u003e Token::Table,\n                \"COLUMN\" =\u003e Token::Column,\n                \"COMMENT\" =\u003e Token::Comment,\n                \"PRIMARY\" =\u003e Token::Primary,\n                \"FOREIGN\" =\u003e Token::Foreign,\n                \"KEY\" =\u003e Token::Key,\n                \"ADD\" =\u003e Token::Add,\n                \"RENAME\" =\u003e Token::Rename,\n                \"TO\" =\u003e Token::To,\n                \"SHOW\" =\u003e Token::Show,\n                \"DATABASES\" =\u003e Token::Databases,\n                \"TABLES\" =\u003e Token::Tables,\n                \"AND\" =\u003e Token::And,\n                \"OR\" =\u003e Token::Or,\n                \"NOT\" =\u003e Token::Not,\n                \"BETWEEN\" =\u003e Token::Between,\n                \"LIKE\" =\u003e Token::Like,\n                \"IN\" =\u003e Token::In,\n                \"IS\" =\u003e Token::Is,\n                \"TRUE\" =\u003e Token::Boolean(true),\n                \"FALSE\" =\u003e Token::Boolean(false),\n                \"NULL\" =\u003e Token::Null,\n                \"DEFAULT\" =\u003e Token::Default,\n                \"IF\" =\u003e Token::If,\n                \"EXISTS\" =\u003e Token::Exists,\n                \"ON\" =\u003e Token::On,\n                \"USE\" =\u003e Token::Use,\n                \"DATA\" =\u003e Token::Data,\n                \"TYPE\" =\u003e Token::Type,\n                \"NULLS\" =\u003e Token::Nulls,\n                \"FIRST\" =\u003e Token::First,\n                \"LAST\" =\u003e Token::Last,\n                \"BEGIN\" =\u003e Token::Begin,\n                \"TRANSACTION\" =\u003e Token::Transaction,\n                \"COMMIT\" =\u003e Token::Commit,\n                \"ROLLBACK\" =\u003e Token::Rollback,\n                _ =\u003e Token::Identifier(identifier),\n            };\n\n            return Ok(token);\n        }\n        // 첫번째 글자가 숫자일 경우 정수 및 실수값으로 인식\n        else if self.is_digit() {\n            let mut number_string = vec![self.last_char];\n\n            // 숫자나 .이 나올 때까지만 버퍼에서 읽어서 number_string에 저장\n            loop {\n                self.read_char();\n                if self.is_digit() || self.is_dot() {\n                    number_string.push(self.last_char);\n                    continue;\n                } else if self.is_eof() {\n                    break;\n                } else {\n                    self.unread_char();\n                    break;\n                }\n            }\n\n            let number_string: String =\n                number_string.into_iter().collect::\u003cString\u003e().to_uppercase();\n\n            // .이 있을 경우 실수, 아닌 경우 정수로 인식\n            if number_string.contains('.') {\n                let number = number_string.parse::\u003cf64\u003e();\n\n                match number {\n                    Ok(number) =\u003e Token::Float(number),\n                    Err(_) =\u003e {\n                        return Err(LexingError::wrap(format!(\n                            \"invalid floating point number format: {}\",\n                            number_string\n                        )))\n                    }\n                }\n            } else {\n                let number = number_string.parse::\u003ci64\u003e();\n\n                match number {\n                    Ok(number) =\u003e Token::Integer(number),\n                    Err(_) =\u003e {\n                        return Err(LexingError::wrap(format!(\n                            \"invalid integer number format: {}\",\n                            number_string\n                        )))\n                    }\n                }\n            }\n        }\n        // 특수문자일 경우\n        else if self.is_special_character() {\n            match self.last_char {\n                ',' =\u003e Token::Comma,\n                '\\\\' =\u003e Token::Backslash,\n                '-' =\u003e {\n                    // 다음 문자가 또 -일 경우 행 단위 주석으로 처리\n                    self.read_char();\n\n                    if self.last_char == '-' {\n                        let mut comment = vec![];\n\n                        while !self.is_eof() {\n                            self.read_char();\n\n                            if self.last_char == '\\n' {\n                                break;\n                            } else {\n                                comment.push(self.last_char);\n                            }\n                        }\n\n                        let comment: String = comment.into_iter().collect();\n                        Token::CodeComment(comment)\n                    } else {\n                        self.unread_char();\n                        Token::Operator(OperatorToken::Minus)\n                    }\n                }\n                '/' =\u003e {\n                    // 다음 문자가 *일 경우 블록 단위 주석으로 처리\n\n                    self.read_char();\n\n                    if self.last_char == '*' {\n                        let mut comment = vec![];\n\n                        self.read_char();\n                        while !self.is_eof() {\n                            if self.last_char == '*' {\n                                self.read_char();\n                                if self.last_char == '/' {\n                                    break;\n                                }\n                            } else {\n                                comment.push(self.last_char);\n                            }\n\n                            self.read_char();\n                        }\n\n                        let comment: String = comment.into_iter().collect();\n                        Token::CodeComment(comment)\n                    } else {\n                        self.unread_char();\n                        Token::Operator(OperatorToken::Slash)\n                    }\n                }\n                '+' =\u003e Token::Operator(OperatorToken::Plus),\n                '*' =\u003e Token::Operator(OperatorToken::Asterisk),\n                '!' =\u003e Token::Operator(OperatorToken::Not), // TODO: != 연산자 처리\n                '=' =\u003e Token::Operator(OperatorToken::Eq),\n                '\u003c' =\u003e Token::Operator(OperatorToken::Lt), // TODO: \u003c= 연산자 처리\n                '\u003e' =\u003e Token::Operator(OperatorToken::Gt), // TODO: \u003e= 연산자 처리\n                _ =\u003e {\n                    return Err(LexingError::wrap(format!(\n                        \"unexpected operator: {:?}\",\n                        self.last_char\n                    )))\n                }\n            }\n        }\n        // 따옴표일 경우 처리\n        else if self.is_quote() {\n            if self.last_char == '\"' {\n                let mut identifier = vec![];\n\n                self.read_char();\n                while self.last_char != '\"' {\n                    identifier.push(self.last_char);\n                    self.read_char();\n                }\n\n                let identifier: String = identifier.into_iter().collect::\u003cString\u003e();\n\n                Token::Identifier(identifier)\n            } else {\n                let mut string = vec![];\n\n                self.read_char();\n                while !self.is_eof() {\n                    if self.last_char == '\\'' {\n                        self.read_char();\n\n                        // '' 의 형태일 경우 '로 이스케이프\n                        // 아닐 경우 문자열 종료\n                        if self.last_char == '\\'' {\n                            string.push(self.last_char);\n                        } else {\n                            self.unread_char();\n                            break;\n                        }\n                    } else {\n                        string.push(self.last_char);\n                    }\n\n                    self.read_char();\n                }\n\n                let string: String = string.into_iter().collect::\u003cString\u003e();\n\n                Token::String(string)\n            }\n        } else if self.is_backtick() {\n            let mut string = vec![];\n\n            self.read_char();\n            while !self.is_eof() {\n                if self.last_char == '`' {\n                    self.read_char();\n\n                    // `` 의 형태일 경우 `로 이스케이프\n                    // 아닐 경우 문자열 종료\n                    if self.last_char == '`' {\n                        string.push(self.last_char);\n                    } else {\n                        self.unread_char();\n                        break;\n                    }\n                } else {\n                    string.push(self.last_char);\n                }\n\n                self.read_char();\n            }\n\n            let string: String = string.into_iter().collect::\u003cString\u003e();\n\n            Token::Identifier(string)\n        }\n        // 세미콜론\n        else if self.is_semicolon() {\n            Token::SemiColon\n        }\n        // 마침표\n        else if self.is_dot() {\n            Token::Period\n        }\n        // 괄호\n        else if self.is_parentheses() {\n            if self.last_char == '(' {\n                Token::LeftParentheses\n            } else {\n                Token::RightParentheses\n            }\n        }\n        // 아무것도 해당되지 않을 경우 예외처리\n        else if self.is_eof() {\n            Token::EOF\n        } else {\n            return Err(LexingError::wrap(format!(\n                \"unexpected character: {:?}\",\n                self.last_char\n            )));\n        };\n\n        self.last_char = ' ';\n\n        Ok(token)\n    }\n\n    // Tokenizer 생성 없이 토큰 목록을 가져올 수 있는 유틸 함수입니다.\n    pub fn string_to_tokens(text: String) -\u003e Result\u003cVec\u003cToken\u003e, RRDBError\u003e {\n        let mut tokenizer = Tokenizer::new(text);\n\n        let mut tokens = vec![];\n\n        while !tokenizer.is_eof() {\n            tokens.push(tokenizer.get_token()?);\n        }\n\n        Ok(tokens)\n    }\n}\n","traces":[{"line":14,"address":[2053830,2053456],"length":1,"stats":{"Line":2}},{"line":15,"address":[2053599],"length":1,"stats":{"Line":2}},{"line":18,"address":[2053680],"length":1,"stats":{"Line":2}},{"line":23,"address":[2053856],"length":1,"stats":{"Line":3}},{"line":24,"address":[2053866],"length":1,"stats":{"Line":3}},{"line":27,"address":[2053920],"length":1,"stats":{"Line":2}},{"line":28,"address":[2053925],"length":1,"stats":{"Line":2}},{"line":31,"address":[2053952],"length":1,"stats":{"Line":3}},{"line":32,"address":[2053957],"length":1,"stats":{"Line":3}},{"line":35,"address":[2053984],"length":1,"stats":{"Line":3}},{"line":36,"address":[2053989],"length":1,"stats":{"Line":3}},{"line":39,"address":[2054016],"length":1,"stats":{"Line":3}},{"line":40,"address":[2054021],"length":1,"stats":{"Line":3}},{"line":43,"address":[2054048],"length":1,"stats":{"Line":1}},{"line":44,"address":[2054056],"length":1,"stats":{"Line":1}},{"line":47,"address":[2054096],"length":1,"stats":{"Line":1}},{"line":48,"address":[2054104],"length":1,"stats":{"Line":1}},{"line":51,"address":[2054144],"length":1,"stats":{"Line":1}},{"line":52,"address":[2054149],"length":1,"stats":{"Line":1}},{"line":55,"address":[2054176],"length":1,"stats":{"Line":2}},{"line":56,"address":[2054181],"length":1,"stats":{"Line":2}},{"line":59,"address":[2054208],"length":1,"stats":{"Line":1}},{"line":60,"address":[2054213],"length":1,"stats":{"Line":1}},{"line":63,"address":[2054240],"length":1,"stats":{"Line":1}},{"line":64,"address":[2054250],"length":1,"stats":{"Line":1}},{"line":67,"address":[2054304],"length":1,"stats":{"Line":2}},{"line":68,"address":[2054313],"length":1,"stats":{"Line":2}},{"line":72,"address":[2054352],"length":1,"stats":{"Line":3}},{"line":73,"address":[2054475,2054366,2054459],"length":1,"stats":{"Line":7}},{"line":74,"address":[2054452],"length":1,"stats":{"Line":1}},{"line":76,"address":[2054398],"length":1,"stats":{"Line":3}},{"line":77,"address":[2054427,2054471,2054477],"length":1,"stats":{"Line":6}},{"line":82,"address":[2054512],"length":1,"stats":{"Line":2}},{"line":83,"address":[2054606,2054526],"length":1,"stats":{"Line":4}},{"line":84,"address":[2054608,2054543],"length":1,"stats":{"Line":2}},{"line":85,"address":[2054577],"length":1,"stats":{"Line":2}},{"line":91,"address":[2054624,2056054,2056086],"length":1,"stats":{"Line":3}},{"line":93,"address":[2054771,2054663],"length":1,"stats":{"Line":6}},{"line":94,"address":[2054788],"length":1,"stats":{"Line":3}},{"line":98,"address":[2054752,2054803],"length":1,"stats":{"Line":5}},{"line":99,"address":[2059711,2054814,2059656],"length":1,"stats":{"Line":6}},{"line":101,"address":[2059696,2059773],"length":1,"stats":{"Line":6}},{"line":102,"address":[2059783,2059856],"length":1,"stats":{"Line":6}},{"line":103,"address":[2059831],"length":1,"stats":{"Line":3}},{"line":104,"address":[2064116],"length":1,"stats":{"Line":3}},{"line":107,"address":[2059862],"length":1,"stats":{"Line":3}},{"line":109,"address":[2060135,2060040,2059972],"length":1,"stats":{"Line":9}},{"line":110,"address":[2060151,2060217],"length":1,"stats":{"Line":6}},{"line":111,"address":[2060273,2060194,2060234],"length":1,"stats":{"Line":3}},{"line":112,"address":[2060329,2060250,2060290],"length":1,"stats":{"Line":3}},{"line":113,"address":[2060306,2060346,2060385],"length":1,"stats":{"Line":3}},{"line":114,"address":[2060402,2060362,2060441],"length":1,"stats":{"Line":4}},{"line":115,"address":[2060497,2060418,2060458],"length":1,"stats":{"Line":3}},{"line":116,"address":[2060474,2060553,2060514],"length":1,"stats":{"Line":4}},{"line":117,"address":[2060609,2060530,2060570],"length":1,"stats":{"Line":3}},{"line":118,"address":[2060626,2060586,2060665],"length":1,"stats":{"Line":3}},{"line":119,"address":[2060721,2060642,2060682],"length":1,"stats":{"Line":3}},{"line":120,"address":[2060698,2060777,2060738],"length":1,"stats":{"Line":4}},{"line":121,"address":[2060794,2060833,2060754],"length":1,"stats":{"Line":3}},{"line":122,"address":[2060889,2060850,2060810],"length":1,"stats":{"Line":6}},{"line":123,"address":[2060945,2060866,2060906],"length":1,"stats":{"Line":6}},{"line":124,"address":[2060962,2060922,2061001],"length":1,"stats":{"Line":5}},{"line":125,"address":[2061057,2060978,2061018],"length":1,"stats":{"Line":4}},{"line":126,"address":[2061113,2061074,2061034],"length":1,"stats":{"Line":4}},{"line":127,"address":[2061169,2061090,2061130],"length":1,"stats":{"Line":3}},{"line":128,"address":[2061225,2061186,2061146],"length":1,"stats":{"Line":3}},{"line":129,"address":[2061242,2061281,2061202],"length":1,"stats":{"Line":3}},{"line":130,"address":[2061258,2061298,2061337],"length":1,"stats":{"Line":4}},{"line":131,"address":[2061354,2061393,2061314],"length":1,"stats":{"Line":3}},{"line":132,"address":[2061370,2061410,2061449],"length":1,"stats":{"Line":3}},{"line":133,"address":[2061426,2061466,2061505],"length":1,"stats":{"Line":3}},{"line":134,"address":[2061561,2061482,2061522],"length":1,"stats":{"Line":5}},{"line":135,"address":[2061538,2061617,2061578],"length":1,"stats":{"Line":6}},{"line":136,"address":[2061673,2061594,2061634],"length":1,"stats":{"Line":3}},{"line":137,"address":[2061650,2061729,2061690],"length":1,"stats":{"Line":4}},{"line":138,"address":[2061746,2061785,2061706],"length":1,"stats":{"Line":4}},{"line":139,"address":[2061762,2061841,2061802],"length":1,"stats":{"Line":3}},{"line":140,"address":[2061897,2061858,2061818],"length":1,"stats":{"Line":2}},{"line":141,"address":[2061914,2061874,2061953],"length":1,"stats":{"Line":3}},{"line":142,"address":[2061970,2062009,2061930],"length":1,"stats":{"Line":2}},{"line":143,"address":[2062065,2062026,2061986],"length":1,"stats":{"Line":3}},{"line":144,"address":[2062042,2062082,2062121],"length":1,"stats":{"Line":4}},{"line":145,"address":[2062177,2062098,2062138],"length":1,"stats":{"Line":3}},{"line":146,"address":[2062233,2062194,2062154],"length":1,"stats":{"Line":3}},{"line":147,"address":[2062210,2062289,2062250],"length":1,"stats":{"Line":3}},{"line":148,"address":[2062266,2062306,2062345],"length":1,"stats":{"Line":5}},{"line":149,"address":[2062401,2062322,2062362],"length":1,"stats":{"Line":5}},{"line":150,"address":[2062378,2062457,2062418],"length":1,"stats":{"Line":5}},{"line":151,"address":[2062434,2062474,2062513],"length":1,"stats":{"Line":4}},{"line":152,"address":[2062490,2062530,2062569],"length":1,"stats":{"Line":5}},{"line":153,"address":[2062546,2062625,2062586],"length":1,"stats":{"Line":5}},{"line":154,"address":[2062642,2062602,2062681],"length":1,"stats":{"Line":4}},{"line":155,"address":[2062658,2062698,2062737],"length":1,"stats":{"Line":5}},{"line":156,"address":[2062714,2062754,2062793],"length":1,"stats":{"Line":4}},{"line":157,"address":[2062849,2062810,2062770],"length":1,"stats":{"Line":5}},{"line":158,"address":[2062913,2062874,2062826],"length":1,"stats":{"Line":4}},{"line":159,"address":[2062938,2062890,2062977],"length":1,"stats":{"Line":5}},{"line":160,"address":[2062994,2063033,2062954],"length":1,"stats":{"Line":5}},{"line":161,"address":[2063050,2063089,2063010],"length":1,"stats":{"Line":5}},{"line":162,"address":[2063145,2063106,2063066],"length":1,"stats":{"Line":5}},{"line":163,"address":[2063122,2063162,2063201],"length":1,"stats":{"Line":5}},{"line":164,"address":[2063218,2063257,2063178],"length":1,"stats":{"Line":5}},{"line":165,"address":[2063234,2063313,2063274],"length":1,"stats":{"Line":5}},{"line":166,"address":[2063330,2063290,2063369],"length":1,"stats":{"Line":5}},{"line":167,"address":[2063346,2063386,2063425],"length":1,"stats":{"Line":5}},{"line":168,"address":[2063481,2063442,2063402],"length":1,"stats":{"Line":5}},{"line":169,"address":[2063458,2063498,2063537],"length":1,"stats":{"Line":5}},{"line":170,"address":[2063593,2063514,2063554],"length":1,"stats":{"Line":5}},{"line":171,"address":[2063649,2063610,2063570],"length":1,"stats":{"Line":5}},{"line":172,"address":[2063626,2063705,2063666],"length":1,"stats":{"Line":5}},{"line":173,"address":[2063682,2063722,2063842],"length":1,"stats":{"Line":5}},{"line":174,"address":[2063728],"length":1,"stats":{"Line":2}},{"line":177,"address":[2063917],"length":1,"stats":{"Line":3}},{"line":180,"address":[2059469,2054880],"length":1,"stats":{"Line":4}},{"line":181,"address":[2058241,2054908,2058280],"length":1,"stats":{"Line":2}},{"line":184,"address":[2058270],"length":1,"stats":{"Line":1}},{"line":185,"address":[2058309],"length":1,"stats":{"Line":2}},{"line":186,"address":[2058365,2058450],"length":1,"stats":{"Line":4}},{"line":187,"address":[2058422,2059614],"length":1,"stats":{"Line":2}},{"line":189,"address":[2058464],"length":1,"stats":{"Line":2}},{"line":192,"address":[2058499,2058573],"length":1,"stats":{"Line":4}},{"line":197,"address":[2058506,2058575],"length":1,"stats":{"Line":4}},{"line":201,"address":[2059008,2059360,2058783],"length":1,"stats":{"Line":5}},{"line":202,"address":[2058897,2059288],"length":1,"stats":{"Line":2}},{"line":204,"address":[2059307],"length":1,"stats":{"Line":1}},{"line":205,"address":[2059325],"length":1,"stats":{"Line":1}},{"line":207,"address":[2059474],"length":1,"stats":{"Line":1}},{"line":214,"address":[2058866,2058939],"length":1,"stats":{"Line":4}},{"line":216,"address":[2058958],"length":1,"stats":{"Line":2}},{"line":217,"address":[2058976],"length":1,"stats":{"Line":2}},{"line":219,"address":[2059128],"length":1,"stats":{"Line":1}},{"line":228,"address":[2054897],"length":1,"stats":{"Line":1}},{"line":229,"address":[2054993],"length":1,"stats":{"Line":1}},{"line":230,"address":[2057086],"length":1,"stats":{"Line":1}},{"line":231,"address":[2057099],"length":1,"stats":{"Line":1}},{"line":234,"address":[2057120],"length":1,"stats":{"Line":1}},{"line":236,"address":[2057759,2057460,2057133],"length":1,"stats":{"Line":3}},{"line":237,"address":[2057394],"length":1,"stats":{"Line":1}},{"line":239,"address":[2057473,2057535],"length":1,"stats":{"Line":2}},{"line":240,"address":[2057549],"length":1,"stats":{"Line":1}},{"line":242,"address":[2057631],"length":1,"stats":{"Line":1}},{"line":245,"address":[2057645],"length":1,"stats":{"Line":1}},{"line":249,"address":[2057668,2057556],"length":1,"stats":{"Line":2}},{"line":250,"address":[2057695],"length":1,"stats":{"Line":1}},{"line":252,"address":[2057425],"length":1,"stats":{"Line":1}},{"line":253,"address":[2057430],"length":1,"stats":{"Line":1}},{"line":259,"address":[2057156],"length":1,"stats":{"Line":1}},{"line":261,"address":[2057169,2057865,2058199],"length":1,"stats":{"Line":3}},{"line":262,"address":[2057786],"length":1,"stats":{"Line":1}},{"line":264,"address":[2057815,2057911],"length":1,"stats":{"Line":2}},{"line":265,"address":[2057921],"length":1,"stats":{"Line":1}},{"line":266,"address":[2057956],"length":1,"stats":{"Line":1}},{"line":267,"address":[2058039],"length":1,"stats":{"Line":1}},{"line":268,"address":[2058080],"length":1,"stats":{"Line":1}},{"line":272,"address":[2058054,2058101],"length":1,"stats":{"Line":2}},{"line":275,"address":[2058094,2058103],"length":1,"stats":{"Line":2}},{"line":278,"address":[2057964,2058108],"length":1,"stats":{"Line":2}},{"line":279,"address":[2058135],"length":1,"stats":{"Line":1}},{"line":281,"address":[2057830],"length":1,"stats":{"Line":1}},{"line":282,"address":[2057835],"length":1,"stats":{"Line":1}},{"line":285,"address":[2057184],"length":1,"stats":{"Line":1}},{"line":286,"address":[2057219],"length":1,"stats":{"Line":1}},{"line":287,"address":[2057254],"length":1,"stats":{"Line":1}},{"line":288,"address":[2057289],"length":1,"stats":{"Line":1}},{"line":289,"address":[2057324],"length":1,"stats":{"Line":1}},{"line":290,"address":[2057359],"length":1,"stats":{"Line":1}},{"line":292,"address":[2056952,2056870],"length":1,"stats":{"Line":2}},{"line":300,"address":[2054974],"length":1,"stats":{"Line":1}},{"line":301,"address":[2056835,2055069,2056411],"length":1,"stats":{"Line":3}},{"line":302,"address":[2056095],"length":1,"stats":{"Line":1}},{"line":304,"address":[2056124,2056211],"length":1,"stats":{"Line":2}},{"line":305,"address":[2056221],"length":1,"stats":{"Line":1}},{"line":306,"address":[2056302],"length":1,"stats":{"Line":1}},{"line":307,"address":[2056424],"length":1,"stats":{"Line":1}},{"line":310,"address":[2056320,2056227],"length":1,"stats":{"Line":2}},{"line":312,"address":[2056347],"length":1,"stats":{"Line":1}},{"line":314,"address":[2056131],"length":1,"stats":{"Line":1}},{"line":316,"address":[2056160,2056499],"length":1,"stats":{"Line":2}},{"line":317,"address":[2056509],"length":1,"stats":{"Line":1}},{"line":318,"address":[2056544],"length":1,"stats":{"Line":1}},{"line":319,"address":[2056627],"length":1,"stats":{"Line":1}},{"line":323,"address":[2056668],"length":1,"stats":{"Line":1}},{"line":324,"address":[2056715,2056682],"length":1,"stats":{"Line":2}},{"line":326,"address":[2056732,2056708],"length":1,"stats":{"Line":2}},{"line":330,"address":[2056642,2056737],"length":1,"stats":{"Line":2}},{"line":333,"address":[2056725,2056739],"length":1,"stats":{"Line":2}},{"line":336,"address":[2056552,2056744],"length":1,"stats":{"Line":2}},{"line":338,"address":[2056771],"length":1,"stats":{"Line":1}},{"line":340,"address":[2055050,2056049],"length":1,"stats":{"Line":2}},{"line":341,"address":[2055103],"length":1,"stats":{"Line":1}},{"line":343,"address":[2055713,2055132],"length":1,"stats":{"Line":2}},{"line":344,"address":[2055723],"length":1,"stats":{"Line":1}},{"line":345,"address":[2055758],"length":1,"stats":{"Line":1}},{"line":346,"address":[2055841],"length":1,"stats":{"Line":1}},{"line":350,"address":[2055882],"length":1,"stats":{"Line":1}},{"line":351,"address":[2055929,2055896],"length":1,"stats":{"Line":2}},{"line":353,"address":[2055946,2055922],"length":1,"stats":{"Line":2}},{"line":357,"address":[2055856,2055951],"length":1,"stats":{"Line":2}},{"line":360,"address":[2055939,2055953],"length":1,"stats":{"Line":2}},{"line":363,"address":[2055766,2055958],"length":1,"stats":{"Line":2}},{"line":365,"address":[2055985],"length":1,"stats":{"Line":1}},{"line":368,"address":[2055169,2055092],"length":1,"stats":{"Line":2}},{"line":369,"address":[2055161],"length":1,"stats":{"Line":1}},{"line":372,"address":[2055150,2055201],"length":1,"stats":{"Line":2}},{"line":373,"address":[2055193],"length":1,"stats":{"Line":1}},{"line":376,"address":[2055182,2055481],"length":1,"stats":{"Line":3}},{"line":377,"address":[2055654,2055237,2055667],"length":1,"stats":{"Line":5}},{"line":378,"address":[2055646],"length":1,"stats":{"Line":2}},{"line":380,"address":[2055659],"length":1,"stats":{"Line":2}},{"line":384,"address":[2055214],"length":1,"stats":{"Line":1}},{"line":385,"address":[2055473],"length":1,"stats":{"Line":2}},{"line":387,"address":[2055342,2055260],"length":1,"stats":{"Line":2}},{"line":393,"address":[2055515],"length":1,"stats":{"Line":1}},{"line":395,"address":[2055522],"length":1,"stats":{"Line":1}},{"line":399,"address":[2064160,2064650],"length":1,"stats":{"Line":1}},{"line":400,"address":[2064182],"length":1,"stats":{"Line":2}},{"line":402,"address":[2064192,2064236],"length":1,"stats":{"Line":4}},{"line":404,"address":[2064292,2064243],"length":1,"stats":{"Line":4}},{"line":405,"address":[2064311,2064433],"length":1,"stats":{"Line":5}},{"line":408,"address":[2064323],"length":1,"stats":{"Line":1}}],"covered":220,"coverable":220},{"path":["/","home","runner","work","rrdb","rrdb","src","lexer","tokens.rs"],"content":"use super::predule::OperatorToken;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::errors::predule::IntoError;\nuse crate::errors::RRDBError;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Token {\n    // DCL\n    // Grant,\n    // Revoke,\n\n    // DML\n    Select,\n    From,\n    Where,\n    As,\n    Order,\n    By,\n    Asc,\n    Desc,\n    Group,\n    Having,\n    Limit,\n    Offset,\n    Insert,\n    Into,\n    Values,\n    Update,\n    Set,\n    Delete,\n    Join,\n    Inner,\n    Left,\n    Right,\n    Full,\n    Outer,\n    On,\n    Nulls,\n    First,\n    Last,\n\n    // DDL\n    Create,\n    Alter,\n    Drop,\n    Database,\n    Table,\n    Column,\n    Comment,\n    Primary,\n    Foreign,\n    Key,\n    Add,\n    If,\n    Rename,\n    To,\n    Show,\n    Databases,\n    Tables,\n    Use,\n    Type,\n    Default,\n    Data,\n\n    // TCL\n    Begin,\n    Transaction,\n    Commit,\n    Rollback,\n\n    // ETC\n    // Analyze,\n    CodeComment(String),\n\n    // EXPRESSION\n    And,\n    Or,\n    Not,\n    Between,\n    Like,\n    In,\n    Is,\n\n    // primary expression\n    Identifier(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    String(String),\n    Null,\n\n    Operator(OperatorToken),\n\n    //functions\n    Exists,\n\n    // general syntax\n    Comma,\n    Period,\n    SemiColon,\n    LeftParentheses,\n    RightParentheses,\n    Backslash,\n\n    // exception handling\n    EOF,\n    Error(String),\n    UnknownCharacter(char),\n}\n\nimpl Token {\n    pub fn is_eof(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self {\n            Token::EOF =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_unary_operator(\u0026self) -\u003e bool {\n        match self {\n            Token::Operator(operator) =\u003e operator.is_unary_operator(),\n            _ =\u003e false,\n        }\n    }\n\n    // 복합 토큰으로 구성된 연산자일 수 있는 경우\n    // IS NOT, NOT IN 등\n    pub fn can_be_multi_token_operator(\u0026self) -\u003e bool {\n        #[allow(clippy::match_like_matches_macro)]\n        match self {\n            Token::Not | Token::Is =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn try_into_multi_token_operator(\n        self,\n        second_token: Self,\n    ) -\u003e Result\u003cBinaryOperator, RRDBError\u003e {\n        match self {\n            Token::Not =\u003e match second_token {\n                Token::Like =\u003e Ok(BinaryOperator::NotLike),\n                Token::In =\u003e Ok(BinaryOperator::NotIn),\n                _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n            },\n            Token::Is =\u003e match second_token {\n                Token::Not =\u003e Ok(BinaryOperator::IsNot),\n                _ =\u003e Ok(BinaryOperator::Is),\n            },\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n\n    pub fn is_expression(\u0026self) -\u003e bool {\n        match self {\n            Token::Identifier(_)\n            | Token::Integer(_)\n            | Token::Float(_)\n            | Token::Boolean(_)\n            | Token::String(_)\n            | Token::Null\n            | Token::LeftParentheses\n            | Token::Not =\u003e true,\n            Token::Operator(operator) =\u003e operator.is_unary_operator(),\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl TryInto\u003cBinaryOperator\u003e for Token {\n    type Error = RRDBError;\n\n    fn try_into(self) -\u003e Result\u003cBinaryOperator, RRDBError\u003e {\n        match self {\n            Token::Operator(operator) =\u003e operator.try_into(),\n            Token::And =\u003e Ok(BinaryOperator::And),\n            Token::Or =\u003e Ok(BinaryOperator::Or),\n            Token::Like =\u003e Ok(BinaryOperator::Like),\n            Token::In =\u003e Ok(BinaryOperator::In),\n            Token::Is =\u003e Ok(BinaryOperator::Is),\n            _ =\u003e Err(IntoError::wrap(\"BinaryOperator Cast Error\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        ast::dml::expressions::operators::BinaryOperator,\n        lexer::{predule::OperatorToken, tokens::Token},\n    };\n\n    #[test]\n    fn test_token_is_unary_operator() {\n        let test_cases = vec![\n            (Token::Operator(OperatorToken::Plus), true),\n            (Token::Operator(OperatorToken::Minus), true),\n            (Token::Operator(OperatorToken::Not), true),\n            (Token::And, false),\n            (Token::Or, false),\n            (Token::Like, false),\n            (Token::In, false),\n            (Token::Is, false),\n            (Token::Identifier(\"test\".to_owned()), false),\n            (Token::Integer(1), false),\n            (Token::Float(1.0), false),\n            (Token::Boolean(true), false),\n            (Token::String(\"test\".to_owned()), false),\n            (Token::Null, false),\n            (Token::LeftParentheses, false),\n        ];\n\n        for (token, want) in test_cases {\n            assert_eq!(token.is_unary_operator(), want);\n        }\n    }\n\n    #[test]\n    fn test_token_try_into_multi_token_operator() {\n        struct TestCase {\n            name: String,\n            first: Token,\n            second: Token,\n            expected: BinaryOperator,\n            want_error: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"NOT LIKE\".into(),\n                first: Token::Not,\n                second: Token::Like,\n                expected: BinaryOperator::NotLike,\n                want_error: false,\n            },\n            TestCase {\n                name: \"NOT IN\".into(),\n                first: Token::Not,\n                second: Token::In,\n                expected: BinaryOperator::NotIn,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS NOT\".into(),\n                first: Token::Is,\n                second: Token::Not,\n                expected: BinaryOperator::IsNot,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS\".into(),\n                first: Token::Is,\n                second: Token::Is,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"NOT AND\".into(),\n                first: Token::Not,\n                second: Token::And,\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n            TestCase {\n                name: \"IS LIKE\".into(),\n                first: Token::Is,\n                second: Token::Like,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"Error\".into(),\n                first: Token::Select,\n                second: Token::Like,\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n        ];\n\n        for t in test_cases {\n            let got = t.first.try_into_multi_token_operator(t.second);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n\n    #[test]\n    fn test_token_is_expression() {\n        struct TestCase {\n            name: String,\n            input: Token,\n            expected: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"Identifier\".into(),\n                input: Token::Identifier(\"test\".into()),\n                expected: true,\n            },\n            TestCase {\n                name: \"Integer\".into(),\n                input: Token::Integer(1),\n                expected: true,\n            },\n            TestCase {\n                name: \"Float\".into(),\n                input: Token::Float(1.0),\n                expected: true,\n            },\n            TestCase {\n                name: \"Boolean\".into(),\n                input: Token::Boolean(true),\n                expected: true,\n            },\n            TestCase {\n                name: \"String\".into(),\n                input: Token::String(\"test\".into()),\n                expected: true,\n            },\n            TestCase {\n                name: \"Null\".into(),\n                input: Token::Null,\n                expected: true,\n            },\n            TestCase {\n                name: \"LeftParentheses\".into(),\n                input: Token::LeftParentheses,\n                expected: true,\n            },\n            TestCase {\n                name: \"Not\".into(),\n                input: Token::Not,\n                expected: true,\n            },\n            TestCase {\n                name: \"Operator\".into(),\n                input: Token::Operator(OperatorToken::Plus),\n                expected: true,\n            },\n            TestCase {\n                name: \"And\".into(),\n                input: Token::And,\n                expected: false,\n            },\n            TestCase {\n                name: \"Or\".into(),\n                input: Token::Or,\n                expected: false,\n            },\n            TestCase {\n                name: \"Like\".into(),\n                input: Token::Like,\n                expected: false,\n            },\n            TestCase {\n                name: \"In\".into(),\n                input: Token::In,\n                expected: false,\n            },\n            TestCase {\n                name: \"Is\".into(),\n                input: Token::Is,\n                expected: false,\n            },\n            TestCase {\n                name: \"Comma\".into(),\n                input: Token::Comma,\n                expected: false,\n            },\n            TestCase {\n                name: \"Period\".into(),\n                input: Token::Period,\n                expected: false,\n            },\n            TestCase {\n                name: \"SemiColon\".into(),\n                input: Token::SemiColon,\n                expected: false,\n            },\n            TestCase {\n                name: \"RightParentheses\".into(),\n                input: Token::RightParentheses,\n                expected: false,\n            },\n            TestCase {\n                name: \"EOF\".into(),\n                input: Token::EOF,\n                expected: false,\n            },\n        ];\n\n        for t in test_cases {\n            let got = t.input.is_expression();\n            assert_eq!(got, t.expected, \"TC: {}\", t.name);\n        }\n    }\n\n    #[test]\n    fn test_token_try_into_binary_operator() {\n        struct TestCase {\n            name: String,\n            input: Token,\n            expected: BinaryOperator,\n            want_error: bool,\n        }\n\n        let test_cases = vec![\n            TestCase {\n                name: \"AND\".into(),\n                input: Token::And,\n                expected: BinaryOperator::And,\n                want_error: false,\n            },\n            TestCase {\n                name: \"OR\".into(),\n                input: Token::Or,\n                expected: BinaryOperator::Or,\n                want_error: false,\n            },\n            TestCase {\n                name: \"LIKE\".into(),\n                input: Token::Like,\n                expected: BinaryOperator::Like,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IN\".into(),\n                input: Token::In,\n                expected: BinaryOperator::In,\n                want_error: false,\n            },\n            TestCase {\n                name: \"IS\".into(),\n                input: Token::Is,\n                expected: BinaryOperator::Is,\n                want_error: false,\n            },\n            TestCase {\n                name: \"Identifier\".into(),\n                input: Token::Identifier(\"test\".into()),\n                expected: BinaryOperator::Is,\n                want_error: true,\n            },\n        ];\n\n        for t in test_cases {\n            let got = TryInto::\u003cBinaryOperator\u003e::try_into(t.input);\n\n            assert_eq!(\n                got.is_err(),\n                t.want_error,\n                \"{}: want_error: {}, error: {:?}\",\n                t.name,\n                t.want_error,\n                got.err()\n            );\n\n            if let Ok(tokens) = got {\n                assert_eq!(tokens, t.expected, \"TC: {}\", t.name);\n            }\n        }\n    }\n}\n","traces":[{"line":112,"address":[5764384],"length":1,"stats":{"Line":4}},{"line":114,"address":[5764389],"length":1,"stats":{"Line":4}},{"line":120,"address":[5764416],"length":1,"stats":{"Line":1}},{"line":121,"address":[5764430],"length":1,"stats":{"Line":1}},{"line":122,"address":[5764444],"length":1,"stats":{"Line":1}},{"line":123,"address":[5764466],"length":1,"stats":{"Line":1}},{"line":129,"address":[5764496],"length":1,"stats":{"Line":2}},{"line":131,"address":[5764501],"length":1,"stats":{"Line":2}},{"line":132,"address":[5764521],"length":1,"stats":{"Line":1}},{"line":133,"address":[5764514],"length":1,"stats":{"Line":2}},{"line":137,"address":[5764544,5764987],"length":1,"stats":{"Line":1}},{"line":141,"address":[5764571],"length":1,"stats":{"Line":1}},{"line":142,"address":[5764635],"length":1,"stats":{"Line":1}},{"line":143,"address":[5764716],"length":1,"stats":{"Line":1}},{"line":144,"address":[5764742],"length":1,"stats":{"Line":1}},{"line":145,"address":[5764687,5764818],"length":1,"stats":{"Line":2}},{"line":147,"address":[5764669],"length":1,"stats":{"Line":1}},{"line":148,"address":[5764840],"length":1,"stats":{"Line":1}},{"line":149,"address":[5764872],"length":1,"stats":{"Line":1}},{"line":151,"address":[5764600,5764907],"length":1,"stats":{"Line":2}},{"line":155,"address":[5765024],"length":1,"stats":{"Line":1}},{"line":156,"address":[5765037],"length":1,"stats":{"Line":1}},{"line":157,"address":[5765103],"length":1,"stats":{"Line":1}},{"line":165,"address":[5765114],"length":1,"stats":{"Line":1}},{"line":166,"address":[5765096],"length":1,"stats":{"Line":1}},{"line":174,"address":[5765503,5765152],"length":1,"stats":{"Line":1}},{"line":175,"address":[5765174],"length":1,"stats":{"Line":1}},{"line":176,"address":[5765383,5765454],"length":1,"stats":{"Line":4}},{"line":177,"address":[5765245],"length":1,"stats":{"Line":1}},{"line":178,"address":[5765274],"length":1,"stats":{"Line":1}},{"line":179,"address":[5765300],"length":1,"stats":{"Line":1}},{"line":180,"address":[5765326],"length":1,"stats":{"Line":1}},{"line":181,"address":[5765352],"length":1,"stats":{"Line":1}},{"line":182,"address":[5765461,5765213],"length":1,"stats":{"Line":2}}],"covered":34,"coverable":34},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","logger.rs"],"content":"use colored::Colorize;\n\npub struct Logger {}\n\nimpl Logger {\n    pub fn error(text: impl Into\u003cString\u003e) {\n        println!(\"{}\", format!(\"!![ERROR] {}\", text.into()).red());\n    }\n\n    pub fn info(text: impl Into\u003cString\u003e) {\n        println!(\"{}\", format!(\"@@[INFO] {}\", text.into()).green());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_error() {\n        Logger::error(\"This is an error message\");\n    }\n\n    #[test]\n    fn test_info() {\n        Logger::info(\"This is an info message\");\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":1}},{"line":10,"address":[],"length":0,"stats":{"Line":3}},{"line":11,"address":[],"length":0,"stats":{"Line":3}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","mod.rs"],"content":"#[allow(clippy::module_inception)]\npub mod logger;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","logger","predule.rs"],"content":"pub use super::logger::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","main.rs"],"content":"pub mod ast;\npub mod command;\npub mod constants;\npub mod errors;\npub mod executor;\npub mod lexer;\npub mod logger;\npub mod optimizer;\npub mod parser;\npub mod pgwire;\npub mod server;\npub mod utils;\n\nuse std::sync::Arc;\n\nuse command::{Command, SubCommand};\nuse errors::RRDBError;\nuse executor::{config::global::GlobalConfig, predule::Executor};\nuse server::predule::Server;\n\nuse clap::Parser;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), RRDBError\u003e {\n    let args = Command::parse();\n\n    match args.action {\n        SubCommand::Init(init) =\u003e {\n            let config = GlobalConfig::load_from_path(None).unwrap_or_default();\n\n            let _init_option = init.init;\n\n            let executor = Executor::new(Arc::new(config));\n\n            executor.init_config().await?;\n            executor.init_database().await?;\n        }\n        SubCommand::Run(run) =\u003e {\n            let config = GlobalConfig::load_from_path(run.value.config).expect(\"config load error\");\n\n            let server = Server::new(config);\n\n            server.run().await?;\n        }\n        SubCommand::Client =\u003e {\n            println!(\"Client\");\n            unimplemented!();\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":24,"address":[4553504,4553909],"length":1,"stats":{"Line":0}},{"line":25,"address":[5458581],"length":1,"stats":{"Line":0}},{"line":27,"address":[4553675,4553545,4553784,4553605],"length":1,"stats":{"Line":0}},{"line":28,"address":[5458760],"length":1,"stats":{"Line":0}},{"line":29,"address":[5459005,5458800],"length":1,"stats":{"Line":0}},{"line":31,"address":[5459012],"length":1,"stats":{"Line":0}},{"line":33,"address":[5459047,5459102],"length":1,"stats":{"Line":0}},{"line":35,"address":[4795581],"length":1,"stats":{"Line":0}},{"line":36,"address":[4795597],"length":1,"stats":{"Line":0}},{"line":38,"address":[5458834],"length":1,"stats":{"Line":0}},{"line":39,"address":[5458863,5459262],"length":1,"stats":{"Line":0}},{"line":41,"address":[5459304],"length":1,"stats":{"Line":0}},{"line":43,"address":[4795613],"length":1,"stats":{"Line":0}},{"line":46,"address":[5458921,5459498],"length":1,"stats":{"Line":0}},{"line":51,"address":[4553806,4553629],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","mod.rs"],"content":"#[allow(clippy::module_inception)]\npub mod optimizer;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","optimizer.rs"],"content":"use crate::{\n    ast::dml::{\n        delete::DeleteQuery,\n        parts::from::FromTarget,\n        plan::{\n            delete::{delete_plan::DeletePlan, from::DeleteFromPlan},\n            select::{\n                filter::FilterPlan,\n                from::SelectFromPlan,\n                limit_offset::LimitOffsetPlan,\n                scan::ScanType,\n                select_plan::{SelectPlan, SelectPlanItem},\n            },\n            update::{from::UpdateFromPlan, update_plan::UpdatePlan},\n        },\n        select::SelectQuery,\n        update::UpdateQuery,\n    },\n    errors::RRDBError,\n};\n\npub struct Optimizer {}\n\nimpl Optimizer {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n\n    pub async fn optimize_select(\u0026self, query: SelectQuery) -\u003e Result\u003cSelectPlan, RRDBError\u003e {\n        let mut has_from = false;\n        let mut plan = SelectPlan { list: vec![] };\n\n        // FROM 절 분석\n        if let Some(from_clause) = query.from_table {\n            has_from = true;\n            let alias = from_clause.alias;\n\n            match from_clause.from {\n                FromTarget::Table(table_name) =\u003e plan.list.push(\n                    SelectFromPlan {\n                        table_name,\n                        alias,\n                        scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n                    }\n                    .into(),\n                ),\n                FromTarget::Subquery(_subquery) =\u003e {}\n            }\n        }\n\n        if has_from {\n            // JOIN 절 구성\n            if !query.join_clause.is_empty() {\n                // TODO\n            }\n\n            // WHERE 절 필터링 구성\n            if let Some(where_clause) = query.where_clause {\n                let expression = where_clause.expression;\n\n                plan.list.push(FilterPlan { expression }.into());\n            }\n\n            // GROUP BY 절 구성\n            if let Some(group_by_clause) = query.group_by_clause {\n                plan.list.push(group_by_clause.into());\n\n                // HAVING 절 구성\n                if let Some(having_clause) = query.having_clause {\n                    plan.list.push(\n                        FilterPlan {\n                            expression: *having_clause.expression,\n                        }\n                        .into(),\n                    );\n                }\n            } else if query.has_aggregate {\n                plan.list.push(SelectPlanItem::GroupAll);\n            }\n\n            // ORDER BY 절 구성\n            if let Some(order_by_clause) = query.order_by_clause {\n                plan.list.push(order_by_clause.into());\n            }\n\n            // LIMIT OFFSET 절 구성\n            if query.limit.is_some() || query.offset.is_some() {\n                plan.list.push(\n                    LimitOffsetPlan {\n                        limit: query.limit,\n                        offset: query.offset,\n                    }\n                    .into(),\n                );\n            }\n        }\n\n        Ok(plan)\n    }\n\n    pub async fn optimize_update(\u0026self, query: UpdateQuery) -\u003e Result\u003cUpdatePlan, RRDBError\u003e {\n        let mut plan = UpdatePlan { list: vec![] };\n\n        let target_table = query.target_table.clone().unwrap();\n\n        plan.list.push(\n            UpdateFromPlan {\n                table_name: target_table.table.clone(),\n                alias: target_table.alias,\n                scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n            }\n            .into(),\n        );\n\n        // WHERE 절 분석\n        if let Some(where_clause) = query.where_clause {\n            // WHERE 절 필터링 구성\n\n            let expression = where_clause.expression;\n\n            plan.list.push(FilterPlan { expression }.into());\n        }\n\n        Ok(plan)\n    }\n\n    pub async fn optimize_delete(\u0026self, query: DeleteQuery) -\u003e Result\u003cDeletePlan, RRDBError\u003e {\n        let mut plan = DeletePlan { list: vec![] };\n\n        let target_table = query.from_table.clone().unwrap();\n\n        plan.list.push(\n            DeleteFromPlan {\n                table_name: target_table.table.clone(),\n                alias: target_table.alias,\n                scan: ScanType::FullScan, // TODO: 인덱스 스캔 처리\n            }\n            .into(),\n        );\n\n        // WHERE 절 분석\n        if let Some(where_clause) = query.where_clause {\n            // WHERE 절 필터링 구성\n\n            let expression = where_clause.expression;\n\n            plan.list.push(FilterPlan { expression }.into());\n        }\n\n        Ok(plan)\n    }\n}\n\nimpl Default for Optimizer {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":29,"address":[4150128,4150163],"length":1,"stats":{"Line":0}},{"line":30,"address":[4416830],"length":1,"stats":{"Line":0}},{"line":31,"address":[4416912,4416846],"length":1,"stats":{"Line":0}},{"line":34,"address":[4417551,4417138,4416960],"length":1,"stats":{"Line":0}},{"line":35,"address":[4417034],"length":1,"stats":{"Line":0}},{"line":36,"address":[4417042],"length":1,"stats":{"Line":0}},{"line":38,"address":[4417098,4416696],"length":1,"stats":{"Line":0}},{"line":39,"address":[4417143,4417524],"length":1,"stats":{"Line":0}},{"line":40,"address":[4417249],"length":1,"stats":{"Line":0}},{"line":42,"address":[4417191],"length":1,"stats":{"Line":0}},{"line":43,"address":[4417241],"length":1,"stats":{"Line":0}},{"line":47,"address":[4417439],"length":1,"stats":{"Line":0}},{"line":51,"address":[4417604],"length":1,"stats":{"Line":0}},{"line":53,"address":[4417757],"length":1,"stats":{"Line":0}},{"line":58,"address":[4417794],"length":1,"stats":{"Line":0}},{"line":59,"address":[4417921],"length":1,"stats":{"Line":0}},{"line":61,"address":[4418001,4418164],"length":1,"stats":{"Line":0}},{"line":65,"address":[4418111,4418173],"length":1,"stats":{"Line":0}},{"line":66,"address":[4418213,4418275],"length":1,"stats":{"Line":0}},{"line":69,"address":[4418282],"length":1,"stats":{"Line":0}},{"line":70,"address":[4418657],"length":1,"stats":{"Line":0}},{"line":71,"address":[4418468],"length":1,"stats":{"Line":0}},{"line":72,"address":[4418583,4418335,4418409],"length":1,"stats":{"Line":0}},{"line":77,"address":[4418243],"length":1,"stats":{"Line":0}},{"line":78,"address":[4418699],"length":1,"stats":{"Line":0}},{"line":82,"address":[4418735,4418363],"length":1,"stats":{"Line":0}},{"line":83,"address":[4418838,4418769],"length":1,"stats":{"Line":0}},{"line":87,"address":[4418851,4418799,4418970],"length":1,"stats":{"Line":0}},{"line":88,"address":[4418995],"length":1,"stats":{"Line":0}},{"line":89,"address":[4418908],"length":1,"stats":{"Line":0}},{"line":90,"address":[4418880],"length":1,"stats":{"Line":0}},{"line":91,"address":[4418894],"length":1,"stats":{"Line":0}},{"line":98,"address":[4417666],"length":1,"stats":{"Line":0}},{"line":101,"address":[4150243,4150208],"length":1,"stats":{"Line":0}},{"line":102,"address":[4420561,4420487],"length":1,"stats":{"Line":0}},{"line":104,"address":[4420601,4420743],"length":1,"stats":{"Line":0}},{"line":106,"address":[4421078],"length":1,"stats":{"Line":0}},{"line":107,"address":[4420872],"length":1,"stats":{"Line":0}},{"line":108,"address":[4420767],"length":1,"stats":{"Line":0}},{"line":109,"address":[4420814],"length":1,"stats":{"Line":0}},{"line":110,"address":[4420864],"length":1,"stats":{"Line":0}},{"line":116,"address":[4421085],"length":1,"stats":{"Line":0}},{"line":119,"address":[4421212],"length":1,"stats":{"Line":0}},{"line":121,"address":[4421292,4421517],"length":1,"stats":{"Line":0}},{"line":124,"address":[4421402],"length":1,"stats":{"Line":0}},{"line":127,"address":[4150323,4150288],"length":1,"stats":{"Line":0}},{"line":128,"address":[4422198,4422272],"length":1,"stats":{"Line":0}},{"line":130,"address":[4422454,4422325],"length":1,"stats":{"Line":0}},{"line":132,"address":[4422789],"length":1,"stats":{"Line":0}},{"line":133,"address":[4422583],"length":1,"stats":{"Line":0}},{"line":134,"address":[4422478],"length":1,"stats":{"Line":0}},{"line":135,"address":[4422525],"length":1,"stats":{"Line":0}},{"line":136,"address":[4422575],"length":1,"stats":{"Line":0}},{"line":142,"address":[4422796],"length":1,"stats":{"Line":0}},{"line":145,"address":[4422914],"length":1,"stats":{"Line":0}},{"line":147,"address":[4422994,4423219],"length":1,"stats":{"Line":0}},{"line":150,"address":[4423104],"length":1,"stats":{"Line":0}},{"line":155,"address":[4150368],"length":1,"stats":{"Line":0}},{"line":156,"address":[4150369],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","home","runner","work","rrdb","rrdb","src","optimizer","predule.rs"],"content":"pub use super::optimizer::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","context.rs"],"content":"#[derive(Debug, Default, Clone)]\npub struct ParserContext {\n    pub in_between_clause: bool,\n    pub in_parentheses: bool,\n    pub default_database: Option\u003cString\u003e,\n}\n\nimpl ParserContext {\n    pub fn set_in_between_clause(mut self, in_between_clause: bool) -\u003e Self {\n        self.in_between_clause = in_between_clause;\n        self\n    }\n\n    pub fn set_in_parentheses(mut self, in_parentheses: bool) -\u003e Self {\n        self.in_parentheses = in_parentheses;\n        self\n    }\n\n    pub fn set_default_database(mut self, default_database: String) -\u003e Self {\n        self.default_database = Some(default_database);\n        self\n    }\n}\n","traces":[{"line":9,"address":[5284496],"length":1,"stats":{"Line":1}},{"line":10,"address":[5284510],"length":1,"stats":{"Line":1}},{"line":11,"address":[5284516],"length":1,"stats":{"Line":1}},{"line":14,"address":[5284560],"length":1,"stats":{"Line":1}},{"line":15,"address":[5284574],"length":1,"stats":{"Line":1}},{"line":16,"address":[5284580],"length":1,"stats":{"Line":1}},{"line":19,"address":[5284800,5284624],"length":1,"stats":{"Line":1}},{"line":20,"address":[5284651,5284739],"length":1,"stats":{"Line":2}},{"line":21,"address":[5284765],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","common.rs"],"content":"use crate::ast::dml::expressions::subquery::SubqueryExpression;\nuse crate::ast::dml::parts::join::JoinType;\nuse crate::ast::types::{Column, DataType, SelectColumn, TableName};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    // 테이블 컬럼 정의 분석\n    pub(crate) fn parse_table_column(\u0026mut self) -\u003e Result\u003cColumn, RRDBError\u003e {\n        let mut builder = Column::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0001 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(name) = current_token {\n            builder = builder.set_name(name);\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0028 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let data_type = self.parse_data_type()?;\n        builder = builder.set_data_type(data_type);\n\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Comma =\u003e {\n                    // , 만나면 종료\n                    break;\n                }\n                Token::RightParentheses =\u003e {\n                    // ) 만나면 종료\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::Primary =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0003 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Key =\u003e {\n                            builder = builder.set_primary_key(true).set_not_null(true);\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected 'PRIMARY KEY'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0004 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Null =\u003e {\n                            builder = builder.set_not_null(true);\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected 'NOT NULL'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n                Token::Null =\u003e {\n                    builder = builder.set_not_null(false);\n                }\n                Token::Comment =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0005 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if let Token::String(comment) = current_token {\n                        builder = builder.set_comment(comment);\n                    } else {\n                        return Err(ParsingError::wrap(format!(\n                            \"expected comment string. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n                }\n                Token::Default =\u003e {\n                    return Err(ParsingError::wrap(\"not supported yet\"));\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(builder.build())\n    }\n\n    // 데이터 타입 분석\n    pub(crate) fn parse_data_type(\u0026mut self) -\u003e Result\u003cDataType, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0006 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(type_name) = current_token {\n            match type_name.to_uppercase().as_str() {\n                \"INTEGER\" | \"INT\" =\u003e Ok(DataType::Int),\n                \"FLOAT\" =\u003e Ok(DataType::Float),\n                \"BOOLEAN\" | \"BOOL\" =\u003e Ok(DataType::Boolean),\n                \"VARCHAR\" =\u003e {\n                    // 여는 괄호 체크\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0007 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if Token::LeftParentheses != current_token {\n                        return Err(ParsingError::wrap(format!(\n                            \"expected '('. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n\n                    // 문자열 길이 체크\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0008 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if let Token::Integer(integer) = current_token {\n                        // 닫는 괄호 체크\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E0009 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if Token::RightParentheses != current_token {\n                            return Err(ParsingError::wrap(format!(\n                                \"expected ')'. but your input word is '{:?}'\",\n                                current_token\n                            )));\n                        }\n\n                        Ok(DataType::Varchar(integer))\n                    } else {\n                        Err(ParsingError::wrap(format!(\n                            \"expected integer number. but your input word is '{:?}'\",\n                            current_token\n                        )))\n                    }\n                }\n                _ =\u003e Err(ParsingError::wrap(format!(\n                    \"unknown data type '{}'\",\n                    type_name\n                ))),\n            }\n        } else {\n            Err(ParsingError::wrap(format!(\n                \"E0029 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )))\n        }\n    }\n\n    // 테이블명 분석\n    pub(crate) fn parse_table_name(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cTableName, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0010 need more tokens\"));\n        }\n\n        // 첫번째로 오는 이름은 테이블명으로 추정\n        let current_token = self.get_next_token();\n        let mut database_name = None;\n\n        let mut table_name = if let Token::Identifier(name) = current_token {\n            name\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0030 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        };\n\n        if !self.has_next_token() {\n            return Ok(TableName::new(\n                database_name.or(context.default_database),\n                table_name,\n            ));\n        }\n\n        let current_token = self.get_next_token();\n\n        // .가 있을 경우 \"데이터베이스명\".\"테이블명\"의 형태로 추정\n        if current_token == Token::Period {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0012 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if let Token::Identifier(name) = current_token {\n                database_name = Some(table_name);\n                table_name = name;\n            } else {\n                return Err(ParsingError::wrap(format!(\n                    \"E0031 expected identifier. but your input word is '{:?}'\",\n                    current_token\n                )));\n            }\n        } else {\n            self.unget_next_token(current_token);\n        }\n\n        Ok(TableName::new(\n            database_name.or(context.default_database),\n            table_name,\n        ))\n    }\n\n    // IF NOT EXISTS 체크 로직\n    pub(crate) fn has_if_not_exists(\u0026mut self) -\u003e Result\u003cbool, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0013 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::If == current_token {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0014 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if Token::Not == current_token {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0015 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if Token::Exists == current_token {\n                    Ok(true)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"expected keyword is 'exists'. but your input word is '{:?}'\",\n                        current_token\n                    )))\n                }\n            } else {\n                Err(ParsingError::wrap(format!(\n                    \"expected keyword is 'not'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        } else {\n            self.unget_next_token(current_token);\n            Ok(false)\n        }\n    }\n\n    // IF EXISTS 체크 로직\n    pub(crate) fn has_if_exists(\u0026mut self) -\u003e Result\u003cbool, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0016 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::If == current_token {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0017 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            if Token::Exists == current_token {\n                Ok(true)\n            } else {\n                Err(ParsingError::wrap(format!(\n                    \"expected keyword is 'exists'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        } else {\n            self.unget_next_token(current_token);\n            Ok(false)\n        }\n    }\n\n    // SELECT 컬럼 정의 분석\n    pub(crate) fn parse_select_column(\u0026mut self) -\u003e Result\u003cSelectColumn, RRDBError\u003e {\n        let mut select_column = SelectColumn::new(None, \"\".to_string());\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0018 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if let Token::Identifier(name) = current_token {\n            select_column.column_name = name;\n        } else {\n            return Err(ParsingError::wrap(format!(\n                \"E0032 expected identifier. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            Ok(select_column)\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::Period {\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(name) = current_token {\n                    select_column.table_name = Some(select_column.column_name);\n                    select_column.column_name = name;\n                    Ok(select_column)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"E0033 expected identifier. but your input word is '{:?}'\",\n                        current_token\n                    )))\n                }\n            } else {\n                self.unget_next_token(current_token);\n                Ok(select_column)\n            }\n        }\n    }\n\n    // 다음 토큰이 2항 연산자/키워드인지\n    pub(crate) fn next_token_is_binary_operator(\u0026mut self, context: ParserContext) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            // 2항 키워드, 연산자일 경우에만 true 반환\n            match current_token {\n                Token::And =\u003e {\n                    self.unget_next_token(current_token);\n\n                    // BETWEEN 파싱중이면서 괄호가 없는 상태라면 연산자가 아닌 것으로 간주.\n                    #[allow(clippy::needless_bool)]\n                    if context.in_between_clause \u0026\u0026 !context.in_parentheses {\n                        false\n                    } else {\n                        true\n                    }\n                }\n                Token::Or | Token::Like | Token::In =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Operator(ref operator) =\u003e {\n                    let result = [\n                        OperatorToken::Plus,\n                        OperatorToken::Minus,\n                        OperatorToken::Asterisk,\n                        OperatorToken::Slash,\n                        OperatorToken::Lt,\n                        OperatorToken::Lte,\n                        OperatorToken::Gt,\n                        OperatorToken::Gte,\n                        OperatorToken::Eq,\n                        OperatorToken::Neq,\n                    ]\n                    .contains(operator);\n\n                    self.unget_next_token(current_token);\n\n                    result\n                }\n                Token::Is =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::In | Token::Like =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn next_token_is_left_parentheses(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::LeftParentheses\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn _next_token_is_subquery(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::LeftParentheses {\n                if !self.has_next_token() {\n                    self.unget_next_token(current_token);\n                    false\n                } else {\n                    let second_token = self.get_next_token();\n\n                    if second_token == Token::Select {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        true\n                    } else {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        false\n                    }\n                }\n            } else {\n                self.unget_next_token(current_token);\n                false\n            }\n        }\n    }\n\n    // 다음 토큰이 닫는 괄호인지\n    pub(crate) fn next_token_is_right_parentheses(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::RightParentheses\n        }\n    }\n\n    // 다음 토큰이 쉼표인지\n    pub(crate) fn next_token_is_comma(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            self.unget_next_token(current_token.clone());\n\n            current_token == Token::Comma\n        }\n    }\n\n    // 다음 토큰이 여는 괄호인지\n    pub(crate) fn next_token_is_between(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Between =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n                        match second_token.clone() {\n                            Token::Between =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 AS인지\n    pub(crate) fn next_token_is_table_alias(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token.clone() {\n                Token::As =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                Token::Identifier(_) =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 AS인지\n    pub(crate) fn next_token_is_where(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token.clone() {\n                Token::Where =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 ORDER BY인지\n    pub(crate) fn next_token_is_order_by(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Order =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        return false;\n                    }\n\n                    let second_token = self.get_next_token();\n\n                    match second_token {\n                        Token::By =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            true\n                        }\n                        _ =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            false\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 GROUP BY인지\n    pub(crate) fn next_token_is_group_by(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Group =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        return false;\n                    }\n\n                    let second_token = self.get_next_token();\n\n                    match second_token {\n                        Token::By =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            true\n                        }\n                        _ =\u003e {\n                            self.unget_next_token(second_token);\n                            self.unget_next_token(current_token);\n                            false\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 HAVING인지\n    pub(crate) fn next_token_is_having(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Having =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 OFFSET인지\n    pub(crate) fn next_token_is_offset(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Offset =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 OFFSET인지\n    pub(crate) fn next_token_is_limit(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Limit =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_column(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Column =\u003e {\n                    self.unget_next_token(current_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_not_null(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Not =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(first_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Null =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_data_type(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Data =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(first_token);\n                        false\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Type =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                true\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(first_token);\n                                false\n                            }\n                        }\n                    }\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 COLUMN인지\n    pub(crate) fn next_token_is_default(\u0026mut self) -\u003e bool {\n        if !self.has_next_token() {\n            false\n        } else {\n            let first_token = self.get_next_token();\n\n            match first_token {\n                Token::Default =\u003e {\n                    self.unget_next_token(first_token);\n                    true\n                }\n                _ =\u003e {\n                    self.unget_next_token(first_token);\n                    false\n                }\n            }\n        }\n    }\n\n    // 다음 토큰이 JOIN 토큰이라면 JOIN 타입을 추출해서 반환\n    pub(crate) fn get_next_join_type(\u0026mut self) -\u003e Option\u003cJoinType\u003e {\n        if !self.has_next_token() {\n            None\n        } else {\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Inner =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e Some(JoinType::InnerJoin),\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Left | Token::Right =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e match current_token {\n                                Token::Left =\u003e Some(JoinType::LeftOuterJoin),\n                                Token::Right =\u003e Some(JoinType::RightOuterJoin),\n                                _ =\u003e unreachable!(),\n                            },\n                            Token::Outer =\u003e {\n                                if !self.has_next_token() {\n                                    self.unget_next_token(second_token);\n                                    self.unget_next_token(current_token);\n                                    None\n                                } else {\n                                    let third_token = self.get_next_token();\n\n                                    match third_token {\n                                        Token::Join =\u003e match current_token {\n                                            Token::Left =\u003e Some(JoinType::LeftOuterJoin),\n                                            Token::Right =\u003e Some(JoinType::RightOuterJoin),\n                                            _ =\u003e unreachable!(),\n                                        },\n                                        _ =\u003e {\n                                            self.unget_next_token(third_token);\n                                            self.unget_next_token(second_token);\n                                            self.unget_next_token(current_token);\n                                            None\n                                        }\n                                    }\n                                }\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Full =\u003e {\n                    if !self.has_next_token() {\n                        self.unget_next_token(current_token);\n                        None\n                    } else {\n                        let second_token = self.get_next_token();\n\n                        match second_token {\n                            Token::Join =\u003e Some(JoinType::FullOuterJoin),\n                            Token::Outer =\u003e {\n                                if !self.has_next_token() {\n                                    self.unget_next_token(current_token);\n                                    None\n                                } else {\n                                    let third_token = self.get_next_token();\n\n                                    match third_token {\n                                        Token::Join =\u003e Some(JoinType::FullOuterJoin),\n                                        _ =\u003e {\n                                            self.unget_next_token(third_token);\n                                            self.unget_next_token(second_token);\n                                            self.unget_next_token(current_token);\n                                            None\n                                        }\n                                    }\n                                }\n                            }\n                            _ =\u003e {\n                                self.unget_next_token(second_token);\n                                self.unget_next_token(current_token);\n                                None\n                            }\n                        }\n                    }\n                }\n                Token::Join =\u003e Some(JoinType::InnerJoin),\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    None\n                }\n            }\n        }\n    }\n\n    // Table Alias 획득\n    pub(crate) fn parse_table_alias(\u0026mut self) -\u003e Result\u003cString, RRDBError\u003e {\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0024 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::As =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0026 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(id) =\u003e Ok(id),\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"E0027 expected identifier. but your input is {:?}\",\n                        current_token\n                    ))),\n                }\n            }\n            Token::Identifier(id) =\u003e Ok(id),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0025 expected AS. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    // 서브쿼리 분석\n    pub(crate) fn parse_subquery(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSubqueryExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0019 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0020 expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0021 need more tokens\"));\n        }\n\n        // 서브쿼리 파싱\n        let select = self.handle_select_query(context)?;\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0022 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0023 expected right parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        Ok(select.into())\n    }\n}\n","traces":[{"line":11,"address":[5090928,5094712,5093029],"length":1,"stats":{"Line":1}},{"line":12,"address":[5090973],"length":1,"stats":{"Line":2}},{"line":14,"address":[5091087,5091031],"length":1,"stats":{"Line":4}},{"line":15,"address":[5091145,5091093],"length":1,"stats":{"Line":0}},{"line":18,"address":[5091205,5091133],"length":1,"stats":{"Line":4}},{"line":20,"address":[5091213],"length":1,"stats":{"Line":2}},{"line":21,"address":[5091267,5091485],"length":1,"stats":{"Line":4}},{"line":23,"address":[5094458],"length":1,"stats":{"Line":0}},{"line":29,"address":[5091712,5094453,5091536],"length":1,"stats":{"Line":2}},{"line":30,"address":[5091634,5091817],"length":1,"stats":{"Line":4}},{"line":32,"address":[5094448],"length":1,"stats":{"Line":2}},{"line":33,"address":[5091856],"length":1,"stats":{"Line":2}},{"line":37,"address":[5091956],"length":1,"stats":{"Line":2}},{"line":39,"address":[5091971],"length":1,"stats":{"Line":2}},{"line":46,"address":[5092212,5094306],"length":1,"stats":{"Line":2}},{"line":50,"address":[5092057,5093042],"length":1,"stats":{"Line":2}},{"line":51,"address":[5093048,5093100],"length":1,"stats":{"Line":0}},{"line":54,"address":[5093088],"length":1,"stats":{"Line":1}},{"line":56,"address":[5093139],"length":1,"stats":{"Line":1}},{"line":58,"address":[5093153,5093381],"length":1,"stats":{"Line":2}},{"line":61,"address":[5093444],"length":1,"stats":{"Line":0}},{"line":69,"address":[5092106,5093678],"length":1,"stats":{"Line":0}},{"line":70,"address":[5093736,5093684],"length":1,"stats":{"Line":0}},{"line":73,"address":[5093724],"length":1,"stats":{"Line":0}},{"line":75,"address":[5093775],"length":1,"stats":{"Line":0}},{"line":77,"address":[5093789,5093994],"length":1,"stats":{"Line":0}},{"line":80,"address":[5094050],"length":1,"stats":{"Line":0}},{"line":87,"address":[5094301],"length":1,"stats":{"Line":0}},{"line":88,"address":[5094267,5092120],"length":1,"stats":{"Line":0}},{"line":91,"address":[5092038,5092315],"length":1,"stats":{"Line":0}},{"line":92,"address":[5092373,5092321],"length":1,"stats":{"Line":0}},{"line":95,"address":[5092425,5092361],"length":1,"stats":{"Line":0}},{"line":97,"address":[5092433],"length":1,"stats":{"Line":0}},{"line":98,"address":[5092702,5092487],"length":1,"stats":{"Line":0}},{"line":100,"address":[5092778],"length":1,"stats":{"Line":0}},{"line":107,"address":[5092071,5093635],"length":1,"stats":{"Line":0}},{"line":113,"address":[5094344,5091877],"length":1,"stats":{"Line":4}},{"line":117,"address":[5097027,5097659,5094752],"length":1,"stats":{"Line":2}},{"line":118,"address":[5094790],"length":1,"stats":{"Line":2}},{"line":119,"address":[5094807],"length":1,"stats":{"Line":0}},{"line":122,"address":[5094856],"length":1,"stats":{"Line":2}},{"line":124,"address":[5094877,5094906],"length":1,"stats":{"Line":4}},{"line":125,"address":[5094954,5095127,5095222],"length":1,"stats":{"Line":6}},{"line":126,"address":[5095238],"length":1,"stats":{"Line":2}},{"line":127,"address":[5095448,5095377],"length":1,"stats":{"Line":2}},{"line":128,"address":[5095420,5095500],"length":1,"stats":{"Line":4}},{"line":129,"address":[5095612],"length":1,"stats":{"Line":2}},{"line":131,"address":[5095746,5095905],"length":1,"stats":{"Line":4}},{"line":132,"address":[5095911,5095963],"length":1,"stats":{"Line":0}},{"line":135,"address":[5095951],"length":1,"stats":{"Line":2}},{"line":137,"address":[5096073,5096003],"length":1,"stats":{"Line":4}},{"line":138,"address":[5097178],"length":1,"stats":{"Line":0}},{"line":145,"address":[5096198,5096084],"length":1,"stats":{"Line":4}},{"line":146,"address":[5096204,5096256],"length":1,"stats":{"Line":0}},{"line":149,"address":[5096244],"length":1,"stats":{"Line":2}},{"line":151,"address":[5097155,5096292],"length":1,"stats":{"Line":2}},{"line":153,"address":[5096332,5096489],"length":1,"stats":{"Line":4}},{"line":154,"address":[5096495,5096547],"length":1,"stats":{"Line":0}},{"line":157,"address":[5096535],"length":1,"stats":{"Line":2}},{"line":159,"address":[5096583,5096653],"length":1,"stats":{"Line":4}},{"line":160,"address":[5096849],"length":1,"stats":{"Line":0}},{"line":166,"address":[5096669],"length":1,"stats":{"Line":2}},{"line":168,"address":[5097036],"length":1,"stats":{"Line":0}},{"line":174,"address":[5095760],"length":1,"stats":{"Line":0}},{"line":180,"address":[5097450],"length":1,"stats":{"Line":0}},{"line":188,"address":[5100422,5099625,5097696],"length":1,"stats":{"Line":2}},{"line":193,"address":[5097851,5097739],"length":1,"stats":{"Line":4}},{"line":194,"address":[5097906,5097857],"length":1,"stats":{"Line":0}},{"line":198,"address":[5097894,5097940],"length":1,"stats":{"Line":4}},{"line":199,"address":[5097948],"length":1,"stats":{"Line":2}},{"line":201,"address":[5097974],"length":1,"stats":{"Line":2}},{"line":202,"address":[5098033],"length":1,"stats":{"Line":2}},{"line":204,"address":[5100062],"length":1,"stats":{"Line":0}},{"line":210,"address":[5098231,5098073],"length":1,"stats":{"Line":4}},{"line":211,"address":[5098431],"length":1,"stats":{"Line":0}},{"line":212,"address":[5098242],"length":1,"stats":{"Line":0}},{"line":213,"address":[5098367],"length":1,"stats":{"Line":0}},{"line":217,"address":[5098357,5098496],"length":1,"stats":{"Line":4}},{"line":220,"address":[5099392,5098504,5098575],"length":1,"stats":{"Line":5}},{"line":221,"address":[5098773,5098646],"length":1,"stats":{"Line":2}},{"line":222,"address":[5098779,5098831],"length":1,"stats":{"Line":0}},{"line":225,"address":[5098819,5098867],"length":1,"stats":{"Line":2}},{"line":227,"address":[5098875],"length":1,"stats":{"Line":1}},{"line":228,"address":[5099126,5098933,5099210],"length":1,"stats":{"Line":2}},{"line":229,"address":[5099266],"length":1,"stats":{"Line":1}},{"line":231,"address":[5099679],"length":1,"stats":{"Line":0}},{"line":237,"address":[5098657,5098586],"length":1,"stats":{"Line":4}},{"line":240,"address":[5099476],"length":1,"stats":{"Line":2}},{"line":241,"address":[5098664],"length":1,"stats":{"Line":2}},{"line":242,"address":[5099412],"length":1,"stats":{"Line":2}},{"line":247,"address":[5100464,5101720],"length":1,"stats":{"Line":2}},{"line":249,"address":[5100502],"length":1,"stats":{"Line":3}},{"line":250,"address":[5100519],"length":1,"stats":{"Line":0}},{"line":253,"address":[5100568],"length":1,"stats":{"Line":3}},{"line":255,"address":[5100675,5100599],"length":1,"stats":{"Line":6}},{"line":256,"address":[5100796,5100746],"length":1,"stats":{"Line":2}},{"line":257,"address":[5100854,5100802],"length":1,"stats":{"Line":0}},{"line":260,"address":[5100842],"length":1,"stats":{"Line":1}},{"line":262,"address":[5100898,5100968],"length":1,"stats":{"Line":2}},{"line":263,"address":[5101230,5101075],"length":1,"stats":{"Line":2}},{"line":264,"address":[5101288,5101236],"length":1,"stats":{"Line":0}},{"line":267,"address":[5101276],"length":1,"stats":{"Line":1}},{"line":269,"address":[5101553,5101365,5101435],"length":1,"stats":{"Line":3}},{"line":270,"address":[5101542],"length":1,"stats":{"Line":1}},{"line":272,"address":[5101555],"length":1,"stats":{"Line":0}},{"line":278,"address":[5101089],"length":1,"stats":{"Line":0}},{"line":284,"address":[5100686],"length":1,"stats":{"Line":2}},{"line":285,"address":[5100762],"length":1,"stats":{"Line":2}},{"line":290,"address":[5101760,5102549],"length":1,"stats":{"Line":2}},{"line":292,"address":[5101798],"length":1,"stats":{"Line":2}},{"line":293,"address":[5101815],"length":1,"stats":{"Line":0}},{"line":296,"address":[5101864],"length":1,"stats":{"Line":2}},{"line":298,"address":[5101895,5101971],"length":1,"stats":{"Line":4}},{"line":299,"address":[5102042,5102092],"length":1,"stats":{"Line":4}},{"line":300,"address":[5102150,5102098],"length":1,"stats":{"Line":0}},{"line":303,"address":[5102138],"length":1,"stats":{"Line":2}},{"line":305,"address":[5102382,5102194,5102264],"length":1,"stats":{"Line":6}},{"line":306,"address":[5102371],"length":1,"stats":{"Line":2}},{"line":308,"address":[5102384],"length":1,"stats":{"Line":0}},{"line":314,"address":[5101982],"length":1,"stats":{"Line":0}},{"line":315,"address":[5102058],"length":1,"stats":{"Line":0}},{"line":320,"address":[5104285,5102592,5104691],"length":1,"stats":{"Line":1}},{"line":321,"address":[5102622,5105086],"length":1,"stats":{"Line":1}},{"line":323,"address":[5102814,5102870],"length":1,"stats":{"Line":2}},{"line":324,"address":[5102928,5102876],"length":1,"stats":{"Line":0}},{"line":327,"address":[5102977,5102916],"length":1,"stats":{"Line":2}},{"line":329,"address":[5102985],"length":1,"stats":{"Line":1}},{"line":330,"address":[5103157,5103039],"length":1,"stats":{"Line":1}},{"line":332,"address":[5104793],"length":1,"stats":{"Line":0}},{"line":338,"address":[5104530,5103327,5103411,5103267],"length":1,"stats":{"Line":3}},{"line":339,"address":[5103333],"length":1,"stats":{"Line":0}},{"line":341,"address":[5103426,5103456],"length":1,"stats":{"Line":2}},{"line":343,"address":[5104498,5103535,5103464],"length":1,"stats":{"Line":3}},{"line":344,"address":[5103614,5103718],"length":1,"stats":{"Line":2}},{"line":346,"address":[5104458,5103726],"length":1,"stats":{"Line":1}},{"line":347,"address":[5104042,5103964,5103780],"length":1,"stats":{"Line":2}},{"line":348,"address":[5104089],"length":1,"stats":{"Line":1}},{"line":349,"address":[5104184],"length":1,"stats":{"Line":1}},{"line":351,"address":[5104339],"length":1,"stats":{"Line":0}},{"line":357,"address":[5103546],"length":1,"stats":{"Line":1}},{"line":358,"address":[5103621],"length":1,"stats":{"Line":1}},{"line":364,"address":[5105120,5106074],"length":1,"stats":{"Line":1}},{"line":365,"address":[5105145,5105205,5105663,5105216],"length":1,"stats":{"Line":4}},{"line":366,"address":[5105211],"length":1,"stats":{"Line":1}},{"line":368,"address":[5105262,5105228],"length":1,"stats":{"Line":2}},{"line":371,"address":[5105270],"length":1,"stats":{"Line":1}},{"line":373,"address":[5105373],"length":1,"stats":{"Line":2}},{"line":377,"address":[5105639,5105628],"length":1,"stats":{"Line":2}},{"line":380,"address":[5105634],"length":1,"stats":{"Line":0}},{"line":384,"address":[5105421],"length":1,"stats":{"Line":1}},{"line":385,"address":[5105947],"length":1,"stats":{"Line":1}},{"line":387,"address":[5105543],"length":1,"stats":{"Line":1}},{"line":388,"address":[5105556,5105976],"length":1,"stats":{"Line":3}},{"line":402,"address":[5105985],"length":1,"stats":{"Line":2}},{"line":404,"address":[5106038],"length":1,"stats":{"Line":2}},{"line":407,"address":[5105491],"length":1,"stats":{"Line":0}},{"line":408,"address":[5105957],"length":1,"stats":{"Line":0}},{"line":411,"address":[5105472,5105757,5105672],"length":1,"stats":{"Line":3}},{"line":412,"address":[5105683],"length":1,"stats":{"Line":0}},{"line":413,"address":[5105752],"length":1,"stats":{"Line":0}},{"line":415,"address":[5105745],"length":1,"stats":{"Line":2}},{"line":417,"address":[5105759],"length":1,"stats":{"Line":2}},{"line":419,"address":[5105812],"length":1,"stats":{"Line":1}},{"line":420,"address":[5105824],"length":1,"stats":{"Line":1}},{"line":421,"address":[5105873],"length":1,"stats":{"Line":1}},{"line":424,"address":[5105792],"length":1,"stats":{"Line":1}},{"line":425,"address":[5105888],"length":1,"stats":{"Line":1}},{"line":426,"address":[5105937],"length":1,"stats":{"Line":1}},{"line":432,"address":[5105316],"length":1,"stats":{"Line":1}},{"line":433,"address":[5106049],"length":1,"stats":{"Line":1}},{"line":440,"address":[5106096,5106298],"length":1,"stats":{"Line":2}},{"line":441,"address":[5106110,5106124],"length":1,"stats":{"Line":4}},{"line":442,"address":[5106119],"length":1,"stats":{"Line":2}},{"line":444,"address":[5106141],"length":1,"stats":{"Line":2}},{"line":446,"address":[5106156,5106215],"length":1,"stats":{"Line":4}},{"line":448,"address":[5106277,5106222],"length":1,"stats":{"Line":4}},{"line":453,"address":[5107002,5106320],"length":1,"stats":{"Line":0}},{"line":454,"address":[5106370,5106340,5106574],"length":1,"stats":{"Line":0}},{"line":455,"address":[5106365],"length":1,"stats":{"Line":0}},{"line":457,"address":[5106377],"length":1,"stats":{"Line":0}},{"line":459,"address":[5106485,5106405],"length":1,"stats":{"Line":0}},{"line":460,"address":[5106921,5106550,5106656,5106583],"length":1,"stats":{"Line":0}},{"line":461,"address":[5106594],"length":1,"stats":{"Line":0}},{"line":462,"address":[5106651],"length":1,"stats":{"Line":0}},{"line":464,"address":[5106644,5106658],"length":1,"stats":{"Line":0}},{"line":466,"address":[5106666,5106734,5106985],"length":1,"stats":{"Line":0}},{"line":467,"address":[5106802],"length":1,"stats":{"Line":0}},{"line":468,"address":[5106931],"length":1,"stats":{"Line":0}},{"line":469,"address":[5106980],"length":1,"stats":{"Line":0}},{"line":471,"address":[5106745],"length":1,"stats":{"Line":0}},{"line":472,"address":[5106859],"length":1,"stats":{"Line":0}},{"line":473,"address":[5106908],"length":1,"stats":{"Line":0}},{"line":477,"address":[5106496],"length":1,"stats":{"Line":0}},{"line":478,"address":[5106561],"length":1,"stats":{"Line":0}},{"line":484,"address":[5107242,5107040],"length":1,"stats":{"Line":2}},{"line":485,"address":[5107068,5107054],"length":1,"stats":{"Line":2}},{"line":486,"address":[5107063],"length":1,"stats":{"Line":0}},{"line":488,"address":[5107085],"length":1,"stats":{"Line":2}},{"line":490,"address":[5107159,5107100],"length":1,"stats":{"Line":4}},{"line":492,"address":[5107221,5107166],"length":1,"stats":{"Line":4}},{"line":497,"address":[5107264,5107466],"length":1,"stats":{"Line":2}},{"line":498,"address":[5107292,5107278],"length":1,"stats":{"Line":2}},{"line":499,"address":[5107287],"length":1,"stats":{"Line":0}},{"line":501,"address":[5107309],"length":1,"stats":{"Line":2}},{"line":503,"address":[5107324,5107383],"length":1,"stats":{"Line":4}},{"line":505,"address":[5107445,5107390],"length":1,"stats":{"Line":4}},{"line":510,"address":[5108246,5108217,5107488],"length":1,"stats":{"Line":1}},{"line":511,"address":[5107853,5107530,5107508],"length":1,"stats":{"Line":3}},{"line":512,"address":[5107525],"length":1,"stats":{"Line":1}},{"line":514,"address":[5107537],"length":1,"stats":{"Line":1}},{"line":516,"address":[5107555],"length":1,"stats":{"Line":1}},{"line":518,"address":[5107681],"length":1,"stats":{"Line":1}},{"line":519,"address":[5108226],"length":1,"stats":{"Line":1}},{"line":522,"address":[5107665,5107769],"length":1,"stats":{"Line":2}},{"line":523,"address":[5107780],"length":1,"stats":{"Line":0}},{"line":524,"address":[5107840],"length":1,"stats":{"Line":0}},{"line":526,"address":[5107833],"length":1,"stats":{"Line":1}},{"line":527,"address":[5107874,5107921],"length":1,"stats":{"Line":2}},{"line":529,"address":[5107940],"length":1,"stats":{"Line":1}},{"line":530,"address":[5108084],"length":1,"stats":{"Line":1}},{"line":531,"address":[5108133],"length":1,"stats":{"Line":1}},{"line":534,"address":[5107992],"length":1,"stats":{"Line":0}},{"line":535,"address":[5108161],"length":1,"stats":{"Line":0}},{"line":536,"address":[5108210],"length":1,"stats":{"Line":0}},{"line":542,"address":[5107608],"length":1,"stats":{"Line":1}},{"line":543,"address":[5108236],"length":1,"stats":{"Line":1}},{"line":550,"address":[5108628,5108272],"length":1,"stats":{"Line":1}},{"line":551,"address":[5108292,5108306],"length":1,"stats":{"Line":2}},{"line":552,"address":[5108301],"length":1,"stats":{"Line":1}},{"line":554,"address":[5108323],"length":1,"stats":{"Line":1}},{"line":556,"address":[5108399,5108338],"length":1,"stats":{"Line":2}},{"line":558,"address":[5108482],"length":1,"stats":{"Line":1}},{"line":559,"address":[5108594],"length":1,"stats":{"Line":1}},{"line":562,"address":[5108519],"length":1,"stats":{"Line":0}},{"line":563,"address":[5108614],"length":1,"stats":{"Line":0}},{"line":566,"address":[5108433],"length":1,"stats":{"Line":1}},{"line":567,"address":[5108621],"length":1,"stats":{"Line":1}},{"line":574,"address":[5108656,5108938],"length":1,"stats":{"Line":1}},{"line":575,"address":[5108676,5108690],"length":1,"stats":{"Line":2}},{"line":576,"address":[5108685],"length":1,"stats":{"Line":1}},{"line":578,"address":[5108707],"length":1,"stats":{"Line":1}},{"line":580,"address":[5108783,5108722],"length":1,"stats":{"Line":2}},{"line":582,"address":[5108799],"length":1,"stats":{"Line":1}},{"line":583,"address":[5108911],"length":1,"stats":{"Line":1}},{"line":586,"address":[5108836],"length":1,"stats":{"Line":1}},{"line":587,"address":[5108931],"length":1,"stats":{"Line":1}},{"line":594,"address":[5109471,5108960,5109446],"length":1,"stats":{"Line":1}},{"line":595,"address":[5108980,5109002,5109373],"length":1,"stats":{"Line":3}},{"line":596,"address":[5108997],"length":1,"stats":{"Line":1}},{"line":598,"address":[5109009],"length":1,"stats":{"Line":1}},{"line":600,"address":[5109027],"length":1,"stats":{"Line":1}},{"line":602,"address":[5109175,5109062],"length":1,"stats":{"Line":2}},{"line":603,"address":[5109186],"length":1,"stats":{"Line":0}},{"line":604,"address":[5109243],"length":1,"stats":{"Line":0}},{"line":607,"address":[5109236],"length":1,"stats":{"Line":1}},{"line":609,"address":[5109261],"length":1,"stats":{"Line":2}},{"line":611,"address":[5109282],"length":1,"stats":{"Line":2}},{"line":612,"address":[5109311],"length":1,"stats":{"Line":2}},{"line":613,"address":[5109360],"length":1,"stats":{"Line":2}},{"line":616,"address":[5109299],"length":1,"stats":{"Line":0}},{"line":617,"address":[5109383],"length":1,"stats":{"Line":0}},{"line":618,"address":[5109432],"length":1,"stats":{"Line":0}},{"line":623,"address":[5109078],"length":1,"stats":{"Line":1}},{"line":624,"address":[5109439],"length":1,"stats":{"Line":1}},{"line":631,"address":[5109974,5109999,5109488],"length":1,"stats":{"Line":1}},{"line":632,"address":[5109508,5109530,5109901],"length":1,"stats":{"Line":3}},{"line":633,"address":[5109525],"length":1,"stats":{"Line":1}},{"line":635,"address":[5109537],"length":1,"stats":{"Line":1}},{"line":637,"address":[5109555],"length":1,"stats":{"Line":1}},{"line":639,"address":[5109590,5109703],"length":1,"stats":{"Line":2}},{"line":640,"address":[5109714],"length":1,"stats":{"Line":0}},{"line":641,"address":[5109771],"length":1,"stats":{"Line":0}},{"line":644,"address":[5109764],"length":1,"stats":{"Line":1}},{"line":646,"address":[5109789],"length":1,"stats":{"Line":1}},{"line":648,"address":[5109810],"length":1,"stats":{"Line":1}},{"line":649,"address":[5109839],"length":1,"stats":{"Line":1}},{"line":650,"address":[5109888],"length":1,"stats":{"Line":1}},{"line":653,"address":[5109827],"length":1,"stats":{"Line":0}},{"line":654,"address":[5109911],"length":1,"stats":{"Line":0}},{"line":655,"address":[5109960],"length":1,"stats":{"Line":0}},{"line":660,"address":[5109606],"length":1,"stats":{"Line":1}},{"line":661,"address":[5109967],"length":1,"stats":{"Line":1}},{"line":668,"address":[5110016],"length":1,"stats":{"Line":1}},{"line":669,"address":[5110029,5110043],"length":1,"stats":{"Line":2}},{"line":670,"address":[5110038],"length":1,"stats":{"Line":1}},{"line":672,"address":[5110049],"length":1,"stats":{"Line":1}},{"line":674,"address":[5110059],"length":1,"stats":{"Line":1}},{"line":676,"address":[5110090],"length":1,"stats":{"Line":1}},{"line":677,"address":[5110100],"length":1,"stats":{"Line":1}},{"line":680,"address":[5110111],"length":1,"stats":{"Line":1}},{"line":681,"address":[5110121],"length":1,"stats":{"Line":1}},{"line":688,"address":[5110128],"length":1,"stats":{"Line":1}},{"line":689,"address":[5110141,5110155],"length":1,"stats":{"Line":2}},{"line":690,"address":[5110150],"length":1,"stats":{"Line":1}},{"line":692,"address":[5110161],"length":1,"stats":{"Line":1}},{"line":694,"address":[5110171],"length":1,"stats":{"Line":1}},{"line":696,"address":[5110202],"length":1,"stats":{"Line":1}},{"line":697,"address":[5110212],"length":1,"stats":{"Line":1}},{"line":700,"address":[5110223],"length":1,"stats":{"Line":1}},{"line":701,"address":[5110233],"length":1,"stats":{"Line":1}},{"line":708,"address":[5110240],"length":1,"stats":{"Line":1}},{"line":709,"address":[5110253,5110267],"length":1,"stats":{"Line":2}},{"line":710,"address":[5110262],"length":1,"stats":{"Line":1}},{"line":712,"address":[5110273],"length":1,"stats":{"Line":1}},{"line":714,"address":[5110283],"length":1,"stats":{"Line":1}},{"line":716,"address":[5110314],"length":1,"stats":{"Line":1}},{"line":717,"address":[5110324],"length":1,"stats":{"Line":2}},{"line":720,"address":[5110335],"length":1,"stats":{"Line":1}},{"line":721,"address":[5110345],"length":1,"stats":{"Line":1}},{"line":728,"address":[5110352],"length":1,"stats":{"Line":1}},{"line":729,"address":[5110379,5110365],"length":1,"stats":{"Line":1}},{"line":730,"address":[5110374],"length":1,"stats":{"Line":0}},{"line":732,"address":[5110385],"length":1,"stats":{"Line":2}},{"line":734,"address":[5110395],"length":1,"stats":{"Line":2}},{"line":736,"address":[5110426],"length":1,"stats":{"Line":2}},{"line":737,"address":[5110436],"length":1,"stats":{"Line":2}},{"line":740,"address":[5110447],"length":1,"stats":{"Line":1}},{"line":741,"address":[5110457],"length":1,"stats":{"Line":1}},{"line":748,"address":[5110464,5110945,5110970],"length":1,"stats":{"Line":2}},{"line":749,"address":[5110484,5110760,5110506],"length":1,"stats":{"Line":3}},{"line":750,"address":[5110501],"length":1,"stats":{"Line":0}},{"line":752,"address":[5110513],"length":1,"stats":{"Line":2}},{"line":754,"address":[5110531],"length":1,"stats":{"Line":2}},{"line":756,"address":[5110566,5110679],"length":1,"stats":{"Line":2}},{"line":757,"address":[5110690],"length":1,"stats":{"Line":0}},{"line":758,"address":[5110747],"length":1,"stats":{"Line":0}},{"line":760,"address":[5110740],"length":1,"stats":{"Line":1}},{"line":762,"address":[5110765],"length":1,"stats":{"Line":1}},{"line":764,"address":[5110786],"length":1,"stats":{"Line":1}},{"line":765,"address":[5110815],"length":1,"stats":{"Line":1}},{"line":766,"address":[5110864],"length":1,"stats":{"Line":1}},{"line":769,"address":[5110803],"length":1,"stats":{"Line":0}},{"line":770,"address":[5110876],"length":1,"stats":{"Line":0}},{"line":771,"address":[5110925],"length":1,"stats":{"Line":0}},{"line":777,"address":[5110582],"length":1,"stats":{"Line":1}},{"line":778,"address":[5110935],"length":1,"stats":{"Line":1}},{"line":785,"address":[5110992,5111498,5111473],"length":1,"stats":{"Line":1}},{"line":786,"address":[5111012,5111034,5111288],"length":1,"stats":{"Line":2}},{"line":787,"address":[5111029],"length":1,"stats":{"Line":0}},{"line":789,"address":[5111041],"length":1,"stats":{"Line":1}},{"line":791,"address":[5111059],"length":1,"stats":{"Line":1}},{"line":793,"address":[5111207,5111094],"length":1,"stats":{"Line":2}},{"line":794,"address":[5111218],"length":1,"stats":{"Line":0}},{"line":795,"address":[5111275],"length":1,"stats":{"Line":0}},{"line":797,"address":[5111268],"length":1,"stats":{"Line":1}},{"line":799,"address":[5111293],"length":1,"stats":{"Line":1}},{"line":801,"address":[5111314],"length":1,"stats":{"Line":1}},{"line":802,"address":[5111343],"length":1,"stats":{"Line":1}},{"line":803,"address":[5111392],"length":1,"stats":{"Line":1}},{"line":806,"address":[5111331],"length":1,"stats":{"Line":0}},{"line":807,"address":[5111404],"length":1,"stats":{"Line":0}},{"line":808,"address":[5111453],"length":1,"stats":{"Line":0}},{"line":814,"address":[5111110],"length":1,"stats":{"Line":1}},{"line":815,"address":[5111463],"length":1,"stats":{"Line":1}},{"line":822,"address":[5111520],"length":1,"stats":{"Line":1}},{"line":823,"address":[5111547,5111533],"length":1,"stats":{"Line":1}},{"line":824,"address":[5111542],"length":1,"stats":{"Line":0}},{"line":826,"address":[5111553],"length":1,"stats":{"Line":1}},{"line":828,"address":[5111563],"length":1,"stats":{"Line":1}},{"line":830,"address":[5111594],"length":1,"stats":{"Line":1}},{"line":831,"address":[5111604],"length":1,"stats":{"Line":1}},{"line":834,"address":[5111615],"length":1,"stats":{"Line":0}},{"line":835,"address":[5111625],"length":1,"stats":{"Line":0}},{"line":842,"address":[5113230,5111632,5114155],"length":1,"stats":{"Line":1}},{"line":843,"address":[5111652,5114138,5111714],"length":1,"stats":{"Line":3}},{"line":844,"address":[5111709],"length":1,"stats":{"Line":1}},{"line":846,"address":[5111721],"length":1,"stats":{"Line":1}},{"line":848,"address":[5111739],"length":1,"stats":{"Line":1}},{"line":850,"address":[5112067,5112256,5111875,5111988],"length":1,"stats":{"Line":3}},{"line":851,"address":[5111999],"length":1,"stats":{"Line":0}},{"line":852,"address":[5112062],"length":1,"stats":{"Line":0}},{"line":854,"address":[5112055,5112072],"length":1,"stats":{"Line":2}},{"line":856,"address":[5112080],"length":1,"stats":{"Line":1}},{"line":857,"address":[5112094],"length":1,"stats":{"Line":1}},{"line":859,"address":[5112120],"length":1,"stats":{"Line":0}},{"line":860,"address":[5112192],"length":1,"stats":{"Line":0}},{"line":861,"address":[5112241],"length":1,"stats":{"Line":0}},{"line":867,"address":[5113311,5111891,5112280,5112365],"length":1,"stats":{"Line":5}},{"line":868,"address":[5112291],"length":1,"stats":{"Line":0}},{"line":869,"address":[5112360],"length":1,"stats":{"Line":0}},{"line":871,"address":[5112370,5112353],"length":1,"stats":{"Line":4}},{"line":873,"address":[5112378],"length":1,"stats":{"Line":2}},{"line":874,"address":[5112475],"length":1,"stats":{"Line":1}},{"line":875,"address":[5112555],"length":1,"stats":{"Line":1}},{"line":876,"address":[5112576],"length":1,"stats":{"Line":1}},{"line":880,"address":[5113192,5112511,5112806,5112661],"length":1,"stats":{"Line":3}},{"line":881,"address":[5112672],"length":1,"stats":{"Line":0}},{"line":882,"address":[5112752],"length":1,"stats":{"Line":0}},{"line":883,"address":[5112801],"length":1,"stats":{"Line":0}},{"line":885,"address":[5112811,5112740],"length":1,"stats":{"Line":2}},{"line":887,"address":[5112819],"length":1,"stats":{"Line":1}},{"line":888,"address":[5112833],"length":1,"stats":{"Line":1}},{"line":889,"address":[5112960],"length":1,"stats":{"Line":1}},{"line":890,"address":[5112981],"length":1,"stats":{"Line":1}},{"line":894,"address":[5112869],"length":1,"stats":{"Line":0}},{"line":895,"address":[5113065],"length":1,"stats":{"Line":0}},{"line":896,"address":[5113125],"length":1,"stats":{"Line":0}},{"line":897,"address":[5113174],"length":1,"stats":{"Line":0}},{"line":903,"address":[5112417],"length":1,"stats":{"Line":0}},{"line":904,"address":[5113244],"length":1,"stats":{"Line":0}},{"line":905,"address":[5113293],"length":1,"stats":{"Line":0}},{"line":911,"address":[5111910,5113353,5114082,5113438],"length":1,"stats":{"Line":3}},{"line":912,"address":[5113364],"length":1,"stats":{"Line":0}},{"line":913,"address":[5113433],"length":1,"stats":{"Line":0}},{"line":915,"address":[5113443,5113426],"length":1,"stats":{"Line":2}},{"line":917,"address":[5113451],"length":1,"stats":{"Line":1}},{"line":918,"address":[5113548],"length":1,"stats":{"Line":1}},{"line":920,"address":[5113574,5113649,5113734,5113990],"length":1,"stats":{"Line":3}},{"line":921,"address":[5113660],"length":1,"stats":{"Line":0}},{"line":922,"address":[5113729],"length":1,"stats":{"Line":0}},{"line":924,"address":[5113722,5113739],"length":1,"stats":{"Line":2}},{"line":926,"address":[5113747],"length":1,"stats":{"Line":1}},{"line":927,"address":[5113761],"length":1,"stats":{"Line":1}},{"line":929,"address":[5113787],"length":1,"stats":{"Line":0}},{"line":930,"address":[5113863],"length":1,"stats":{"Line":0}},{"line":931,"address":[5113923],"length":1,"stats":{"Line":0}},{"line":932,"address":[5113972],"length":1,"stats":{"Line":0}},{"line":938,"address":[5113490],"length":1,"stats":{"Line":0}},{"line":939,"address":[5114015],"length":1,"stats":{"Line":0}},{"line":940,"address":[5114064],"length":1,"stats":{"Line":0}},{"line":945,"address":[5111849],"length":1,"stats":{"Line":1}},{"line":947,"address":[5111797],"length":1,"stats":{"Line":1}},{"line":948,"address":[5114120],"length":1,"stats":{"Line":1}},{"line":955,"address":[5114192,5115264,5115482],"length":1,"stats":{"Line":1}},{"line":957,"address":[5114230],"length":1,"stats":{"Line":1}},{"line":958,"address":[5114255],"length":1,"stats":{"Line":0}},{"line":961,"address":[5114304],"length":1,"stats":{"Line":1}},{"line":963,"address":[5114325],"length":1,"stats":{"Line":1}},{"line":965,"address":[5114484,5114656],"length":1,"stats":{"Line":2}},{"line":966,"address":[5114662,5114714],"length":1,"stats":{"Line":0}},{"line":969,"address":[5114702,5114774],"length":1,"stats":{"Line":2}},{"line":971,"address":[5114782],"length":1,"stats":{"Line":1}},{"line":972,"address":[5114801],"length":1,"stats":{"Line":1}},{"line":973,"address":[5115061],"length":1,"stats":{"Line":0}},{"line":979,"address":[5114503],"length":1,"stats":{"Line":0}},{"line":980,"address":[5115273],"length":1,"stats":{"Line":0}},{"line":988,"address":[5117139,5115520,5116971],"length":1,"stats":{"Line":1}},{"line":992,"address":[5115563,5115643],"length":1,"stats":{"Line":2}},{"line":993,"address":[5115698,5115649],"length":1,"stats":{"Line":0}},{"line":997,"address":[5115686],"length":1,"stats":{"Line":1}},{"line":999,"address":[5115732,5115802],"length":1,"stats":{"Line":2}},{"line":1000,"address":[5117000],"length":1,"stats":{"Line":0}},{"line":1006,"address":[5115813,5115927],"length":1,"stats":{"Line":2}},{"line":1007,"address":[5116029,5115933],"length":1,"stats":{"Line":0}},{"line":1011,"address":[5116225,5116081,5115970,5116998],"length":1,"stats":{"Line":2}},{"line":1013,"address":[5116206,5116375],"length":1,"stats":{"Line":2}},{"line":1014,"address":[5116433,5116381],"length":1,"stats":{"Line":0}},{"line":1018,"address":[5116421],"length":1,"stats":{"Line":1}},{"line":1020,"address":[5116539,5116469],"length":1,"stats":{"Line":2}},{"line":1021,"address":[5116780],"length":1,"stats":{"Line":0}},{"line":1027,"address":[5116545,5116718],"length":1,"stats":{"Line":2}}],"covered":306,"coverable":451},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","database.rs"],"content":"use crate::ast::ddl::alter_database::{\n    AlterDatabaseAction, AlterDatabaseQuery, AlterDatabaseRenameTo,\n};\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::ast::ddl::drop_database::{DropDatabaseQuery, SQLStatement};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE DATABASE 쿼리 분석\n    pub(crate) fn handle_create_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0101 need more tokens\"));\n        }\n\n        let mut query_builder = CreateDatabaseQuery::builder();\n\n        // IF NOT EXISTS 파싱\n        let if_not_exists = self.has_if_not_exists()?;\n        query_builder = query_builder.set_if_not_exists(if_not_exists);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0102 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (create database)\",\n                ));\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // DROP DATABASE 쿼리 분석\n    pub(crate) fn handle_drop_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        let mut query_builder = DropDatabaseQuery::builder();\n\n        // IF EXISTS 파싱\n        let if_exists = self.has_if_exists()?;\n        query_builder = query_builder.set_if_exists(if_exists);\n\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0104 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (create database)\",\n                ));\n            }\n        }\n\n        // 세미콜론 체크\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // ALTER DATABASE 쿼리 분석\n    pub(crate) fn handle_alter_database_query(\u0026mut self) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0105 need more tokens\"));\n        }\n\n        let mut query_builder = AlterDatabaseQuery::builder();\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e {\n                query_builder = query_builder.set_name(identifier);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(\n                    \"not supported command. possible commands: (alter database)\",\n                ));\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Rename =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E106: expected 'TO'. but no more token\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if current_token != Token::To {\n                    return Err(ParsingError::wrap(format!(\n                        \"E107: expected 'TO'. but your input word is '{:?}'\",\n                        current_token\n                    )));\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\n                        \"E108: expected identifier. but no more token\",\n                    ));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(identifier) =\u003e {\n                        query_builder = query_builder.set_action(AlterDatabaseAction::RenameTo(\n                            AlterDatabaseRenameTo { name: identifier },\n                        ));\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(\n                            \"E109: not supported command. possible commands: (alter database)\",\n                        ));\n                    }\n                }\n            }\n            Token::SemiColon =\u003e {}\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E107: not supported syntax'{:?}'\",\n                    current_token\n                )));\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":13,"address":[5118917,5118714,5117168],"length":1,"stats":{"Line":2}},{"line":14,"address":[5117206],"length":1,"stats":{"Line":2}},{"line":15,"address":[5117231],"length":1,"stats":{"Line":0}},{"line":18,"address":[5117297],"length":1,"stats":{"Line":2}},{"line":21,"address":[5117525,5117405,5117328,5117446,5118887],"length":1,"stats":{"Line":4}},{"line":22,"address":[5117457,5117438,5117635],"length":1,"stats":{"Line":3}},{"line":24,"address":[5117672],"length":1,"stats":{"Line":1}},{"line":25,"address":[5117745,5117693],"length":1,"stats":{"Line":0}},{"line":28,"address":[5117804,5117733],"length":1,"stats":{"Line":2}},{"line":30,"address":[5117812],"length":1,"stats":{"Line":1}},{"line":31,"address":[5117826],"length":1,"stats":{"Line":1}},{"line":32,"address":[5118014,5117866],"length":1,"stats":{"Line":4}},{"line":35,"address":[5117934,5118728],"length":1,"stats":{"Line":0}},{"line":41,"address":[5118051],"length":1,"stats":{"Line":2}},{"line":42,"address":[5118157,5118072],"length":1,"stats":{"Line":0}},{"line":45,"address":[5118145],"length":1,"stats":{"Line":2}},{"line":47,"address":[5118268,5118198],"length":1,"stats":{"Line":4}},{"line":48,"address":[5118522],"length":1,"stats":{"Line":0}},{"line":54,"address":[5118455,5118274],"length":1,"stats":{"Line":4}},{"line":58,"address":[5120365,5120568,5118944],"length":1,"stats":{"Line":1}},{"line":59,"address":[5118974],"length":1,"stats":{"Line":1}},{"line":62,"address":[5119117,5119193,5119082,5119021,5120538],"length":1,"stats":{"Line":3}},{"line":63,"address":[5119128,5119291,5119112],"length":1,"stats":{"Line":3}},{"line":66,"address":[5119325],"length":1,"stats":{"Line":1}},{"line":67,"address":[5119398,5119346],"length":1,"stats":{"Line":0}},{"line":70,"address":[5119386,5119457],"length":1,"stats":{"Line":2}},{"line":72,"address":[5119465],"length":1,"stats":{"Line":1}},{"line":73,"address":[5119479],"length":1,"stats":{"Line":1}},{"line":74,"address":[5119664,5119519],"length":1,"stats":{"Line":2}},{"line":77,"address":[5120379,5119584],"length":1,"stats":{"Line":0}},{"line":84,"address":[5119698],"length":1,"stats":{"Line":1}},{"line":85,"address":[5119801,5119719],"length":1,"stats":{"Line":0}},{"line":88,"address":[5119789],"length":1,"stats":{"Line":1}},{"line":90,"address":[5119912,5119842],"length":1,"stats":{"Line":2}},{"line":91,"address":[5120173],"length":1,"stats":{"Line":0}},{"line":97,"address":[5120096,5119918],"length":1,"stats":{"Line":2}},{"line":101,"address":[5123127,5120608,5122535],"length":1,"stats":{"Line":2}},{"line":102,"address":[5120646],"length":1,"stats":{"Line":2}},{"line":103,"address":[5120679],"length":1,"stats":{"Line":0}},{"line":106,"address":[5120745],"length":1,"stats":{"Line":2}},{"line":108,"address":[5120779,5120840],"length":1,"stats":{"Line":4}},{"line":110,"address":[5120848],"length":1,"stats":{"Line":2}},{"line":111,"address":[5120862],"length":1,"stats":{"Line":2}},{"line":112,"address":[5121069,5120902],"length":1,"stats":{"Line":4}},{"line":115,"address":[5120989,5122933],"length":1,"stats":{"Line":0}},{"line":121,"address":[5121125],"length":1,"stats":{"Line":2}},{"line":122,"address":[5121146,5121250],"length":1,"stats":{"Line":0}},{"line":125,"address":[5121238],"length":1,"stats":{"Line":2}},{"line":127,"address":[5121291],"length":1,"stats":{"Line":2}},{"line":129,"address":[5121566,5121429],"length":1,"stats":{"Line":2}},{"line":130,"address":[5121624,5121572],"length":1,"stats":{"Line":0}},{"line":133,"address":[5121612],"length":1,"stats":{"Line":1}},{"line":135,"address":[5121752,5121682],"length":1,"stats":{"Line":2}},{"line":136,"address":[5122544],"length":1,"stats":{"Line":0}},{"line":142,"address":[5121763,5121877],"length":1,"stats":{"Line":2}},{"line":143,"address":[5121935,5121883],"length":1,"stats":{"Line":0}},{"line":148,"address":[5121993,5121923],"length":1,"stats":{"Line":2}},{"line":150,"address":[5122001],"length":1,"stats":{"Line":1}},{"line":151,"address":[5122019],"length":1,"stats":{"Line":1}},{"line":152,"address":[5122285,5122147,5122059],"length":1,"stats":{"Line":3}},{"line":153,"address":[5122115],"length":1,"stats":{"Line":1}},{"line":157,"address":[5122379,5122210],"length":1,"stats":{"Line":0}},{"line":165,"address":[5122782],"length":1,"stats":{"Line":0}},{"line":172,"address":[5122715,5121440],"length":1,"stats":{"Line":2}}],"covered":47,"coverable":64},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","mod.rs"],"content":"pub mod database;\npub mod table;\npub mod top_level;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","table.rs"],"content":"use crate::ast::ddl::alter_table::{\n    AlterColumnDropDefault, AlterColumnDropNotNull, AlterColumnSetDefault, AlterColumnSetNotNull,\n    AlterColumnSetType, AlterTableAddColumn, AlterTableAlterColumn, AlterTableDropColumn,\n    AlterTableQuery, AlterTableRenameColumn, AlterTableRenameTo,\n};\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::ast::ddl::drop_database::SQLStatement;\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE TABLE 쿼리 분석\n    pub(crate) fn handle_create_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1205 need more tokens\"));\n        }\n\n        let mut query_builder = CreateTableQuery::builder();\n\n        // IF NOT EXISTS 파싱\n        let if_not_exists = self.has_if_not_exists()?;\n        query_builder = query_builder.set_if_not_exists(if_not_exists);\n\n        // 테이블명 설정\n        let table = self.parse_table_name(context)?;\n        query_builder = query_builder.set_table(table);\n\n        // 여는 괄호 체크\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1206 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::LeftParentheses != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1207 expected '('. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // 닫는 괄호 나올때까지 행 파싱 반복\n        loop {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E1208 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::RightParentheses =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    let column = self.parse_table_column()?;\n                    query_builder = query_builder.add_column(column);\n                }\n            }\n        }\n\n        // 닫는 괄호 체크\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1209 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::RightParentheses != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1210 expected ')'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1211 expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // ALTER TABLE 쿼리 분석\n    pub(crate) fn handle_alter_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1201 need more tokens\"));\n        }\n\n        let mut query_builder = AlterTableQuery::builder();\n\n        let table_name = self.parse_table_name(context.clone())?;\n\n        query_builder = query_builder.set_table(table_name);\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::SemiColon =\u003e return Ok(query_builder.build()),\n            Token::Rename =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1212 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    // table name rename\n                    Token::To =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1213 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        match current_token {\n                            Token::Identifier(identifier) =\u003e {\n                                query_builder = query_builder\n                                    .set_action(AlterTableRenameTo { name: identifier }.into());\n                            }\n                            _ =\u003e {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1214 unexpected token {:?}\",\n                                    current_token\n                                )))\n                            }\n                        }\n                    }\n                    // table column name rename\n                    Token::Column =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1217 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if let Token::Identifier(from_name) = current_token {\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1219 need more tokens\"));\n                            }\n\n                            let current_token = self.get_next_token();\n\n                            if Token::To != current_token {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1220 expected token is 'TO', but you input is {:?}\",\n                                    current_token\n                                )));\n                            }\n\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1221 need more tokens\"));\n                            }\n\n                            let current_token = self.get_next_token();\n\n                            if let Token::Identifier(to_name) = current_token {\n                                query_builder = query_builder.set_action(\n                                    AlterTableRenameColumn { from_name, to_name }.into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(format!(\n                                    \"E1222 expected token is 'identifer', but you input is {:?}\",\n                                    current_token\n                                )));\n                            }\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1218 expected token {:?}\",\n                                current_token\n                            )));\n                        }\n                    }\n                    // table column name rename\n                    Token::Identifier(from_name) =\u003e {\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1218 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if Token::To != current_token {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1223 expected token is 'TO', but you input is {:?}\",\n                                current_token\n                            )));\n                        }\n\n                        if !self.has_next_token() {\n                            return Err(ParsingError::wrap(\"E1224 need more tokens\"));\n                        }\n\n                        let current_token = self.get_next_token();\n\n                        if let Token::Identifier(to_name) = current_token {\n                            query_builder = query_builder\n                                .set_action(AlterTableRenameColumn { from_name, to_name }.into());\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1225 expected token is 'identifer', but you input is {:?}\",\n                                current_token\n                            )));\n                        }\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E1213 expected token is 'TO' or 'COLUMN', but you input is {:?}\",\n                            current_token\n                        )))\n                    }\n                }\n            }\n            Token::Add =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1215 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Column =\u003e {\n                        let column = self.parse_table_column()?;\n\n                        query_builder =\n                            query_builder.set_action(AlterTableAddColumn { column }.into());\n                    }\n                    Token::Identifier(_) =\u003e {\n                        self.unget_next_token(current_token);\n\n                        let column = self.parse_table_column()?;\n\n                        query_builder =\n                            query_builder.set_action(AlterTableAddColumn { column }.into());\n                    }\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E1216 unexpected keyword '{:?}'\",\n                            current_token\n                        )))\n                    }\n                }\n            }\n            Token::Drop =\u003e {\n                if self.next_token_is_column() {\n                    self.get_next_token();\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1226 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(column_name) = current_token {\n                    query_builder =\n                        query_builder.set_action(AlterTableDropColumn { column_name }.into());\n                } else {\n                    return Err(ParsingError::wrap(format!(\n                        \"E1227 unexpected token {:?}\",\n                        current_token\n                    )));\n                }\n            }\n            Token::Alter =\u003e {\n                if self.next_token_is_column() {\n                    self.get_next_token();\n                }\n\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E1228 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                if let Token::Identifier(column_name) = current_token {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E1230 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::Set =\u003e {\n                            if self.next_token_is_not_null() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetNotNull {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_data_type() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                if !self.has_next_token() {\n                                    return Err(ParsingError::wrap(\"E1233 need more tokens\"));\n                                }\n\n                                let data_type = self.parse_data_type()?;\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetType { data_type }.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_default() {\n                                self.get_next_token();\n\n                                if !self.has_next_token() {\n                                    return Err(ParsingError::wrap(\"E1234 need more tokens\"));\n                                }\n\n                                let expression = self.parse_expression(context)?;\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnSetDefault { expression }.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(\"E1231 unexpected tokens\"));\n                            }\n                        }\n                        Token::Drop =\u003e {\n                            if self.next_token_is_not_null() {\n                                self.get_next_token();\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnDropNotNull {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else if self.next_token_is_default() {\n                                self.get_next_token();\n\n                                query_builder = query_builder.set_action(\n                                    AlterTableAlterColumn {\n                                        action: AlterColumnDropDefault {}.into(),\n                                        column_name,\n                                    }\n                                    .into(),\n                                );\n                            } else {\n                                return Err(ParsingError::wrap(\"E1231 unexpected tokens\"));\n                            }\n                        }\n                        Token::Type =\u003e {\n                            if !self.has_next_token() {\n                                return Err(ParsingError::wrap(\"E1232 need more tokens\"));\n                            }\n\n                            let data_type = self.parse_data_type()?;\n\n                            query_builder = query_builder.set_action(\n                                AlterTableAlterColumn {\n                                    action: AlterColumnSetType { data_type }.into(),\n                                    column_name,\n                                }\n                                .into(),\n                            );\n                        }\n                        _ =\u003e {\n                            return Err(ParsingError::wrap(format!(\n                                \"E1229 unexpected token {:?}\",\n                                current_token\n                            )))\n                        }\n                    }\n                } else {\n                    return Err(ParsingError::wrap(format!(\n                        \"E1229 unexpected token {:?}\",\n                        current_token\n                    )));\n                }\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E1202 unexpected keyword '{:?}'\",\n                    current_token\n                )))\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n\n    // DROP TABLE 쿼리 분석\n    pub(crate) fn handle_drop_table_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        let mut query_builder = DropTableQuery::builder();\n\n        // IF EXISTS 파싱\n        let if_exists = self.has_if_exists()?;\n        query_builder = query_builder.set_if_exists(if_exists);\n\n        // 테이블명 획득 로직\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1203 need more tokens\"));\n        }\n\n        let table = self.parse_table_name(context)?;\n\n        // 테이블명 설정\n        query_builder = query_builder.set_table(table);\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        if Token::SemiColon != current_token {\n            return Err(ParsingError::wrap(format!(\n                \"E1204 expected ';'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":17,"address":[5125860,5126759,5123168],"length":1,"stats":{"Line":1}},{"line":21,"address":[5123232,5123334],"length":1,"stats":{"Line":2}},{"line":22,"address":[5123390,5123340],"length":1,"stats":{"Line":0}},{"line":25,"address":[5123375],"length":1,"stats":{"Line":1}},{"line":28,"address":[5123537,5123669,5123582,5123457,5126696],"length":1,"stats":{"Line":3}},{"line":29,"address":[5123774,5123591,5123570],"length":1,"stats":{"Line":3}},{"line":32,"address":[5124171,5126679,5123822],"length":1,"stats":{"Line":1}},{"line":33,"address":[5124033,5124317],"length":1,"stats":{"Line":2}},{"line":36,"address":[5124360],"length":1,"stats":{"Line":1}},{"line":37,"address":[5124436,5124381],"length":1,"stats":{"Line":0}},{"line":40,"address":[5124421],"length":1,"stats":{"Line":1}},{"line":42,"address":[5124562,5124492],"length":1,"stats":{"Line":2}},{"line":43,"address":[5126509],"length":1,"stats":{"Line":0}},{"line":50,"address":[5126473],"length":1,"stats":{"Line":1}},{"line":51,"address":[5124573,5124687],"length":1,"stats":{"Line":2}},{"line":52,"address":[5124748,5124693],"length":1,"stats":{"Line":0}},{"line":55,"address":[5124733],"length":1,"stats":{"Line":1}},{"line":57,"address":[5124809],"length":1,"stats":{"Line":1}},{"line":59,"address":[5124836],"length":1,"stats":{"Line":1}},{"line":63,"address":[5124856],"length":1,"stats":{"Line":1}},{"line":64,"address":[5126292,5126034],"length":1,"stats":{"Line":1}},{"line":65,"address":[5126431,5126182],"length":1,"stats":{"Line":2}},{"line":71,"address":[5124871],"length":1,"stats":{"Line":1}},{"line":72,"address":[5124947,5124892],"length":1,"stats":{"Line":0}},{"line":75,"address":[5124932],"length":1,"stats":{"Line":1}},{"line":77,"address":[5124995,5125065],"length":1,"stats":{"Line":2}},{"line":78,"address":[5125869],"length":1,"stats":{"Line":0}},{"line":84,"address":[5125076,5125190],"length":1,"stats":{"Line":2}},{"line":85,"address":[5125287,5125196],"length":1,"stats":{"Line":0}},{"line":88,"address":[5125272],"length":1,"stats":{"Line":1}},{"line":90,"address":[5125393,5125323],"length":1,"stats":{"Line":2}},{"line":91,"address":[5125665],"length":1,"stats":{"Line":0}},{"line":97,"address":[5125586,5125399],"length":1,"stats":{"Line":2}},{"line":101,"address":[5142998,5126784,5130704],"length":1,"stats":{"Line":2}},{"line":105,"address":[5127204,5126902],"length":1,"stats":{"Line":4}},{"line":106,"address":[5127210,5127260],"length":1,"stats":{"Line":0}},{"line":109,"address":[5127245],"length":1,"stats":{"Line":2}},{"line":111,"address":[5127330,5127418,5142929,5127726],"length":1,"stats":{"Line":4}},{"line":113,"address":[5127582,5127872],"length":1,"stats":{"Line":4}},{"line":115,"address":[5127918],"length":1,"stats":{"Line":2}},{"line":116,"address":[5128045,5127945],"length":1,"stats":{"Line":0}},{"line":119,"address":[5128030],"length":1,"stats":{"Line":2}},{"line":121,"address":[5128090],"length":1,"stats":{"Line":2}},{"line":122,"address":[5128339,5142736],"length":1,"stats":{"Line":0}},{"line":124,"address":[5137235,5128322],"length":1,"stats":{"Line":4}},{"line":125,"address":[5137299,5137241],"length":1,"stats":{"Line":0}},{"line":128,"address":[5137347,5137284],"length":1,"stats":{"Line":4}},{"line":130,"address":[5137355],"length":1,"stats":{"Line":2}},{"line":133,"address":[5139923,5137543],"length":1,"stats":{"Line":2}},{"line":134,"address":[5139987,5139929],"length":1,"stats":{"Line":0}},{"line":137,"address":[5140035,5139972],"length":1,"stats":{"Line":2}},{"line":139,"address":[5140043],"length":1,"stats":{"Line":1}},{"line":140,"address":[5140061],"length":1,"stats":{"Line":1}},{"line":141,"address":[5140352,5140399,5140101],"length":1,"stats":{"Line":3}},{"line":142,"address":[5140147,5140311,5140391,5140506],"length":1,"stats":{"Line":2}},{"line":145,"address":[5140535],"length":1,"stats":{"Line":0}},{"line":154,"address":[5137676,5137521],"length":1,"stats":{"Line":2}},{"line":155,"address":[5137740,5137682],"length":1,"stats":{"Line":0}},{"line":158,"address":[5137806,5137725],"length":1,"stats":{"Line":2}},{"line":160,"address":[5137814],"length":1,"stats":{"Line":1}},{"line":161,"address":[5138042,5137884],"length":1,"stats":{"Line":2}},{"line":162,"address":[5138106,5138048],"length":1,"stats":{"Line":0}},{"line":165,"address":[5138091],"length":1,"stats":{"Line":1}},{"line":167,"address":[5138241,5138171],"length":1,"stats":{"Line":2}},{"line":168,"address":[5139406],"length":1,"stats":{"Line":0}},{"line":174,"address":[5138255,5138369],"length":1,"stats":{"Line":2}},{"line":175,"address":[5138433,5138375],"length":1,"stats":{"Line":0}},{"line":178,"address":[5138494,5138418],"length":1,"stats":{"Line":2}},{"line":180,"address":[5138502],"length":1,"stats":{"Line":1}},{"line":181,"address":[5138930,5138560,5138883],"length":1,"stats":{"Line":3}},{"line":182,"address":[5138606],"length":1,"stats":{"Line":1}},{"line":185,"address":[5139146],"length":1,"stats":{"Line":0}},{"line":191,"address":[5139653],"length":1,"stats":{"Line":0}},{"line":198,"address":[5137565],"length":1,"stats":{"Line":1}},{"line":199,"address":[5140840,5137613],"length":1,"stats":{"Line":2}},{"line":200,"address":[5140904,5140846],"length":1,"stats":{"Line":0}},{"line":203,"address":[5140889],"length":1,"stats":{"Line":1}},{"line":205,"address":[5140969,5141039],"length":1,"stats":{"Line":2}},{"line":206,"address":[5142275],"length":1,"stats":{"Line":0}},{"line":212,"address":[5141053,5141165],"length":1,"stats":{"Line":2}},{"line":213,"address":[5141229,5141171],"length":1,"stats":{"Line":0}},{"line":216,"address":[5141214,5141290],"length":1,"stats":{"Line":2}},{"line":218,"address":[5141298],"length":1,"stats":{"Line":1}},{"line":219,"address":[5141679,5141356,5141726],"length":1,"stats":{"Line":3}},{"line":220,"address":[5141986,5141402,5141718,5141638],"length":1,"stats":{"Line":2}},{"line":222,"address":[5142015],"length":1,"stats":{"Line":0}},{"line":229,"address":[5142462],"length":1,"stats":{"Line":0}},{"line":237,"address":[5135394,5128297],"length":1,"stats":{"Line":4}},{"line":238,"address":[5135400,5135458],"length":1,"stats":{"Line":0}},{"line":241,"address":[5135506,5135443],"length":1,"stats":{"Line":4}},{"line":243,"address":[5135514],"length":1,"stats":{"Line":2}},{"line":245,"address":[5135663,5135793,5136063],"length":1,"stats":{"Line":2}},{"line":247,"address":[5136256],"length":1,"stats":{"Line":1}},{"line":248,"address":[5136168,5135918,5136340],"length":1,"stats":{"Line":1}},{"line":251,"address":[5135678],"length":1,"stats":{"Line":1}},{"line":253,"address":[5136701,5136408],"length":1,"stats":{"Line":1}},{"line":255,"address":[5136894],"length":1,"stats":{"Line":1}},{"line":256,"address":[5136556,5136806,5136992],"length":1,"stats":{"Line":1}},{"line":259,"address":[5137030],"length":1,"stats":{"Line":0}},{"line":267,"address":[5134448,5128272],"length":1,"stats":{"Line":3}},{"line":268,"address":[5134489],"length":1,"stats":{"Line":1}},{"line":271,"address":[5134515,5134462],"length":1,"stats":{"Line":4}},{"line":272,"address":[5134521,5134579],"length":1,"stats":{"Line":0}},{"line":275,"address":[5134564,5134627],"length":1,"stats":{"Line":4}},{"line":277,"address":[5134635],"length":1,"stats":{"Line":2}},{"line":278,"address":[5134991],"length":1,"stats":{"Line":2}},{"line":279,"address":[5134903,5134693,5135098],"length":1,"stats":{"Line":2}},{"line":281,"address":[5135127],"length":1,"stats":{"Line":0}},{"line":288,"address":[5128458,5128247],"length":1,"stats":{"Line":3}},{"line":289,"address":[5128502],"length":1,"stats":{"Line":2}},{"line":292,"address":[5128531,5128472],"length":1,"stats":{"Line":4}},{"line":293,"address":[5128537,5128595],"length":1,"stats":{"Line":0}},{"line":296,"address":[5128656,5128580],"length":1,"stats":{"Line":4}},{"line":298,"address":[5128664],"length":1,"stats":{"Line":2}},{"line":299,"address":[5128734,5128898],"length":1,"stats":{"Line":4}},{"line":300,"address":[5128962,5128904],"length":1,"stats":{"Line":0}},{"line":303,"address":[5128947],"length":1,"stats":{"Line":2}},{"line":305,"address":[5129027],"length":1,"stats":{"Line":2}},{"line":307,"address":[5131996,5129202,5129313],"length":1,"stats":{"Line":4}},{"line":308,"address":[5131579,5129357],"length":1,"stats":{"Line":2}},{"line":309,"address":[5131602],"length":1,"stats":{"Line":1}},{"line":311,"address":[5131624,5131962,5131915],"length":1,"stats":{"Line":3}},{"line":312,"address":[5131773],"length":1,"stats":{"Line":1}},{"line":313,"address":[5131670],"length":1,"stats":{"Line":1}},{"line":314,"address":[5131733],"length":1,"stats":{"Line":1}},{"line":318,"address":[5131543,5129327,5129374],"length":1,"stats":{"Line":3}},{"line":319,"address":[5129418,5130752],"length":1,"stats":{"Line":2}},{"line":320,"address":[5130775],"length":1,"stats":{"Line":1}},{"line":322,"address":[5130805],"length":1,"stats":{"Line":1}},{"line":323,"address":[5130890,5130832],"length":1,"stats":{"Line":0}},{"line":326,"address":[5130954,5131134,5131566,5130875],"length":1,"stats":{"Line":2}},{"line":328,"address":[5131462,5131509,5131039],"length":1,"stats":{"Line":3}},{"line":329,"address":[5131320],"length":1,"stats":{"Line":1}},{"line":330,"address":[5131101],"length":1,"stats":{"Line":1}},{"line":331,"address":[5131280],"length":1,"stats":{"Line":1}},{"line":335,"address":[5129388,5129435],"length":1,"stats":{"Line":2}},{"line":336,"address":[5129484,5129568],"length":1,"stats":{"Line":2}},{"line":338,"address":[5129583],"length":1,"stats":{"Line":1}},{"line":339,"address":[5129610,5129715],"length":1,"stats":{"Line":0}},{"line":342,"address":[5129779,5130239,5129653],"length":1,"stats":{"Line":2}},{"line":344,"address":[5129984,5130567,5130614],"length":1,"stats":{"Line":3}},{"line":345,"address":[5130425],"length":1,"stats":{"Line":1}},{"line":346,"address":[5130030],"length":1,"stats":{"Line":1}},{"line":347,"address":[5130385],"length":1,"stats":{"Line":1}},{"line":352,"address":[5129441,5129499],"length":1,"stats":{"Line":0}},{"line":356,"address":[5129224,5132586,5132026,5133034],"length":1,"stats":{"Line":5}},{"line":357,"address":[5132617,5132070],"length":1,"stats":{"Line":2}},{"line":358,"address":[5132640],"length":1,"stats":{"Line":1}},{"line":360,"address":[5132662,5132953,5133000],"length":1,"stats":{"Line":3}},{"line":361,"address":[5132811],"length":1,"stats":{"Line":1}},{"line":362,"address":[5132708],"length":1,"stats":{"Line":1}},{"line":363,"address":[5132771],"length":1,"stats":{"Line":1}},{"line":367,"address":[5132087,5132040],"length":1,"stats":{"Line":2}},{"line":368,"address":[5132136,5132207],"length":1,"stats":{"Line":2}},{"line":370,"address":[5132214,5132505,5132552],"length":1,"stats":{"Line":3}},{"line":371,"address":[5132363],"length":1,"stats":{"Line":1}},{"line":372,"address":[5132260],"length":1,"stats":{"Line":1}},{"line":373,"address":[5132323],"length":1,"stats":{"Line":1}},{"line":378,"address":[5132151,5132093],"length":1,"stats":{"Line":0}},{"line":382,"address":[5133064,5129249],"length":1,"stats":{"Line":2}},{"line":383,"address":[5133128,5133070],"length":1,"stats":{"Line":0}},{"line":386,"address":[5133113,5133192,5133372,5133923],"length":1,"stats":{"Line":2}},{"line":388,"address":[5133700,5133277,5133747],"length":1,"stats":{"Line":3}},{"line":389,"address":[5133558],"length":1,"stats":{"Line":1}},{"line":390,"address":[5133339],"length":1,"stats":{"Line":1}},{"line":391,"address":[5133518],"length":1,"stats":{"Line":1}},{"line":397,"address":[5133928],"length":1,"stats":{"Line":0}},{"line":404,"address":[5134175],"length":1,"stats":{"Line":0}},{"line":411,"address":[5142759],"length":1,"stats":{"Line":0}},{"line":418,"address":[5133833,5141881],"length":1,"stats":{"Line":3}},{"line":422,"address":[5144920,5143040,5145022],"length":1,"stats":{"Line":1}},{"line":426,"address":[5143075],"length":1,"stats":{"Line":1}},{"line":429,"address":[5143376,5143165,5144952,5143274,5143239],"length":1,"stats":{"Line":3}},{"line":430,"address":[5143285,5143269,5143483],"length":1,"stats":{"Line":3}},{"line":433,"address":[5143543],"length":1,"stats":{"Line":1}},{"line":434,"address":[5143564,5143660],"length":1,"stats":{"Line":0}},{"line":437,"address":[5144031,5143735,5144947,5143601],"length":1,"stats":{"Line":2}},{"line":440,"address":[5143876,5144182],"length":1,"stats":{"Line":2}},{"line":442,"address":[5144242],"length":1,"stats":{"Line":1}},{"line":443,"address":[5144371,5144263],"length":1,"stats":{"Line":0}},{"line":446,"address":[5144359],"length":1,"stats":{"Line":1}},{"line":448,"address":[5144472,5144402],"length":1,"stats":{"Line":2}},{"line":449,"address":[5144728],"length":1,"stats":{"Line":0}},{"line":455,"address":[5144478,5144682],"length":1,"stats":{"Line":2}}],"covered":142,"coverable":184},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","ddl","top_level.rs"],"content":"use crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\nimpl Parser {\n    // CREATE...로 시작되는 쿼리 분석\n    pub(crate) fn handle_create_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1101 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_create_table_query(context),\n            Token::Database =\u003e self.handle_create_database_query(),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E1102 not supported command. possible commands: (create table). but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    // ALTER TABLE...\n    pub(crate) fn handle_alter_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1103 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_alter_table_query(context),\n            Token::Database =\u003e self.handle_alter_database_query(),\n            _ =\u003e Err(ParsingError::wrap(\n                \"E1104 not supported command. possible commands: (alter table)\",\n            )),\n        }\n    }\n\n    pub(crate) fn handle_drop_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1105 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Table =\u003e self.handle_drop_table_query(context),\n            Token::Database =\u003e self.handle_drop_database_query(),\n            _ =\u003e Err(ParsingError::wrap(\n                \"E1106 not supported command. possible commands: (create table)\",\n            )),\n        }\n    }\n}\n","traces":[{"line":10,"address":[5145732,5145056],"length":1,"stats":{"Line":1}},{"line":14,"address":[5145171,5145099],"length":1,"stats":{"Line":2}},{"line":15,"address":[5145177,5145226],"length":1,"stats":{"Line":0}},{"line":18,"address":[5145214],"length":1,"stats":{"Line":3}},{"line":20,"address":[5145286],"length":1,"stats":{"Line":3}},{"line":21,"address":[5145555,5145449],"length":1,"stats":{"Line":2}},{"line":22,"address":[5145535,5145427],"length":1,"stats":{"Line":4}},{"line":23,"address":[5145557],"length":1,"stats":{"Line":0}},{"line":31,"address":[5145776,5146281],"length":1,"stats":{"Line":4}},{"line":35,"address":[5145891,5145819],"length":1,"stats":{"Line":8}},{"line":36,"address":[5145946,5145897],"length":1,"stats":{"Line":0}},{"line":39,"address":[5145934],"length":1,"stats":{"Line":4}},{"line":41,"address":[5146006],"length":1,"stats":{"Line":4}},{"line":42,"address":[5146100,5146203],"length":1,"stats":{"Line":4}},{"line":43,"address":[5146186,5146078],"length":1,"stats":{"Line":3}},{"line":44,"address":[5146210,5146038],"length":1,"stats":{"Line":0}},{"line":50,"address":[5146320,5146825],"length":1,"stats":{"Line":1}},{"line":54,"address":[5146363,5146435],"length":1,"stats":{"Line":2}},{"line":55,"address":[5146490,5146441],"length":1,"stats":{"Line":0}},{"line":58,"address":[5146478],"length":1,"stats":{"Line":2}},{"line":60,"address":[5146550],"length":1,"stats":{"Line":2}},{"line":61,"address":[5146644,5146747],"length":1,"stats":{"Line":2}},{"line":62,"address":[5146730,5146622],"length":1,"stats":{"Line":2}},{"line":63,"address":[5146582,5146754],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":24},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","debug.rs"],"content":"use crate::parser::predule::Parser;\n\nimpl Parser {\n    #[allow(dead_code)]\n    pub(crate) fn show_tokens(\u0026self) {\n        println!(\"{:?}\", self);\n    }\n}\n","traces":[{"line":5,"address":[5146864],"length":1,"stats":{"Line":0}},{"line":6,"address":[5146932],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","delete.rs"],"content":"use crate::ast::dml::delete::DeleteQuery;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nuse crate::errors::predule::ParsingError;\nuse crate::lexer::predule::Token;\n\nimpl Parser {\n    pub(crate) fn handle_delete_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cDeleteQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0501 need more tokens\"));\n        }\n\n        // DELETE 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Delete {\n            return Err(ParsingError::wrap(format!(\n                \"E0502: expected 'DELETE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0503 need more tokens\"));\n        }\n\n        // FROM 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::From {\n            return Err(ParsingError::wrap(format!(\n                \"E0504: expected 'FROM'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let mut query_builder = DeleteQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0505 need more tokens\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_from_table(table_name);\n\n        // 테이블 alias 파싱\n        if self.next_token_is_table_alias() {\n            let alias = self.parse_table_alias()?;\n            query_builder = query_builder.set_from_alias(alias);\n        }\n\n        // WHERE 절 파싱\n        if self.next_token_is_where() {\n            let where_clause = self.parse_where(context)?;\n            query_builder = query_builder.set_where(where_clause);\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":9,"address":[5149787,5150220,5146992],"length":1,"stats":{"Line":1}},{"line":13,"address":[5147139,5147035],"length":1,"stats":{"Line":2}},{"line":14,"address":[5147145,5147194],"length":1,"stats":{"Line":0}},{"line":18,"address":[5147182],"length":1,"stats":{"Line":1}},{"line":20,"address":[5147320,5147250],"length":1,"stats":{"Line":2}},{"line":21,"address":[5150059],"length":1,"stats":{"Line":0}},{"line":27,"address":[5147331,5147445],"length":1,"stats":{"Line":2}},{"line":28,"address":[5147451,5147503],"length":1,"stats":{"Line":0}},{"line":32,"address":[5147491],"length":1,"stats":{"Line":1}},{"line":34,"address":[5147631,5147561],"length":1,"stats":{"Line":2}},{"line":35,"address":[5149913],"length":1,"stats":{"Line":0}},{"line":41,"address":[5147645],"length":1,"stats":{"Line":1}},{"line":43,"address":[5147756,5147820],"length":1,"stats":{"Line":2}},{"line":44,"address":[5147878,5147826],"length":1,"stats":{"Line":0}},{"line":48,"address":[5147957,5148256,5149867,5147866],"length":1,"stats":{"Line":2}},{"line":49,"address":[5148402,5148121],"length":1,"stats":{"Line":2}},{"line":52,"address":[5148937,5148445],"length":1,"stats":{"Line":1}},{"line":53,"address":[5148749,5148498],"length":1,"stats":{"Line":0}},{"line":54,"address":[5148895,5148630],"length":1,"stats":{"Line":0}},{"line":58,"address":[5149656,5148471,5148946],"length":1,"stats":{"Line":3}},{"line":59,"address":[5149468,5149028],"length":1,"stats":{"Line":1}},{"line":60,"address":[5149303,5149614],"length":1,"stats":{"Line":2}},{"line":63,"address":[5149686,5148952],"length":1,"stats":{"Line":2}}],"covered":16,"coverable":23},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","expression.rs"],"content":"use crate::ast::dml::expressions::between::BetweenExpression;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::call::CallExpression;\nuse crate::ast::dml::expressions::list::ListExpression;\nuse crate::ast::dml::expressions::not_between::NotBetweenExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::dml::expressions::parentheses::ParenthesesExpression;\nuse crate::ast::dml::expressions::unary::UnaryOperatorExpression;\nuse crate::ast::types::{BuiltInFunction, SQLExpression, SelectColumn, UserDefinedFunction};\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::Parser;\nuse crate::parser::predule::ParserContext;\n\nimpl Parser {\n    pub(crate) fn parse_expression(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0201 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Operator(operator) =\u003e {\n                if operator.is_unary_operator() {\n                    let operator: UnaryOperator = operator.try_into()?;\n                    let expression = self.parse_unary_expression(operator, context)?;\n\n                    Ok(expression)\n                } else {\n                    Err(ParsingError::wrap(format!(\n                        \"E0212 unexpected operator: {:?}\",\n                        operator\n                    )))\n                }\n            }\n            Token::Not =\u003e {\n                let operator = UnaryOperator::Not;\n\n                let expression = self.parse_unary_expression(operator, context)?;\n\n                Ok(expression)\n            }\n            Token::Integer(integer) =\u003e {\n                let lhs = SQLExpression::Integer(integer);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Float(float) =\u003e {\n                let lhs = SQLExpression::Float(float);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::String(string) =\u003e {\n                let lhs = SQLExpression::String(string);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Boolean(boolean) =\u003e {\n                let lhs = SQLExpression::Boolean(boolean);\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::Null =\u003e {\n                let lhs = SQLExpression::Null;\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else {\n                    Ok(lhs)\n                }\n            }\n            Token::LeftParentheses =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0214 need more tokens\"));\n                }\n\n                let second_token = self.get_next_token();\n\n                match second_token {\n                    Token::Select =\u003e {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        let lhs = self.parse_subquery(context.clone())?.into();\n\n                        if self.next_token_is_binary_operator(context.clone()) {\n                            let expression = self.parse_binary_expression(lhs, context)?;\n                            Ok(expression)\n                        } else if self.next_token_is_between() {\n                            let expression = self.parse_between_expression(lhs, context)?;\n                            Ok(expression)\n                        } else {\n                            Ok(lhs)\n                        }\n                    }\n                    _ =\u003e {\n                        self.unget_next_token(second_token);\n                        self.unget_next_token(current_token);\n                        let lhs = self.parse_parentheses_expression(context.clone())?;\n\n                        if self.next_token_is_binary_operator(context.clone()) {\n                            let expression = self.parse_binary_expression(lhs, context)?;\n                            Ok(expression)\n                        } else if self.next_token_is_between() {\n                            let expression = self.parse_between_expression(lhs, context)?;\n                            Ok(expression)\n                        } else {\n                            Ok(lhs)\n                        }\n                    }\n                }\n            }\n            Token::RightParentheses =\u003e Err(ParsingError::wrap(format!(\n                \"E0213 unexpected token: {:?}\",\n                current_token\n            ))),\n            Token::Identifier(identifier) =\u003e {\n                self.unget_next_token(Token::Identifier(identifier));\n                let select_column = self.parse_select_column()?;\n\n                let lhs = SQLExpression::SelectColumn(select_column.clone());\n\n                if self.next_token_is_binary_operator(context.clone()) {\n                    let expression = self.parse_binary_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_between() {\n                    let expression = self.parse_between_expression(lhs, context)?;\n                    Ok(expression)\n                } else if self.next_token_is_left_parentheses() {\n                    let SelectColumn {\n                        table_name,\n                        column_name,\n                    } = select_column;\n\n                    let lhs = self.parse_function_call_expression(\n                        table_name,\n                        column_name,\n                        context.clone(),\n                    )?;\n\n                    if self.next_token_is_binary_operator(context.clone()) {\n                        let expression = self.parse_binary_expression(lhs, context)?;\n                        Ok(expression)\n                    } else if self.next_token_is_between() {\n                        let expression = self.parse_between_expression(lhs, context)?;\n                        Ok(expression)\n                    } else {\n                        Ok(lhs)\n                    }\n                } else {\n                    Ok(lhs)\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0202 unexpected token: {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_unary_expression(\n        \u0026mut self,\n        operator: UnaryOperator,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0201 need more tokens\"));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        // expression이 2항 표현식일 경우 단항 표현식이 최우선으로 처리되게 구성\n        match expression {\n            SQLExpression::Binary(mut binary) =\u003e {\n                binary.lhs = UnaryOperatorExpression {\n                    operand: binary.lhs,\n                    operator,\n                }\n                .into();\n\n                Ok(binary.into())\n            }\n            SQLExpression::Between(mut between) =\u003e {\n                between.a = UnaryOperatorExpression {\n                    operand: between.a,\n                    operator,\n                }\n                .into();\n\n                Ok(between.into())\n            }\n            _ =\u003e Ok(UnaryOperatorExpression {\n                operand: expression,\n                operator,\n            }\n            .into()),\n        }\n    }\n\n    /**\n     * 소괄호연산자, 혹은 리스트 파싱\n    parenexpr ::= '(' expression ')'\n    parenexpr ::= '(' 1, 2, 3 ')'\n    */\n    pub(crate) fn parse_parentheses_expression(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let context = context.set_in_parentheses(true);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0203 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0204 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let expression = self.parse_expression(context.clone())?;\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0205 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        match current_token {\n            // 우선순위 연산자\n            Token::RightParentheses =\u003e {\n                let expression = ParenthesesExpression { expression };\n\n                Ok(expression.into())\n            }\n            // 리스트 표현식\n            Token::Comma =\u003e {\n                let mut list = ListExpression {\n                    value: vec![expression],\n                };\n\n                loop {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0215 need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    match current_token {\n                        Token::RightParentheses =\u003e break,\n                        Token::Comma =\u003e continue,\n                        _ =\u003e {\n                            self.unget_next_token(current_token);\n                            let expression = self.parse_expression(context.clone())?;\n                            list.value.push(expression);\n                            continue;\n                        }\n                    }\n                }\n\n                Ok(list.into())\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"expected right parentheses. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n\n    /**\n     * 2항 연산식 파싱\n     */\n    pub(crate) fn parse_binary_expression(\n        \u0026mut self,\n        lhs: SQLExpression,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0206 need more tokens\"));\n        }\n\n        // 연산자 획득\n        let current_token = self.get_next_token();\n\n        let operator: Result\u003cBinaryOperator, _\u003e =\n            if current_token.can_be_multi_token_operator() \u0026\u0026 self.has_next_token() {\n                let second_token = self.get_next_token();\n                current_token.try_into_multi_token_operator(second_token)\n            } else {\n                current_token.try_into()\n            };\n\n        match operator {\n            Ok(operator) =\u003e {\n                let rhs = self.parse_expression(context)?;\n\n                let current_precedence = operator.get_precedence();\n\n                let mut rhs_has_parentheses = false;\n\n                // 소괄호가 있다면 벗기고 플래그값 설정\n                let rhs = if let SQLExpression::Parentheses(paren) = rhs {\n                    rhs_has_parentheses = true;\n                    paren.expression\n                } else {\n                    rhs\n                };\n\n                if let SQLExpression::Binary(rhs_binary) = rhs.clone() {\n                    let next_precedence = rhs_binary.operator.get_precedence();\n\n                    // 단항연산식일 경우\n                    if lhs.is_unary() {\n                        let new_lhs = BinaryOperatorExpression {\n                            lhs,\n                            rhs: rhs_binary.lhs,\n                            operator,\n                        };\n                        Ok(BinaryOperatorExpression {\n                            lhs: new_lhs.into(),\n                            rhs: rhs_binary.rhs,\n                            operator: rhs_binary.operator,\n                        }\n                        .into())\n                    }\n                    // 2항연산식일 경우\n                    else {\n                        // 오른쪽 연산자의 우선순위가 더 크거나, 소괄호가 있을 경우 오른쪽을 먼저 묶어서 바인딩\n                        if next_precedence \u003e current_precedence || rhs_has_parentheses {\n                            Ok(BinaryOperatorExpression { lhs, rhs, operator }.into())\n                        }\n                        // 아니라면 왼쪽으로 묶어서 바인딩\n                        else {\n                            let new_lhs = BinaryOperatorExpression {\n                                lhs,\n                                rhs: rhs_binary.lhs,\n                                operator,\n                            };\n                            Ok(BinaryOperatorExpression {\n                                lhs: new_lhs.into(),\n                                rhs: rhs_binary.rhs,\n                                operator: rhs_binary.operator,\n                            }\n                            .into())\n                        }\n                    }\n                } else {\n                    Ok(BinaryOperatorExpression { lhs, rhs, operator }.into())\n                }\n            }\n            Err(error) =\u003e Err(error),\n        }\n    }\n\n    /**\n     * 함수호출 파싱\n     */\n    pub(crate) fn parse_function_call_expression(\n        \u0026mut self,\n        database_name: Option\u003cString\u003e,\n        function_name: String,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let function = if database_name.is_some() {\n            UserDefinedFunction {\n                database_name,\n                function_name,\n            }\n            .into()\n        } else {\n            match BuiltInFunction::try_from(function_name.clone()) {\n                Ok(builtin) =\u003e builtin.into(),\n                Err(_) =\u003e UserDefinedFunction {\n                    database_name,\n                    function_name,\n                }\n                .into(),\n            }\n        };\n\n        let mut call_expression = CallExpression {\n            function,\n            arguments: vec![],\n        };\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0207 need more tokens\"));\n        }\n\n        // ( 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected left parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0208 need more tokens\"));\n        }\n\n        // 닫는 괄호가 나올때까지 인자 파싱\n        loop {\n            if self.next_token_is_right_parentheses() {\n                break;\n            }\n\n            // 표현식 파싱\n            let expression = self.parse_expression(context.clone())?;\n\n            call_expression.arguments.push(expression);\n\n            // 쉼표 삼키기.\n            if self.next_token_is_comma() {\n                self.get_next_token();\n            }\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0209 need more tokens\"));\n        }\n\n        // ) 삼킴\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected right parentheses. but your input is {:?}\",\n                current_token\n            )));\n        }\n\n        Ok(call_expression.into())\n    }\n\n    /**\n     * between 및 not between 절 파싱\n     */\n    pub(crate) fn parse_between_expression(\n        \u0026mut self,\n        a: SQLExpression,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLExpression, RRDBError\u003e {\n        let context = context.set_in_between_clause(true);\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0210 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Between =\u003e {\n                let x = self.parse_expression(context.clone())?;\n\n                // AND 삼킴\n                self.get_next_token();\n\n                let y = self.parse_expression(context)?;\n\n                let expression = BetweenExpression { a, x, y };\n\n                Ok(expression.into())\n            }\n            Token::Not =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0211 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Between =\u003e {\n                        let x = self.parse_expression(context.clone())?;\n\n                        // AND 삼킴\n                        self.get_next_token();\n\n                        let y = self.parse_expression(context)?;\n\n                        let expression = NotBetweenExpression { a, x, y };\n\n                        Ok(expression.into())\n                    }\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"expected between. but your input is {:?}\",\n                        current_token\n                    ))),\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"expected between. but your input is {:?}\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":17,"address":[5154518,5150256,5165026],"length":1,"stats":{"Line":1}},{"line":21,"address":[5150544,5150344],"length":1,"stats":{"Line":2}},{"line":22,"address":[5150599,5150550],"length":1,"stats":{"Line":0}},{"line":25,"address":[5150633,5150587],"length":1,"stats":{"Line":2}},{"line":27,"address":[5150657],"length":1,"stats":{"Line":1}},{"line":28,"address":[5151377],"length":1,"stats":{"Line":1}},{"line":29,"address":[5151399,5161179,5160573,5160817],"length":1,"stats":{"Line":3}},{"line":30,"address":[5160675,5161296,5160838,5160956,5160888],"length":1,"stats":{"Line":3}},{"line":31,"address":[5160897,5160881,5161189,5161077],"length":1,"stats":{"Line":3}},{"line":33,"address":[5161145],"length":1,"stats":{"Line":1}},{"line":35,"address":[5160698],"length":1,"stats":{"Line":0}},{"line":42,"address":[5150810],"length":1,"stats":{"Line":1}},{"line":44,"address":[5151697,5150818,5151588,5151818],"length":1,"stats":{"Line":2}},{"line":46,"address":[5151656],"length":1,"stats":{"Line":1}},{"line":48,"address":[5150991],"length":1,"stats":{"Line":1}},{"line":49,"address":[5151007],"length":1,"stats":{"Line":1}},{"line":51,"address":[5151049,5156370,5155543],"length":1,"stats":{"Line":5}},{"line":52,"address":[5156380,5156268,5155593],"length":1,"stats":{"Line":4}},{"line":53,"address":[5156336],"length":1,"stats":{"Line":3}},{"line":54,"address":[5155569,5155829,5156125,5155750],"length":1,"stats":{"Line":5}},{"line":55,"address":[5155844,5156135,5156023],"length":1,"stats":{"Line":3}},{"line":56,"address":[5156091],"length":1,"stats":{"Line":2}},{"line":58,"address":[5155756],"length":1,"stats":{"Line":1}},{"line":61,"address":[5151064],"length":1,"stats":{"Line":0}},{"line":62,"address":[5151082],"length":1,"stats":{"Line":0}},{"line":64,"address":[5151125,5157386,5156559],"length":1,"stats":{"Line":0}},{"line":65,"address":[5156609,5157284,5157396],"length":1,"stats":{"Line":0}},{"line":66,"address":[5157352],"length":1,"stats":{"Line":0}},{"line":67,"address":[5157141,5156845,5156585,5156766],"length":1,"stats":{"Line":0}},{"line":68,"address":[5157151,5156860,5157039],"length":1,"stats":{"Line":0}},{"line":69,"address":[5157107],"length":1,"stats":{"Line":0}},{"line":71,"address":[5156772],"length":1,"stats":{"Line":0}},{"line":74,"address":[5151212],"length":1,"stats":{"Line":1}},{"line":75,"address":[5151252],"length":1,"stats":{"Line":1}},{"line":77,"address":[5158591,5159418,5151318],"length":1,"stats":{"Line":2}},{"line":78,"address":[5158641,5159428,5159316],"length":1,"stats":{"Line":0}},{"line":79,"address":[5159384],"length":1,"stats":{"Line":0}},{"line":80,"address":[5159173,5158798,5158877,5158617],"length":1,"stats":{"Line":3}},{"line":81,"address":[5159183,5159071,5158892],"length":1,"stats":{"Line":0}},{"line":82,"address":[5159139],"length":1,"stats":{"Line":0}},{"line":84,"address":[5158804],"length":1,"stats":{"Line":1}},{"line":87,"address":[5151140],"length":1,"stats":{"Line":1}},{"line":88,"address":[5151156],"length":1,"stats":{"Line":1}},{"line":90,"address":[5151197,5157575,5158402],"length":1,"stats":{"Line":2}},{"line":91,"address":[5157625,5158300,5158412],"length":1,"stats":{"Line":0}},{"line":92,"address":[5158368],"length":1,"stats":{"Line":0}},{"line":93,"address":[5157782,5157601,5158157,5157861],"length":1,"stats":{"Line":3}},{"line":94,"address":[5158055,5158167,5157876],"length":1,"stats":{"Line":0}},{"line":95,"address":[5158123],"length":1,"stats":{"Line":0}},{"line":97,"address":[5157788],"length":1,"stats":{"Line":1}},{"line":101,"address":[5151333],"length":1,"stats":{"Line":2}},{"line":103,"address":[5160434,5159607,5151367],"length":1,"stats":{"Line":4}},{"line":104,"address":[5159657,5160444,5160332],"length":1,"stats":{"Line":0}},{"line":105,"address":[5160400],"length":1,"stats":{"Line":0}},{"line":106,"address":[5159633,5159814,5160189,5159893],"length":1,"stats":{"Line":6}},{"line":107,"address":[5160087,5160199,5159908],"length":1,"stats":{"Line":0}},{"line":108,"address":[5160155],"length":1,"stats":{"Line":0}},{"line":110,"address":[5159820],"length":1,"stats":{"Line":2}},{"line":114,"address":[5151418,5161305],"length":1,"stats":{"Line":2}},{"line":115,"address":[5161311,5161363],"length":1,"stats":{"Line":0}},{"line":118,"address":[5161351],"length":1,"stats":{"Line":1}},{"line":120,"address":[5161386],"length":1,"stats":{"Line":1}},{"line":122,"address":[5161413],"length":1,"stats":{"Line":1}},{"line":123,"address":[5161448],"length":1,"stats":{"Line":1}},{"line":124,"address":[5162808,5161532],"length":1,"stats":{"Line":1}},{"line":126,"address":[5161846,5162673,5161785],"length":1,"stats":{"Line":2}},{"line":127,"address":[5161896,5162571,5162683],"length":1,"stats":{"Line":0}},{"line":128,"address":[5162639],"length":1,"stats":{"Line":0}},{"line":129,"address":[5162053,5161872,5162428,5162132],"length":1,"stats":{"Line":3}},{"line":130,"address":[5162326,5162147,5162438],"length":1,"stats":{"Line":0}},{"line":131,"address":[5162394],"length":1,"stats":{"Line":0}},{"line":133,"address":[5162059],"length":1,"stats":{"Line":1}},{"line":137,"address":[5161433],"length":1,"stats":{"Line":1}},{"line":138,"address":[5162818],"length":1,"stats":{"Line":1}},{"line":139,"address":[5164307,5162902,5163186],"length":1,"stats":{"Line":1}},{"line":141,"address":[5164172,5163171,5163345],"length":1,"stats":{"Line":3}},{"line":142,"address":[5163395,5164070,5164182],"length":1,"stats":{"Line":2}},{"line":143,"address":[5164138],"length":1,"stats":{"Line":1}},{"line":144,"address":[5163631,5163371,5163927,5163552],"length":1,"stats":{"Line":3}},{"line":145,"address":[5163937,5163646,5163825],"length":1,"stats":{"Line":0}},{"line":146,"address":[5163893],"length":1,"stats":{"Line":0}},{"line":148,"address":[5163558],"length":1,"stats":{"Line":1}},{"line":153,"address":[5164436],"length":1,"stats":{"Line":0}},{"line":157,"address":[5150888],"length":1,"stats":{"Line":1}},{"line":158,"address":[5150928],"length":1,"stats":{"Line":1}},{"line":159,"address":[5152055,5155484,5151852],"length":1,"stats":{"Line":1}},{"line":161,"address":[5152040,5152206],"length":1,"stats":{"Line":2}},{"line":163,"address":[5152349,5152288,5154960],"length":1,"stats":{"Line":3}},{"line":164,"address":[5152399,5154970,5155240,5154858],"length":1,"stats":{"Line":2}},{"line":165,"address":[5154926],"length":1,"stats":{"Line":1}},{"line":166,"address":[5152556,5152375,5154725],"length":1,"stats":{"Line":4}},{"line":167,"address":[5152591,5154623,5154735],"length":1,"stats":{"Line":0}},{"line":168,"address":[5154691],"length":1,"stats":{"Line":0}},{"line":169,"address":[5154015,5152748,5152567,5152827],"length":1,"stats":{"Line":7}},{"line":171,"address":[5152837],"length":1,"stats":{"Line":2}},{"line":172,"address":[5152877],"length":1,"stats":{"Line":2}},{"line":175,"address":[5153477,5153077,5153164,5154527],"length":1,"stats":{"Line":4}},{"line":176,"address":[5152917],"length":1,"stats":{"Line":2}},{"line":177,"address":[5152957],"length":1,"stats":{"Line":2}},{"line":178,"address":[5153005],"length":1,"stats":{"Line":2}},{"line":181,"address":[5153382,5153556,5154383],"length":1,"stats":{"Line":4}},{"line":182,"address":[5154281,5154393,5153606],"length":1,"stats":{"Line":0}},{"line":183,"address":[5154349],"length":1,"stats":{"Line":0}},{"line":184,"address":[5153582,5153842,5154138,5153763],"length":1,"stats":{"Line":6}},{"line":185,"address":[5153857,5154148,5154036],"length":1,"stats":{"Line":0}},{"line":186,"address":[5154104],"length":1,"stats":{"Line":0}},{"line":188,"address":[5153769],"length":1,"stats":{"Line":2}},{"line":191,"address":[5152754],"length":1,"stats":{"Line":1}},{"line":194,"address":[5164560],"length":1,"stats":{"Line":0}},{"line":201,"address":[5167663,5165056,5166675],"length":1,"stats":{"Line":1}},{"line":206,"address":[5165112,5165240],"length":1,"stats":{"Line":2}},{"line":207,"address":[5165246,5165339],"length":1,"stats":{"Line":0}},{"line":210,"address":[5165686,5165280,5165389],"length":1,"stats":{"Line":2}},{"line":213,"address":[5165610],"length":1,"stats":{"Line":1}},{"line":214,"address":[5166019],"length":1,"stats":{"Line":1}},{"line":215,"address":[5166227,5166549,5166411],"length":1,"stats":{"Line":2}},{"line":216,"address":[5166168,5166349,5166059],"length":1,"stats":{"Line":2}},{"line":221,"address":[5166575,5166498],"length":1,"stats":{"Line":2}},{"line":223,"address":[5166087],"length":1,"stats":{"Line":0}},{"line":224,"address":[5166796,5166980,5167118],"length":1,"stats":{"Line":0}},{"line":225,"address":[5166127,5166918,5166737],"length":1,"stats":{"Line":0}},{"line":230,"address":[5167067,5167144],"length":1,"stats":{"Line":0}},{"line":232,"address":[5167325,5165899],"length":1,"stats":{"Line":2}},{"line":233,"address":[5165795],"length":1,"stats":{"Line":1}},{"line":236,"address":[5167359],"length":1,"stats":{"Line":1}},{"line":245,"address":[5170372,5167696,5170860],"length":1,"stats":{"Line":1}},{"line":249,"address":[5167739],"length":1,"stats":{"Line":1}},{"line":251,"address":[5167843,5167791],"length":1,"stats":{"Line":2}},{"line":252,"address":[5167849,5167898],"length":1,"stats":{"Line":0}},{"line":256,"address":[5167886],"length":1,"stats":{"Line":1}},{"line":258,"address":[5167998,5167928],"length":1,"stats":{"Line":2}},{"line":259,"address":[5170736],"length":1,"stats":{"Line":0}},{"line":265,"address":[5168009,5168123],"length":1,"stats":{"Line":2}},{"line":266,"address":[5168129,5168181],"length":1,"stats":{"Line":0}},{"line":270,"address":[5168169,5170731,5168490,5168238],"length":1,"stats":{"Line":2}},{"line":272,"address":[5168471,5168640],"length":1,"stats":{"Line":2}},{"line":273,"address":[5168646,5168698],"length":1,"stats":{"Line":0}},{"line":277,"address":[5168686],"length":1,"stats":{"Line":1}},{"line":279,"address":[5168735],"length":1,"stats":{"Line":1}},{"line":282,"address":[5168893],"length":1,"stats":{"Line":1}},{"line":284,"address":[5170479,5169061],"length":1,"stats":{"Line":2}},{"line":289,"address":[5168878,5169134],"length":1,"stats":{"Line":2}},{"line":293,"address":[5169354,5169410],"length":1,"stats":{"Line":2}},{"line":294,"address":[5169468,5169416],"length":1,"stats":{"Line":0}},{"line":297,"address":[5169504,5169456],"length":1,"stats":{"Line":2}},{"line":299,"address":[5169512],"length":1,"stats":{"Line":1}},{"line":303,"address":[5169551],"length":1,"stats":{"Line":1}},{"line":304,"address":[5170174,5169799],"length":1,"stats":{"Line":1}},{"line":305,"address":[5170055],"length":1,"stats":{"Line":1}},{"line":311,"address":[5169651],"length":1,"stats":{"Line":1}},{"line":313,"address":[5170518],"length":1,"stats":{"Line":0}},{"line":323,"address":[5175964,5175097,5170880],"length":1,"stats":{"Line":2}},{"line":328,"address":[5171072,5170928],"length":1,"stats":{"Line":4}},{"line":329,"address":[5171078,5171130],"length":1,"stats":{"Line":0}},{"line":333,"address":[5171167,5171118],"length":1,"stats":{"Line":4}},{"line":335,"address":[5171239,5171183,5171313],"length":1,"stats":{"Line":5}},{"line":337,"address":[5171347],"length":1,"stats":{"Line":1}},{"line":338,"address":[5171387],"length":1,"stats":{"Line":1}},{"line":340,"address":[5171354,5171245],"length":1,"stats":{"Line":4}},{"line":343,"address":[5171356],"length":1,"stats":{"Line":2}},{"line":344,"address":[5171470],"length":1,"stats":{"Line":2}},{"line":345,"address":[5171608,5171484,5171848],"length":1,"stats":{"Line":3}},{"line":347,"address":[5171829,5171998],"length":1,"stats":{"Line":2}},{"line":349,"address":[5172005],"length":1,"stats":{"Line":2}},{"line":352,"address":[5172171,5172013],"length":1,"stats":{"Line":5}},{"line":353,"address":[5172077],"length":1,"stats":{"Line":1}},{"line":354,"address":[5172085,5172257,5172178],"length":1,"stats":{"Line":2}},{"line":356,"address":[5172121],"length":1,"stats":{"Line":3}},{"line":359,"address":[5172343,5172296],"length":1,"stats":{"Line":6}},{"line":360,"address":[5172431,5172877],"length":1,"stats":{"Line":4}},{"line":363,"address":[5172884,5174855],"length":1,"stats":{"Line":2}},{"line":366,"address":[5174449,5174181,5172950],"length":1,"stats":{"Line":0}},{"line":369,"address":[5174593,5174821],"length":1,"stats":{"Line":0}},{"line":370,"address":[5174414],"length":1,"stats":{"Line":0}},{"line":371,"address":[5174561,5174470],"length":1,"stats":{"Line":0}},{"line":372,"address":[5174587,5174795,5174528],"length":1,"stats":{"Line":0}},{"line":379,"address":[5172990,5174174,5172913],"length":1,"stats":{"Line":4}},{"line":380,"address":[5173009,5174140],"length":1,"stats":{"Line":2}},{"line":386,"address":[5173402,5173710],"length":1,"stats":{"Line":1}},{"line":389,"address":[5173854,5174082],"length":1,"stats":{"Line":2}},{"line":390,"address":[5173675],"length":1,"stats":{"Line":1}},{"line":391,"address":[5173731,5173822],"length":1,"stats":{"Line":1}},{"line":392,"address":[5173789,5174056,5173848],"length":1,"stats":{"Line":2}},{"line":398,"address":[5175179,5172465],"length":1,"stats":{"Line":6}},{"line":401,"address":[5171538],"length":1,"stats":{"Line":0}},{"line":408,"address":[5179012,5177931,5176000],"length":1,"stats":{"Line":2}},{"line":414,"address":[5176053,5176157],"length":1,"stats":{"Line":4}},{"line":421,"address":[5176364,5176168],"length":1,"stats":{"Line":4}},{"line":422,"address":[5176426,5176652],"length":1,"stats":{"Line":2}},{"line":433,"address":[5176701],"length":1,"stats":{"Line":1}},{"line":436,"address":[5176901,5176845],"length":1,"stats":{"Line":4}},{"line":437,"address":[5176907,5176959],"length":1,"stats":{"Line":0}},{"line":441,"address":[5176947],"length":1,"stats":{"Line":2}},{"line":443,"address":[5177065,5176995],"length":1,"stats":{"Line":4}},{"line":444,"address":[5178774],"length":1,"stats":{"Line":0}},{"line":450,"address":[5177190,5177076],"length":1,"stats":{"Line":4}},{"line":451,"address":[5177196,5177244],"length":1,"stats":{"Line":0}},{"line":455,"address":[5177873],"length":1,"stats":{"Line":2}},{"line":456,"address":[5177284,5177228],"length":1,"stats":{"Line":4}},{"line":461,"address":[5177350,5177697,5177303],"length":1,"stats":{"Line":4}},{"line":463,"address":[5177578],"length":1,"stats":{"Line":2}},{"line":466,"address":[5177844],"length":1,"stats":{"Line":2}},{"line":467,"address":[5177891],"length":1,"stats":{"Line":2}},{"line":471,"address":[5177957,5177315],"length":1,"stats":{"Line":4}},{"line":472,"address":[5178015,5177963],"length":1,"stats":{"Line":0}},{"line":476,"address":[5178003],"length":1,"stats":{"Line":2}},{"line":478,"address":[5178108,5178038],"length":1,"stats":{"Line":4}},{"line":479,"address":[5178596],"length":1,"stats":{"Line":0}},{"line":485,"address":[5178114,5178336],"length":1,"stats":{"Line":4}},{"line":491,"address":[5179056,5181339,5183323],"length":1,"stats":{"Line":1}},{"line":496,"address":[5179104,5179223],"length":1,"stats":{"Line":2}},{"line":498,"address":[5179231,5179284],"length":1,"stats":{"Line":2}},{"line":499,"address":[5179339,5179290],"length":1,"stats":{"Line":0}},{"line":502,"address":[5179327],"length":1,"stats":{"Line":2}},{"line":504,"address":[5179373],"length":1,"stats":{"Line":2}},{"line":506,"address":[5179535,5183077,5181836,5181580],"length":1,"stats":{"Line":4}},{"line":509,"address":[5181990,5181821],"length":1,"stats":{"Line":4}},{"line":511,"address":[5182002,5182806],"length":1,"stats":{"Line":2}},{"line":513,"address":[5182285],"length":1,"stats":{"Line":2}},{"line":515,"address":[5182950,5182768],"length":1,"stats":{"Line":4}},{"line":518,"address":[5179589,5179511],"length":1,"stats":{"Line":2}},{"line":519,"address":[5179595,5179647],"length":1,"stats":{"Line":0}},{"line":522,"address":[5179635],"length":1,"stats":{"Line":1}},{"line":524,"address":[5179683],"length":1,"stats":{"Line":1}},{"line":526,"address":[5179880,5180136,5179710,5181415],"length":1,"stats":{"Line":2}},{"line":529,"address":[5180290,5180121],"length":1,"stats":{"Line":2}},{"line":531,"address":[5180302,5181106],"length":1,"stats":{"Line":1}},{"line":533,"address":[5180585],"length":1,"stats":{"Line":1}},{"line":535,"address":[5181068,5181253],"length":1,"stats":{"Line":2}},{"line":537,"address":[5181417],"length":1,"stats":{"Line":0}},{"line":543,"address":[5183124],"length":1,"stats":{"Line":0}}],"covered":166,"coverable":231},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","insert.rs"],"content":"use crate::ast::dml::insert::InsertQuery;\nuse crate::ast::dml::parts::insert_values::InsertValue;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_insert_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cInsertQuery, RRDBError\u003e {\n        let mut query_builder = InsertQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0401 need more tokens\"));\n        }\n\n        // INSERT 토큰 삼키기\n        let current_token = self.get_next_token();\n        if current_token != Token::Insert {\n            return Err(ParsingError::wrap(\"E0402 expected INSERT\"));\n        }\n\n        // INTO 토큰 삼키기\n        let current_token = self.get_next_token();\n        if current_token != Token::Into {\n            return Err(ParsingError::wrap(\"E0403 expected INTO\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_into_table(table_name);\n\n        // 컬럼명 지정 파싱\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0404 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::LeftParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"expected '('. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0405 need more tokens\"));\n        }\n\n        // 컬럼명 지정 파싱\n        let columns = self.parse_insert_columns(context.clone())?;\n        query_builder = query_builder.set_columns(columns.clone());\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0413 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Values =\u003e {\n                self.unget_next_token(current_token);\n                let values = self.parse_insert_values(context)?;\n\n                if values.iter().any(|e| e.list.len() != columns.len()) {\n                    return Err(ParsingError::wrap(\n                        \"E0415 The number of values in insert and the number of columns do not match.\",\n                    ));\n                }\n\n                query_builder = query_builder.set_values(values);\n            }\n            Token::Select =\u003e {\n                self.unget_next_token(current_token);\n                let select = self.handle_select_query(context)?;\n\n                if select.select_items.len() != columns.len() {\n                    return Err(ParsingError::wrap(\n                        \"E0416 The number of values in insert and the number of columns do not match.\",\n                    ));\n                }\n\n                query_builder = query_builder.set_select(select);\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E0414 expected 'Values'. but your input word is '{:?}'\",\n                    current_token\n                )))\n            }\n        }\n\n        // TODO: On Conflict 절 파싱\n\n        // TODO: Returning 절 파싱\n\n        Ok(query_builder.build())\n    }\n\n    // INSERT의 컬럼명 지정 부분 파싱\n    // INSERT INTO (A, B, C) Values (1, 2, 3);\n    //              ^^^^^^^\n    pub(crate) fn parse_insert_columns(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cVec\u003cString\u003e, RRDBError\u003e {\n        let mut names = vec![];\n        loop {\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0406 need more tokens\"));\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Identifier(identifier) =\u003e {\n                    names.push(identifier);\n                    continue;\n                }\n                Token::Comma =\u003e {\n                    continue;\n                }\n                Token::RightParentheses =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                _ =\u003e {\n                    return Err(ParsingError::wrap(format!(\n                        \"E0407 unexpected input word '{:?}'\",\n                        current_token\n                    )));\n                }\n            }\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::RightParentheses {\n            return Err(ParsingError::wrap(format!(\n                \"E0408 expected ')'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        Ok(names)\n    }\n\n    // Values 절 파싱\n    // INSERT INTO (A, B, C) Values(1, 2, 3);\n    //                       ^^^^^^^^^^^^^^^\n    pub(crate) fn parse_insert_values(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cVec\u003cInsertValue\u003e, RRDBError\u003e {\n        // Values 파싱\n        let mut values: Vec\u003cInsertValue\u003e = vec![];\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0409 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Values {\n            return Err(ParsingError::wrap(format!(\n                \"E0408 expected 'Values'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        loop {\n            let mut list = vec![];\n\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            if current_token != Token::LeftParentheses {\n                self.unget_next_token(current_token);\n                break;\n            }\n\n            if !self.has_next_token() {\n                return Err(ParsingError::wrap(\"E0411 need more tokens\"));\n            }\n\n            // 각 Value 절 파싱. (A, B, C, D...)\n            loop {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0412 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Comma =\u003e {\n                        continue;\n                    }\n                    Token::RightParentheses =\u003e {\n                        break;\n                    }\n                    Token::Default =\u003e {\n                        list.push(None);\n                        continue;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let expression = self.parse_expression(context.clone())?;\n                            list.push(Some(expression));\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            // 쉼표가 있으면 삼키기\n            if self.pick_next_token() == Token::Comma {\n                self.get_next_token();\n            }\n\n            let value = InsertValue { list };\n\n            values.push(value);\n        }\n\n        Ok(values)\n    }\n}\n","traces":[{"line":9,"address":[5187080,5188725,5183360],"length":1,"stats":{"Line":3}},{"line":13,"address":[5183416],"length":1,"stats":{"Line":3}},{"line":15,"address":[5183541,5183602],"length":1,"stats":{"Line":6}},{"line":16,"address":[5183608,5183663],"length":1,"stats":{"Line":0}},{"line":20,"address":[5183648],"length":1,"stats":{"Line":3}},{"line":21,"address":[5183724,5183794],"length":1,"stats":{"Line":8}},{"line":22,"address":[5188625,5183820],"length":1,"stats":{"Line":0}},{"line":26,"address":[5183813],"length":1,"stats":{"Line":4}},{"line":27,"address":[5183850,5183920],"length":1,"stats":{"Line":8}},{"line":28,"address":[5183946,5188554],"length":1,"stats":{"Line":0}},{"line":32,"address":[5183997,5184363,5183939,5188526],"length":1,"stats":{"Line":8}},{"line":33,"address":[5184514,5184161],"length":1,"stats":{"Line":8}},{"line":36,"address":[5184618],"length":1,"stats":{"Line":4}},{"line":37,"address":[5184639,5184694],"length":1,"stats":{"Line":0}},{"line":40,"address":[5184679],"length":1,"stats":{"Line":4}},{"line":42,"address":[5184750,5184820],"length":1,"stats":{"Line":8}},{"line":43,"address":[5188356],"length":1,"stats":{"Line":0}},{"line":49,"address":[5184831,5184945],"length":1,"stats":{"Line":8}},{"line":50,"address":[5185006,5184951],"length":1,"stats":{"Line":0}},{"line":54,"address":[5184991,5185088,5188351,5185362],"length":1,"stats":{"Line":8}},{"line":55,"address":[5185467,5188341,5185212],"length":1,"stats":{"Line":4}},{"line":57,"address":[5185664,5185723],"length":1,"stats":{"Line":8}},{"line":58,"address":[5185784,5185729],"length":1,"stats":{"Line":0}},{"line":61,"address":[5185849,5185769],"length":1,"stats":{"Line":8}},{"line":63,"address":[5185857],"length":1,"stats":{"Line":4}},{"line":65,"address":[5186058],"length":1,"stats":{"Line":3}},{"line":66,"address":[5187120,5187331,5188133],"length":1,"stats":{"Line":3}},{"line":68,"address":[4360750,4360720],"length":1,"stats":{"Line":11}},{"line":69,"address":[5187746,5188014],"length":1,"stats":{"Line":0}},{"line":74,"address":[5187571,5187776],"length":1,"stats":{"Line":6}},{"line":77,"address":[5185998],"length":1,"stats":{"Line":1}},{"line":78,"address":[5186167,5186390,5187089],"length":1,"stats":{"Line":1}},{"line":80,"address":[5186536,5186367],"length":1,"stats":{"Line":2}},{"line":81,"address":[5186754,5186964],"length":1,"stats":{"Line":0}},{"line":86,"address":[5186784,5186579],"length":1,"stats":{"Line":2}},{"line":89,"address":[5188135],"length":1,"stats":{"Line":0}},{"line":100,"address":[5186826,5187831],"length":1,"stats":{"Line":6}},{"line":106,"address":[5190255,5189939,5188752],"length":1,"stats":{"Line":4}},{"line":110,"address":[5188787],"length":1,"stats":{"Line":4}},{"line":111,"address":[5188864],"length":1,"stats":{"Line":4}},{"line":112,"address":[5188877,5188930],"length":1,"stats":{"Line":8}},{"line":113,"address":[5188985,5188936],"length":1,"stats":{"Line":0}},{"line":116,"address":[5189019,5188973],"length":1,"stats":{"Line":8}},{"line":118,"address":[5189035],"length":1,"stats":{"Line":4}},{"line":119,"address":[5189193],"length":1,"stats":{"Line":4}},{"line":120,"address":[5189233,5189388],"length":1,"stats":{"Line":8}},{"line":127,"address":[5189284],"length":1,"stats":{"Line":4}},{"line":131,"address":[5189948],"length":1,"stats":{"Line":0}},{"line":139,"address":[5189466],"length":1,"stats":{"Line":4}},{"line":141,"address":[5189473,5189543],"length":1,"stats":{"Line":8}},{"line":142,"address":[5189761],"length":1,"stats":{"Line":0}},{"line":148,"address":[5189554],"length":1,"stats":{"Line":4}},{"line":154,"address":[5191682,5190272,5192878],"length":1,"stats":{"Line":3}},{"line":159,"address":[5190307],"length":1,"stats":{"Line":3}},{"line":161,"address":[5190401,5190462],"length":1,"stats":{"Line":6}},{"line":162,"address":[5190468,5190517],"length":1,"stats":{"Line":0}},{"line":165,"address":[5190505],"length":1,"stats":{"Line":3}},{"line":167,"address":[5190547,5190617],"length":1,"stats":{"Line":6}},{"line":168,"address":[5192716],"length":1,"stats":{"Line":0}},{"line":174,"address":[5191677],"length":1,"stats":{"Line":3}},{"line":175,"address":[5190631],"length":1,"stats":{"Line":3}},{"line":177,"address":[5190742,5190806],"length":1,"stats":{"Line":6}},{"line":181,"address":[5190843],"length":1,"stats":{"Line":3}},{"line":183,"address":[5190929,5190858],"length":1,"stats":{"Line":6}},{"line":184,"address":[5190956],"length":1,"stats":{"Line":0}},{"line":188,"address":[5191018,5190940],"length":1,"stats":{"Line":6}},{"line":189,"address":[5191024,5191072],"length":1,"stats":{"Line":0}},{"line":193,"address":[5191784],"length":1,"stats":{"Line":0}},{"line":194,"address":[5191112,5191056],"length":1,"stats":{"Line":6}},{"line":195,"address":[5191118,5191170],"length":1,"stats":{"Line":0}},{"line":198,"address":[5191158,5191190],"length":1,"stats":{"Line":6}},{"line":200,"address":[5191198],"length":1,"stats":{"Line":3}},{"line":208,"address":[5191383,5191277],"length":1,"stats":{"Line":2}},{"line":212,"address":[5191253,5191695],"length":1,"stats":{"Line":6}},{"line":213,"address":[5191721],"length":1,"stats":{"Line":3}},{"line":214,"address":[5192257,5191802],"length":1,"stats":{"Line":3}},{"line":215,"address":[5192058],"length":1,"stats":{"Line":3}},{"line":223,"address":[5191406],"length":1,"stats":{"Line":3}},{"line":224,"address":[5191624],"length":1,"stats":{"Line":2}},{"line":227,"address":[5191519],"length":1,"stats":{"Line":1}},{"line":229,"address":[5191604],"length":1,"stats":{"Line":3}},{"line":232,"address":[5192569],"length":1,"stats":{"Line":2}}],"covered":63,"coverable":82},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","mod.rs"],"content":"pub mod delete;\npub mod expression;\npub mod insert;\npub mod select;\npub mod update;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","select.rs"],"content":"use std::collections::HashSet;\n\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::group_by::GroupByItem;\nuse crate::ast::dml::parts::having::HavingClause;\nuse crate::ast::dml::parts::join::{JoinClause, JoinType};\nuse crate::ast::dml::parts::order_by::{OrderByItem, OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectWildCard};\nuse crate::ast::dml::select::SelectQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_select_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSelectQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0301: need more tokens\"));\n        }\n\n        // SELECT 토큰 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Select {\n            return Err(ParsingError::wrap(format!(\n                \"E0302: expected 'SELECT'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0303: need more tokens\"));\n        }\n\n        let mut query_builder = SelectQuery::builder();\n\n        // FROM 절이나 세미콜론이 나오기 전까지 select 절 파싱\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::From =\u003e {\n                    // from 다시 집어넣고 종료\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::SemiColon =\u003e {\n                    // from 없는 select절로 간주. 종료.\n                    return Ok(query_builder.build());\n                }\n                Token::Comma =\u003e continue,\n                Token::Operator(OperatorToken::Asterisk) =\u003e {\n                    query_builder =\n                        query_builder.add_select_wildcard(SelectWildCard { alias: None });\n                    continue;\n                }\n                _ =\u003e {\n                    self.unget_next_token(current_token);\n                    let select_item = self.parse_select_item(context.clone())?;\n                    query_builder = query_builder.add_select_item(select_item);\n                }\n            }\n        }\n\n        if !self.has_next_token() {\n            return Ok(query_builder.build());\n        }\n\n        // FROM 절 파싱\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::From =\u003e {\n                if self.next_token_is_left_parentheses() {\n                    let subquery = self.parse_subquery(context.clone())?;\n                    query_builder = query_builder.set_from_subquery(subquery);\n                } else {\n                    let table_name = self.parse_table_name(context.clone())?;\n                    query_builder = query_builder.set_from_table(table_name);\n                }\n\n                if self.next_token_is_table_alias() {\n                    let alias = self.parse_table_alias()?;\n                    query_builder = query_builder.set_from_alias(alias);\n                }\n            }\n            _ =\u003e {\n                return Err(ParsingError::wrap(format!(\n                    \"E0304 expected 'FROM' clause. but your input word is '{:?}'\",\n                    current_token\n                )));\n            }\n        }\n\n        // JOIN 절 파싱\n        while let Some(join_type) = self.get_next_join_type() {\n            let join = self.parse_join(join_type, context.clone())?;\n            query_builder = query_builder.add_join(join);\n        }\n\n        // WHERE 절 파싱\n        if self.next_token_is_where() {\n            let where_clause = self.parse_where(context.clone())?;\n            query_builder = query_builder.set_where(where_clause);\n        }\n\n        // Group By 절 파싱\n        if self.next_token_is_group_by() {\n            // GROUP BY 삼킴\n            self.get_next_token();\n            self.get_next_token();\n\n            loop {\n                if !self.has_next_token() {\n                    break;\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::SemiColon =\u003e {\n                        return Ok(query_builder.build());\n                    }\n                    Token::Comma =\u003e continue,\n                    Token::Having | Token::Limit | Token::Offset | Token::Order =\u003e {\n                        self.unget_next_token(current_token);\n                        break;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let group_by_item = self.parse_group_by_item(context.clone())?;\n                            query_builder = query_builder.add_group_by(group_by_item);\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E0319 unexpected token '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n            }\n        }\n\n        if !query_builder.select_items.is_empty() {\n            // 집계 함수 \u003c\u003e GROUP BY 불일치 검증\n            if query_builder.has_aggregate() {\n                query_builder = query_builder.set_has_aggregate(true);\n\n                let group_by_columns = match query_builder.group_by_clause {\n                    Some(ref clause) =\u003e HashSet::from_iter(\n                        clause.group_by_items.clone().into_iter().map(|e| e.item),\n                    ),\n                    None =\u003e HashSet::new(),\n                };\n\n                // 집계함수가 사용되지 않은 select column 목록\n                let non_aggregate_columns = query_builder.get_non_aggregate_column();\n\n                // 집계함수가 사용되지 않은 컬럼이 group by에 없다면 오류\n                for non_aggregate_column in non_aggregate_columns {\n                    if !group_by_columns.contains(\u0026non_aggregate_column) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0331: column '{:?}' must be in a GROUP BY clause or used within an aggregate function\",\n                            non_aggregate_column\n                        )));\n                    }\n                }\n\n                // 집계함수가 사용된 select column 목록\n                let aggregate_columns = query_builder.get_aggregate_column();\n\n                // 집계함수가 사용된 컬럼이 group by에 있다면 오류\n                for aggregate_column in aggregate_columns {\n                    if group_by_columns.contains(\u0026aggregate_column) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0332: column '{:?}' cannot be in a GROUP BY clause\",\n                            group_by_columns\n                        )));\n                    }\n                }\n            }\n        }\n\n        // Having 절 파싱\n        if self.next_token_is_having() {\n            if query_builder.has_group_by() {\n                let having_clause = self.parse_having(context.clone())?;\n                query_builder = query_builder.set_having(having_clause);\n            } else {\n                return Err(ParsingError::wrap(\n                    \"E0315 Having without group by is invalid.\",\n                ));\n            }\n        }\n\n        // Order By 절 파싱\n        if self.next_token_is_order_by() {\n            // ORDER BY 삼킴\n            self.get_next_token();\n            self.get_next_token();\n\n            loop {\n                if !self.has_next_token() {\n                    break;\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::SemiColon =\u003e {\n                        return Ok(query_builder.build());\n                    }\n                    Token::Comma =\u003e continue,\n                    Token::Group | Token::Limit | Token::Offset =\u003e {\n                        self.unget_next_token(current_token);\n                        break;\n                    }\n                    _ =\u003e {\n                        if current_token.is_expression() {\n                            self.unget_next_token(current_token);\n                            let order_by_item = self.parse_order_by_item(context.clone())?;\n                            query_builder = query_builder.add_order_by(order_by_item);\n                        } else {\n                            return Err(ParsingError::wrap(format!(\n                                \"E0318 unexpected token '{:?}'\",\n                                current_token\n                            )));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Limit \u0026 Offset 절 파싱\n        // Offset이 먼저인 경우와, Limit이 먼저인 경우 둘다 대응\n        if self.next_token_is_offset() {\n            let offset = self.parse_offset(context.clone())?;\n            query_builder = query_builder.set_offset(offset);\n\n            if self.next_token_is_limit() {\n                let limit = self.parse_limit(context)?;\n                query_builder = query_builder.set_limit(limit);\n            }\n        } else if self.next_token_is_limit() {\n            let limit = self.parse_limit(context.clone())?;\n            query_builder = query_builder.set_limit(limit);\n\n            if self.next_token_is_offset() {\n                let offset = self.parse_offset(context)?;\n                query_builder = query_builder.set_offset(offset);\n            }\n        }\n\n        Ok(query_builder.build())\n    }\n\n    pub(crate) fn parse_select_item(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSelectItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0305 need more tokens\"));\n        }\n\n        let select_item = SelectItem::builder();\n\n        // 표현식 파싱\n        let select_item = select_item.set_item(self.parse_expression(context)?);\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(select_item.build());\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::As =\u003e {\n                // 더 없을 경우 바로 반환\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0306 expected alias. need more\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::Identifier(identifier) =\u003e {\n                        let select_item = select_item.set_alias(identifier);\n                        Ok(select_item.build())\n                    }\n                    _ =\u003e Err(ParsingError::wrap(format!(\n                        \"E0307 expected alias, but your input word is '{:?}'\",\n                        current_token\n                    ))),\n                }\n            }\n            Token::Comma =\u003e {\n                self.unget_next_token(current_token);\n                // 현재 select_item은 종료된 것으로 판단.\n                Ok(select_item.build())\n            }\n            Token::From =\u003e {\n                self.unget_next_token(current_token);\n                // 현재 select_item은 종료된 것으로 판단.\n                Ok(select_item.build())\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0308 expected expression. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_order_by_item(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cOrderByItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0313 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let item = self.parse_expression(context)?;\n\n        let mut order_by_item = OrderByItem {\n            item,\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        };\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(order_by_item);\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Asc =\u003e {\n                order_by_item.order_type = OrderByType::Asc;\n            }\n            Token::Desc =\u003e {\n                order_by_item.order_type = OrderByType::Desc;\n            }\n            _ =\u003e {\n                self.unget_next_token(current_token);\n            }\n        }\n\n        // 더 없을 경우 바로 반환\n        if !self.has_next_token() {\n            return Ok(order_by_item);\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Nulls =\u003e {\n                if !self.has_next_token() {\n                    return Err(ParsingError::wrap(\"E0329 need more tokens\"));\n                }\n\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::First =\u003e {}\n                    Token::Last =\u003e order_by_item.nulls = OrderByNulls::Last,\n                    _ =\u003e {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0330 expected keyword is FIRST or LAST, but your input is {:?}\",\n                            current_token\n                        )))\n                    }\n                }\n\n                Ok(order_by_item)\n            }\n            _ =\u003e {\n                self.unget_next_token(current_token);\n                Ok(order_by_item)\n            }\n        }\n    }\n\n    pub(crate) fn parse_group_by_item(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cGroupByItem, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0314 need more tokens\"));\n        }\n\n        // 표현식 파싱\n        let item = self.parse_select_column()?;\n\n        let order_by_item = GroupByItem { item };\n\n        Ok(order_by_item)\n    }\n\n    pub(crate) fn parse_join(\n        \u0026mut self,\n        join_type: JoinType,\n        context: ParserContext,\n    ) -\u003e Result\u003cJoinClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0310 need more tokens\"));\n        }\n\n        let right = self.parse_table_name(context.clone())?;\n\n        let right_alias = if self.next_token_is_table_alias() {\n            self.parse_table_alias().ok()\n        } else {\n            None\n        };\n\n        let on = if !self.has_next_token() {\n            None\n        } else {\n            let current_token = self.get_next_token();\n\n            if current_token == Token::On {\n                let expression = self.parse_expression(context)?;\n                Some(expression)\n            } else {\n                self.unget_next_token(current_token);\n                None\n            }\n        };\n\n        let join = JoinClause {\n            join_type,\n            on,\n            right,\n            right_alias,\n        };\n\n        Ok(join)\n    }\n\n    pub(crate) fn parse_where(\u0026mut self, context: ParserContext) -\u003e Result\u003cWhereClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0311 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Where {\n            return Err(ParsingError::wrap(format!(\n                \"E0312 expected 'WHERE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        Ok(expression.into())\n    }\n\n    pub(crate) fn parse_having(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cHavingClause, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0316 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Having {\n            return Err(ParsingError::wrap(format!(\n                \"E0317 expected 'Having'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let expression = self.parse_expression(context)?;\n\n        Ok(HavingClause {\n            expression: expression.into(),\n        })\n    }\n\n    pub(crate) fn parse_offset(\u0026mut self, _context: ParserContext) -\u003e Result\u003cu32, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0320 need more tokens\"));\n        }\n\n        // OFFSET 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Offset {\n            return Err(ParsingError::wrap(format!(\n                \"E0321 expected 'Offset'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // OFFSET 숫자값 획득\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0322 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Integer(integer) =\u003e {\n                if integer \u003e= 0 {\n                    Ok(integer as u32)\n                } else {\n                    Err(ParsingError::wrap(\n                        \"E0323 Offset can only contain positive numbers.\",\n                    ))\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0324 expected positive numbers. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n\n    pub(crate) fn parse_limit(\u0026mut self, _context: ParserContext) -\u003e Result\u003cu32, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0325 need more tokens\"));\n        }\n\n        // OFFSET 삼키기\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Limit {\n            return Err(ParsingError::wrap(format!(\n                \"E0326 expected 'Limit'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        // OFFSET 숫자값 획득\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0327 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Integer(integer) =\u003e {\n                if integer \u003e= 0 {\n                    Ok(integer as u32)\n                } else {\n                    Err(ParsingError::wrap(\n                        \"E0327 Limit can only contain positive numbers.\",\n                    ))\n                }\n            }\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0328 expected positive numbers. but your input word is '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":16,"address":[5195125,5192896,5206014],"length":1,"stats":{"Line":1}},{"line":20,"address":[5193014,5193196],"length":1,"stats":{"Line":2}},{"line":21,"address":[5193202,5193260],"length":1,"stats":{"Line":0}},{"line":25,"address":[5193245],"length":1,"stats":{"Line":1}},{"line":27,"address":[5193322,5193398],"length":1,"stats":{"Line":2}},{"line":28,"address":[5205844],"length":1,"stats":{"Line":0}},{"line":34,"address":[5193532,5193412],"length":1,"stats":{"Line":2}},{"line":35,"address":[5193538,5193588],"length":1,"stats":{"Line":0}},{"line":38,"address":[5193573],"length":1,"stats":{"Line":1}},{"line":41,"address":[5193649,5205716],"length":1,"stats":{"Line":4}},{"line":42,"address":[5193727,5193665],"length":1,"stats":{"Line":2}},{"line":46,"address":[5193774],"length":1,"stats":{"Line":1}},{"line":48,"address":[5194009,5193789],"length":1,"stats":{"Line":2}},{"line":51,"address":[5193951],"length":1,"stats":{"Line":1}},{"line":56,"address":[5204988,5194050],"length":1,"stats":{"Line":0}},{"line":60,"address":[5204928],"length":1,"stats":{"Line":1}},{"line":61,"address":[5204807],"length":1,"stats":{"Line":1}},{"line":62,"address":[5204962],"length":1,"stats":{"Line":1}},{"line":65,"address":[5193885],"length":1,"stats":{"Line":1}},{"line":66,"address":[5205041,5205527],"length":1,"stats":{"Line":1}},{"line":67,"address":[5205666,5205341],"length":1,"stats":{"Line":5}},{"line":72,"address":[5193741,5194183],"length":1,"stats":{"Line":6}},{"line":73,"address":[5194289,5194189],"length":1,"stats":{"Line":6}},{"line":77,"address":[5194274],"length":1,"stats":{"Line":1}},{"line":79,"address":[5194326],"length":1,"stats":{"Line":1}},{"line":81,"address":[5195556,5194348,5194511],"length":1,"stats":{"Line":3}},{"line":82,"address":[5195184,5194556,5195368],"length":1,"stats":{"Line":2}},{"line":83,"address":[5195272,5195514],"length":1,"stats":{"Line":2}},{"line":85,"address":[5194898,5194533,5194590],"length":1,"stats":{"Line":2}},{"line":86,"address":[5194754,5195040],"length":1,"stats":{"Line":2}},{"line":89,"address":[5195568,5195090,5196063],"length":1,"stats":{"Line":3}},{"line":90,"address":[5195875,5195615],"length":1,"stats":{"Line":1}},{"line":91,"address":[5195747,5196021],"length":1,"stats":{"Line":2}},{"line":95,"address":[5204655],"length":1,"stats":{"Line":0}},{"line":103,"address":[5195582,5196703,5196075],"length":1,"stats":{"Line":4}},{"line":104,"address":[5196144,5196522,5196191],"length":1,"stats":{"Line":2}},{"line":105,"address":[5196391,5196661],"length":1,"stats":{"Line":4}},{"line":109,"address":[5196159,5196746,5197416],"length":1,"stats":{"Line":3}},{"line":110,"address":[5197228,5196793],"length":1,"stats":{"Line":1}},{"line":111,"address":[5197052,5197374],"length":1,"stats":{"Line":2}},{"line":115,"address":[5197428,5196760],"length":1,"stats":{"Line":2}},{"line":117,"address":[5197475],"length":1,"stats":{"Line":1}},{"line":118,"address":[5197513],"length":1,"stats":{"Line":1}},{"line":120,"address":[5204476],"length":1,"stats":{"Line":1}},{"line":121,"address":[5197543],"length":1,"stats":{"Line":1}},{"line":125,"address":[5197589],"length":1,"stats":{"Line":1}},{"line":127,"address":[5197604],"length":1,"stats":{"Line":1}},{"line":129,"address":[5203574,5197789],"length":1,"stats":{"Line":0}},{"line":133,"address":[5197713],"length":1,"stats":{"Line":1}},{"line":137,"address":[5203618,5197688],"length":1,"stats":{"Line":2}},{"line":138,"address":[5203728],"length":1,"stats":{"Line":1}},{"line":139,"address":[5203954,5204287],"length":1,"stats":{"Line":1}},{"line":140,"address":[5204149,5204426],"length":1,"stats":{"Line":2}},{"line":142,"address":[5203786],"length":1,"stats":{"Line":0}},{"line":152,"address":[5197922,5197442],"length":1,"stats":{"Line":2}},{"line":154,"address":[5197982,5197936],"length":1,"stats":{"Line":2}},{"line":155,"address":[5197988],"length":1,"stats":{"Line":1}},{"line":157,"address":[5198096],"length":1,"stats":{"Line":1}},{"line":159,"address":[4915808,4915836],"length":1,"stats":{"Line":4}},{"line":161,"address":[5198177,5198139],"length":1,"stats":{"Line":0}},{"line":165,"address":[5198195],"length":1,"stats":{"Line":1}},{"line":168,"address":[5198329,5198513,5198463],"length":1,"stats":{"Line":3}},{"line":169,"address":[5198577,5199350],"length":1,"stats":{"Line":2}},{"line":170,"address":[5199470],"length":1,"stats":{"Line":1}},{"line":178,"address":[5198610],"length":1,"stats":{"Line":0}},{"line":181,"address":[5198817,5198633,5198767],"length":1,"stats":{"Line":0}},{"line":182,"address":[5198960,5198881],"length":1,"stats":{"Line":0}},{"line":183,"address":[5199078],"length":1,"stats":{"Line":0}},{"line":193,"address":[5197958,5199687,5200255],"length":1,"stats":{"Line":3}},{"line":194,"address":[5199726],"length":1,"stats":{"Line":1}},{"line":195,"address":[5199883,5199796,5200067],"length":1,"stats":{"Line":2}},{"line":196,"address":[5200213,5199971],"length":1,"stats":{"Line":2}},{"line":198,"address":[5199811,5199753],"length":1,"stats":{"Line":0}},{"line":205,"address":[5199701,5200267],"length":1,"stats":{"Line":2}},{"line":207,"address":[5200314],"length":1,"stats":{"Line":2}},{"line":208,"address":[5200352],"length":1,"stats":{"Line":2}},{"line":210,"address":[5203440],"length":1,"stats":{"Line":1}},{"line":211,"address":[5200382],"length":1,"stats":{"Line":2}},{"line":215,"address":[5200428],"length":1,"stats":{"Line":2}},{"line":217,"address":[5200443],"length":1,"stats":{"Line":2}},{"line":219,"address":[5202457,5200625],"length":1,"stats":{"Line":0}},{"line":223,"address":[5200552],"length":1,"stats":{"Line":0}},{"line":227,"address":[5200527,5202501],"length":1,"stats":{"Line":4}},{"line":228,"address":[5202611],"length":1,"stats":{"Line":2}},{"line":229,"address":[5203251,5202837],"length":1,"stats":{"Line":2}},{"line":230,"address":[5203390,5203081],"length":1,"stats":{"Line":2}},{"line":232,"address":[5202669],"length":1,"stats":{"Line":0}},{"line":244,"address":[5200752,5200281],"length":1,"stats":{"Line":2}},{"line":245,"address":[5201786,5202431,5200793,5201637],"length":1,"stats":{"Line":4}},{"line":246,"address":[5201891,5201711],"length":1,"stats":{"Line":4}},{"line":248,"address":[5202312,5201937],"length":1,"stats":{"Line":3}},{"line":249,"address":[5202173,5202426,5201977],"length":1,"stats":{"Line":1}},{"line":250,"address":[5202278,5202098],"length":1,"stats":{"Line":2}},{"line":252,"address":[5200807,5200766],"length":1,"stats":{"Line":2}},{"line":253,"address":[5201608,5200895,5201075],"length":1,"stats":{"Line":2}},{"line":254,"address":[5201000,5201180],"length":1,"stats":{"Line":4}},{"line":256,"address":[5201598,5201226],"length":1,"stats":{"Line":3}},{"line":257,"address":[5201266,5201603,5201462],"length":1,"stats":{"Line":1}},{"line":258,"address":[5201387,5201564],"length":1,"stats":{"Line":2}},{"line":262,"address":[5200813,5202345],"length":1,"stats":{"Line":2}},{"line":265,"address":[5208970,5206048,5208493],"length":1,"stats":{"Line":1}},{"line":269,"address":[5206091,5206195],"length":1,"stats":{"Line":2}},{"line":270,"address":[5206245,5206201],"length":1,"stats":{"Line":0}},{"line":273,"address":[5206233],"length":1,"stats":{"Line":1}},{"line":276,"address":[5206311,5208920,5208960],"length":1,"stats":{"Line":1}},{"line":279,"address":[5206908,5206852],"length":1,"stats":{"Line":2}},{"line":280,"address":[5207070,5206918],"length":1,"stats":{"Line":0}},{"line":283,"address":[5207058,5207107],"length":1,"stats":{"Line":2}},{"line":285,"address":[5207115],"length":1,"stats":{"Line":1}},{"line":288,"address":[5207338,5207629],"length":1,"stats":{"Line":2}},{"line":289,"address":[5207635,5207690],"length":1,"stats":{"Line":0}},{"line":292,"address":[5207675,5207819],"length":1,"stats":{"Line":2}},{"line":294,"address":[5207827],"length":1,"stats":{"Line":2}},{"line":295,"address":[5207845],"length":1,"stats":{"Line":2}},{"line":296,"address":[5207885],"length":1,"stats":{"Line":2}},{"line":297,"address":[5208180],"length":1,"stats":{"Line":2}},{"line":299,"address":[5208233],"length":1,"stats":{"Line":0}},{"line":306,"address":[5207357],"length":1,"stats":{"Line":1}},{"line":308,"address":[5208502],"length":1,"stats":{"Line":1}},{"line":311,"address":[5207278],"length":1,"stats":{"Line":1}},{"line":313,"address":[5207456],"length":1,"stats":{"Line":1}},{"line":315,"address":[5208657],"length":1,"stats":{"Line":0}},{"line":322,"address":[5211340,5209008,5211605],"length":1,"stats":{"Line":2}},{"line":326,"address":[5209155,5209051],"length":1,"stats":{"Line":4}},{"line":327,"address":[5209254,5209161],"length":1,"stats":{"Line":0}},{"line":331,"address":[5209773,5209195,5211588,5209320],"length":1,"stats":{"Line":4}},{"line":340,"address":[5209923,5209754],"length":1,"stats":{"Line":4}},{"line":341,"address":[5209929],"length":1,"stats":{"Line":0}},{"line":344,"address":[5210017,5210043],"length":1,"stats":{"Line":4}},{"line":346,"address":[5210051],"length":1,"stats":{"Line":2}},{"line":347,"address":[5210169],"length":1,"stats":{"Line":2}},{"line":348,"address":[5210145],"length":1,"stats":{"Line":2}},{"line":351,"address":[5210171],"length":1,"stats":{"Line":1}},{"line":354,"address":[5210090,5210252],"length":1,"stats":{"Line":3}},{"line":359,"address":[5210200,5210258],"length":1,"stats":{"Line":4}},{"line":360,"address":[5210264],"length":1,"stats":{"Line":1}},{"line":363,"address":[5210352,5210378],"length":1,"stats":{"Line":2}},{"line":365,"address":[5210386],"length":1,"stats":{"Line":3}},{"line":367,"address":[5210405,5210524],"length":1,"stats":{"Line":4}},{"line":368,"address":[5210582,5210530],"length":1,"stats":{"Line":0}},{"line":371,"address":[5210570],"length":1,"stats":{"Line":2}},{"line":373,"address":[5210634],"length":1,"stats":{"Line":2}},{"line":375,"address":[5210946],"length":1,"stats":{"Line":1}},{"line":377,"address":[5211034],"length":1,"stats":{"Line":0}},{"line":384,"address":[5210776],"length":1,"stats":{"Line":1}},{"line":387,"address":[5210421],"length":1,"stats":{"Line":1}},{"line":388,"address":[5211349],"length":1,"stats":{"Line":1}},{"line":393,"address":[5212093,5211632],"length":1,"stats":{"Line":1}},{"line":397,"address":[5211675,5211727],"length":1,"stats":{"Line":2}},{"line":398,"address":[5211733,5211782],"length":1,"stats":{"Line":0}},{"line":402,"address":[5211973,5211770,5211828,5212088],"length":1,"stats":{"Line":2}},{"line":404,"address":[5211891],"length":1,"stats":{"Line":1}},{"line":406,"address":[5211922],"length":1,"stats":{"Line":1}},{"line":409,"address":[5212128,5213753,5213782],"length":1,"stats":{"Line":1}},{"line":414,"address":[5212184,5212264],"length":1,"stats":{"Line":2}},{"line":415,"address":[5212319,5212270],"length":1,"stats":{"Line":0}},{"line":418,"address":[5213762,5212307,5212396,5212572],"length":1,"stats":{"Line":2}},{"line":420,"address":[5212745,5212721,5212553],"length":1,"stats":{"Line":2}},{"line":421,"address":[5212799,5212760],"length":1,"stats":{"Line":2}},{"line":423,"address":[5212727],"length":1,"stats":{"Line":0}},{"line":426,"address":[5212856,5213630,5212880,5212772],"length":1,"stats":{"Line":4}},{"line":427,"address":[5212862],"length":1,"stats":{"Line":0}},{"line":429,"address":[5213162,5212895],"length":1,"stats":{"Line":3}},{"line":431,"address":[5213513,5213170,5213241],"length":1,"stats":{"Line":6}},{"line":432,"address":[5213520,5213424,5213317],"length":1,"stats":{"Line":4}},{"line":433,"address":[5213487],"length":1,"stats":{"Line":2}},{"line":435,"address":[5213252],"length":1,"stats":{"Line":0}},{"line":436,"address":[5213371],"length":1,"stats":{"Line":0}},{"line":447,"address":[5213125],"length":1,"stats":{"Line":2}},{"line":450,"address":[5215052,5213808,5214878],"length":1,"stats":{"Line":1}},{"line":451,"address":[5213931,5213851],"length":1,"stats":{"Line":2}},{"line":452,"address":[5213937,5213986],"length":1,"stats":{"Line":0}},{"line":455,"address":[5213974],"length":1,"stats":{"Line":1}},{"line":457,"address":[5214020,5214090],"length":1,"stats":{"Line":2}},{"line":458,"address":[5214913],"length":1,"stats":{"Line":0}},{"line":464,"address":[5214106,5214606,5214275],"length":1,"stats":{"Line":2}},{"line":466,"address":[5214757,5214480],"length":1,"stats":{"Line":2}},{"line":469,"address":[5216269,5215088,5216095],"length":1,"stats":{"Line":1}},{"line":473,"address":[5215211,5215131],"length":1,"stats":{"Line":2}},{"line":474,"address":[5215217,5215266],"length":1,"stats":{"Line":0}},{"line":477,"address":[5215254],"length":1,"stats":{"Line":1}},{"line":479,"address":[5215300,5215370],"length":1,"stats":{"Line":2}},{"line":480,"address":[5216130],"length":1,"stats":{"Line":0}},{"line":486,"address":[5215555,5215882,5215386],"length":1,"stats":{"Line":2}},{"line":488,"address":[5216030],"length":1,"stats":{"Line":1}},{"line":489,"address":[5215760],"length":1,"stats":{"Line":1}},{"line":493,"address":[5217332,5216304,5217199],"length":1,"stats":{"Line":1}},{"line":494,"address":[5216399,5216347],"length":1,"stats":{"Line":2}},{"line":495,"address":[5216405,5216454],"length":1,"stats":{"Line":0}},{"line":499,"address":[5216442],"length":1,"stats":{"Line":1}},{"line":501,"address":[5216484,5216554],"length":1,"stats":{"Line":2}},{"line":502,"address":[5217208],"length":1,"stats":{"Line":0}},{"line":509,"address":[5216565,5216679],"length":1,"stats":{"Line":2}},{"line":510,"address":[5216685,5216737],"length":1,"stats":{"Line":0}},{"line":513,"address":[5216725],"length":1,"stats":{"Line":1}},{"line":515,"address":[5216773],"length":1,"stats":{"Line":1}},{"line":516,"address":[5216787],"length":1,"stats":{"Line":1}},{"line":517,"address":[5216957,5216807],"length":1,"stats":{"Line":2}},{"line":518,"address":[5216947],"length":1,"stats":{"Line":1}},{"line":520,"address":[5217004,5216911],"length":1,"stats":{"Line":0}},{"line":525,"address":[5217037],"length":1,"stats":{"Line":0}},{"line":532,"address":[5217360,5218255,5218388],"length":1,"stats":{"Line":2}},{"line":533,"address":[5217455,5217403],"length":1,"stats":{"Line":4}},{"line":534,"address":[5217461,5217510],"length":1,"stats":{"Line":0}},{"line":538,"address":[5217498],"length":1,"stats":{"Line":2}},{"line":540,"address":[5217610,5217540],"length":1,"stats":{"Line":4}},{"line":541,"address":[5218264],"length":1,"stats":{"Line":0}},{"line":548,"address":[5217735,5217621],"length":1,"stats":{"Line":4}},{"line":549,"address":[5217793,5217741],"length":1,"stats":{"Line":0}},{"line":552,"address":[5217781],"length":1,"stats":{"Line":2}},{"line":554,"address":[5217829],"length":1,"stats":{"Line":2}},{"line":555,"address":[5217843],"length":1,"stats":{"Line":2}},{"line":556,"address":[5217863,5218013],"length":1,"stats":{"Line":4}},{"line":557,"address":[5218003],"length":1,"stats":{"Line":2}},{"line":559,"address":[5217967,5218060],"length":1,"stats":{"Line":0}},{"line":564,"address":[5218093],"length":1,"stats":{"Line":0}}],"covered":171,"coverable":216},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","dml","update.rs"],"content":"use crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::update_item::UpdateItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{OperatorToken, Token};\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn handle_update_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cUpdateQuery, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0601: need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Update {\n            return Err(ParsingError::wrap(format!(\n                \"E0602: expected 'UPDATE'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        let mut query_builder = UpdateQuery::builder();\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0603: need more tokens\"));\n        }\n\n        // 테이블명 파싱\n        let table_name = self.parse_table_name(context.clone())?;\n        query_builder = query_builder.set_target_table(table_name);\n\n        if self.next_token_is_table_alias() {\n            let alias = self.parse_table_alias()?;\n            query_builder = query_builder.set_target_alias(alias);\n        }\n\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0604: need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Set {\n            return Err(ParsingError::wrap(format!(\n                \"E0605: expected 'SET'. but your input word is '{:?}'\",\n                current_token\n            )));\n        }\n\n        loop {\n            if !self.has_next_token() {\n                break;\n            }\n\n            let current_token = self.get_next_token();\n\n            match current_token {\n                Token::Comma =\u003e continue,\n                Token::Where =\u003e {\n                    self.unget_next_token(current_token);\n                    break;\n                }\n                Token::SemiColon =\u003e {\n                    return Ok(query_builder.build());\n                }\n                Token::Identifier(identifier) =\u003e {\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0606: need more tokens\"));\n                    }\n\n                    let current_token = self.get_next_token();\n\n                    if current_token != Token::Operator(OperatorToken::Eq) {\n                        return Err(ParsingError::wrap(format!(\n                            \"E0607: expected '='. but your input word is '{:?}'\",\n                            current_token\n                        )));\n                    }\n\n                    if !self.has_next_token() {\n                        return Err(ParsingError::wrap(\"E0608: need more tokens\"));\n                    }\n\n                    let expression = self.parse_expression(context.clone())?;\n\n                    let update_item = UpdateItem {\n                        column: identifier,\n                        value: expression,\n                    };\n\n                    query_builder = query_builder.add_update_item(update_item)\n                }\n                _ =\u003e {\n                    return Err(ParsingError::wrap(format!(\n                        \"E0609: unexpected input word: '{:?}'\",\n                        current_token\n                    )));\n                }\n            }\n        }\n\n        // Where 절 파싱\n        if self.next_token_is_where() {\n            self.get_next_token(); // where 토큰 삼키기\n\n            let expression = self.parse_expression(context)?;\n            query_builder = query_builder.set_where(WhereClause { expression });\n        }\n\n        Ok(query_builder.build())\n    }\n}\n","traces":[{"line":10,"address":[5218416,5221912,5224277],"length":1,"stats":{"Line":2}},{"line":14,"address":[5218474,5218616],"length":1,"stats":{"Line":4}},{"line":15,"address":[5218674,5218622],"length":1,"stats":{"Line":0}},{"line":18,"address":[5218662],"length":1,"stats":{"Line":2}},{"line":20,"address":[5218803,5218733],"length":1,"stats":{"Line":4}},{"line":21,"address":[5224116],"length":1,"stats":{"Line":0}},{"line":27,"address":[5218817],"length":1,"stats":{"Line":2}},{"line":29,"address":[5218992,5218928],"length":1,"stats":{"Line":4}},{"line":30,"address":[5218998,5219050],"length":1,"stats":{"Line":0}},{"line":34,"address":[5219429,5219038,5219130,5224050],"length":1,"stats":{"Line":4}},{"line":35,"address":[5219294,5219575],"length":1,"stats":{"Line":4}},{"line":37,"address":[5219618,5220110],"length":1,"stats":{"Line":2}},{"line":38,"address":[5219671,5219922],"length":1,"stats":{"Line":0}},{"line":39,"address":[5219803,5220068],"length":1,"stats":{"Line":0}},{"line":42,"address":[5219644,5220119],"length":1,"stats":{"Line":4}},{"line":43,"address":[5220125,5220177],"length":1,"stats":{"Line":0}},{"line":46,"address":[5220165],"length":1,"stats":{"Line":2}},{"line":48,"address":[5220230,5220300],"length":1,"stats":{"Line":4}},{"line":49,"address":[5223851],"length":1,"stats":{"Line":0}},{"line":55,"address":[5223242],"length":1,"stats":{"Line":2}},{"line":56,"address":[5220425,5220311],"length":1,"stats":{"Line":4}},{"line":60,"address":[5220463],"length":1,"stats":{"Line":2}},{"line":62,"address":[5220486],"length":1,"stats":{"Line":2}},{"line":65,"address":[5220666],"length":1,"stats":{"Line":1}},{"line":69,"address":[5223541,5220822],"length":1,"stats":{"Line":0}},{"line":71,"address":[5220737],"length":1,"stats":{"Line":2}},{"line":72,"address":[5221992,5220785],"length":1,"stats":{"Line":4}},{"line":73,"address":[5221998,5222050],"length":1,"stats":{"Line":0}},{"line":76,"address":[5222038],"length":1,"stats":{"Line":2}},{"line":78,"address":[5222182,5222112],"length":1,"stats":{"Line":4}},{"line":79,"address":[5223293],"length":1,"stats":{"Line":0}},{"line":85,"address":[5222193,5222307],"length":1,"stats":{"Line":4}},{"line":86,"address":[5222365,5222313],"length":1,"stats":{"Line":0}},{"line":89,"address":[5222444,5222353,5222989],"length":1,"stats":{"Line":4}},{"line":96,"address":[5223135,5222912],"length":1,"stats":{"Line":4}},{"line":99,"address":[5223561],"length":1,"stats":{"Line":0}},{"line":108,"address":[5220436,5220954,5221781],"length":1,"stats":{"Line":5}},{"line":109,"address":[5221039],"length":1,"stats":{"Line":1}},{"line":111,"address":[5221071,5221593],"length":1,"stats":{"Line":1}},{"line":112,"address":[5221346,5221739],"length":1,"stats":{"Line":2}},{"line":115,"address":[5221811,5220960],"length":1,"stats":{"Line":4}}],"covered":29,"coverable":41},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","mod.rs"],"content":"pub mod common;\npub mod ddl;\npub mod debug;\npub mod dml;\npub mod other;\npub mod tcl;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","backslash_command.rs"],"content":"use crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_backslash_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0801 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e match identifier.as_str() {\n                \"l\" =\u003e Ok(ShowDatabasesQuery {}.into()),\n                _ =\u003e Err(ParsingError::wrap(format!(\n                    \"E0803: unexpected identifier '{:?}'\",\n                    identifier\n                ))),\n            },\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0802: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":9,"address":[5225172,5225451,5224304],"length":1,"stats":{"Line":1}},{"line":13,"address":[5224347,5224407],"length":1,"stats":{"Line":2}},{"line":14,"address":[5224462,5224413],"length":1,"stats":{"Line":0}},{"line":17,"address":[5224450,5224522],"length":1,"stats":{"Line":2}},{"line":19,"address":[5224530],"length":1,"stats":{"Line":1}},{"line":20,"address":[5224544],"length":1,"stats":{"Line":1}},{"line":21,"address":[5225084,5224894,5224765],"length":1,"stats":{"Line":3}},{"line":22,"address":[5224919],"length":1,"stats":{"Line":0}},{"line":27,"address":[5225181],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":9},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","desc.rs"],"content":"use crate::ast::other::desc_table::DescTableQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_desc_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E1001 need more tokens\"));\n        }\n\n        let table_name = self.parse_table_name(context)?;\n\n        Ok(DescTableQuery { table_name }.into())\n    }\n}\n","traces":[{"line":8,"address":[5225472,5226284,5226250],"length":1,"stats":{"Line":1}},{"line":12,"address":[5225515,5225595],"length":1,"stats":{"Line":2}},{"line":13,"address":[5225601,5225694],"length":1,"stats":{"Line":0}},{"line":16,"address":[5225766,5225635,5226049],"length":1,"stats":{"Line":2}},{"line":18,"address":[5225907,5226193],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":5},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","mod.rs"],"content":"pub mod backslash_command;\npub mod desc;\npub mod show;\n#[path = \"./use.rs\"]\npub mod use_;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","show.rs"],"content":"use crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_show_query(\n        \u0026mut self,\n        context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0701 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Databases =\u003e Ok(ShowDatabasesQuery {}.into()),\n            Token::Tables =\u003e Ok(ShowTablesQuery {\n                database: context.default_database.unwrap_or_else(|| \"None\".into()),\n            }\n            .into()),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0702: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":10,"address":[5227113,5226320],"length":1,"stats":{"Line":1}},{"line":14,"address":[5226363,5226435],"length":1,"stats":{"Line":2}},{"line":15,"address":[5226441,5226490],"length":1,"stats":{"Line":0}},{"line":18,"address":[5226478],"length":1,"stats":{"Line":1}},{"line":20,"address":[5226550],"length":1,"stats":{"Line":1}},{"line":21,"address":[5226814,5226681],"length":1,"stats":{"Line":2}},{"line":22,"address":[5226850],"length":1,"stats":{"Line":1}},{"line":23,"address":[1863292,1863280],"length":1,"stats":{"Line":1}},{"line":25,"address":[5226935],"length":1,"stats":{"Line":1}},{"line":26,"address":[5226937],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":10},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","other","use.rs"],"content":"use crate::ast::other::use_database::UseDatabaseQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_use_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E0901 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        match current_token {\n            Token::Identifier(identifier) =\u003e Ok(UseDatabaseQuery {\n                database_name: identifier,\n            }\n            .into()),\n            _ =\u003e Err(ParsingError::wrap(format!(\n                \"E0902: unexpected token '{:?}'\",\n                current_token\n            ))),\n        }\n    }\n}\n","traces":[{"line":9,"address":[5227954,5227152],"length":1,"stats":{"Line":1}},{"line":13,"address":[5227255,5227195],"length":1,"stats":{"Line":2}},{"line":14,"address":[5227310,5227261],"length":1,"stats":{"Line":0}},{"line":17,"address":[5227298,5227370],"length":1,"stats":{"Line":2}},{"line":19,"address":[5227378],"length":1,"stats":{"Line":1}},{"line":20,"address":[5227643,5227392],"length":1,"stats":{"Line":2}},{"line":24,"address":[5227684],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","begin.rs"],"content":"use crate::ast::tcl::BeginTransactionQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::predule::ParsingError;\nuse crate::errors::RRDBError;\nuse crate::lexer::tokens::Token;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_begin_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        if !self.has_next_token() {\n            return Err(ParsingError::wrap(\"E2001 need more tokens\"));\n        }\n\n        let current_token = self.get_next_token();\n\n        if current_token != Token::Transaction {\n            return Err(ParsingError::wrap(\"E2002 Expected BEGIN\"));\n        }\n\n        Ok(BeginTransactionQuery {}.into())\n    }\n}\n","traces":[{"line":9,"address":[5227984,5228472],"length":1,"stats":{"Line":1}},{"line":13,"address":[5228079,5228027],"length":1,"stats":{"Line":2}},{"line":14,"address":[5228085,5228134],"length":1,"stats":{"Line":2}},{"line":17,"address":[5228122],"length":1,"stats":{"Line":1}},{"line":19,"address":[5228256,5228186],"length":1,"stats":{"Line":2}},{"line":20,"address":[5228381,5228284],"length":1,"stats":{"Line":2}},{"line":23,"address":[5228336,5228262],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":7},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","commit.rs"],"content":"use crate::ast::tcl::CommitQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_commit_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        Ok(CommitQuery {}.into())\n    }\n}\n","traces":[{"line":7,"address":[5228622,5228496],"length":1,"stats":{"Line":1}},{"line":11,"address":[5228526,5228584],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","mod.rs"],"content":"pub mod begin;\npub mod commit;\npub mod rollback;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","tcl","rollback.rs"],"content":"use crate::ast::tcl::RollbackQuery;\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::parser::predule::{Parser, ParserContext};\n\nimpl Parser {\n    pub(crate) fn parse_rollback_query(\n        \u0026mut self,\n        _context: ParserContext,\n    ) -\u003e Result\u003cSQLStatement, RRDBError\u003e {\n        Ok(RollbackQuery {}.into())\n    }\n}\n","traces":[{"line":7,"address":[5228656,5228782],"length":1,"stats":{"Line":1}},{"line":11,"address":[5228686,5228744],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","implements","utils.rs"],"content":"use crate::parser::predule::Parser;\n\nuse crate::lexer::predule::Token;\n\nimpl Parser {\n    // 다음 토큰 획득\n    pub(crate) fn get_next_token(\u0026mut self) -\u003e Token {\n        self.tokens.pop_front().unwrap()\n    }\n\n    // 다음 토큰 미리보기\n    pub(crate) fn pick_next_token(\u0026mut self) -\u003e Token {\n        self.tokens.front().unwrap().to_owned()\n    }\n\n    // 토큰 획득 롤백\n    pub(crate) fn unget_next_token(\u0026mut self, token: Token) {\n        self.tokens.push_front(token)\n    }\n\n    // 다음 토큰 유무 확인\n    pub(crate) fn has_next_token(\u0026self) -\u003e bool {\n        !self.tokens.is_empty() \u0026\u0026 !self.tokens.front().unwrap().is_eof()\n    }\n}\n","traces":[{"line":7,"address":[5228816],"length":1,"stats":{"Line":4}},{"line":8,"address":[5228834],"length":1,"stats":{"Line":4}},{"line":12,"address":[5228928],"length":1,"stats":{"Line":3}},{"line":13,"address":[5229019,5228960],"length":1,"stats":{"Line":6}},{"line":17,"address":[5229040],"length":1,"stats":{"Line":2}},{"line":18,"address":[5229045],"length":1,"stats":{"Line":2}},{"line":22,"address":[5229056],"length":1,"stats":{"Line":2}},{"line":23,"address":[5229136,5229069],"length":1,"stats":{"Line":6}}],"covered":8,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","mod.rs"],"content":"pub mod context;\npub mod implements;\n#[allow(clippy::module_inception)]\npub mod parser;\npub mod predule;\n\npub(crate) mod test;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","parser.rs"],"content":"use std::collections::VecDeque;\n\nuse crate::ast::SQLStatement;\nuse crate::errors::RRDBError;\nuse crate::lexer::predule::{Token, Tokenizer};\nuse crate::parser::predule::ParserContext;\n\n#[derive(Debug)]\npub struct Parser {\n    pub current_token: Token,\n    pub tokens: VecDeque\u003cToken\u003e,\n}\n\nimpl Parser {\n    // 파서 객체 생성\n    pub fn new(tokens: Vec\u003cToken\u003e) -\u003e Self {\n        Self {\n            current_token: Token::EOF,\n            tokens: VecDeque::from(tokens),\n        }\n    }\n\n    // deorecated\n    pub fn with_string(text: String) -\u003e Result\u003cSelf, RRDBError\u003e {\n        Ok(Self {\n            current_token: Token::EOF,\n            tokens: VecDeque::from(Tokenizer::string_to_tokens(text)?),\n        })\n    }\n\n    // 파서 객체 생성\n    pub fn with_tokens(tokens: VecDeque\u003cToken\u003e) -\u003e Self {\n        Self {\n            current_token: Token::EOF,\n            tokens,\n        }\n    }\n\n    pub fn parse(\u0026mut self, context: ParserContext) -\u003e Result\u003cVec\u003cSQLStatement\u003e, RRDBError\u003e {\n        let mut statements: Vec\u003cSQLStatement\u003e = vec![];\n\n        // Top-Level Parser Loop\n        loop {\n            if self.has_next_token() {\n                let current_token = self.get_next_token();\n\n                match current_token {\n                    Token::EOF =\u003e {\n                        // 루프 종료\n                        break;\n                    }\n                    Token::SemiColon =\u003e {\n                        // top-level 세미콜론 무시\n                        continue;\n                    }\n                    Token::Create =\u003e statements.push(self.handle_create_query(context.clone())?),\n                    Token::Alter =\u003e statements.push(self.handle_alter_query(context.clone())?),\n                    Token::Drop =\u003e statements.push(self.handle_drop_query(context.clone())?),\n                    Token::Select =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_select_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Update =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_update_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Insert =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_insert_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Delete =\u003e {\n                        self.unget_next_token(current_token);\n                        let query = self.handle_delete_query(context.clone())?;\n                        statements.push(query.into());\n                    }\n                    Token::Backslash =\u003e {\n                        let query = self.parse_backslash_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Show =\u003e {\n                        let query = self.parse_show_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Use =\u003e {\n                        let query = self.parse_use_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Desc =\u003e {\n                        let query = self.parse_desc_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Begin =\u003e {\n                        let query = self.parse_begin_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Commit =\u003e {\n                        let query = self.parse_commit_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    Token::Rollback =\u003e {\n                        let query = self.parse_rollback_query(context.clone())?;\n                        statements.push(query);\n                    }\n                    _ =\u003e {\n                        break;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        Ok(statements)\n    }\n}\n","traces":[{"line":16,"address":[5229652,5229184],"length":1,"stats":{"Line":4}},{"line":17,"address":[5229511],"length":1,"stats":{"Line":2}},{"line":18,"address":[5229200],"length":1,"stats":{"Line":4}},{"line":19,"address":[5229273,5229213],"length":1,"stats":{"Line":6}},{"line":24,"address":[5229680],"length":1,"stats":{"Line":0}},{"line":31,"address":[5229760,5237223,5231405],"length":1,"stats":{"Line":1}},{"line":32,"address":[5230018,5229867],"length":1,"stats":{"Line":3}},{"line":35,"address":[5237074],"length":1,"stats":{"Line":1}},{"line":36,"address":[5230086,5230028],"length":1,"stats":{"Line":6}},{"line":37,"address":[5230225],"length":1,"stats":{"Line":4}},{"line":39,"address":[5230240],"length":1,"stats":{"Line":4}},{"line":40,"address":[3513960],"length":1,"stats":{"Line":0}},{"line":44,"address":[3514030],"length":1,"stats":{"Line":0}},{"line":48,"address":[5230610,5233630],"length":1,"stats":{"Line":2}},{"line":49,"address":[5233900,5230636],"length":1,"stats":{"Line":8}},{"line":50,"address":[5230662,5234170],"length":1,"stats":{"Line":2}},{"line":51,"address":[3532236,3514048,3518811],"length":1,"stats":{"Line":0}},{"line":52,"address":[5230312],"length":1,"stats":{"Line":1}},{"line":53,"address":[5230903,5231198],"length":1,"stats":{"Line":2}},{"line":54,"address":[5231131,5231353],"length":1,"stats":{"Line":6}},{"line":57,"address":[5230470],"length":1,"stats":{"Line":2}},{"line":58,"address":[5232883,5232588],"length":1,"stats":{"Line":2}},{"line":59,"address":[5232816,5233038],"length":1,"stats":{"Line":4}},{"line":61,"address":[3514440],"length":1,"stats":{"Line":0}},{"line":62,"address":[3514448],"length":1,"stats":{"Line":3}},{"line":63,"address":[3514468],"length":1,"stats":{"Line":3}},{"line":64,"address":[5232221,5232521],"length":1,"stats":{"Line":6}},{"line":66,"address":[3514480],"length":1,"stats":{"Line":0}},{"line":67,"address":[5230536],"length":1,"stats":{"Line":1}},{"line":68,"address":[3514488],"length":1,"stats":{"Line":1}},{"line":69,"address":[5233555,5233333],"length":1,"stats":{"Line":2}},{"line":71,"address":[3514564,3514496],"length":1,"stats":{"Line":0}},{"line":72,"address":[5236695,5236914,5230836],"length":1,"stats":{"Line":2}},{"line":73,"address":[5236860],"length":1,"stats":{"Line":1}},{"line":75,"address":[3532382,3532368],"length":1,"stats":{"Line":0}},{"line":76,"address":[5234697,5234440,5230688],"length":1,"stats":{"Line":2}},{"line":77,"address":[5234637],"length":1,"stats":{"Line":1}},{"line":80,"address":[3528084,3514798],"length":1,"stats":{"Line":2}},{"line":81,"address":[5235101],"length":1,"stats":{"Line":1}},{"line":84,"address":[5231722,5230386,5231465],"length":1,"stats":{"Line":2}},{"line":85,"address":[3532448,3515098,3532466],"length":1,"stats":{"Line":1}},{"line":88,"address":[5235619,5230740,5235368],"length":1,"stats":{"Line":3}},{"line":89,"address":[5235559],"length":1,"stats":{"Line":1}},{"line":91,"address":[3515230,3515261],"length":1,"stats":{"Line":0}},{"line":92,"address":[5230766,5236047,5235826],"length":1,"stats":{"Line":2}},{"line":93,"address":[5235993],"length":1,"stats":{"Line":1}},{"line":96,"address":[5236475,5236254,5230792],"length":1,"stats":{"Line":2}},{"line":97,"address":[5236421],"length":1,"stats":{"Line":1}},{"line":104,"address":[3515408,3515362],"length":1,"stats":{"Line":0}},{"line":108,"address":[5230108],"length":1,"stats":{"Line":1}}],"covered":40,"coverable":50},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","predule.rs"],"content":"pub use super::context::*;\npub use super::implements::*;\npub use super::parser::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","alter_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::alter_database::{\n    AlterDatabaseAction, AlterDatabaseQuery, AlterDatabaseRenameTo,\n};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn alter_database_1() {\n    let text = r#\"\n        ALTER DATABASE foo RENAME TO bar;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterDatabaseQuery::builder()\n        .set_name(\"foo\".to_owned())\n        .set_action(AlterDatabaseAction::RenameTo(AlterDatabaseRenameTo {\n            name: \"bar\".into(),\n        }))\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_database_2() {\n    let text = r#\"\n        ALTER DATABASE foo;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterDatabaseQuery::builder()\n        .set_name(\"foo\".to_owned())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","alter_table.rs"],"content":"#![cfg(test)]\n\nuse crate::{\n    ast::{\n        ddl::alter_table::{\n            AlterColumnDropDefault, AlterColumnDropNotNull, AlterColumnSetDefault,\n            AlterColumnSetNotNull, AlterColumnSetType, AlterTableAddColumn, AlterTableAlterColumn,\n            AlterTableDropColumn, AlterTableQuery, AlterTableRenameColumn, AlterTableRenameTo,\n        },\n        types::{Column, DataType, SQLExpression, TableName},\n    },\n    parser::predule::{Parser, ParserContext},\n};\n\n#[test]\npub fn alter_table_rename_1() {\n    let text = r#\"\n        ALTER TABLE foo RENAME TO bar;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(AlterTableRenameTo { name: \"bar\".into() }.into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_add_column_1() {\n    let text = r#\"\n        ALTER TABLE foo ADD COLUMN name varchar(100);\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAddColumn {\n                column: Column::builder()\n                    .set_name(\"name\".to_owned())\n                    .set_data_type(DataType::Varchar(100))\n                    .build(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_add_column_2() {\n    let text = r#\"\n        ALTER TABLE foo ADD name varchar(100);\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAddColumn {\n                column: Column::builder()\n                    .set_name(\"name\".to_owned())\n                    .set_data_type(DataType::Varchar(100))\n                    .build(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_rename_column_1() {\n    let text = r#\"\n        ALTER TABLE foo RENAME COLUMN name TO name_1;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableRenameColumn {\n                from_name: \"name\".into(),\n                to_name: \"name_1\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_rename_column_2() {\n    let text = r#\"\n        ALTER TABLE foo RENAME name TO name_1;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableRenameColumn {\n                from_name: \"name\".into(),\n                to_name: \"name_1\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_drop_not_null_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name DROP NOT NULL;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnDropNotNull {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_not_null_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name SET NOT NULL;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetNotNull {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_type_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name TYPE int;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetType {\n                    data_type: DataType::Int,\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_type_2() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN name SET DATA TYPE int;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"name\".into(),\n                action: AlterColumnSetType {\n                    data_type: DataType::Int,\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_set_default_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN id SET DEFAULT 0;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"id\".into(),\n                action: AlterColumnSetDefault {\n                    expression: SQLExpression::Integer(0),\n                }\n                .into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_alter_column_drop_default_1() {\n    let text = r#\"\n        ALTER TABLE foo ALTER COLUMN id DROP DEFAULT;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableAlterColumn {\n                column_name: \"id\".into(),\n                action: AlterColumnDropDefault {}.into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_drop_column_1() {\n    let text = r#\"\n        ALTER TABLE foo DROP COLUMN name;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableDropColumn {\n                column_name: \"name\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn alter_table_drop_column_2() {\n    let text = r#\"\n        ALTER TABLE foo DROP name;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = AlterTableQuery::builder()\n        .set_table(TableName {\n            table_name: \"foo\".to_owned(),\n            database_name: None,\n        })\n        .set_action(\n            AlterTableDropColumn {\n                column_name: \"name\".into(),\n            }\n            .into(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","create_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::create_database::CreateDatabaseQuery;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn create_database_1() {\n    let text = r#\"\n        CREATE DATABASE IF Not exists test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_not_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n\n#[test]\npub fn create_database_2() {\n    let text = r#\"\n        CREATE DATABASE test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_not_exists(false)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","create_table.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::ddl::create_table::CreateTableQuery;\nuse crate::ast::types::{Column, DataType, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn create_table() {\n    let text = r#\"\n        CREATE TABLE \"test_db\".person\n        (\n            id INTEGER PRIMARY KEY,\n            name varchar(100),\n            age INTEGER\n        );\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = CreateTableQuery::builder()\n        .set_table(TableName::new(\n            Some(\"test_db\".to_owned()),\n            \"person\".to_owned(),\n        ))\n        .add_column(\n            Column::builder()\n                .set_name(\"id\".to_owned())\n                .set_data_type(DataType::Int)\n                .set_primary_key(true)\n                .build(),\n        )\n        .add_column(\n            Column::builder()\n                .set_name(\"name\".to_owned())\n                .set_data_type(DataType::Varchar(100))\n                .build(),\n        )\n        .add_column(\n            Column::builder()\n                .set_name(\"age\".to_owned())\n                .set_data_type(DataType::Int)\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","delete.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::delete::DeleteQuery;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::lexer::predule::OperatorToken;\nuse crate::lexer::tokens::Token;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn test_delete_query() {\n    struct TestCase {\n        name: String,\n        input: Vec\u003cToken\u003e,\n        expected: DeleteQuery,\n        want_error: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"성공: delete from foo.bar\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"성공: DELETE FROM foo.bar WHERE name = 'asdf'\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n                Token::Where,\n                Token::Identifier(\"name\".into()),\n                Token::Operator(OperatorToken::Eq),\n                Token::String(\"asdf\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_where(WhereClause {\n                    expression: BinaryOperatorExpression {\n                        operator: BinaryOperator::Eq,\n                        lhs: SelectColumn::new(None, \"name\".into()).into(),\n                        rhs: SQLExpression::String(\"asdf\".into()),\n                    }\n                    .into(),\n                })\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"성공: DELETE FROM foo.bar as f\".into(),\n            input: vec![\n                Token::Delete,\n                Token::From,\n                Token::Identifier(\"foo\".into()),\n                Token::Period,\n                Token::Identifier(\"bar\".into()),\n                Token::As,\n                Token::Identifier(\"f\".into()),\n            ],\n            expected: DeleteQuery::builder()\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_from_alias(\"f\".into())\n                .build(),\n            want_error: false,\n        },\n        TestCase {\n            name: \"실패: 토큰이 하나도 없음\".into(),\n            input: vec![],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE가 아님\".into(),\n            input: vec![Token::Select],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE밖에 없음\".into(),\n            input: vec![Token::Delete],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE INTO\".into(),\n            input: vec![Token::Delete, Token::Into],\n            expected: Default::default(),\n            want_error: true,\n        },\n        TestCase {\n            name: \"실패: DELETE FROM\".into(),\n            input: vec![Token::Delete, Token::From],\n            expected: Default::default(),\n            want_error: true,\n        },\n    ];\n\n    for t in test_cases {\n        let mut parser = Parser::new(t.input);\n\n        let got = parser.handle_delete_query(Default::default());\n\n        assert_eq!(\n            got.is_err(),\n            t.want_error,\n            \"{}: want_error: {}, error: {:?}\",\n            t.name,\n            t.want_error,\n            got.err()\n        );\n\n        if let Ok(statements) = got {\n            assert_eq!(statements, t.expected.into(), \"TC: {}\", t.name);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","drop_database.rs"],"content":"#![cfg(test)]\nuse crate::ast::ddl::drop_database::DropDatabaseQuery;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn drop_database() {\n    let text = r#\"\n        DROP DATABASE IF exists test_db;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DropDatabaseQuery::builder()\n        .set_name(\"test_db\".to_owned())\n        .set_if_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","drop_table.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::ddl::drop_table::DropTableQuery;\nuse crate::ast::types::TableName;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn drop_table() {\n    let text = r#\"\n        drop table if exists \"foo_db\".foo;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DropTableQuery::builder()\n        .set_table(TableName::new(Some(\"foo_db\".to_owned()), \"foo\".to_owned()))\n        .set_if_exists(true)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","expressions.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::between::BetweenExpression;\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::call::CallExpression;\nuse crate::ast::dml::expressions::list::ListExpression;\nuse crate::ast::dml::expressions::not_between::NotBetweenExpression;\nuse crate::ast::dml::expressions::operators::{BinaryOperator, UnaryOperator};\nuse crate::ast::dml::expressions::parentheses::ParenthesesExpression;\nuse crate::ast::dml::expressions::unary::UnaryOperatorExpression;\nuse crate::ast::dml::parts::select_item::SelectItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{ConditionalFunction, SQLExpression, UserDefinedFunction};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn unary_expression_1() {\n    let text = r#\"\n        SELECT Not TRUE AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    UnaryOperatorExpression {\n                        operator: UnaryOperator::Not,\n                        operand: SQLExpression::Boolean(true),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn unary_expression_2() {\n    let text = r#\"\n        SELECT !TRUE AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    UnaryOperatorExpression {\n                        operator: UnaryOperator::Not,\n                        operand: SQLExpression::Boolean(true),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_1() {\n    let text = r#\"\n        SELECT 3 + 5 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: SQLExpression::Integer(3),\n                        rhs: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_2() {\n    let text = r#\"\n        SELECT 1 + 2 + 3 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: SQLExpression::Integer(2),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(3),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_3() {\n    let text = r#\"\n        SELECT 1 + 2 * 3 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Mul,\n                            lhs: SQLExpression::Integer(2),\n                            rhs: SQLExpression::Integer(3),\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_4() {\n    let text = r#\"\n        SELECT 1 + 2 * 3 + 4 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Add,\n                        lhs: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: BinaryOperatorExpression {\n                                operator: BinaryOperator::Mul,\n                                lhs: SQLExpression::Integer(2),\n                                rhs: SQLExpression::Integer(3),\n                            }\n                            .into(),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(4),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_5() {\n    let text = r#\"\n        SELECT 2 * (3 + 5) AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Mul,\n                        lhs: SQLExpression::Integer(2),\n                        rhs: SQLExpression::Binary(\n                            BinaryOperatorExpression {\n                                operator: BinaryOperator::Add,\n                                lhs: SQLExpression::Integer(3),\n                                rhs: SQLExpression::Integer(5),\n                            }\n                            .into(),\n                        ),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn arithmetic_expression_6() {\n    let text = r#\"\n        SELECT -2 * 5 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Mul,\n                        lhs: UnaryOperatorExpression {\n                            operator: UnaryOperator::Neg,\n                            operand: SQLExpression::Integer(2),\n                        }\n                        .into(),\n                        rhs: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn function_call_expression_1() {\n    let text = r#\"\n        SELECT foobar(null, 1) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    CallExpression {\n                        function: UserDefinedFunction {\n                            database_name: None,\n                            function_name: \"foobar\".into(),\n                        }\n                        .into(),\n                        arguments: vec![SQLExpression::Null, SQLExpression::Integer(1)],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn function_call_expression_2() {\n    let text = r#\"\n        SELECT coalesce(null, 1) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    CallExpression {\n                        function: ConditionalFunction::Coalesce.into(),\n                        arguments: vec![SQLExpression::Null, SQLExpression::Integer(1)],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_1() {\n    let text = r#\"\n        SELECT 3 between 1 and 5 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_2() {\n    let text = r#\"\n        SELECT 3 between 1 and 5 + 1 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(5),\n                            rhs: SQLExpression::Integer(1),\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn between_expression_3() {\n    let text = r#\"\n        SELECT 3 between 1 + 1 and 99 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: BinaryOperatorExpression {\n                            operator: BinaryOperator::Add,\n                            lhs: SQLExpression::Integer(1),\n                            rhs: SQLExpression::Integer(1),\n                        }\n                        .into(),\n                        y: SQLExpression::Integer(99),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn not_between_expression_1() {\n    let text = r#\"\n        SELECT 3 not between 1 and 5 as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    NotBetweenExpression {\n                        a: SQLExpression::Integer(3),\n                        x: SQLExpression::Integer(1),\n                        y: SQLExpression::Integer(5),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn list_expression_1() {\n    let text = r#\"\n        SELECT (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    ListExpression {\n                        value: vec![\n                            SQLExpression::Integer(1),\n                            SQLExpression::Integer(2),\n                            SQLExpression::Integer(3),\n                        ],\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn in_expression_1() {\n    let text = r#\"\n        SELECT 1 in (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::In,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: ListExpression {\n                            value: vec![\n                                SQLExpression::Integer(1),\n                                SQLExpression::Integer(2),\n                                SQLExpression::Integer(3),\n                            ],\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn not_in_expression_1() {\n    let text = r#\"\n        SELECT 1 not in (1,2,3) as foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::NotIn,\n                        lhs: SQLExpression::Integer(1),\n                        rhs: ListExpression {\n                            value: vec![\n                                SQLExpression::Integer(1),\n                                SQLExpression::Integer(2),\n                                SQLExpression::Integer(3),\n                            ],\n                        }\n                        .into(),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn complex_expression_1() {\n    let text = r#\"\n        SELECT 3+(10*2+44)-11 AS foo\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    BinaryOperatorExpression {\n                        operator: BinaryOperator::Sub,\n                        lhs: SQLExpression::Binary(\n                            BinaryOperatorExpression {\n                                operator: BinaryOperator::Add,\n                                lhs: SQLExpression::Integer(3),\n                                rhs: ParenthesesExpression {\n                                    expression: BinaryOperatorExpression {\n                                        operator: BinaryOperator::Add,\n                                        lhs: BinaryOperatorExpression {\n                                            operator: BinaryOperator::Mul,\n                                            lhs: SQLExpression::Integer(10),\n                                            rhs: SQLExpression::Integer(2),\n                                        }\n                                        .into(),\n                                        rhs: SQLExpression::Integer(44),\n                                    }\n                                    .into(),\n                                }\n                                .into(),\n                            }\n                            .into(),\n                        ),\n                        rhs: SQLExpression::Integer(11),\n                    }\n                    .into(),\n                )\n                .set_alias(\"foo\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","insert.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::insert::InsertQuery;\nuse crate::ast::dml::parts::insert_values::InsertValue;\nuse crate::ast::dml::parts::select_item::SelectItem;\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn insert_into_values_1() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![InsertValue {\n            list: vec![\n                Some(SQLExpression::Integer(1)),\n                Some(SQLExpression::Integer(2)),\n                Some(SQLExpression::Integer(3)),\n            ],\n        }])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_values_2() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3), (4, 5, 6)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(1)),\n                    Some(SQLExpression::Integer(2)),\n                    Some(SQLExpression::Integer(3)),\n                ],\n            },\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(4)),\n                    Some(SQLExpression::Integer(5)),\n                    Some(SQLExpression::Integer(6)),\n                ],\n            },\n        ])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_values_3() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Values(1, 2, 3), (4, 5, DEFAULT)\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_values(vec![\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(1)),\n                    Some(SQLExpression::Integer(2)),\n                    Some(SQLExpression::Integer(3)),\n                ],\n            },\n            InsertValue {\n                list: vec![\n                    Some(SQLExpression::Integer(4)),\n                    Some(SQLExpression::Integer(5)),\n                    None,\n                ],\n            },\n        ])\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn insert_into_select_1() {\n    let text = r#\"\n        INSERT INTO foo.bar(a, b, c)\n        Select s.a, s.b, s.c from boom.some as s\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = InsertQuery::builder()\n        .set_into_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_columns(vec![\"a\".into(), \"b\".into(), \"c\".into()])\n        .set_select(\n            SelectQuery::builder()\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"a\".into()).into())\n                        .build(),\n                )\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"b\".into()).into())\n                        .build(),\n                )\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SelectColumn::new(Some(\"s\".into()), \"c\".into()).into())\n                        .build(),\n                )\n                .set_from_table(TableName {\n                    database_name: Some(\"boom\".into()),\n                    table_name: \"some\".into(),\n                })\n                .set_from_alias(\"s\".into())\n                .build(),\n        )\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","mod.rs"],"content":"pub(crate) mod alter_database;\npub(crate) mod create_database;\npub(crate) mod drop_database;\n\npub(crate) mod alter_table;\npub(crate) mod create_table;\npub(crate) mod drop_table;\npub(crate) mod expressions;\n\npub(crate) mod delete;\npub(crate) mod insert;\npub(crate) mod select;\npub(crate) mod update;\n\npub(crate) mod other;\n\npub(crate) mod tcl;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","other.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::other::desc_table::DescTableQuery;\nuse crate::ast::other::show_databases::ShowDatabasesQuery;\nuse crate::ast::other::show_tables::ShowTablesQuery;\nuse crate::ast::other::use_database::UseDatabaseQuery;\nuse crate::ast::types::TableName;\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn show_databases_1() {\n    let text = r#\"\n        Show Databases\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowDatabasesQuery {};\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn show_databases_2() {\n    let text = r#\"\n        \\l\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowDatabasesQuery {};\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn use_databases_1() {\n    let text = r#\"\n        Use asdf;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UseDatabaseQuery {\n        database_name: \"asdf\".into(),\n    };\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn desc_table_1() {\n    let text = r#\"\n        desc asdf;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = DescTableQuery {\n        table_name: TableName {\n            database_name: None,\n            table_name: \"asdf\".into(),\n        },\n    };\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn show_tables_1() {\n    let text = r#\"\n        show tables;\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = ShowTablesQuery {\n        database: \"rrdb\".into(),\n    };\n\n    assert_eq!(\n        parser\n            .parse(ParserContext::default().set_default_database(\"rrdb\".into()))\n            .unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","select.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::group_by::GroupByItem;\nuse crate::ast::dml::parts::having::HavingClause;\nuse crate::ast::dml::parts::join::{JoinClause, JoinType};\nuse crate::ast::dml::parts::order_by::{OrderByItem, OrderByNulls, OrderByType};\nuse crate::ast::dml::parts::select_item::{SelectItem, SelectWildCard};\nuse crate::ast::dml::select::SelectQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn select_from_1() {\n    let text = r#\"\n        SELECT 1 as asdf\n        FROM foo.bar\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SQLExpression::Integer(1))\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_2() {\n    let text = r#\"\n        SELECT 1 as asdf\n        FROM foo.bar as boom\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SQLExpression::Integer(1))\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .set_from_alias(\"boom\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_3() {\n    let text = r#\"\n        SELECT boom.number as number\n        FROM (\n            select 1 as number\n            from foo.bar as temp\n        ) as boom\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"boom\".into()), \"number\".into()).into())\n                .set_alias(\"number\".into())\n                .build(),\n        )\n        .set_from_subquery(\n            SelectQuery::builder()\n                .add_select_item(\n                    SelectItem::builder()\n                        .set_item(SQLExpression::Integer(1))\n                        .set_alias(\"number\".into())\n                        .build(),\n                )\n                .set_from_table(TableName {\n                    database_name: Some(\"foo\".into()),\n                    table_name: \"bar\".into(),\n                })\n                .set_from_alias(\"temp\".into())\n                .build()\n                .into(),\n        )\n        .set_from_alias(\"boom\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_from_4() {\n    let text = r#\"\n        SELECT *\n        FROM foo.bar\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_wildcard(SelectWildCard { alias: None })\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_inner_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        INNER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::InnerJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_inner_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::InnerJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_left_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        LEFT JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::LeftOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_left_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        LEFT OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::LeftOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_right_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        RIGHT JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::RightOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_right_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        RIGHT OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::RightOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_full_join_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        FULL JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::FullOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_full_join_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n            , c.content as `comment`\n        FROM post as p\n        FULL OUTER JOIN `comment` as c\n        on p.id = c.post_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"c\".into()), \"content\".into()).into())\n                .set_alias(\"comment\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_join(JoinClause {\n            join_type: JoinType::FullOuterJoin,\n            right: TableName::new(None, \"comment\".into()),\n            right_alias: Some(\"c\".into()),\n            on: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n                rhs: SelectColumn::new(Some(\"c\".into()), \"post_id\".into()).into(),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_where_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        where p.user_id = 1\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_where(WhereClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n                rhs: SQLExpression::Integer(1),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id ASC\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id ASC, p.id DESC\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"id\".into()).into(),\n            order_type: OrderByType::Desc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_3() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id NULLS FIRST\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::First,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_order_by_4() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        ORDER BY p.user_id NULLS LAST\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_order_by(OrderByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()).into(),\n            order_type: OrderByType::Asc,\n            nulls: OrderByNulls::Last,\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_group_by_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_group_by_2() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content, p.user_id\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"user_id\".into()),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn error_select_group_by_1() {\n    let text = r#\"\n        SELECT \n            COUNT(p.a),\n            p.b,\n            p.c\n        FROM post as p\n        GROUP BY p.b\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    assert!(parser.parse(ParserContext::default()).is_err());\n}\n\n#[test]\npub fn select_group_by_having_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        GROUP BY p.content\n        HAVING p.content = 'FOO'\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .add_group_by(GroupByItem {\n            item: SelectColumn::new(Some(\"p\".into()), \"content\".into()),\n        })\n        .set_having(HavingClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(Some(\"p\".into()), \"content\".into()).into(),\n                rhs: SQLExpression::String(\"FOO\".into()),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_offset_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        OFFSET 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_limit_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        LIMIT 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_limit(5)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_offset_limit_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        OFFSET 5\n        LIMIT 10\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .set_limit(10)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_limit_offset_1() {\n    let text = r#\"\n        SELECT \n            p.content as post\n        FROM post as p\n        LIMIT 10\n        OFFSET 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"p\".into()), \"content\".into()).into())\n                .set_alias(\"post\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: None,\n            table_name: \"post\".into(),\n        })\n        .set_from_alias(\"p\".into())\n        .set_offset(5)\n        .set_limit(10)\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn select_subquery_1() {\n    let text = r#\"\n        SELECT \n            ff.number as number,\n            (\n                select 1 as number\n                from foo.bar as temp\n                limit 1\n            ) as asdf\n        FROM foo.foo as ff\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = SelectQuery::builder()\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(SelectColumn::new(Some(\"ff\".into()), \"number\".into()).into())\n                .set_alias(\"number\".into())\n                .build(),\n        )\n        .add_select_item(\n            SelectItem::builder()\n                .set_item(\n                    SelectQuery::builder()\n                        .add_select_item(\n                            SelectItem::builder()\n                                .set_item(SQLExpression::Integer(1))\n                                .set_alias(\"number\".into())\n                                .build(),\n                        )\n                        .set_from_table(TableName {\n                            database_name: Some(\"foo\".into()),\n                            table_name: \"bar\".into(),\n                        })\n                        .set_from_alias(\"temp\".into())\n                        .set_limit(1)\n                        .build()\n                        .into(),\n                )\n                .set_alias(\"asdf\".into())\n                .build(),\n        )\n        .set_from_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"foo\".into(),\n        })\n        .set_from_alias(\"ff\".into())\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","tcl.rs"],"content":"#![cfg(test)]\n\nuse crate::{\n    ast::{\n        tcl::{BeginTransactionQuery, CommitQuery, RollbackQuery},\n        SQLStatement,\n    },\n    parser::predule::{Parser, ParserContext},\n};\n\n#[test]\npub fn begin_transaction() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![\n        TestCase {\n            name: \"정상적인 트랜잭션 시작\".to_owned(),\n            input: \"BEGIN TRANSACTION;\".to_owned(),\n            expected: BeginTransactionQuery {}.into(),\n            want_err: false,\n        },\n        TestCase {\n            name: \"begin만 있는 경우\".to_owned(),\n            input: \"BEGIN;\".to_owned(),\n            expected: Default::default(),\n            want_err: true,\n        },\n        TestCase {\n            name: \"begin 이후에 기대하지 않은 입력이 있는 경우\".to_owned(),\n            input: \"BEGIN TRANSITION;\".to_owned(),\n            expected: Default::default(),\n            want_err: true,\n        },\n    ];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n\n#[test]\npub fn commit() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"정상적인 Commit 명령\".to_owned(),\n        input: \"COMMIT;\".to_owned(),\n        expected: CommitQuery {}.into(),\n        want_err: false,\n    }];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n\n#[test]\npub fn rollback() {\n    struct TestCase {\n        name: String,\n        input: String,\n        expected: SQLStatement,\n        want_err: bool,\n    }\n\n    let test_cases = vec![TestCase {\n        name: \"정상적인 ROLLBACK 명령\".to_owned(),\n        input: \"ROLLBACK;\".to_owned(),\n        expected: RollbackQuery {}.into(),\n        want_err: false,\n    }];\n\n    for tc in test_cases {\n        let mut parser = Parser::with_string(tc.input).unwrap();\n\n        let result = parser.parse(ParserContext::default());\n\n        if tc.want_err {\n            assert!(\n                result.is_err(),\n                \"{} - expected error, got {:?}\",\n                tc.name,\n                result\n            );\n            continue;\n        }\n\n        assert_eq!(result.unwrap(), vec![tc.expected], \"{}\", tc.name);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","parser","test","update.rs"],"content":"#![cfg(test)]\n\nuse crate::ast::dml::expressions::binary::BinaryOperatorExpression;\nuse crate::ast::dml::expressions::operators::BinaryOperator;\nuse crate::ast::dml::parts::_where::WhereClause;\nuse crate::ast::dml::parts::update_item::UpdateItem;\nuse crate::ast::dml::update::UpdateQuery;\nuse crate::ast::types::{SQLExpression, SelectColumn, TableName};\nuse crate::parser::context::ParserContext;\nuse crate::parser::predule::Parser;\n\n#[test]\npub fn update_set_1() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn update_set_2() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1,\n            b = 2\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .add_update_item(UpdateItem {\n            column: \"b\".into(),\n            value: SQLExpression::Integer(2),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n\n#[test]\npub fn update_set_where_1() {\n    let text = r#\"\n        Update foo.bar\n        set\n            a = 1\n        where a = 5\n    \"#\n    .to_owned();\n\n    let mut parser = Parser::with_string(text).unwrap();\n\n    let expected = UpdateQuery::builder()\n        .set_target_table(TableName {\n            database_name: Some(\"foo\".into()),\n            table_name: \"bar\".into(),\n        })\n        .add_update_item(UpdateItem {\n            column: \"a\".into(),\n            value: SQLExpression::Integer(1),\n        })\n        .set_where(WhereClause {\n            expression: BinaryOperatorExpression {\n                operator: BinaryOperator::Eq,\n                lhs: SelectColumn::new(None, \"a\".into()).into(),\n                rhs: SQLExpression::Integer(5),\n            }\n            .into(),\n        })\n        .build();\n\n    assert_eq!(\n        parser.parse(ParserContext::default()).unwrap(),\n        vec![expected.into()],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","bound_portal.rs"],"content":"use crate::pgwire::{engine::Engine, protocol::backend::RowDescription};\n\npub struct BoundPortal\u003cE: Engine\u003e {\n    pub portal: E::PortalType,\n    pub row_desc: RowDescription,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","connection.rs"],"content":"//! Contains the [Connection] struct, which represents an individual Postgres session, and related types.\n\nuse futures::{SinkExt, StreamExt};\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::io::{AsyncRead, AsyncWrite};\nuse tokio_util::codec::Framed;\n\nuse crate::{\n    ast::{OtherStatement, SQLStatement},\n    executor::{config::global::GlobalConfig, executor::Executor},\n    lexer::predule::Tokenizer,\n    logger::predule::Logger,\n    parser::{context::ParserContext, predule::Parser},\n    pgwire::{\n        connection::{BoundPortal, ConnectionError, ConnectionState, PreparedStatement},\n        engine::{Engine, Portal, RRDBEngine},\n        protocol::{\n            backend::{\n                AuthenticationOk, BindComplete, CommandComplete, EmptyQueryResponse, ErrorResponse,\n                NoData, ParameterDescription, ParameterStatus, ParseComplete, ReadyForQuery,\n                RowDescription,\n            },\n            client::{BindFormat, ClientMessage, Describe},\n            ConnectionCodec, DataRowBatch, FormatCode, Severity, SqlState,\n        },\n    },\n    server::predule::SharedState,\n};\n\n/// Describes a connection using a specific engine.\n/// Contains connection state including prepared statements and portals.\npub struct Connection {\n    engine: RRDBEngine,\n    state: ConnectionState,\n    statements: HashMap\u003cString, PreparedStatement\u003e,\n    portals: HashMap\u003cString, Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e\u003e,\n    config: Arc\u003cGlobalConfig\u003e,\n}\n\nimpl Connection {\n    /// Create a new connection from an engine instance.\n    pub fn new(shared_state: SharedState, config: Arc\u003cGlobalConfig\u003e) -\u003e Self {\n        Self {\n            state: ConnectionState::Startup,\n            statements: HashMap::new(),\n            portals: HashMap::new(),\n            engine: RRDBEngine {\n                shared_state,\n                portal: None,\n            },\n            config,\n        }\n    }\n\n    fn prepared_statement(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026PreparedStatement, ConnectionError\u003e {\n        Ok(self.statements.get(name).ok_or_else(|| {\n            ErrorResponse::error(SqlState::INVALID_SQL_STATEMENT_NAME, \"missing statement\")\n        })?)\n    }\n\n    fn portal(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e, ConnectionError\u003e {\n        Ok(self\n            .portals\n            .get(name)\n            .ok_or_else(|| ErrorResponse::error(SqlState::INVALID_CURSOR_NAME, \"missing portal\"))?)\n    }\n\n    fn portal_mut(\n        \u0026mut self,\n        name: \u0026str,\n    ) -\u003e Result\u003c\u0026mut Option\u003cBoundPortal\u003cRRDBEngine\u003e\u003e, ConnectionError\u003e {\n        Ok(self\n            .portals\n            .get_mut(name)\n            .ok_or_else(|| ErrorResponse::error(SqlState::INVALID_CURSOR_NAME, \"missing portal\"))?)\n    }\n\n    fn parse_statement(\u0026mut self, text: \u0026str) -\u003e Result\u003cOption\u003cSQLStatement\u003e, ErrorResponse\u003e {\n        let tokens = match Tokenizer::string_to_tokens(text.into()) {\n            Ok(tokens) =\u003e tokens,\n            Err(e) =\u003e {\n                return Err(ErrorResponse::error(SqlState::SYNTAX_ERROR, e.to_string()));\n            }\n        };\n\n        let mut parser = Parser::new(tokens);\n\n        let statements = parser\n            .parse(\n                ParserContext::default()\n                    .set_default_database(self.engine.shared_state.client_info.database.clone()),\n            )\n            .map_err(|e| ErrorResponse::error(SqlState::SYNTAX_ERROR, e.to_string()))?;\n\n        match statements.len() {\n            0 =\u003e Ok(None),\n            1 =\u003e Ok(Some(statements[0].clone())),\n            _ =\u003e Err(ErrorResponse::error(\n                SqlState::SYNTAX_ERROR,\n                \"expected zero or one statements\",\n            )),\n        }\n    }\n\n    async fn step(\n        \u0026mut self,\n        framed: \u0026mut Framed\u003cimpl AsyncRead + AsyncWrite + Unpin, ConnectionCodec\u003e,\n    ) -\u003e Result\u003cOption\u003cConnectionState\u003e, ConnectionError\u003e {\n        match self.state {\n            ConnectionState::Startup =\u003e {\n                match framed\n                    .next()\n                    .await\n                    .ok_or(ConnectionError::ConnectionClosed)??\n                {\n                    ClientMessage::Startup(startup) =\u003e {\n                        if let Some(database_name) = startup.parameters.get(\"database\") {\n                            // 해당 데이터베이스가 존재하는지 검사\n                            let executor = Executor::new(self.config.clone());\n                            let result = executor.find_database(database_name.clone()).await;\n\n                            match result {\n                                Ok(has_match) =\u003e {\n                                    if has_match {\n                                        self.engine.shared_state.client_info.database =\n                                            database_name.to_owned();\n\n                                        Logger::info(format!(\n                                            \"New Connection=\u003e UUID:{} IP:{} DATABASE:{}\",\n                                            self.engine.shared_state.client_info.connection_id,\n                                            self.engine.shared_state.client_info.ip,\n                                            self.engine.shared_state.client_info.database\n                                        ));\n                                    } else {\n                                        return Err(ErrorResponse::fatal(\n                                            SqlState::CONNECTION_EXCEPTION,\n                                            format!(\"No database named '{}'\", database_name),\n                                        )\n                                        .into());\n                                    }\n                                }\n                                Err(error) =\u003e {\n                                    return Err(ErrorResponse::fatal(\n                                        SqlState::CONNECTION_EXCEPTION,\n                                        format!(\"{:?}\", error),\n                                    )\n                                    .into());\n                                }\n                            }\n                        }\n                    }\n                    ClientMessage::SSLRequest =\u003e {\n                        // we don't support SSL for now\n                        // client will retry with startup packet\n                        framed.send('N').await?;\n                        return Ok(Some(ConnectionState::Startup));\n                    }\n                    _ =\u003e {\n                        return Err(ErrorResponse::fatal(\n                            SqlState::PROTOCOL_VIOLATION,\n                            \"expected startup message\",\n                        )\n                        .into());\n                    }\n                }\n\n                framed.send(AuthenticationOk).await?;\n\n                let param_statuses = \u0026[\n                    (\"server_version\", \"13\"),\n                    (\"server_encoding\", \"UTF8\"),\n                    (\"client_encoding\", \"UTF8\"),\n                    (\"DateStyle\", \"ISO\"),\n                    (\"TimeZone\", \"UTC\"),\n                    (\"integer_datetimes\", \"on\"),\n                ];\n\n                for \u0026(param, status) in param_statuses {\n                    framed.send(ParameterStatus::new(param, status)).await?;\n                }\n\n                framed.send(ReadyForQuery).await?;\n                Ok(Some(ConnectionState::Idle))\n            }\n            ConnectionState::Idle =\u003e {\n                match framed\n                    .next()\n                    .await\n                    .ok_or(ConnectionError::ConnectionClosed)??\n                {\n                    ClientMessage::Parse(parse) =\u003e {\n                        let parsed_statement = self.parse_statement(\u0026parse.query)?;\n\n                        self.statements.insert(\n                            parse.prepared_statement_name,\n                            PreparedStatement {\n                                fields: match \u0026parsed_statement {\n                                    Some(statement) =\u003e self.engine.prepare(statement).await?,\n                                    None =\u003e vec![],\n                                },\n                                statement: parsed_statement,\n                            },\n                        );\n                        framed.send(ParseComplete).await?;\n                    }\n                    ClientMessage::Bind(bind) =\u003e {\n                        let format_code = match bind.result_format {\n                            BindFormat::All(format) =\u003e format,\n                            BindFormat::PerColumn(_) =\u003e {\n                                return Err(ErrorResponse::error(\n                                    SqlState::FEATURE_NOT_SUPPORTED,\n                                    \"per-column format codes not supported\",\n                                )\n                                .into());\n                            }\n                        };\n\n                        let prepared = self\n                            .prepared_statement(\u0026bind.prepared_statement_name)?\n                            .clone();\n\n                        let portal = match prepared.statement {\n                            Some(statement) =\u003e {\n                                let portal = self.engine.create_portal(\u0026statement).await?;\n                                let row_desc = RowDescription {\n                                    fields: prepared.fields.clone(),\n                                    format_code,\n                                };\n\n                                Some(BoundPortal { portal, row_desc })\n                            }\n                            None =\u003e None,\n                        };\n\n                        self.portals.insert(bind.portal, portal);\n\n                        framed.send(BindComplete).await?;\n                    }\n                    ClientMessage::Describe(Describe::PreparedStatement(ref statement_name)) =\u003e {\n                        let fields = self.prepared_statement(statement_name)?.fields.clone();\n                        framed.send(ParameterDescription {}).await?;\n                        framed\n                            .send(RowDescription {\n                                fields,\n                                format_code: FormatCode::Text,\n                            })\n                            .await?;\n                    }\n                    ClientMessage::Describe(Describe::Portal(ref portal_name)) =\u003e {\n                        match self.portal(portal_name)? {\n                            Some(portal) =\u003e framed.send(portal.row_desc.clone()).await?,\n                            None =\u003e framed.send(NoData).await?,\n                        }\n                    }\n                    ClientMessage::Sync =\u003e {\n                        framed.send(ReadyForQuery).await?;\n                    }\n                    ClientMessage::Execute(exec) =\u003e match self.portal_mut(\u0026exec.portal)? {\n                        Some(bound) =\u003e {\n                            let mut batch_writer = DataRowBatch::from_row_desc(\u0026bound.row_desc);\n                            bound.portal.fetch(\u0026mut batch_writer).await?;\n                            let num_rows = batch_writer.num_rows();\n\n                            framed.send(batch_writer).await?;\n\n                            framed\n                                .send(CommandComplete {\n                                    command_tag: format!(\"SELECT {}\", num_rows),\n                                })\n                                .await?;\n                        }\n                        None =\u003e {\n                            framed.send(EmptyQueryResponse).await?;\n                        }\n                    },\n                    ClientMessage::Query(query) =\u003e {\n                        if let Some(parsed) = self.parse_statement(\u0026query)? {\n                            let fields = self.engine.prepare(\u0026parsed).await?;\n                            let row_desc = RowDescription {\n                                fields,\n                                format_code: FormatCode::Text,\n                            };\n                            let mut portal = self.engine.create_portal(\u0026parsed).await?;\n\n                            let mut batch_writer = DataRowBatch::from_row_desc(\u0026row_desc);\n                            portal.fetch(\u0026mut batch_writer).await?;\n                            let num_rows = batch_writer.num_rows();\n\n                            if let SQLStatement::Other(OtherStatement::UseDatabase(query)) = parsed\n                            {\n                                self.engine.shared_state.client_info.database = query.database_name;\n                            }\n\n                            framed.send(row_desc).await?;\n                            framed.send(batch_writer).await?;\n\n                            framed\n                                .send(CommandComplete {\n                                    command_tag: format!(\"SELECT {}\", num_rows),\n                                })\n                                .await?;\n                        } else {\n                            framed.send(EmptyQueryResponse).await?;\n                        }\n                        framed.send(ReadyForQuery).await?;\n                    }\n                    ClientMessage::Terminate =\u003e {\n                        return Ok(None);\n                    }\n                    _ =\u003e {\n                        return Err(ErrorResponse::error(\n                            SqlState::PROTOCOL_VIOLATION,\n                            \"unexpected message\",\n                        )\n                        .into())\n                    }\n                };\n\n                Ok(Some(ConnectionState::Idle))\n            }\n        }\n    }\n\n    /// Given a stream (typically TCP), extract Postgres protocol messages and respond accordingly.\n    /// This function only returns when the connection is closed (either gracefully or due to an error).\n    pub async fn run(\n        \u0026mut self,\n        stream: impl AsyncRead + AsyncWrite + Unpin,\n    ) -\u003e Result\u003c(), ConnectionError\u003e {\n        let mut framed = Framed::new(stream, ConnectionCodec::new());\n\n        loop {\n            let new_state = match self.step(\u0026mut framed).await {\n                Ok(Some(state)) =\u003e state,\n                Ok(None) =\u003e {\n                    return Ok(());\n                }\n                Err(ConnectionError::ErrorResponse(err_info)) =\u003e {\n                    framed.send(err_info.clone()).await?;\n\n                    if err_info.severity == Severity::FATAL {\n                        return Err(err_info.into());\n                    }\n\n                    framed.send(ReadyForQuery).await?;\n                    ConnectionState::Idle\n                }\n                Err(err) =\u003e {\n                    framed\n                        .send(ErrorResponse::fatal(\n                            SqlState::CONNECTION_EXCEPTION,\n                            \"connection error\",\n                        ))\n                        .await?;\n                    return Err(err);\n                }\n            };\n\n            self.state = new_state;\n        }\n    }\n}\n","traces":[{"line":41,"address":[2328448,2328801,2328822],"length":1,"stats":{"Line":0}},{"line":44,"address":[2328485],"length":1,"stats":{"Line":0}},{"line":45,"address":[2328534],"length":1,"stats":{"Line":0}},{"line":46,"address":[2328616],"length":1,"stats":{"Line":0}},{"line":54,"address":[2328848],"length":1,"stats":{"Line":0}},{"line":55,"address":[2329065,2328928],"length":1,"stats":{"Line":0}},{"line":56,"address":[1562556],"length":1,"stats":{"Line":0}},{"line":60,"address":[2329104],"length":1,"stats":{"Line":0}},{"line":61,"address":[2329184,2329321],"length":1,"stats":{"Line":0}},{"line":64,"address":[2329293],"length":1,"stats":{"Line":0}},{"line":67,"address":[2329360],"length":1,"stats":{"Line":0}},{"line":71,"address":[2329577,2329440],"length":1,"stats":{"Line":0}},{"line":74,"address":[2329549],"length":1,"stats":{"Line":0}},{"line":77,"address":[2329616,2330799,2330838],"length":1,"stats":{"Line":0}},{"line":78,"address":[2329985,2329688],"length":1,"stats":{"Line":0}},{"line":79,"address":[1562736,1562759],"length":1,"stats":{"Line":0}},{"line":81,"address":[2330189,2330433],"length":1,"stats":{"Line":0}},{"line":83,"address":[2330121,2329943],"length":1,"stats":{"Line":0}},{"line":84,"address":[2330828,2330160,2330052],"length":1,"stats":{"Line":0}},{"line":86,"address":[2330369],"length":1,"stats":{"Line":0}},{"line":88,"address":[2330503,2330349],"length":1,"stats":{"Line":0}},{"line":89,"address":[2330571],"length":1,"stats":{"Line":0}},{"line":90,"address":[2330668,2330609],"length":1,"stats":{"Line":0}},{"line":91,"address":[2330523,2330731],"length":1,"stats":{"Line":0}},{"line":98,"address":[1562992],"length":1,"stats":{"Line":0}},{"line":102,"address":[1563179,1563512],"length":1,"stats":{"Line":0}},{"line":104,"address":[1564163,1564732,1564791,1564610,1566336,1564299,1566314,1565393,1565035],"length":1,"stats":{"Line":0}},{"line":106,"address":[1563583,1564276,1564755,1564314,1564557],"length":1,"stats":{"Line":0}},{"line":107,"address":[1565340,1564700,1564967],"length":1,"stats":{"Line":0}},{"line":109,"address":[1565514],"length":1,"stats":{"Line":0}},{"line":110,"address":[1565601,1565858],"length":1,"stats":{"Line":0}},{"line":112,"address":[1565918,1565988],"length":1,"stats":{"Line":0}},{"line":113,"address":[1563604,1566010,1566133,1566338],"length":1,"stats":{"Line":0}},{"line":115,"address":[1566596],"length":1,"stats":{"Line":0}},{"line":116,"address":[1566622],"length":1,"stats":{"Line":0}},{"line":117,"address":[1566641],"length":1,"stats":{"Line":0}},{"line":118,"address":[1567096,1567204],"length":1,"stats":{"Line":0}},{"line":119,"address":[1566870,1567177],"length":1,"stats":{"Line":0}},{"line":121,"address":[1567255,1567445,1567348,1567542],"length":1,"stats":{"Line":0}},{"line":128,"address":[1566980],"length":1,"stats":{"Line":0}},{"line":130,"address":[1566776,1566907],"length":1,"stats":{"Line":0}},{"line":135,"address":[1566651],"length":1,"stats":{"Line":0}},{"line":136,"address":[1568059],"length":1,"stats":{"Line":0}},{"line":138,"address":[1567986],"length":1,"stats":{"Line":0}},{"line":148,"address":[1568248,1565710,1563625,1568525,1565469],"length":1,"stats":{"Line":0}},{"line":149,"address":[1568464],"length":1,"stats":{"Line":0}},{"line":152,"address":[1566231,1565426],"length":1,"stats":{"Line":0}},{"line":160,"address":[1568817,1567844,1563646,1569220,1567720,1569071],"length":1,"stats":{"Line":0}},{"line":162,"address":[1569033],"length":1,"stats":{"Line":0}},{"line":171,"address":[1569644,1569550,1569165,1569718,1569048],"length":1,"stats":{"Line":0}},{"line":172,"address":[1569257,1569555,1569225,1569781,1569957,1563667],"length":1,"stats":{"Line":0}},{"line":175,"address":[1569681,1570038,1563688,1570315,1569834],"length":1,"stats":{"Line":0}},{"line":176,"address":[1570254],"length":1,"stats":{"Line":0}},{"line":179,"address":[1577397,1570459,1571290,1570581,1564467,1570884,1570640,1577464,1564193,1571538],"length":1,"stats":{"Line":0}},{"line":181,"address":[1570604,1570406,1563709,1564444,1564482],"length":1,"stats":{"Line":0}},{"line":182,"address":[1570816,1571237,1570549],"length":1,"stats":{"Line":0}},{"line":184,"address":[1571366],"length":1,"stats":{"Line":0}},{"line":185,"address":[1572946,1572081,1571482,1572410],"length":1,"stats":{"Line":0}},{"line":187,"address":[1572224,1572771],"length":1,"stats":{"Line":0}},{"line":188,"address":[1572261],"length":1,"stats":{"Line":0}},{"line":189,"address":[1572729],"length":1,"stats":{"Line":0}},{"line":190,"address":[1572349],"length":1,"stats":{"Line":0}},{"line":191,"address":[1563730,1572530,1577466,1572850],"length":1,"stats":{"Line":0}},{"line":192,"address":[1572515,1572627],"length":1,"stats":{"Line":0}},{"line":194,"address":[1572629],"length":1,"stats":{"Line":0}},{"line":197,"address":[1578891,1578605,1563751,1578051,1578348],"length":1,"stats":{"Line":0}},{"line":199,"address":[1571565],"length":1,"stats":{"Line":0}},{"line":200,"address":[1571639],"length":1,"stats":{"Line":0}},{"line":201,"address":[1574404],"length":1,"stats":{"Line":0}},{"line":203,"address":[1574495,1575372],"length":1,"stats":{"Line":0}},{"line":211,"address":[1575305,1574612,1574442,1574779],"length":1,"stats":{"Line":0}},{"line":212,"address":[1574715,1574465],"length":1,"stats":{"Line":0}},{"line":215,"address":[1574827],"length":1,"stats":{"Line":0}},{"line":216,"address":[1574889],"length":1,"stats":{"Line":0}},{"line":217,"address":[1574943,1579212,1575209,1579882,1563772],"length":1,"stats":{"Line":0}},{"line":219,"address":[1579849],"length":1,"stats":{"Line":0}},{"line":223,"address":[1580074],"length":1,"stats":{"Line":0}},{"line":225,"address":[1574869],"length":1,"stats":{"Line":0}},{"line":228,"address":[1580498,1574991],"length":1,"stats":{"Line":0}},{"line":230,"address":[1563793,1580711,1580505,1580949,1581199],"length":1,"stats":{"Line":0}},{"line":232,"address":[1573061],"length":1,"stats":{"Line":0}},{"line":233,"address":[1573965,1574382,1573084],"length":1,"stats":{"Line":0}},{"line":234,"address":[1574180,1582067,1581542,1581901,1563814,1574280],"length":1,"stats":{"Line":0}},{"line":235,"address":[1582002,1582208,1582456,1581894,1581762,1582346],"length":1,"stats":{"Line":0}},{"line":236,"address":[1581830],"length":1,"stats":{"Line":0}},{"line":237,"address":[1581777],"length":1,"stats":{"Line":0}},{"line":238,"address":[1581822],"length":1,"stats":{"Line":0}},{"line":240,"address":[1582095,1581995,1582035,1563835,1582408,1582256],"length":1,"stats":{"Line":0}},{"line":242,"address":[1572989],"length":1,"stats":{"Line":0}},{"line":243,"address":[1573012,1573828,1573248],"length":1,"stats":{"Line":0}},{"line":244,"address":[1582839,1573730,1573539,1582541,1563856],"length":1,"stats":{"Line":0}},{"line":245,"address":[1573604,1563877,1582930,1573494],"length":1,"stats":{"Line":0}},{"line":248,"address":[1583458],"length":1,"stats":{"Line":0}},{"line":249,"address":[1571690,1575469,1563898,1583242,1583463],"length":1,"stats":{"Line":0}},{"line":251,"address":[1576352,1571730,1575647],"length":1,"stats":{"Line":0}},{"line":252,"address":[1575938],"length":1,"stats":{"Line":0}},{"line":253,"address":[1576142,1575946],"length":1,"stats":{"Line":0}},{"line":254,"address":[1576157,1583546,1563919,1576256,1584249,1583902],"length":1,"stats":{"Line":0}},{"line":255,"address":[1584015,1583855],"length":1,"stats":{"Line":0}},{"line":257,"address":[1563940,1584687,1585027,1584018,1584277],"length":1,"stats":{"Line":0}},{"line":259,"address":[1584897,1585145,1584570,1585283,1585442,1584927,1585390],"length":1,"stats":{"Line":0}},{"line":260,"address":[1584849],"length":1,"stats":{"Line":0}},{"line":261,"address":[1584768,1584593],"length":1,"stats":{"Line":0}},{"line":263,"address":[1563961,1585193,1585342,1584920,1584995,1585032],"length":1,"stats":{"Line":0}},{"line":265,"address":[1585738],"length":1,"stats":{"Line":0}},{"line":266,"address":[1585743,1575990,1563982,1585522,1575893],"length":1,"stats":{"Line":0}},{"line":269,"address":[1571834],"length":1,"stats":{"Line":0}},{"line":270,"address":[1576450,1590696,1577314,1571885,1591618],"length":1,"stats":{"Line":0}},{"line":271,"address":[1564003,1576831,1577028,1586390,1585826,1586644],"length":1,"stats":{"Line":0}},{"line":276,"address":[1586342,1564024,1586551,1587716,1587372,1586717],"length":1,"stats":{"Line":0}},{"line":278,"address":[1587337,1587524],"length":1,"stats":{"Line":0}},{"line":279,"address":[1588715,1587638,1588091,1587744,1564045,1587539],"length":1,"stats":{"Line":0}},{"line":280,"address":[1588198,1588050],"length":1,"stats":{"Line":0}},{"line":282,"address":[1588381,1588201,1588625],"length":1,"stats":{"Line":0}},{"line":284,"address":[1588574,1588434],"length":1,"stats":{"Line":0}},{"line":287,"address":[1564066,1589343,1589180,1588646,1588295,1588743],"length":1,"stats":{"Line":0}},{"line":288,"address":[1589752,1564087,1590086,1589348,1589037,1589274],"length":1,"stats":{"Line":0}},{"line":290,"address":[1589959,1590201,1590459,1590339,1590813,1589989,1589638],"length":1,"stats":{"Line":0}},{"line":291,"address":[1589911],"length":1,"stats":{"Line":0}},{"line":292,"address":[1589658,1589833],"length":1,"stats":{"Line":0}},{"line":294,"address":[1590057,1590091,1590411,1590249,1564108,1589982],"length":1,"stats":{"Line":0}},{"line":296,"address":[1576879,1591623,1591402,1591933,1577212,1564129],"length":1,"stats":{"Line":0}},{"line":298,"address":[1564150,1592064,1592309,1591736,1592533,1591849],"length":1,"stats":{"Line":0}},{"line":301,"address":[1571941],"length":1,"stats":{"Line":0}},{"line":304,"address":[1571323,1577336],"length":1,"stats":{"Line":0}},{"line":312,"address":[1592472],"length":1,"stats":{"Line":0}},{"line":319,"address":[1592976],"length":1,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":147},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","engine_func.rs"],"content":"use std::{pin::Pin, sync::Arc};\n\npub type EngineFunc\u003cE\u003e =\n    Arc\u003cdyn Fn() -\u003e Pin\u003cBox\u003cdyn futures::Future\u003cOutput = E\u003e + Send\u003e\u003e + Send + Sync\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","error","connection_error.rs"],"content":"use crate::pgwire::protocol::{backend::ErrorResponse, ProtocolError};\n\n/// Describes an error that may or may not result in the termination of a connection.\n#[derive(thiserror::Error, Debug)]\npub enum ConnectionError {\n    /// A protocol error was encountered, e.g. an invalid message for a connection's current state.\n    #[error(\"protocol error: {0}\")]\n    Protocol(#[from] ProtocolError),\n    /// A Postgres error containing a SqlState code and message occurred.\n    /// May result in connection termination depending on the severity.\n    #[error(\"error response: {0}\")]\n    ErrorResponse(#[from] ErrorResponse),\n    /// The connection was closed.\n    /// This always implies connection termination.\n    #[error(\"connection closed\")]\n    ConnectionClosed,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","error","mod.rs"],"content":"pub mod connection_error;\npub use connection_error::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","mod.rs"],"content":"pub mod error;\npub use error::*;\n\n#[path = \"./connection.rs\"]\npub mod connection_impl;\npub use connection_impl::*;\n\npub mod state;\npub use state::*;\n\npub mod prepared_statement;\npub use prepared_statement::*;\n\npub mod bound_portal;\npub use bound_portal::*;\n\npub mod engine_func;\npub use engine_func::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","prepared_statement.rs"],"content":"use crate::{ast::SQLStatement, pgwire::protocol::backend::FieldDescription};\n\n#[derive(Debug, Clone)]\npub struct PreparedStatement {\n    pub statement: Option\u003cSQLStatement\u003e,\n    pub fields: Vec\u003cFieldDescription\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","connection","state.rs"],"content":"#[derive(Debug)]\npub enum ConnectionState {\n    Startup,\n    Idle,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","engine.rs"],"content":"use async_trait::async_trait;\n\nuse crate::{\n    ast::SQLStatement,\n    pgwire::protocol::backend::{ErrorResponse, FieldDescription},\n};\n\nuse super::Portal;\n\n/// The engine trait is the core of the `convergence` crate, and is responsible for dispatching most SQL operations.\n///\n/// Each connection is allocated an [Engine] instance, which it uses to prepare statements, create portals, etc.\n#[async_trait]\npub trait Engine: Send + Sync + 'static {\n    /// The [Portal] implementation used by [Engine::create_portal].\n    type PortalType: Portal;\n\n    /// Prepares a statement, returning a vector of field descriptions for the final statement result.\n    async fn prepare(\n        \u0026mut self,\n        statement: \u0026SQLStatement,\n    ) -\u003e Result\u003cVec\u003cFieldDescription\u003e, ErrorResponse\u003e;\n\n    /// Creates a new portal for the given statement.\n    async fn create_portal(\n        \u0026mut self,\n        stmt: \u0026SQLStatement,\n    ) -\u003e Result\u003cSelf::PortalType, ErrorResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","mod.rs"],"content":"#[path = \"./engine.rs\"]\npub mod engine_impl;\npub use engine_impl::*;\n\npub mod portal;\npub use portal::*;\n\npub mod rrdb;\npub use rrdb::*;","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","portal.rs"],"content":"use async_trait::async_trait;\n\nuse crate::pgwire::protocol::{backend::ErrorResponse, DataRowBatch};\n\n/// A Postgres portal. Portals represent a prepared statement with all parameters specified.\n///\n/// See Postgres' protocol docs regarding the [extended query overview](https://www.postgresql.org/docs/current/protocol-overview.html#PROTOCOL-QUERY-CONCEPTS)\n/// for more details.\n#[async_trait]\npub trait Portal: Send + Sync {\n    /// Fetches the contents of the portal into a [DataRowBatch].\n    async fn fetch(\u0026mut self, batch: \u0026mut DataRowBatch) -\u003e Result\u003c(), ErrorResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","engine","rrdb.rs"],"content":"use async_trait::async_trait;\nuse tokio::sync::oneshot;\n\nuse crate::ast::SQLStatement;\nuse crate::executor::predule::ExecuteResult;\nuse crate::executor::result::ExecuteField;\nuse crate::pgwire::engine::{Engine, Portal};\nuse crate::pgwire::protocol::backend::{ErrorResponse, FieldDescription};\nuse crate::pgwire::protocol::{DataRowBatch, SqlState};\nuse crate::server::predule::{ChannelRequest, ChannelResponse, SharedState};\n\n#[derive(Debug, Clone)]\npub struct RRDBPortal {\n    pub shared_state: SharedState,\n    pub execute_result: ExecuteResult,\n}\n\n#[async_trait]\nimpl Portal for RRDBPortal {\n    // 실제 결과 데이터 리스트 전송\n    async fn fetch(\u0026mut self, batch: \u0026mut DataRowBatch) -\u003e Result\u003c(), ErrorResponse\u003e {\n        for row in self.execute_result.rows.iter().cloned() {\n            let mut writer = batch.create_row();\n\n            for field in row.fields {\n                match field {\n                    ExecuteField::Bool(data) =\u003e {\n                        writer.write_bool(data);\n                    }\n                    ExecuteField::Integer(data) =\u003e {\n                        writer.write_int8(data);\n                    }\n                    ExecuteField::Float(data) =\u003e {\n                        writer.write_float8(data);\n                    }\n                    ExecuteField::String(data) =\u003e {\n                        writer.write_string(\u0026data);\n                    }\n                    ExecuteField::Null =\u003e {\n                        writer.write_null();\n                    }\n                }\n            }\n        }\n\n        return Ok(());\n    }\n}\n\npub struct RRDBEngine {\n    pub shared_state: SharedState,\n    pub portal: Option\u003cRRDBPortal\u003e,\n}\n\n#[async_trait]\nimpl Engine for RRDBEngine {\n    type PortalType = RRDBPortal;\n\n    // 결과 데이터 리스트의 컬럼 정보 전송\n    async fn prepare(\n        \u0026mut self,\n        statement: \u0026SQLStatement,\n    ) -\u003e Result\u003cVec\u003cFieldDescription\u003e, ErrorResponse\u003e {\n        // Server Background Loop와의 통신용 채널\n        let (response_sender, response_receiver) = oneshot::channel::\u003cChannelResponse\u003e();\n\n        if let Err(error) = self\n            .shared_state\n            .sender\n            .send(ChannelRequest {\n                statement: statement.to_owned(),\n                response_sender,\n                connection_id: self.shared_state.client_info.connection_id.clone(),\n            })\n            .await\n        {\n            return Err(ErrorResponse::fatal(\n                SqlState::CONNECTION_EXCEPTION,\n                error.to_string(),\n            ));\n        }\n\n        match response_receiver.await {\n            Ok(response) =\u003e match response.result {\n                Ok(result) =\u003e {\n                    let return_value = Ok(result\n                        .columns\n                        .iter()\n                        .map(|e| FieldDescription {\n                            name: e.name.to_owned(),\n                            data_type: e.data_type.to_owned().into(),\n                        })\n                        .collect());\n\n                    self.portal = Some(RRDBPortal {\n                        execute_result: result,\n                        shared_state: self.shared_state.clone(),\n                    });\n\n                    return return_value;\n                }\n                Err(error) =\u003e {\n                    return Err(ErrorResponse::error(\n                        SqlState::SYNTAX_ERROR,\n                        error.to_string(),\n                    ));\n                }\n            },\n            Err(error) =\u003e {\n                return Err(ErrorResponse::fatal(\n                    SqlState::CONNECTION_EXCEPTION,\n                    error.to_string(),\n                ));\n            }\n        }\n    }\n\n    async fn create_portal(\u0026mut self, _: \u0026SQLStatement) -\u003e Result\u003cSelf::PortalType, ErrorResponse\u003e {\n        match \u0026self.portal {\n            Some(portal) =\u003e Ok(portal.to_owned()),\n            None =\u003e {\n                return Err(ErrorResponse::fatal(\n                    SqlState::CONNECTION_EXCEPTION,\n                    \"not prepared yet\".to_string(),\n                ));\n            }\n        }\n    }\n}\n","traces":[{"line":21,"address":[5646400,5646433,5646539,5646678,5647775,5647817],"length":1,"stats":{"Line":0}},{"line":22,"address":[5647487,5646953,5646744,5646474],"length":1,"stats":{"Line":0}},{"line":23,"address":[5647073,5646993],"length":1,"stats":{"Line":0}},{"line":25,"address":[5647192,5647319,5647369,5647089],"length":1,"stats":{"Line":0}},{"line":26,"address":[5647401],"length":1,"stats":{"Line":0}},{"line":27,"address":[5647500],"length":1,"stats":{"Line":0}},{"line":28,"address":[5647512,5647669,5647492],"length":1,"stats":{"Line":0}},{"line":30,"address":[5647533],"length":1,"stats":{"Line":0}},{"line":31,"address":[5647557,5647674],"length":1,"stats":{"Line":0}},{"line":33,"address":[5647564],"length":1,"stats":{"Line":0}},{"line":34,"address":[5647679,5647590],"length":1,"stats":{"Line":0}},{"line":36,"address":[5647597],"length":1,"stats":{"Line":0}},{"line":37,"address":[5647637,5647746],"length":1,"stats":{"Line":0}},{"line":40,"address":[5647662,5647784],"length":1,"stats":{"Line":0}},{"line":46,"address":[5646930],"length":1,"stats":{"Line":0}},{"line":65,"address":[5648304],"length":1,"stats":{"Line":0}},{"line":67,"address":[5648391,5648686,5648952,5648656,5649047,5648376],"length":1,"stats":{"Line":0}},{"line":70,"address":[5648557],"length":1,"stats":{"Line":0}},{"line":71,"address":[5648387,5648408],"length":1,"stats":{"Line":0}},{"line":72,"address":[5648459],"length":1,"stats":{"Line":0}},{"line":73,"address":[5648487],"length":1,"stats":{"Line":0}},{"line":75,"address":[4712332],"length":1,"stats":{"Line":0}},{"line":77,"address":[5649195],"length":1,"stats":{"Line":0}},{"line":79,"address":[5649130],"length":1,"stats":{"Line":0}},{"line":83,"address":[4712348],"length":1,"stats":{"Line":0}},{"line":84,"address":[5649840],"length":1,"stats":{"Line":0}},{"line":85,"address":[5649920],"length":1,"stats":{"Line":0}},{"line":86,"address":[5649976,5650161],"length":1,"stats":{"Line":0}},{"line":89,"address":[5651136,5651286,5651323],"length":1,"stats":{"Line":0}},{"line":90,"address":[5651173],"length":1,"stats":{"Line":0}},{"line":91,"address":[5651192,5651243],"length":1,"stats":{"Line":0}},{"line":95,"address":[5650402],"length":1,"stats":{"Line":0}},{"line":96,"address":[5650280],"length":1,"stats":{"Line":0}},{"line":97,"address":[5650336],"length":1,"stats":{"Line":0}},{"line":100,"address":[5650770],"length":1,"stats":{"Line":0}},{"line":102,"address":[5650004],"length":1,"stats":{"Line":0}},{"line":103,"address":[5650918],"length":1,"stats":{"Line":0}},{"line":105,"address":[5650100],"length":1,"stats":{"Line":0}},{"line":110,"address":[5651060],"length":1,"stats":{"Line":0}},{"line":112,"address":[5649910],"length":1,"stats":{"Line":0}},{"line":118,"address":[5651890,5651587,5651344,5651457,5651374],"length":1,"stats":{"Line":0}},{"line":119,"address":[5651406,5651647],"length":1,"stats":{"Line":0}},{"line":120,"address":[5651833,5651722],"length":1,"stats":{"Line":0}},{"line":122,"address":[5651745],"length":1,"stats":{"Line":0}},{"line":124,"address":[5651690],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","mod.rs"],"content":"pub mod connection;\npub mod engine;\npub mod predule;\npub mod protocol;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","predule.rs"],"content":"pub use super::connection::*;\npub use super::engine::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","connection_codec.rs"],"content":"use bytes::{Buf, BufMut, BytesMut};\nuse std::collections::HashMap;\nuse tokio_util::codec::{Decoder, Encoder};\n\nuse crate::pgwire::protocol::ProtocolError;\n\nuse super::{\n    backend::BackendMessage,\n    client::{Bind, BindFormat, ClientMessage, Describe, Execute, Parse, Startup},\n    FormatCode, MESSAGE_HEADER_SIZE, STARTUP_HEADER_SIZE,\n};\n\n#[derive(Default, Debug)]\npub struct ConnectionCodec {\n    // most state tracking is handled at a higher level\n    // however, the actual wire format uses a different header for startup vs normal messages\n    // so we need to be able to differentiate inside the decoder\n    startup_received: bool,\n}\n\nimpl ConnectionCodec {\n    pub fn new() -\u003e Self {\n        Self {\n            startup_received: false,\n        }\n    }\n}\n\nimpl Decoder for ConnectionCodec {\n    type Item = ClientMessage;\n    type Error = ProtocolError;\n\n    fn decode(\u0026mut self, src: \u0026mut BytesMut) -\u003e Result\u003cOption\u003cSelf::Item\u003e, Self::Error\u003e {\n        if !self.startup_received {\n            if src.len() \u003c STARTUP_HEADER_SIZE {\n                return Ok(None);\n            }\n\n            let mut header_buf = src.clone();\n            let message_len = header_buf.get_i32() as usize;\n            let protocol_version_major = header_buf.get_i16();\n            let protocol_version_minor = header_buf.get_i16();\n\n            if protocol_version_major == 1234i16 \u0026\u0026 protocol_version_minor == 5679i16 {\n                src.advance(STARTUP_HEADER_SIZE);\n                return Ok(Some(ClientMessage::SSLRequest));\n            }\n\n            if src.len() \u003c message_len {\n                src.reserve(message_len - src.len());\n                return Ok(None);\n            }\n\n            src.advance(STARTUP_HEADER_SIZE);\n\n            let mut parameters = HashMap::new();\n\n            let mut param_str_start_pos = 0;\n            let mut current_key = None;\n\n            for (i, \u0026blah) in src.iter().enumerate() {\n                if blah == 0 {\n                    let string_value = String::from_utf8(src[param_str_start_pos..i].to_owned())?;\n\n                    param_str_start_pos = i + 1;\n\n                    current_key = match current_key {\n                        Some(key) =\u003e {\n                            parameters.insert(key, string_value);\n                            None\n                        }\n                        None =\u003e Some(string_value),\n                    }\n                }\n            }\n\n            src.advance(message_len - STARTUP_HEADER_SIZE);\n\n            self.startup_received = true;\n            return Ok(Some(ClientMessage::Startup(Startup {\n                requested_protocol_version: (protocol_version_major, protocol_version_minor),\n                parameters,\n            })));\n        }\n\n        if src.len() \u003c MESSAGE_HEADER_SIZE {\n            src.reserve(MESSAGE_HEADER_SIZE);\n            return Ok(None);\n        }\n\n        let mut header_buf = src.clone();\n        let message_tag = header_buf.get_u8();\n        let message_len = header_buf.get_i32() as usize;\n\n        if src.len() \u003c message_len {\n            src.reserve(message_len - src.len());\n            return Ok(None);\n        }\n\n        src.advance(MESSAGE_HEADER_SIZE);\n\n        let read_cstr = |src: \u0026mut BytesMut| -\u003e Result\u003cString, ProtocolError\u003e {\n            let next_null = src\n                .iter()\n                .position(|\u0026b| b == 0)\n                .ok_or(ProtocolError::ParserError)?;\n            let bytes = src[..next_null].to_owned();\n            src.advance(bytes.len() + 1);\n            Ok(String::from_utf8(bytes)?)\n        };\n\n        let message = match message_tag {\n            b'P' =\u003e {\n                let prepared_statement_name = read_cstr(src)?;\n                let query = read_cstr(src)?;\n                let num_params = src.get_i16();\n                let _params: Vec\u003c_\u003e = (0..num_params).map(|_| src.get_u32()).collect();\n\n                ClientMessage::Parse(Parse {\n                    prepared_statement_name,\n                    query,\n                    parameter_types: Vec::new(),\n                })\n            }\n            b'D' =\u003e {\n                let target_type = src.get_u8();\n                let name = read_cstr(src)?;\n\n                ClientMessage::Describe(match target_type {\n                    b'P' =\u003e Describe::Portal(name),\n                    b'S' =\u003e Describe::PreparedStatement(name),\n                    _ =\u003e return Err(ProtocolError::ParserError),\n                })\n            }\n            b'S' =\u003e ClientMessage::Sync,\n            b'B' =\u003e {\n                let portal = read_cstr(src)?;\n                let prepared_statement_name = read_cstr(src)?;\n\n                let num_param_format_codes = src.get_i16();\n                for _ in 0..num_param_format_codes {\n                    let _format_code = src.get_i16();\n                }\n\n                let num_params = src.get_i16();\n                for _ in 0..num_params {\n                    let param_len = src.get_i32() as usize;\n                    let _bytes = \u0026src[0..param_len];\n                    src.advance(param_len);\n                }\n\n                let result_format = match src.get_i16() {\n                    0 =\u003e BindFormat::All(FormatCode::Text),\n                    1 =\u003e BindFormat::All(src.get_i16().try_into()?),\n                    n =\u003e {\n                        let mut result_format_codes = Vec::new();\n                        for _ in 0..n {\n                            result_format_codes.push(src.get_i16().try_into()?);\n                        }\n                        BindFormat::PerColumn(result_format_codes)\n                    }\n                };\n\n                ClientMessage::Bind(Bind {\n                    portal,\n                    prepared_statement_name,\n                    result_format,\n                })\n            }\n            b'E' =\u003e {\n                let portal = read_cstr(src)?;\n                let max_rows = match src.get_i32() {\n                    0 =\u003e None,\n                    other =\u003e Some(other),\n                };\n\n                ClientMessage::Execute(Execute { portal, max_rows })\n            }\n            b'Q' =\u003e {\n                let query = read_cstr(src)?;\n                ClientMessage::Query(query)\n            }\n            b'X' =\u003e ClientMessage::Terminate,\n            other =\u003e {\n                return Err(ProtocolError::InvalidMessageType(other));\n            }\n        };\n\n        Ok(Some(message))\n    }\n}\n\nimpl\u003cT: BackendMessage\u003e Encoder\u003cT\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: T, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut body = BytesMut::new();\n        item.encode(\u0026mut body);\n\n        dst.put_u8(T::TAG);\n        dst.put_i32((body.len() + 4) as i32);\n        dst.put_slice(\u0026body);\n        Ok(())\n    }\n}\n\nimpl Encoder\u003cchar\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: char, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        dst.put_u8(item as u8);\n        Ok(())\n    }\n}\n","traces":[{"line":33,"address":[5040181,5037392,5039891],"length":1,"stats":{"Line":0}},{"line":34,"address":[5037462],"length":1,"stats":{"Line":0}},{"line":35,"address":[5037515],"length":1,"stats":{"Line":0}},{"line":36,"address":[5037623],"length":1,"stats":{"Line":0}},{"line":39,"address":[5037564],"length":1,"stats":{"Line":0}},{"line":40,"address":[5037597,5037709],"length":1,"stats":{"Line":0}},{"line":41,"address":[5037727],"length":1,"stats":{"Line":0}},{"line":42,"address":[5037770],"length":1,"stats":{"Line":0}},{"line":44,"address":[5037821],"length":1,"stats":{"Line":0}},{"line":45,"address":[5037877],"length":1,"stats":{"Line":0}},{"line":46,"address":[5037884],"length":1,"stats":{"Line":0}},{"line":49,"address":[5037849,5037983],"length":1,"stats":{"Line":0}},{"line":50,"address":[5040059,5038016],"length":1,"stats":{"Line":0}},{"line":51,"address":[5040130],"length":1,"stats":{"Line":0}},{"line":54,"address":[5038001],"length":1,"stats":{"Line":0}},{"line":56,"address":[5038042],"length":1,"stats":{"Line":0}},{"line":58,"address":[5038057],"length":1,"stats":{"Line":0}},{"line":59,"address":[5038077],"length":1,"stats":{"Line":0}},{"line":61,"address":[5038208,5038103,5038472],"length":1,"stats":{"Line":0}},{"line":62,"address":[5039825,5038513],"length":1,"stats":{"Line":0}},{"line":63,"address":[5039098,5039345,5038796],"length":1,"stats":{"Line":0}},{"line":65,"address":[5039426,5039314,5039474],"length":1,"stats":{"Line":0}},{"line":67,"address":[5039434,5039761],"length":1,"stats":{"Line":0}},{"line":68,"address":[5039642],"length":1,"stats":{"Line":0}},{"line":69,"address":[5039682,5039830],"length":1,"stats":{"Line":0}},{"line":70,"address":[5039849],"length":1,"stats":{"Line":0}},{"line":72,"address":[5039536],"length":1,"stats":{"Line":0}},{"line":77,"address":[5038449,5038542],"length":1,"stats":{"Line":0}},{"line":79,"address":[5038577],"length":1,"stats":{"Line":0}},{"line":80,"address":[5038630],"length":1,"stats":{"Line":0}},{"line":82,"address":[5038580],"length":1,"stats":{"Line":0}},{"line":86,"address":[5037536],"length":1,"stats":{"Line":0}},{"line":87,"address":[5040261],"length":1,"stats":{"Line":0}},{"line":88,"address":[5040279],"length":1,"stats":{"Line":0}},{"line":91,"address":[5040202],"length":1,"stats":{"Line":0}},{"line":92,"address":[5040235,5040365],"length":1,"stats":{"Line":0}},{"line":93,"address":[5040372],"length":1,"stats":{"Line":0}},{"line":95,"address":[5040428],"length":1,"stats":{"Line":0}},{"line":96,"address":[5045913,5040489],"length":1,"stats":{"Line":0}},{"line":97,"address":[5045976],"length":1,"stats":{"Line":0}},{"line":100,"address":[5040474],"length":1,"stats":{"Line":0}},{"line":102,"address":[1243556,1242640,1243524],"length":1,"stats":{"Line":0}},{"line":103,"address":[1243099,1242686,1242761],"length":1,"stats":{"Line":0}},{"line":105,"address":[1243568,1243578],"length":1,"stats":{"Line":0}},{"line":106,"address":[1242743,1243071],"length":1,"stats":{"Line":0}},{"line":107,"address":[1242853,1243020],"length":1,"stats":{"Line":0}},{"line":108,"address":[1243055,1243170],"length":1,"stats":{"Line":0}},{"line":109,"address":[1243452,1243219],"length":1,"stats":{"Line":0}},{"line":112,"address":[5040511],"length":1,"stats":{"Line":0}},{"line":114,"address":[5042028,5040652,5040993,5040840],"length":1,"stats":{"Line":0}},{"line":115,"address":[5040978,5041123,5041269],"length":1,"stats":{"Line":0}},{"line":116,"address":[5041396,5041245],"length":1,"stats":{"Line":0}},{"line":117,"address":[1243600,1243617],"length":1,"stats":{"Line":0}},{"line":119,"address":[5041586],"length":1,"stats":{"Line":0}},{"line":120,"address":[5041447],"length":1,"stats":{"Line":0}},{"line":121,"address":[5041487],"length":1,"stats":{"Line":0}},{"line":122,"address":[5041535],"length":1,"stats":{"Line":0}},{"line":126,"address":[5042061,5040670],"length":1,"stats":{"Line":0}},{"line":127,"address":[5042712,5042084,5042249],"length":1,"stats":{"Line":0}},{"line":129,"address":[5042631,5042217],"length":1,"stats":{"Line":0}},{"line":130,"address":[5042413],"length":1,"stats":{"Line":0}},{"line":131,"address":[5042523],"length":1,"stats":{"Line":0}},{"line":132,"address":[5042340],"length":1,"stats":{"Line":0}},{"line":135,"address":[5040688],"length":1,"stats":{"Line":0}},{"line":137,"address":[5040729,5042733,5045113,5042878],"length":1,"stats":{"Line":0}},{"line":138,"address":[5043149,5045108,5043011,5042863],"length":1,"stats":{"Line":0}},{"line":140,"address":[5043125,5043271],"length":1,"stats":{"Line":0}},{"line":141,"address":[5043279],"length":1,"stats":{"Line":0}},{"line":142,"address":[5045095,5043424],"length":1,"stats":{"Line":0}},{"line":145,"address":[5043400,5043448],"length":1,"stats":{"Line":0}},{"line":146,"address":[5043456],"length":1,"stats":{"Line":0}},{"line":147,"address":[5044847,5043601],"length":1,"stats":{"Line":0}},{"line":148,"address":[5045062,5044862],"length":1,"stats":{"Line":0}},{"line":149,"address":[5045078],"length":1,"stats":{"Line":0}},{"line":152,"address":[5043624,5043577],"length":1,"stats":{"Line":0}},{"line":153,"address":[5043670],"length":1,"stats":{"Line":0}},{"line":154,"address":[5043722,5044081],"length":1,"stats":{"Line":0}},{"line":156,"address":[5043660],"length":1,"stats":{"Line":0}},{"line":157,"address":[5044315,5044387],"length":1,"stats":{"Line":0}},{"line":158,"address":[5044577],"length":1,"stats":{"Line":0}},{"line":160,"address":[5044468],"length":1,"stats":{"Line":0}},{"line":164,"address":[5043885],"length":1,"stats":{"Line":0}},{"line":165,"address":[5043741],"length":1,"stats":{"Line":0}},{"line":166,"address":[5043789],"length":1,"stats":{"Line":0}},{"line":167,"address":[5043837],"length":1,"stats":{"Line":0}},{"line":171,"address":[5045271,5045644,5040763,5045134],"length":1,"stats":{"Line":0}},{"line":172,"address":[5045392,5045248],"length":1,"stats":{"Line":0}},{"line":173,"address":[5045404],"length":1,"stats":{"Line":0}},{"line":174,"address":[5045421],"length":1,"stats":{"Line":0}},{"line":177,"address":[5045439],"length":1,"stats":{"Line":0}},{"line":180,"address":[5040797,5045665,5045828],"length":1,"stats":{"Line":0}},{"line":181,"address":[5045755],"length":1,"stats":{"Line":0}},{"line":183,"address":[5040807],"length":1,"stats":{"Line":0}},{"line":185,"address":[5040561],"length":1,"stats":{"Line":0}},{"line":189,"address":[5041809],"length":1,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[5046016],"length":1,"stats":{"Line":0}},{"line":211,"address":[5046057],"length":1,"stats":{"Line":0}},{"line":212,"address":[5046078],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":105},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","constants.rs"],"content":"use std::mem::size_of;\n\n// length prefix, two version components\npub const STARTUP_HEADER_SIZE: usize = size_of::\u003ci32\u003e() + (size_of::\u003ci16\u003e() * 2);\n// message tag, length prefix\npub const MESSAGE_HEADER_SIZE: usize = size_of::\u003cu8\u003e() + size_of::\u003ci32\u003e();\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","data_types.rs"],"content":"macro_rules! data_types {\n\t($($name:ident = $oid:expr, $size: expr)*) =\u003e {\n\t\t#[derive(Debug, Copy, Clone)]\n\t\t/// Describes a Postgres data type.\n\t\tpub enum DataTypeOid {\n\t\t\t$(\n\t\t\t\t#[allow(missing_docs)]\n\t\t\t\t$name,\n\t\t\t)*\n\t\t\t/// A type which is not known to this crate.\n\t\t\tUnknown(u32),\n\t\t}\n\n\t\timpl DataTypeOid {\n\t\t\t/// Fetch the size in bytes for this data type.\n\t\t\t/// Variably-sized types return -1.\n\t\t\tpub fn size_bytes(\u0026self) -\u003e i16 {\n\t\t\t\tmatch self {\n\t\t\t\t\t$(\n\t\t\t\t\t\tSelf::$name =\u003e $size,\n\t\t\t\t\t)*\n\t\t\t\t\tSelf::Unknown(_) =\u003e unimplemented!(),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timpl From\u003cu32\u003e for DataTypeOid {\n\t\t\tfn from(value: u32) -\u003e Self {\n\t\t\t\tmatch value {\n\t\t\t\t\t$(\n\t\t\t\t\t\t$oid =\u003e Self::$name,\n\t\t\t\t\t)*\n\t\t\t\t\tother =\u003e Self::Unknown(other),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timpl From\u003cDataTypeOid\u003e for u32 {\n\t\t\tfn from(value: DataTypeOid) -\u003e Self {\n\t\t\t\tmatch value {\n\t\t\t\t\t$(\n\t\t\t\t\t\tDataTypeOid::$name =\u003e $oid,\n\t\t\t\t\t)*\n\t\t\t\t\tDataTypeOid::Unknown(other) =\u003e other,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// For oid see:\n// https://github.com/sfackler/rust-postgres/blob/master/postgres-types/src/type_gen.rs\ndata_types! {\n    Unspecified = 0, 0\n\n    Bool = 16, 1\n\n    Int2 = 21, 2\n    Int4 = 23, 4\n    Int8 = 20, 8\n\n    Float4 = 700, 4\n    Float8 = 701, 8\n\n    Date = 1082, 4\n    Timestamp = 1114, 8\n\n    Text = 25, -1\n}\n","traces":[{"line":3,"address":[1860871,1861312,1860848,1861317,1861250],"length":1,"stats":{"Line":0}},{"line":11,"address":[1861241],"length":1,"stats":{"Line":0}},{"line":17,"address":[1860240],"length":1,"stats":{"Line":0}},{"line":18,"address":[1860249],"length":1,"stats":{"Line":0}},{"line":22,"address":[1860367],"length":1,"stats":{"Line":0}},{"line":28,"address":[1860416],"length":1,"stats":{"Line":0}},{"line":29,"address":[1860424],"length":1,"stats":{"Line":0}},{"line":31,"address":[1860571],"length":1,"stats":{"Line":0}},{"line":33,"address":[1860557],"length":1,"stats":{"Line":0}},{"line":39,"address":[1860688],"length":1,"stats":{"Line":0}},{"line":40,"address":[1860696],"length":1,"stats":{"Line":0}},{"line":44,"address":[1860828],"length":1,"stats":{"Line":0}},{"line":54,"address":[1860277,1860728],"length":1,"stats":{"Line":0}},{"line":56,"address":[1860738,1860286],"length":1,"stats":{"Line":0}},{"line":58,"address":[1860748,1860295],"length":1,"stats":{"Line":0}},{"line":59,"address":[1860758,1860304],"length":1,"stats":{"Line":0}},{"line":60,"address":[1860768,1860313],"length":1,"stats":{"Line":0}},{"line":62,"address":[1860322,1860778],"length":1,"stats":{"Line":0}},{"line":63,"address":[1860331,1860788],"length":1,"stats":{"Line":0}},{"line":65,"address":[1860798,1860340],"length":1,"stats":{"Line":0}},{"line":66,"address":[1860808,1860349],"length":1,"stats":{"Line":0}},{"line":68,"address":[1860818,1860358],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","data_row_batch.rs"],"content":"use bytes::BytesMut;\nuse tokio_util::codec::Encoder;\n\nuse crate::pgwire::protocol::{\n    backend::RowDescription, ConnectionCodec, FormatCode, ProtocolError,\n};\n\nuse super::data_row_writer::DataRowWriter;\n\n/// Supports batched rows for e.g. returning portal result sets.\n///\n/// NB: this struct only performs limited validation of column consistency across rows.\npub struct DataRowBatch {\n    pub(crate) format_code: FormatCode,\n    pub(crate) num_cols: usize,\n    pub(crate) num_rows: usize,\n    pub(crate) data: BytesMut,\n    pub(crate) row: BytesMut,\n}\n\nimpl DataRowBatch {\n    /// Creates a new row batch using the given format code, requiring a certain number of columns per row.\n    pub fn new(format_code: FormatCode, num_cols: usize) -\u003e Self {\n        Self {\n            format_code,\n            num_cols,\n            num_rows: 0,\n            data: BytesMut::new(),\n            row: BytesMut::new(),\n        }\n    }\n\n    /// Creates a [DataRowBatch] from the given [RowDescription].\n    pub fn from_row_desc(desc: \u0026RowDescription) -\u003e Self {\n        Self::new(desc.format_code, desc.fields.len())\n    }\n\n    /// Starts writing a new row.\n    ///\n    /// Returns a [DataRowWriter] that is responsible for the actual value encoding.\n    pub fn create_row(\u0026mut self) -\u003e DataRowWriter {\n        self.num_rows += 1;\n        DataRowWriter::new(self)\n    }\n\n    /// Returns the number of rows currently written to this batch.\n    pub fn num_rows(\u0026self) -\u003e usize {\n        self.num_rows\n    }\n}\n\nimpl Encoder\u003cDataRowBatch\u003e for ConnectionCodec {\n    type Error = ProtocolError;\n\n    fn encode(\u0026mut self, item: DataRowBatch, dst: \u0026mut BytesMut) -\u003e Result\u003c(), Self::Error\u003e {\n        dst.extend(item.data);\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[7543035,7542816],"length":1,"stats":{"Line":0}},{"line":28,"address":[7542861],"length":1,"stats":{"Line":0}},{"line":29,"address":[7542871],"length":1,"stats":{"Line":0}},{"line":34,"address":[7543056],"length":1,"stats":{"Line":0}},{"line":35,"address":[7543086],"length":1,"stats":{"Line":0}},{"line":41,"address":[7543136],"length":1,"stats":{"Line":0}},{"line":42,"address":[7543190,7543149],"length":1,"stats":{"Line":0}},{"line":43,"address":[7543180],"length":1,"stats":{"Line":0}},{"line":47,"address":[7543216],"length":1,"stats":{"Line":0}},{"line":48,"address":[7543221],"length":1,"stats":{"Line":0}},{"line":55,"address":[5046096,5046243],"length":1,"stats":{"Line":0}},{"line":56,"address":[5046137],"length":1,"stats":{"Line":0}},{"line":57,"address":[5046210],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","data_row_writer.rs"],"content":"use bytes::BufMut;\nuse chrono::{NaiveDate, NaiveDateTime};\n\nuse crate::pgwire::protocol::FormatCode;\n\nuse super::DataRowBatch;\n\nmacro_rules! primitive_write {\n    ($name: ident, $type: ident) =\u003e {\n        #[allow(missing_docs)]\n        pub fn $name(\u0026mut self, val: $type) {\n            match self.parent.format_code {\n                FormatCode::Text =\u003e self.write_value(\u0026val.to_string().into_bytes()),\n                FormatCode::Binary =\u003e self.write_value(\u0026val.to_be_bytes()),\n            };\n        }\n    };\n}\n\n/// Temporarily leased from a [DataRowBatch] to encode a single row.\npub struct DataRowWriter\u003c'a\u003e {\n    current_col: usize,\n    parent: \u0026'a mut DataRowBatch,\n}\n\nimpl\u003c'a\u003e DataRowWriter\u003c'a\u003e {\n    pub fn new(parent: \u0026'a mut DataRowBatch) -\u003e Self {\n        parent.row.put_i16(parent.num_cols as i16);\n        Self {\n            current_col: 0,\n            parent,\n        }\n    }\n\n    fn write_value(\u0026mut self, data: \u0026[u8]) {\n        self.current_col += 1;\n        self.parent.row.put_i32(data.len() as i32);\n        self.parent.row.put_slice(data);\n    }\n\n    /// Writes a null value for the next column.\n    pub fn write_null(\u0026mut self) {\n        self.current_col += 1;\n        self.parent.row.put_i32(-1);\n    }\n\n    /// Writes a string value for the next column.\n    pub fn write_string(\u0026mut self, val: \u0026str) {\n        self.write_value(val.as_bytes());\n    }\n\n    /// Writes a bool value for the next column.\n    pub fn write_bool(\u0026mut self, val: bool) {\n        match self.parent.format_code {\n            FormatCode::Text =\u003e self.write_value(if val { \"t\" } else { \"f\" }.as_bytes()),\n            FormatCode::Binary =\u003e {\n                self.current_col += 1;\n                self.parent.row.put_u8(val as u8);\n            }\n        };\n    }\n\n    fn pg_date_epoch() -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(2000, 1, 1).unwrap()\n    }\n\n    /// Writes a date value for the next column.\n    pub fn write_date(\u0026mut self, val: NaiveDate) {\n        match self.parent.format_code {\n            FormatCode::Binary =\u003e {\n                self.write_int4(val.signed_duration_since(Self::pg_date_epoch()).num_days() as i32)\n            }\n            FormatCode::Text =\u003e self.write_string(\u0026val.to_string()),\n        }\n    }\n\n    /// Writes a timestamp value for the next column.\n    pub fn write_timestamp(\u0026mut self, val: NaiveDateTime) {\n        match self.parent.format_code {\n            FormatCode::Binary =\u003e {\n                self.write_int8(\n                    val.signed_duration_since(Self::pg_date_epoch().and_hms_opt(0, 0, 0).unwrap())\n                        .num_microseconds()\n                        .unwrap(),\n                );\n            }\n            FormatCode::Text =\u003e self.write_string(\u0026val.to_string()),\n        }\n    }\n\n    primitive_write!(write_int2, i16);\n    primitive_write!(write_int4, i32);\n    primitive_write!(write_int8, i64);\n    primitive_write!(write_float4, f32);\n    primitive_write!(write_float8, f64);\n}\n\nimpl\u003c'a\u003e Drop for DataRowWriter\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        assert_eq!(\n            self.parent.num_cols, self.current_col,\n            \"dropped a row writer with an invalid number of columns\"\n        );\n\n        self.parent.data.put_u8(b'D');\n        self.parent.data.put_i32((self.parent.row.len() + 4) as i32);\n        self.parent.data.extend(self.parent.row.split());\n    }\n}\n","traces":[{"line":11,"address":[5760304,5759536,5760048,5759792,5760025,5759516,5759280,5759764,5760539,5760276],"length":1,"stats":{"Line":0}},{"line":12,"address":[5759557,5759814,5760327,5759305,5760071],"length":1,"stats":{"Line":0}},{"line":13,"address":[5759322,5759831,5759691,5760466,5760102,5759952,5759443,5759574,5760344,5760203],"length":1,"stats":{"Line":0}},{"line":14,"address":[5760412,5759642,5759390,5760152,5759899],"length":1,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","extension","mod.rs"],"content":"pub mod data_row_batch;\npub use data_row_batch::*;\n\npub mod data_row_writer;\npub use data_row_writer::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","format_code.rs"],"content":"use crate::pgwire::protocol::ProtocolError;\n\n/// Describes how to format a given value or set of values.\n#[derive(Debug, Copy, Clone)]\npub enum FormatCode {\n    /// Use the stable text representation.\n    Text = 0,\n    /// Use the less-stable binary representation.\n    Binary = 1,\n}\n\nimpl TryFrom\u003ci16\u003e for FormatCode {\n    type Error = ProtocolError;\n\n    fn try_from(value: i16) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            0 =\u003e Ok(FormatCode::Text),\n            1 =\u003e Ok(FormatCode::Binary),\n            other =\u003e Err(ProtocolError::InvalidFormatCode(other)),\n        }\n    }\n}\n","traces":[{"line":15,"address":[1222976],"length":1,"stats":{"Line":0}},{"line":16,"address":[1223003],"length":1,"stats":{"Line":0}},{"line":17,"address":[1223075],"length":1,"stats":{"Line":0}},{"line":18,"address":[1223110],"length":1,"stats":{"Line":0}},{"line":19,"address":[1223033],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","backend_message.rs"],"content":"use bytes::BytesMut;\n\npub trait BackendMessage: std::fmt::Debug {\n    const TAG: u8;\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","mod.rs"],"content":"pub mod backend_message;\npub use backend_message::*;\n\npub mod types;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","bind_complete.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct BindComplete;\n\nimpl BackendMessage for BindComplete {\n    const TAG: u8 = b'2';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[3503354,3503344],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","command_complete.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct CommandComplete {\n    pub command_tag: String,\n}\n\nimpl BackendMessage for CommandComplete {\n    const TAG: u8 = b'C';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_slice(self.command_tag.as_bytes());\n        dst.put_u8(0);\n    }\n}\n","traces":[{"line":13,"address":[4416368],"length":1,"stats":{"Line":0}},{"line":14,"address":[4416386],"length":1,"stats":{"Line":0}},{"line":15,"address":[4416408],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","empty_query_response.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct EmptyQueryResponse;\n\nimpl BackendMessage for EmptyQueryResponse {\n    const TAG: u8 = b'I';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[1205136,1205146],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","error_response.rs"],"content":"use std::fmt::Display;\n\nuse bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::{backend::BackendMessage, Severity, SqlState};\n\n#[derive(thiserror::Error, Debug, Clone)]\npub struct ErrorResponse {\n    pub sql_state: SqlState,\n    pub severity: Severity,\n    pub message: String,\n}\n\nimpl ErrorResponse {\n    pub fn new(sql_state: SqlState, severity: Severity, message: impl Into\u003cString\u003e) -\u003e Self {\n        ErrorResponse {\n            sql_state,\n            severity,\n            message: message.into(),\n        }\n    }\n\n    pub fn error(sql_state: SqlState, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(sql_state, Severity::ERROR, message)\n    }\n\n    pub fn fatal(sql_state: SqlState, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(sql_state, Severity::FATAL, message)\n    }\n}\n\nimpl Display for ErrorResponse {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"error\")\n    }\n}\n\nimpl From\u003cBox\u003cdyn std::error::Error\u003e\u003e for ErrorResponse {\n    fn from(value: Box\u003cdyn std::error::Error\u003e) -\u003e ErrorResponse {\n        ErrorResponse {\n            sql_state: SqlState::SYNTAX_ERROR,\n            severity: Severity::ERROR,\n            message: value.to_string(),\n        }\n    }\n}\n\nimpl BackendMessage for ErrorResponse {\n    const TAG: u8 = b'E';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_u8(b'C');\n        dst.put_slice(self.sql_state.0.as_bytes());\n        dst.put_u8(0);\n        dst.put_u8(b'S');\n        dst.put_slice(self.severity.0.as_bytes());\n        dst.put_u8(0);\n        dst.put_u8(b'M');\n        dst.put_slice(self.message.as_bytes());\n        dst.put_u8(0);\n\n        dst.put_u8(0); // tag\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[5755968],"length":1,"stats":{"Line":0}},{"line":34,"address":[5755986],"length":1,"stats":{"Line":0}},{"line":39,"address":[5756188,5756032],"length":1,"stats":{"Line":0}},{"line":43,"address":[5756065],"length":1,"stats":{"Line":0}},{"line":51,"address":[5756208],"length":1,"stats":{"Line":0}},{"line":52,"address":[5756245],"length":1,"stats":{"Line":0}},{"line":53,"address":[5756274],"length":1,"stats":{"Line":0}},{"line":54,"address":[5756313],"length":1,"stats":{"Line":0}},{"line":55,"address":[5756330],"length":1,"stats":{"Line":0}},{"line":56,"address":[5756342],"length":1,"stats":{"Line":0}},{"line":57,"address":[5756371],"length":1,"stats":{"Line":0}},{"line":58,"address":[5756384],"length":1,"stats":{"Line":0}},{"line":59,"address":[5756400],"length":1,"stats":{"Line":0}},{"line":60,"address":[5756424],"length":1,"stats":{"Line":0}},{"line":62,"address":[5756437],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","field_description.rs"],"content":"use crate::pgwire::protocol::DataTypeOid;\n\n#[derive(Debug, Clone)]\npub struct FieldDescription {\n    pub name: String,\n    pub data_type: DataTypeOid,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","mod.rs"],"content":"pub mod parameter_description;\npub use parameter_description::*;\n\npub mod field_description;\npub use field_description::*;\n\npub mod row_description;\npub use row_description::*;\n\npub mod ok;\npub use ok::*;\n\npub mod ready_for_query;\npub use ready_for_query::*;\n\npub mod parse_complete;\npub use parse_complete::*;\n\npub mod bind_complete;\npub use bind_complete::*;\n\npub mod no_data;\npub use no_data::*;\n\npub mod empty_query_response;\npub use empty_query_response::*;\n\npub mod command_complete;\npub use command_complete::*;\n\npub mod parameter_status;\npub use parameter_status::*;\n\npub mod error_response;\npub use error_response::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","no_data.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct NoData;\n\nimpl BackendMessage for NoData {\n    const TAG: u8 = b'n';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[5749994,5749984],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","ok.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct AuthenticationOk;\n\nimpl BackendMessage for AuthenticationOk {\n    const TAG: u8 = b'R';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i32(0);\n    }\n}\n","traces":[{"line":11,"address":[3435808],"length":1,"stats":{"Line":0}},{"line":12,"address":[3435833],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parameter_description.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParameterDescription {}\n\nimpl BackendMessage for ParameterDescription {\n    const TAG: u8 = b't';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i16(0);\n    }\n}\n","traces":[{"line":11,"address":[2903008],"length":1,"stats":{"Line":0}},{"line":12,"address":[2903033],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parameter_status.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParameterStatus {\n    name: String,\n    value: String,\n}\n\nimpl BackendMessage for ParameterStatus {\n    const TAG: u8 = b'S';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_slice(self.name.as_bytes());\n        dst.put_u8(0);\n        dst.put_slice(self.value.as_bytes());\n        dst.put_u8(0);\n    }\n}\n\nimpl ParameterStatus {\n    pub fn new(name: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            value: value.into(),\n        }\n    }\n}\n","traces":[{"line":14,"address":[5284832],"length":1,"stats":{"Line":0}},{"line":15,"address":[5284856],"length":1,"stats":{"Line":0}},{"line":16,"address":[5284880],"length":1,"stats":{"Line":0}},{"line":17,"address":[5284893],"length":1,"stats":{"Line":0}},{"line":18,"address":[5284921],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","parse_complete.rs"],"content":"use bytes::BytesMut;\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ParseComplete;\n\nimpl BackendMessage for ParseComplete {\n    const TAG: u8 = b'1';\n\n    fn encode(\u0026self, _dst: \u0026mut BytesMut) {}\n}\n","traces":[{"line":11,"address":[1868730,1868720],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","ready_for_query.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::backend::BackendMessage;\n\n#[derive(Debug)]\npub struct ReadyForQuery;\n\nimpl BackendMessage for ReadyForQuery {\n    const TAG: u8 = b'Z';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_u8(b'I');\n    }\n}\n","traces":[{"line":11,"address":[1708272],"length":1,"stats":{"Line":0}},{"line":12,"address":[1708297],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","backend","types","row_description.rs"],"content":"use bytes::{BufMut, BytesMut};\n\nuse crate::pgwire::protocol::{backend::BackendMessage, FormatCode};\n\nuse super::field_description::FieldDescription;\n\n#[derive(Debug, Clone)]\npub struct RowDescription {\n    pub fields: Vec\u003cFieldDescription\u003e,\n    pub format_code: FormatCode,\n}\n\nimpl BackendMessage for RowDescription {\n    const TAG: u8 = b'T';\n\n    fn encode(\u0026self, dst: \u0026mut BytesMut) {\n        dst.put_i16(self.fields.len() as i16);\n        for field in \u0026self.fields {\n            dst.put_slice(field.name.as_bytes());\n            dst.put_u8(0);\n            dst.put_i32(0); // table oid\n            dst.put_i16(0); // column attr number\n            dst.put_u32(field.data_type.into());\n            dst.put_i16(field.data_type.size_bytes());\n            dst.put_i32(-1); // data type modifier\n            dst.put_i16(self.format_code as i16);\n        }\n    }\n}\n","traces":[{"line":16,"address":[3940272],"length":1,"stats":{"Line":0}},{"line":17,"address":[3940296],"length":1,"stats":{"Line":0}},{"line":18,"address":[3940320,3940381],"length":1,"stats":{"Line":0}},{"line":19,"address":[3940396],"length":1,"stats":{"Line":0}},{"line":20,"address":[3940420],"length":1,"stats":{"Line":0}},{"line":21,"address":[3940433],"length":1,"stats":{"Line":0}},{"line":22,"address":[3940446],"length":1,"stats":{"Line":0}},{"line":23,"address":[3940459],"length":1,"stats":{"Line":0}},{"line":24,"address":[3940495],"length":1,"stats":{"Line":0}},{"line":25,"address":[3940523],"length":1,"stats":{"Line":0}},{"line":26,"address":[3940544],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","client_message.rs"],"content":"use super::{Bind, Describe, Execute, Parse, Startup};\n\n#[derive(Debug)]\npub enum ClientMessage {\n    SSLRequest, // for SSL negotiation\n    Startup(Startup),\n    Parse(Parse),\n    Describe(Describe),\n    Bind(Bind),\n    Sync,\n    Execute(Execute),\n    Query(String),\n    Terminate,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","mod.rs"],"content":"pub mod client_message;\npub use client_message::*;\n\npub mod types;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","bind.rs"],"content":"use super::BindFormat;\n\n#[derive(Debug)]\npub struct Bind {\n    pub portal: String,\n    pub prepared_statement_name: String,\n    pub result_format: BindFormat,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","bind_format.rs"],"content":"use crate::pgwire::protocol::FormatCode;\n\n#[derive(Debug)]\npub enum BindFormat {\n    All(FormatCode),\n    PerColumn(Vec\u003cFormatCode\u003e),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","describe.rs"],"content":"#[derive(Debug)]\npub enum Describe {\n    Portal(String),\n    PreparedStatement(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","execute.rs"],"content":"#[derive(Debug)]\npub struct Execute {\n    pub portal: String,\n    pub max_rows: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","mod.rs"],"content":"pub mod startup;\npub use startup::*;\n\npub mod describe;\npub use describe::*;\n\npub mod parse;\npub use parse::*;\n\npub mod bind_format;\npub use bind_format::*;\n\npub mod bind;\npub use bind::*;\n\npub mod execute;\npub use execute::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","parse.rs"],"content":"use crate::pgwire::protocol::DataTypeOid;\n\n#[derive(Debug)]\npub struct Parse {\n    pub prepared_statement_name: String,\n    pub query: String,\n    pub parameter_types: Vec\u003cDataTypeOid\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","client","types","startup.rs"],"content":"use std::collections::HashMap;\n\n#[derive(Debug)]\npub struct Startup {\n    pub requested_protocol_version: (i16, i16),\n    pub parameters: HashMap\u003cString, String\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","message","mod.rs"],"content":"pub mod backend;\npub mod client;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","mod.rs"],"content":"pub mod data_types;\npub use data_types::*;\n\npub mod format_code;\npub use format_code::*;\n\npub mod sql_state;\npub use sql_state::*;\n\npub mod severity;\npub use severity::*;\n\npub mod message;\npub use message::*;\n\npub mod connection_codec;\npub use connection_codec::*;\n\npub mod protocol_error;\npub use protocol_error::*;\n\npub mod constants;\npub use constants::*;\n\npub mod extension;\npub use extension::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","protocol_error.rs"],"content":"#[derive(thiserror::Error, Debug)]\npub enum ProtocolError {\n    #[error(\"io error: {0}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"utf8 error: {0}\")]\n    Utf8(#[from] std::string::FromUtf8Error),\n    #[error(\"parsing error\")]\n    ParserError,\n    #[error(\"invalid message type: {0}\")]\n    InvalidMessageType(u8),\n    #[error(\"invalid format code: {0}\")]\n    InvalidFormatCode(i16),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","severity.rs"],"content":"#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Severity(pub \u0026'static str);\n\nimpl Severity {\n    pub const ERROR: Severity = Severity(\"ERROR\");\n    pub const FATAL: Severity = Severity(\"FATAL\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","pgwire","protocol","sql_state.rs"],"content":"#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SqlState(pub \u0026'static str);\n\nimpl SqlState {\n    pub const SUCCESSFUL_COMPLETION: SqlState = SqlState(\"00000\");\n    pub const FEATURE_NOT_SUPPORTED: SqlState = SqlState(\"0A000\");\n    pub const INVALID_CURSOR_NAME: SqlState = SqlState(\"34000\");\n    pub const CONNECTION_EXCEPTION: SqlState = SqlState(\"08000\");\n    pub const INVALID_SQL_STATEMENT_NAME: SqlState = SqlState(\"26000\");\n    pub const DATA_EXCEPTION: SqlState = SqlState(\"22000\");\n    pub const PROTOCOL_VIOLATION: SqlState = SqlState(\"08P01\");\n    pub const SYNTAX_ERROR: SqlState = SqlState(\"42601\");\n    pub const INVALID_DATETIME_FORMAT: SqlState = SqlState(\"22007\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","channel.rs"],"content":"use tokio::sync::oneshot::Sender;\n\nuse crate::{ast::SQLStatement, errors::RRDBError, executor::result::ExecuteResult};\n\n#[derive(Debug)]\npub struct ChannelRequest {\n    pub statement: SQLStatement,\n    pub connection_id: String,\n    pub response_sender: Sender\u003cChannelResponse\u003e,\n}\n\n#[derive(Debug)]\npub struct ChannelResponse {\n    pub result: Result\u003cExecuteResult, RRDBError\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","client.rs"],"content":"use std::net::IpAddr;\n\n#[derive(Clone, Debug)]\npub struct ClientInfo {\n    pub ip: IpAddr,\n    pub connection_id: String,\n    pub database: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","mod.rs"],"content":"pub mod channel;\npub mod client;\npub mod predule;\n#[allow(clippy::module_inception)]\npub mod server;\npub mod shared_state;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","predule.rs"],"content":"pub use super::channel::*;\npub use super::client::*;\npub use super::server::*;\npub use super::shared_state::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","server","server.rs"],"content":"use std::sync::Arc;\n\nuse crate::errors::execute_error::ExecuteError;\nuse crate::errors::RRDBError;\nuse crate::executor::config::global::GlobalConfig;\nuse crate::executor::predule::Executor;\nuse crate::logger::predule::Logger;\nuse crate::pgwire::predule::Connection;\nuse crate::server::channel::ChannelResponse;\nuse crate::server::predule::{ChannelRequest, SharedState};\n\nuse futures::future::join_all;\nuse tokio::net::TcpListener;\nuse tokio::sync::mpsc;\n\nuse super::client::ClientInfo;\n\npub struct Server {\n    pub config: Arc\u003cGlobalConfig\u003e,\n}\n\nimpl Server {\n    pub fn new(config: GlobalConfig) -\u003e Self {\n        Self {\n            config: Arc::new(config),\n        }\n    }\n\n    /// 메인 서버 루프.\n    /// 여러개의 태스크 제어\n    pub async fn run(\u0026self) -\u003e Result\u003c(), RRDBError\u003e {\n        // TODO: 인덱스 로딩 등 기본 로직 실행.\n\n        let (request_sender, mut request_receiver) = mpsc::channel::\u003cChannelRequest\u003e(1000);\n\n        // background task\n        // 쿼리 실행 요청을 전달받음\n        let config = self.config.clone();\n\n        let background_task = tokio::spawn(async move {\n            while let Some(request) = request_receiver.recv().await {\n                let config = config.clone();\n\n                // 쿼리 실행 태스크\n                tokio::spawn(async move {\n                    let executor = Executor::new(config);\n                    let result = executor\n                        .process_query(request.statement, request.connection_id)\n                        .await;\n\n                    match result {\n                        Ok(result) =\u003e {\n                            if let Err(_response) = request\n                                .response_sender\n                                .send(ChannelResponse { result: Ok(result) })\n                            {\n                                Logger::error(\"channel send failed\");\n                            }\n                        }\n                        Err(error) =\u003e {\n                            let error = error.to_string();\n                            if let Err(_response) = request.response_sender.send(ChannelResponse {\n                                result: Err(ExecuteError::wrap(error)),\n                            }) {\n                                Logger::error(\"channel send failed\");\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        // connection task\n        // client와의 커넥션 처리 루프\n        let listener = TcpListener::bind((self.config.host.to_owned(), self.config.port as u16))\n            .await\n            .map_err(|error| ExecuteError::wrap(error.to_string()))?;\n\n        let config = self.config.clone();\n        let connection_task = tokio::spawn(async move {\n            loop {\n                let accepted = listener.accept().await;\n\n                let (stream, address) = match accepted {\n                    Ok((stream, address)) =\u003e (stream, address),\n                    Err(error) =\u003e {\n                        Logger::error(format!(\"socket error {:?}\", error));\n                        continue;\n                    }\n                };\n\n                let client_info = ClientInfo {\n                    ip: address.ip(),\n                    connection_id: uuid::Uuid::new_v4().to_string(),\n                    database: \"None\".into(),\n                };\n\n                let shared_state = SharedState {\n                    sender: request_sender.clone(),\n                    client_info,\n                };\n\n                let config = config.clone();\n                tokio::spawn(async move {\n                    let mut conn = Connection::new(shared_state, config);\n                    if let Err(error) = conn.run(stream).await {\n                        Logger::error(format!(\"connection error {:?}\", error));\n                    }\n                });\n            }\n        });\n\n        Logger::info(format!(\n            \"Server is running on {}:{}\",\n            self.config.host, self.config.port\n        ));\n\n        join_all(vec![connection_task, background_task]).await;\n\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[2380096],"length":1,"stats":{"Line":0}},{"line":25,"address":[2380097],"length":1,"stats":{"Line":0}},{"line":31,"address":[2380112,2380120],"length":1,"stats":{"Line":0}},{"line":34,"address":[5237758,5237608],"length":1,"stats":{"Line":0}},{"line":38,"address":[5237875,5237802],"length":1,"stats":{"Line":0}},{"line":40,"address":[5240504,5241570,5240464,5241420,5240546,5238020,5240580,5240634,5237883],"length":1,"stats":{"Line":0}},{"line":41,"address":[4668453],"length":1,"stats":{"Line":0}},{"line":42,"address":[5241028,5241110],"length":1,"stats":{"Line":0}},{"line":45,"address":[5241664,5241704,5243965,5241118,5241749,5242217,5243115,5241879],"length":1,"stats":{"Line":0}},{"line":46,"address":[5241757],"length":1,"stats":{"Line":0}},{"line":47,"address":[5241964,5242093,5242347,5242164],"length":1,"stats":{"Line":0}},{"line":48,"address":[5241984],"length":1,"stats":{"Line":0}},{"line":49,"address":[4686171],"length":1,"stats":{"Line":0}},{"line":51,"address":[5242480],"length":1,"stats":{"Line":0}},{"line":52,"address":[5242510],"length":1,"stats":{"Line":0}},{"line":53,"address":[5242738,5242558,5242897,5243030],"length":1,"stats":{"Line":0}},{"line":55,"address":[5242889,5242582],"length":1,"stats":{"Line":0}},{"line":57,"address":[5243011],"length":1,"stats":{"Line":0}},{"line":60,"address":[5242748],"length":1,"stats":{"Line":0}},{"line":61,"address":[5242844],"length":1,"stats":{"Line":0}},{"line":62,"address":[5243673,5243540,5243221,5243405],"length":1,"stats":{"Line":0}},{"line":63,"address":[5243277,5243325],"length":1,"stats":{"Line":0}},{"line":65,"address":[5243654],"length":1,"stats":{"Line":0}},{"line":75,"address":[5238117,5238617,5238035,5238295,5238491,5238891],"length":1,"stats":{"Line":0}},{"line":76,"address":[4812893],"length":1,"stats":{"Line":0}},{"line":77,"address":[5244016,5244034,5238811],"length":1,"stats":{"Line":0}},{"line":79,"address":[5238785,5238974],"length":1,"stats":{"Line":0}},{"line":80,"address":[5244226,5244184,5244260,5246238,5239161,5244310,5245944,5244144,5238982],"length":1,"stats":{"Line":0}},{"line":81,"address":[5244234],"length":1,"stats":{"Line":0}},{"line":82,"address":[5244273,5244326,5246170,5244350,5244219],"length":1,"stats":{"Line":0}},{"line":84,"address":[5244806,5244616],"length":1,"stats":{"Line":0}},{"line":85,"address":[5244646],"length":1,"stats":{"Line":0}},{"line":86,"address":[5244920],"length":1,"stats":{"Line":0}},{"line":87,"address":[5246047],"length":1,"stats":{"Line":0}},{"line":92,"address":[5245212],"length":1,"stats":{"Line":0}},{"line":93,"address":[5244910],"length":1,"stats":{"Line":0}},{"line":94,"address":[5245084],"length":1,"stats":{"Line":0}},{"line":95,"address":[5245130],"length":1,"stats":{"Line":0}},{"line":98,"address":[5245477],"length":1,"stats":{"Line":0}},{"line":99,"address":[5245314],"length":1,"stats":{"Line":0}},{"line":100,"address":[5245389],"length":1,"stats":{"Line":0}},{"line":103,"address":[5245573,5245640],"length":1,"stats":{"Line":0}},{"line":104,"address":[5247744,5246312,5246778,5246357,5245648,5246272,5246472,5246756],"length":1,"stats":{"Line":0}},{"line":105,"address":[5246365],"length":1,"stats":{"Line":0}},{"line":106,"address":[4686680],"length":1,"stats":{"Line":0}},{"line":107,"address":[5247362],"length":1,"stats":{"Line":0}},{"line":113,"address":[5239439,5239357],"length":1,"stats":{"Line":0}},{"line":115,"address":[5239329,5239181],"length":1,"stats":{"Line":0}},{"line":118,"address":[4812909],"length":1,"stats":{"Line":0}},{"line":120,"address":[5240237],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["/","home","runner","work","rrdb","rrdb","src","server","shared_state.rs"],"content":"use tokio::sync::mpsc::Sender;\n\nuse super::{channel::ChannelRequest, client::ClientInfo};\n\n#[derive(Clone, Debug)]\npub struct SharedState {\n    pub sender: Sender\u003cChannelRequest\u003e,\n    pub client_info: ClientInfo,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","test.rs"],"content":"#![allow(unused_imports)]\n#![allow(dead_code)]\n\npub mod command;\n// pub mod lib;\n\n// use parser::context::ParserContext;\n\n// use crate::ast::predule::{\n//     BinaryOperator, BinaryOperatorExpression, SQLExpression, SelectItem, SelectQuery,\n// };\n// use crate::parser::predule::Parser;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // let text = r#\"\n    // create database asdf;\n    // \"#\n    // .to_owned();\n\n    // let mut parser = Parser::new(text).unwrap();\n\n    // parser.parse(ParserContext::default()).unwrap();\n\n    Ok(())\n}\n","traces":[{"line":15,"address":[483664,484072],"length":1,"stats":{"Line":0}},{"line":25,"address":[483692,483899,483752],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","collection.rs"],"content":"macro_rules! join_vec {\n    ($x:expr) =\u003e {\n        $x\n    };\n    ($x:expr, $($y:expr),+) =\u003e {\n        {\n            let join_fn = |mut lhs: Vec\u003c_\u003e, mut rhs: Vec\u003c_\u003e| -\u003e Vec\u003c_\u003e {\n                lhs.append(\u0026mut rhs);\n                lhs\n            };\n\n            join_fn($x, join_vec!($($y),+))\n        }\n\n    };\n}\n\npub(crate) use join_vec;\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_join_vec() {\n        let v1 = vec![1, 2, 3];\n        let v2 = vec![4, 5, 6];\n\n        assert_eq!(join_vec!(v1), vec![1, 2, 3]);\n        assert_eq!(join_vec!(v1, v2), vec![1, 2, 3, 4, 5, 6]);\n    }\n}\n","traces":[{"line":7,"address":[3138608,3137984,3137110,3136486,3137360,3136070,3136902,3137568,3136694,3137942,3136528,3138816,3138400,3137318,3136320,3138774,3135904,3137734,3137776,3138358,3136736,3137152,3138192,3138566,3136278,3136944,3138150,3137526,3138982,3136112],"length":1,"stats":{"Line":19}},{"line":8,"address":[3136781,3135949,3136573,3138237,3136989,3138653,3138445,3138861,3137613,3137821,3136365,3137197,3136157,3137405,3138029],"length":1,"stats":{"Line":16}},{"line":9,"address":[3137049,3137465,3138505,3137881,3136425,3137257,3138921,3137673,3138713,3136009,3138297,3136217,3136841,3138089,3136633],"length":1,"stats":{"Line":16}},{"line":12,"address":[8201346,8196817,8200845,8199053,8196741,8200686,8196542,8197103,8201231,8198961,8200945,8199732,8200861,8196725,8199446,8198977,8197496,8201632,8197210,8198802,8199339],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","float.rs"],"content":"use std::{\n    cmp::Ordering,\n    hash::{Hash, Hasher},\n    ops::{Add, Div, Mul, Neg, Sub},\n};\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Deserialize, Serialize, Clone, Copy, Debug)]\npub struct Float64 {\n    pub value: f64,\n}\n\nimpl Eq for Float64 {}\n\nimpl Hash for Float64 {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.value.to_ne_bytes().hash(state)\n    }\n}\n\nimpl ToString for Float64 {\n    fn to_string(\u0026self) -\u003e String {\n        self.value.to_string()\n    }\n}\n\nimpl From\u003cf64\u003e for Float64 {\n    fn from(value: f64) -\u003e Self {\n        Float64 { value }\n    }\n}\n\nimpl From\u003cFloat64\u003e for f64 {\n    fn from(value: Float64) -\u003e Self {\n        value.value\n    }\n}\n\nimpl Neg for Float64 {\n    type Output = Self;\n\n    fn neg(self) -\u003e Self::Output {\n        (-self.value).into()\n    }\n}\n\nimpl Add for Float64 {\n    type Output = Self;\n\n    fn add(self, other: Self) -\u003e Self {\n        let result = self.value + other.value;\n        result.into()\n    }\n}\n\nimpl Sub for Float64 {\n    type Output = Self;\n\n    fn sub(self, other: Self) -\u003e Self {\n        let result = self.value - other.value;\n        result.into()\n    }\n}\n\nimpl Mul for Float64 {\n    type Output = Self;\n\n    fn mul(self, other: Self) -\u003e Self {\n        let result = self.value * other.value;\n        result.into()\n    }\n}\n\nimpl Div for Float64 {\n    type Output = Self;\n\n    fn div(self, other: Self) -\u003e Self {\n        let result = self.value / other.value;\n        result.into()\n    }\n}\n\nimpl PartialEq for Float64 {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.value == other.value\n    }\n}\n\nimpl PartialOrd for Float64 {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Float64 {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        if self == other {\n            Ordering::Equal\n        } else {\n            let lhs = self.value;\n            let rhs = other.value;\n\n            match lhs.partial_cmp(\u0026rhs) {\n                Some(order) =\u003e order,\n                None =\u003e Ordering::Less,\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_float64_hash() {\n        use super::Float64;\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        Float64 { value: 1.0 }.hash(\u0026mut hasher);\n        let hash1 = hasher.finish();\n\n        let mut hasher = DefaultHasher::new();\n        Float64 { value: 1.0 }.hash(\u0026mut hasher);\n        let hash2 = hasher.finish();\n\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_float64_to_string() {\n        use super::Float64;\n\n        let f = Float64 { value: 1.0 };\n        assert_eq!(f.to_string(), \"1\");\n    }\n\n    #[test]\n    fn test_float64_from_f64() {\n        use super::Float64;\n\n        let f: Float64 = 1.0.into();\n        assert_eq!(f, Float64 { value: 1.0 });\n    }\n\n    #[test]\n    fn test_float64_from_float64() {\n        use super::Float64;\n\n        let f: f64 = Float64 { value: 1.0 }.into();\n        assert_eq!(f, 1.0);\n    }\n\n    #[test]\n    fn test_float64_neg() {\n        use super::Float64;\n\n        let f = Float64 { value: 1.0 };\n        assert_eq!(-f, Float64 { value: -1.0 });\n    }\n\n    #[test]\n    fn test_float64_add() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 + f2, Float64 { value: 3.0 });\n    }\n\n    #[test]\n    fn test_float64_sub() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 - f2, Float64 { value: -1.0 });\n    }\n\n    #[test]\n    fn test_float64_mul() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 * f2, Float64 { value: 2.0 });\n    }\n\n    #[test]\n    fn test_float64_div() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(f1 / f2, Float64 { value: 0.5 });\n    }\n\n    #[test]\n    fn test_float64_eq() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(PartialEq::eq(\u0026f1, \u0026f2), true);\n    }\n\n    #[test]\n    fn test_float64_partial_cmp() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Less)\n        );\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Equal)\n        );\n\n        let f1 = Float64 { value: 2.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(\n            PartialOrd::partial_cmp(\u0026f1, \u0026f2),\n            Some(std::cmp::Ordering::Greater)\n        );\n    }\n\n    #[test]\n    fn test_float64_cmp() {\n        use super::Float64;\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 2.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Less);\n\n        let f1 = Float64 { value: 1.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Equal);\n\n        let f1 = Float64 { value: 2.0 };\n        let f2 = Float64 { value: 1.0 };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Greater);\n\n        let f1 = Float64 { value: f64::NAN };\n        let f2 = Float64 { value: f64::NAN };\n        assert_eq!(Ord::cmp(\u0026f1, \u0026f2), std::cmp::Ordering::Less);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[5272208],"length":1,"stats":{"Line":1}},{"line":24,"address":[5272225],"length":1,"stats":{"Line":1}},{"line":29,"address":[5272256],"length":1,"stats":{"Line":1}},{"line":35,"address":[5272272],"length":1,"stats":{"Line":1}},{"line":43,"address":[5272288],"length":1,"stats":{"Line":1}},{"line":44,"address":[5272294],"length":1,"stats":{"Line":1}},{"line":51,"address":[5272336],"length":1,"stats":{"Line":1}},{"line":52,"address":[5272351],"length":1,"stats":{"Line":1}},{"line":53,"address":[5272361],"length":1,"stats":{"Line":1}},{"line":60,"address":[5272384],"length":1,"stats":{"Line":1}},{"line":61,"address":[5272399],"length":1,"stats":{"Line":1}},{"line":62,"address":[5272409],"length":1,"stats":{"Line":1}},{"line":69,"address":[5272432],"length":1,"stats":{"Line":1}},{"line":70,"address":[5272447],"length":1,"stats":{"Line":1}},{"line":71,"address":[5272457],"length":1,"stats":{"Line":1}},{"line":78,"address":[5272480],"length":1,"stats":{"Line":1}},{"line":79,"address":[5272495],"length":1,"stats":{"Line":1}},{"line":80,"address":[5272505],"length":1,"stats":{"Line":1}},{"line":85,"address":[5272528],"length":1,"stats":{"Line":1}},{"line":86,"address":[5272538],"length":1,"stats":{"Line":1}},{"line":91,"address":[5272560],"length":1,"stats":{"Line":1}},{"line":92,"address":[5272574],"length":1,"stats":{"Line":1}},{"line":97,"address":[5272592],"length":1,"stats":{"Line":1}},{"line":98,"address":[5272606,5272703],"length":1,"stats":{"Line":2}},{"line":99,"address":[5272698],"length":1,"stats":{"Line":1}},{"line":101,"address":[5272625],"length":1,"stats":{"Line":1}},{"line":102,"address":[5272640],"length":1,"stats":{"Line":1}},{"line":104,"address":[5272655],"length":1,"stats":{"Line":1}},{"line":105,"address":[5272712],"length":1,"stats":{"Line":1}},{"line":106,"address":[5272705],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","macos.rs"],"content":"// MacOS에서 고정 환경변수를 가져옵니다.\npub fn get_profile_path() -\u003e String {\n    let username = whoami::username();\n    let user_path = format!(\"/Users/{}\", username);\n    let profile_path = format!(\"{}/.zshenv\", user_path);\n\n    profile_path\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_profile_path() {\n        let username = whoami::username();\n        let user_path = format!(\"/Users/{}\", username);\n        let profile_path = format!(\"{}/.zshenv\", user_path);\n\n        assert_eq!(get_profile_path(), profile_path);\n    }\n}\n","traces":[{"line":2,"address":[5251537,5250992],"length":1,"stats":{"Line":1}},{"line":4,"address":[5251202],"length":1,"stats":{"Line":1}},{"line":5,"address":[5251427],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","mod.rs"],"content":"pub mod collection;\npub mod float;\npub mod macos;\npub mod predule;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","rrdb","rrdb","src","utils","predule.rs"],"content":"pub use super::float::*;\npub use super::macos::*;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>